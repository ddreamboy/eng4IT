{
  "text": "what's happening everyone in this video\nI'll be introducing the linked list data\nstructure we'll be using the Python\ncoding language because one it's my\nfavorite language and to its simplicity\nwill allow me to explain more of the\nhigh-level features of the data\nstructure without having to delve too\ndeep into the lower level functionality\nunlike dictionaries seen in our prior\nvideo link lists are not a built-in\nfeature of the Python language instead\nin this video I'll start off by\nexplaining the basics of the data\nstructure and later on we'll get to\ncoding up the actual classes and\nfunctions if you have any suggestions on\ndata structures to cover in future\nvideos definitely don't hesitate to post\na comment I'll certainly read through\nthem all as well as address any\nquestions you may have so to start off\nwith a linked list is essentially a way\nin which to store data in an ordered\nmanner if you have any experience with\narrays as you can see in this picture\nhere there should be a fairly simple\nidea to understand the easiest way in my\nopinion to introduce linked lists is to\ncompare them with arrays in most coding\nlanguages an array is basically a fixed\nsized chunk in memory this chunk is then\nsubdivided into smaller sections which\ncan be accessed using indices starting\nwith the index zero one of the great\nbenefits to using an array is that we\ncan access any of the addresses or\nindices in constant time that is Big O\nof one in Big O notation in layman's\nterms this means we can pretty much\naccess any of the elements in the array\nin the same amount of time be that the\nfirst index or at the millionth index\nthe reason being we only need to\ncalculate a single memory address that\ninstruct the computer to pull the data\nat that address for any spot in the\narray so for example if this were an\narray here these shaded green blocks the\nindices above them or what you would use\nto index into each one of the green\nblocks so this would be the data at the\nzero with index first index all the way\non up to however large the array may be\nin this case the array length is 10 the\nonly true connection between the\nelements of an array lies in the fact\nthey're slotted next to each other in\nmemory you can think of the Python list\nobject as being an array like data\nstructure the linked list on the other\nhand has no strict linear ordering in\nmemory\ninstead the ordering of the elements is\ncontrolled by the data structures which\ncontain each one of the individual\nelements rather than each element having\nits own fixed size block in memory\nslotted in next to its neighbors the\nlength list uses a data structure called\na node to wrap each one of its elements\nalong with the stored element itself\nthis node structure contains the\nmetadata that shows the whole linked\nlist together the node contains for one\na pointer to the next element in the\nlist you can think of the pointer as\neither the memory address of the next\nnode or the next node itself suffice to\nsay the node has the knowledge of how to\nget to the next node as you can see in\nthe picture the last node can be\nidentified as the last node because its\nnext node pointer is set to null there\nare two common forms of the length list\nboth shown in the picture the first is\nthe one we have just described and is\ncalled a singly linked list the other is\nthe doubly linked list the only\ndifference being that the doubly linked\nlist nodes contain pointers to the prior\nelement in the list as well as the next\nin this picture we can see the\nefficiency of various operations using\nboth the singly and doubly linked lists\npause the video now and jot down this\ninformation if you need it for an exam\ntake note of the comparisons here\nbetween the linked list and array data\nstructures I'll now switch over to a\ncoding editor so we can begin developing\nthe underlying node and length list data\nstructures and algorithms okay so the\nfirst data structure we're going to be\nimplementing is the node class fairly\nsimple just contains two elements we'll\nbe passing in a data point or an element\nto be stored by this node in the\nconstructor and by default it will be\nset to none\nso this is where we're going to be\nstoring the past data point and this is\nwhere we'll be storing the pointer to\nthe next node as you can see in the\nconstructor we're initializing this to\nnone which makes sense if you recall\nthat the last element in the linked list\nis always going to have its next pointer\nset to none so by default we'll set it\nto that and then if we have a child node\nB attached to the end of this node will\nthen update this variable as such the\nnext data structure we're going to be\ncreating is going to be called\nthe linked list class and this is\nbasically a wrapper that wraps over\nthese nodes so the user is never\nactually going to interface with this\nnode class this is just going to be a\nsubclass of the linked list okay so here\nin the constructor we're always going to\nwant to have our head node available\ninside of the linked list the head node\nis never going to contain any actual\ndata and it's not going to be indexable\nin other words the user isn't going to\nbe able to access this head node this is\njust going to be simply used as a\nplaceholder to allow us to point to the\nfirst element in the list so when we're\nfirst creating our list we're going to\nhave a list of length 0 so don't get\nconfused even though we do have a single\nnode in our length list this actually\nisn't going to be one of the data nodes\nnow the first function we're going to\nwant to implement is probably going to\nbe the the append function which is\ngoing to function similarly to the\nappend function in the list object built\ninto Python this is going to be adding\non a new data point to the end of the\ncurrent list and so obviously when the\nlinked list is first created there's not\ngoing to be any elements so the append\nfunction will be what's used to create\nthe first element of the list\nbe passing in the datapoint now first\nwe're gonna be creating a new node of\nthe class node and obviously passing the\ndata into that which as you can recall\nwill set the data point inside of the\nnode will now be creating a variable to\nstore the node that we're currently\nlooking at so we'll just call that cur\nit was equal to self dot head because\nwe're going to start obviously at the\nleft turn left most point of the list\nand now we're going to iterate over each\none of the nodes in the list starting\nwith the head and then once we get to a\npoint where the next node of the current\nnode is none we know that that's going\nto be the last node in the list at which\npoint we can insert our new node as the\nnext node in the prior node so iterating\nwell the next element of the current\nnode is not equal to none just traverse\nthrough the list and now once we know\nwe're at the last element of the list we\ncan set the next node equal to our new\nnode the next function we're probably\ngoing to want to implement is going to\nbe a function to figure out the length\nof our linked list which is obviously\nvery useful if you're trying to manage\nthe nodes in the list or if you just\nwant to figure out how large the data\nstructure is that you're working with so\nwe'll call this one length not passing\nany parameters other than obviously the\ninstance of the class we'll be creating\nanother variable to point to our current\nnode and obviously again we'll set that\nequal to head well create another\nvariable to contain the total number of\nnodes we've seen so at this point we\nhave zero and now we're going to begin\niterating over our nodes\nincrementing the total and then\ntraversing to the next node and then\nhere once we're done obviously we'll be\nexiting once we know that we're at the\nlast node which you can tell once again\nbecause the next node will be equal to\nnine so once we're done with this\niteration or all the iterations of this\nloop we'll know that our total variable\nwill contain the number of elements in\nour list so we can return that the next\nfunction we'll be creating is kind of\njust a helper function just to help us\nalong while we're creating the rest of\nthe functions and that's going to be a\nfunction we can use to display the\ncurrent contents of our list after which\nwe can test and play around with our\nlengths and append functions so we'll\ncall this one display not passed any\nparameters we're gonna be just for now\ncreating a list of elements we've seen\nset a new variable for our current over\nlooking at set that equal to head and\nthen we're going to begin traversing\nover the nodes while the current node\nthe next element in the current node is\nnot equal to none set the current node\nequal to the next node and then append\nthe data of the current node to our list\nof elements we've seen and at the end of\nthis iteration or this loop here we're\ngoing to be printing at the elements\nwe've come across so now we can play\naround with our linked list that we've\ncreated so far just test it out and make\nsure that our two append and length\nfunctions work properly we can begin by\njust creating an instance of our length\nlist call up my list and first we'll\njust display it\nswitch over to our command prompt and\nrun the file okay so as we expected\nobviously at this point we have nothing\nin the list let's try appending on an\ninteger just append on one try appending\non a second integer as well and then\ndisplay it again perfect so now we can\nsee we've added in our two elements and\nwe can see them printed nicely as a list\nin the Python list object format the\nnext function will be implementing will\nbe a extractor function in essence we\nwant to be able to pull out a data point\nat a certain index from our linked list\nand this will be the function we'll be\nusing to do that we'll call it a get\nfunction pass in the index at which we\nwant to extract the data from first\nthing we want to do here is just have a\nsmall check to make sure that the index\nthat the user passed is not out of the\nrange or out of the length of our our\nlength list so we can say if index is\ngreater than or equal to the length\nwe'll just print out an error message\nget index of range and then for now we\ncan just return none so now you're\nprobably getting the hang of this\nalready and pretty much every one of the\nlinked list functions you're going to\nhave to do some sort of iteration over\nthe elements of the list and obviously\nthat's the downside that you get when\nyou switch over from having a structured\ndata type such as an array or a list\nover to one that's more relational so\nI'll begin by creating a variable to\ncontain the current index we're looking\nat set that equal to zero once again\nanother variable to contain the current\nthough you're looking at which is going\nto start with the head and then begin\nthe iteration here incrementing the\ncurrent node by setting the current node\nequal to the next node and now here\nwe're going to be check if the current\nindex is equal to the index that was\nprovided by the user then we know we're\nat the data point that we want to\nextract we'll say return current node\ndot data as simple as that\nand then otherwise we're going to be\nincrementing our current index and we\ndon't have to worry about the fact that\nthis is a pretty much a forever loop\nbecause we already checked to make sure\nthat the index they provided was not\nlonger than the length of our or list so\nfar so now I can write some helper code\nhere to make sure our new get function\nworks properly\nwell obviously again create a linked\nlist we can append on some data end on\none two three and four just print this\nout again to make sure it looks\nappropriate perfect now let's try doing\nprinting\nOh mints at second index do my list\nget index of two okay\nso the element at the second index of\nzero one two is three and we've reported\nthat correctly here so now I can go on\nand implement the last function we'll be\nimplementing in our linked list which\nwill be an erase function to erase a\nnode at a certain provided index so\nwe'll call that erase passing the index\nB would wish to erase app and once again\nwe're going to be checking to make sure\nthat the index they provided is not\nlonger than the actual linked list that\nwe have so far and we would just return\nif that was the case so once again we're\ngoing to obviously be using same\nnotation here to begin our iteration\nstart the loop and in this case it's\ngoing to be a little bit different we're\ngoing to be saving the current node as\nwhat we can call our last node we're\ngoing to need to do this because when\nwe're erasing a node say for example if\nwe wanted to erase three we have to do a\nlittle bit of bookkeeping to make sure\nthat after we've erased three the next\nnode in two points to the appropriate\nspot at four so last node equals current\nnode and then we'll increment current\nnode by spending it equal to the next\nnode now here we want to check and see\nif we're at the index that the user\nprovided in which case we're going to\nwant to delete the node so we don't even\nactually have to delete the current node\nall we have to do is change the pointer\nfrom the last node to be the one skipped\npast the current node\nso we can say last node dot next is\nequal to current node dot next and so\neffectively this is going to be a racing\ncurrent node and then return and then if\nwe weren't at the current index yet at\nthe index the user provided we're going\nto be incrementing our current index to\nreflect the fact that we've incrementing\nour current node now I can add in some\nhelper code once again to make sure that\nour erase function works properly we'll\njust append in some data after creating\nour linked list just make these a little\nbit differentiated display this before\nwe erase anything now we can erase the\nelement at index one which should erase\nour one and then we can display this\nagain to make sure it worked properly\nokay cool\nso as you can see after having inserted\nour five elements 0 1 2 3 4 obviously we\nhave now a linked list of length 5 and\nthen after calling our erase function at\nthe first index which is this index here\nnow we're left with a list of only\nlength 4 where the 1 is now gone so guys\nI think that's going to be it for this\nvideo if you'd like me to create a\ngithub repository for the code in this\nlesson post a comment if I end up doing\nthat I'll also post that in the\ndescription probably also post a comment\non the video so you guys can check that\nout\nif you enjoyed the video give me a\nthumbs up subscribe to my channel if you\nwant to see more of these videos in the\nfuture also I'd recommend checking out\nthe video I did on dictionaries in\nPython if you're interested in that it's\nanother data structure that's very\nuseful\nin numerous algorithms and it's also\nvery efficient to so keep that in mind\nhope you guys enjoy the video and I'll\nsee in the next one\n",
  "words": [
    "happening",
    "everyone",
    "video",
    "introducing",
    "linked",
    "list",
    "data",
    "structure",
    "using",
    "python",
    "coding",
    "language",
    "one",
    "favorite",
    "language",
    "simplicity",
    "allow",
    "explain",
    "features",
    "data",
    "structure",
    "without",
    "delve",
    "deep",
    "lower",
    "level",
    "functionality",
    "unlike",
    "dictionaries",
    "seen",
    "prior",
    "video",
    "link",
    "lists",
    "feature",
    "python",
    "language",
    "instead",
    "video",
    "start",
    "explaining",
    "basics",
    "data",
    "structure",
    "later",
    "get",
    "coding",
    "actual",
    "classes",
    "functions",
    "suggestions",
    "data",
    "structures",
    "cover",
    "future",
    "videos",
    "definitely",
    "hesitate",
    "post",
    "comment",
    "certainly",
    "read",
    "well",
    "address",
    "questions",
    "may",
    "start",
    "linked",
    "list",
    "essentially",
    "way",
    "store",
    "data",
    "ordered",
    "manner",
    "experience",
    "arrays",
    "see",
    "picture",
    "fairly",
    "simple",
    "idea",
    "understand",
    "easiest",
    "way",
    "opinion",
    "introduce",
    "linked",
    "lists",
    "compare",
    "arrays",
    "coding",
    "languages",
    "array",
    "basically",
    "fixed",
    "sized",
    "chunk",
    "memory",
    "chunk",
    "subdivided",
    "smaller",
    "sections",
    "accessed",
    "using",
    "indices",
    "starting",
    "index",
    "zero",
    "one",
    "great",
    "benefits",
    "using",
    "array",
    "access",
    "addresses",
    "indices",
    "constant",
    "time",
    "big",
    "one",
    "big",
    "notation",
    "layman",
    "terms",
    "means",
    "pretty",
    "much",
    "access",
    "elements",
    "array",
    "amount",
    "time",
    "first",
    "index",
    "millionth",
    "index",
    "reason",
    "need",
    "calculate",
    "single",
    "memory",
    "address",
    "instruct",
    "computer",
    "pull",
    "data",
    "address",
    "spot",
    "array",
    "example",
    "array",
    "shaded",
    "green",
    "blocks",
    "indices",
    "would",
    "use",
    "index",
    "one",
    "green",
    "blocks",
    "would",
    "data",
    "zero",
    "index",
    "first",
    "index",
    "way",
    "however",
    "large",
    "array",
    "may",
    "case",
    "array",
    "length",
    "10",
    "true",
    "connection",
    "elements",
    "array",
    "lies",
    "fact",
    "slotted",
    "next",
    "memory",
    "think",
    "python",
    "list",
    "object",
    "array",
    "like",
    "data",
    "structure",
    "linked",
    "list",
    "hand",
    "strict",
    "linear",
    "ordering",
    "memory",
    "instead",
    "ordering",
    "elements",
    "controlled",
    "data",
    "structures",
    "contain",
    "one",
    "individual",
    "elements",
    "rather",
    "element",
    "fixed",
    "size",
    "block",
    "memory",
    "slotted",
    "next",
    "neighbors",
    "length",
    "list",
    "uses",
    "data",
    "structure",
    "called",
    "node",
    "wrap",
    "one",
    "elements",
    "along",
    "stored",
    "element",
    "node",
    "structure",
    "contains",
    "metadata",
    "shows",
    "whole",
    "linked",
    "list",
    "together",
    "node",
    "contains",
    "one",
    "pointer",
    "next",
    "element",
    "list",
    "think",
    "pointer",
    "either",
    "memory",
    "address",
    "next",
    "node",
    "next",
    "node",
    "suffice",
    "say",
    "node",
    "knowledge",
    "get",
    "next",
    "node",
    "see",
    "picture",
    "last",
    "node",
    "identified",
    "last",
    "node",
    "next",
    "node",
    "pointer",
    "set",
    "null",
    "two",
    "common",
    "forms",
    "length",
    "list",
    "shown",
    "picture",
    "first",
    "one",
    "described",
    "called",
    "singly",
    "linked",
    "list",
    "doubly",
    "linked",
    "list",
    "difference",
    "doubly",
    "linked",
    "list",
    "nodes",
    "contain",
    "pointers",
    "prior",
    "element",
    "list",
    "well",
    "next",
    "picture",
    "see",
    "efficiency",
    "various",
    "operations",
    "using",
    "singly",
    "doubly",
    "linked",
    "lists",
    "pause",
    "video",
    "jot",
    "information",
    "need",
    "exam",
    "take",
    "note",
    "comparisons",
    "linked",
    "list",
    "array",
    "data",
    "structures",
    "switch",
    "coding",
    "editor",
    "begin",
    "developing",
    "underlying",
    "node",
    "length",
    "list",
    "data",
    "structures",
    "algorithms",
    "okay",
    "first",
    "data",
    "structure",
    "going",
    "implementing",
    "node",
    "class",
    "fairly",
    "simple",
    "contains",
    "two",
    "elements",
    "passing",
    "data",
    "point",
    "element",
    "stored",
    "node",
    "constructor",
    "default",
    "set",
    "none",
    "going",
    "storing",
    "past",
    "data",
    "point",
    "storing",
    "pointer",
    "next",
    "node",
    "see",
    "constructor",
    "initializing",
    "none",
    "makes",
    "sense",
    "recall",
    "last",
    "element",
    "linked",
    "list",
    "always",
    "going",
    "next",
    "pointer",
    "set",
    "none",
    "default",
    "set",
    "child",
    "node",
    "b",
    "attached",
    "end",
    "node",
    "update",
    "variable",
    "next",
    "data",
    "structure",
    "going",
    "creating",
    "going",
    "called",
    "linked",
    "list",
    "class",
    "basically",
    "wrapper",
    "wraps",
    "nodes",
    "user",
    "never",
    "actually",
    "going",
    "interface",
    "node",
    "class",
    "going",
    "subclass",
    "linked",
    "list",
    "okay",
    "constructor",
    "always",
    "going",
    "want",
    "head",
    "node",
    "available",
    "inside",
    "linked",
    "list",
    "head",
    "node",
    "never",
    "going",
    "contain",
    "actual",
    "data",
    "going",
    "indexable",
    "words",
    "user",
    "going",
    "able",
    "access",
    "head",
    "node",
    "going",
    "simply",
    "used",
    "placeholder",
    "allow",
    "us",
    "point",
    "first",
    "element",
    "list",
    "first",
    "creating",
    "list",
    "going",
    "list",
    "length",
    "0",
    "get",
    "confused",
    "even",
    "though",
    "single",
    "node",
    "length",
    "list",
    "actually",
    "going",
    "one",
    "data",
    "nodes",
    "first",
    "function",
    "going",
    "want",
    "implement",
    "probably",
    "going",
    "append",
    "function",
    "going",
    "function",
    "similarly",
    "append",
    "function",
    "list",
    "object",
    "built",
    "python",
    "going",
    "adding",
    "new",
    "data",
    "point",
    "end",
    "current",
    "list",
    "obviously",
    "linked",
    "list",
    "first",
    "created",
    "going",
    "elements",
    "append",
    "function",
    "used",
    "create",
    "first",
    "element",
    "list",
    "passing",
    "datapoint",
    "first",
    "gon",
    "na",
    "creating",
    "new",
    "node",
    "class",
    "node",
    "obviously",
    "passing",
    "data",
    "recall",
    "set",
    "data",
    "point",
    "inside",
    "node",
    "creating",
    "variable",
    "store",
    "node",
    "currently",
    "looking",
    "call",
    "cur",
    "equal",
    "self",
    "dot",
    "head",
    "going",
    "start",
    "obviously",
    "left",
    "turn",
    "left",
    "point",
    "list",
    "going",
    "iterate",
    "one",
    "nodes",
    "list",
    "starting",
    "head",
    "get",
    "point",
    "next",
    "node",
    "current",
    "node",
    "none",
    "know",
    "going",
    "last",
    "node",
    "list",
    "point",
    "insert",
    "new",
    "node",
    "next",
    "node",
    "prior",
    "node",
    "iterating",
    "well",
    "next",
    "element",
    "current",
    "node",
    "equal",
    "none",
    "traverse",
    "list",
    "know",
    "last",
    "element",
    "list",
    "set",
    "next",
    "node",
    "equal",
    "new",
    "node",
    "next",
    "function",
    "probably",
    "going",
    "want",
    "implement",
    "going",
    "function",
    "figure",
    "length",
    "linked",
    "list",
    "obviously",
    "useful",
    "trying",
    "manage",
    "nodes",
    "list",
    "want",
    "figure",
    "large",
    "data",
    "structure",
    "working",
    "call",
    "one",
    "length",
    "passing",
    "parameters",
    "obviously",
    "instance",
    "class",
    "creating",
    "another",
    "variable",
    "point",
    "current",
    "node",
    "obviously",
    "set",
    "equal",
    "head",
    "well",
    "create",
    "another",
    "variable",
    "contain",
    "total",
    "number",
    "nodes",
    "seen",
    "point",
    "zero",
    "going",
    "begin",
    "iterating",
    "nodes",
    "incrementing",
    "total",
    "traversing",
    "next",
    "node",
    "done",
    "obviously",
    "exiting",
    "know",
    "last",
    "node",
    "tell",
    "next",
    "node",
    "equal",
    "nine",
    "done",
    "iteration",
    "iterations",
    "loop",
    "know",
    "total",
    "variable",
    "contain",
    "number",
    "elements",
    "list",
    "return",
    "next",
    "function",
    "creating",
    "kind",
    "helper",
    "function",
    "help",
    "us",
    "along",
    "creating",
    "rest",
    "functions",
    "going",
    "function",
    "use",
    "display",
    "current",
    "contents",
    "list",
    "test",
    "play",
    "around",
    "lengths",
    "append",
    "functions",
    "call",
    "one",
    "display",
    "passed",
    "parameters",
    "gon",
    "na",
    "creating",
    "list",
    "elements",
    "seen",
    "set",
    "new",
    "variable",
    "current",
    "looking",
    "set",
    "equal",
    "head",
    "going",
    "begin",
    "traversing",
    "nodes",
    "current",
    "node",
    "next",
    "element",
    "current",
    "node",
    "equal",
    "none",
    "set",
    "current",
    "node",
    "equal",
    "next",
    "node",
    "append",
    "data",
    "current",
    "node",
    "list",
    "elements",
    "seen",
    "end",
    "iteration",
    "loop",
    "going",
    "printing",
    "elements",
    "come",
    "across",
    "play",
    "around",
    "linked",
    "list",
    "created",
    "far",
    "test",
    "make",
    "sure",
    "two",
    "append",
    "length",
    "functions",
    "work",
    "properly",
    "begin",
    "creating",
    "instance",
    "length",
    "list",
    "call",
    "list",
    "first",
    "display",
    "switch",
    "command",
    "prompt",
    "run",
    "file",
    "okay",
    "expected",
    "obviously",
    "point",
    "nothing",
    "list",
    "let",
    "try",
    "appending",
    "integer",
    "append",
    "one",
    "try",
    "appending",
    "second",
    "integer",
    "well",
    "display",
    "perfect",
    "see",
    "added",
    "two",
    "elements",
    "see",
    "printed",
    "nicely",
    "list",
    "python",
    "list",
    "object",
    "format",
    "next",
    "function",
    "implementing",
    "extractor",
    "function",
    "essence",
    "want",
    "able",
    "pull",
    "data",
    "point",
    "certain",
    "index",
    "linked",
    "list",
    "function",
    "using",
    "call",
    "get",
    "function",
    "pass",
    "index",
    "want",
    "extract",
    "data",
    "first",
    "thing",
    "want",
    "small",
    "check",
    "make",
    "sure",
    "index",
    "user",
    "passed",
    "range",
    "length",
    "length",
    "list",
    "say",
    "index",
    "greater",
    "equal",
    "length",
    "print",
    "error",
    "message",
    "get",
    "index",
    "range",
    "return",
    "none",
    "probably",
    "getting",
    "hang",
    "already",
    "pretty",
    "much",
    "every",
    "one",
    "linked",
    "list",
    "functions",
    "going",
    "sort",
    "iteration",
    "elements",
    "list",
    "obviously",
    "downside",
    "get",
    "switch",
    "structured",
    "data",
    "type",
    "array",
    "list",
    "one",
    "relational",
    "begin",
    "creating",
    "variable",
    "contain",
    "current",
    "index",
    "looking",
    "set",
    "equal",
    "zero",
    "another",
    "variable",
    "contain",
    "current",
    "though",
    "looking",
    "going",
    "start",
    "head",
    "begin",
    "iteration",
    "incrementing",
    "current",
    "node",
    "setting",
    "current",
    "node",
    "equal",
    "next",
    "node",
    "going",
    "check",
    "current",
    "index",
    "equal",
    "index",
    "provided",
    "user",
    "know",
    "data",
    "point",
    "want",
    "extract",
    "say",
    "return",
    "current",
    "node",
    "dot",
    "data",
    "simple",
    "otherwise",
    "going",
    "incrementing",
    "current",
    "index",
    "worry",
    "fact",
    "pretty",
    "much",
    "forever",
    "loop",
    "already",
    "checked",
    "make",
    "sure",
    "index",
    "provided",
    "longer",
    "length",
    "list",
    "far",
    "write",
    "helper",
    "code",
    "make",
    "sure",
    "new",
    "get",
    "function",
    "works",
    "properly",
    "well",
    "obviously",
    "create",
    "linked",
    "list",
    "append",
    "data",
    "end",
    "one",
    "two",
    "three",
    "four",
    "print",
    "make",
    "sure",
    "looks",
    "appropriate",
    "perfect",
    "let",
    "try",
    "printing",
    "oh",
    "mints",
    "second",
    "index",
    "list",
    "get",
    "index",
    "two",
    "okay",
    "element",
    "second",
    "index",
    "zero",
    "one",
    "two",
    "three",
    "reported",
    "correctly",
    "go",
    "implement",
    "last",
    "function",
    "implementing",
    "linked",
    "list",
    "erase",
    "function",
    "erase",
    "node",
    "certain",
    "provided",
    "index",
    "call",
    "erase",
    "passing",
    "index",
    "b",
    "would",
    "wish",
    "erase",
    "app",
    "going",
    "checking",
    "make",
    "sure",
    "index",
    "provided",
    "longer",
    "actual",
    "linked",
    "list",
    "far",
    "would",
    "return",
    "case",
    "going",
    "obviously",
    "using",
    "notation",
    "begin",
    "iteration",
    "start",
    "loop",
    "case",
    "going",
    "little",
    "bit",
    "different",
    "going",
    "saving",
    "current",
    "node",
    "call",
    "last",
    "node",
    "going",
    "need",
    "erasing",
    "node",
    "say",
    "example",
    "wanted",
    "erase",
    "three",
    "little",
    "bit",
    "bookkeeping",
    "make",
    "sure",
    "erased",
    "three",
    "next",
    "node",
    "two",
    "points",
    "appropriate",
    "spot",
    "four",
    "last",
    "node",
    "equals",
    "current",
    "node",
    "increment",
    "current",
    "node",
    "spending",
    "equal",
    "next",
    "node",
    "want",
    "check",
    "see",
    "index",
    "user",
    "provided",
    "case",
    "going",
    "want",
    "delete",
    "node",
    "even",
    "actually",
    "delete",
    "current",
    "node",
    "change",
    "pointer",
    "last",
    "node",
    "one",
    "skipped",
    "past",
    "current",
    "node",
    "say",
    "last",
    "node",
    "dot",
    "next",
    "equal",
    "current",
    "node",
    "dot",
    "next",
    "effectively",
    "going",
    "racing",
    "current",
    "node",
    "return",
    "current",
    "index",
    "yet",
    "index",
    "user",
    "provided",
    "going",
    "incrementing",
    "current",
    "index",
    "reflect",
    "fact",
    "incrementing",
    "current",
    "node",
    "add",
    "helper",
    "code",
    "make",
    "sure",
    "erase",
    "function",
    "works",
    "properly",
    "append",
    "data",
    "creating",
    "linked",
    "list",
    "make",
    "little",
    "bit",
    "differentiated",
    "display",
    "erase",
    "anything",
    "erase",
    "element",
    "index",
    "one",
    "erase",
    "one",
    "display",
    "make",
    "sure",
    "worked",
    "properly",
    "okay",
    "cool",
    "see",
    "inserted",
    "five",
    "elements",
    "0",
    "1",
    "2",
    "3",
    "4",
    "obviously",
    "linked",
    "list",
    "length",
    "5",
    "calling",
    "erase",
    "function",
    "first",
    "index",
    "index",
    "left",
    "list",
    "length",
    "4",
    "1",
    "gone",
    "guys",
    "think",
    "going",
    "video",
    "like",
    "create",
    "github",
    "repository",
    "code",
    "lesson",
    "post",
    "comment",
    "end",
    "also",
    "post",
    "description",
    "probably",
    "also",
    "post",
    "comment",
    "video",
    "guys",
    "check",
    "enjoyed",
    "video",
    "give",
    "thumbs",
    "subscribe",
    "channel",
    "want",
    "see",
    "videos",
    "future",
    "also",
    "recommend",
    "checking",
    "video",
    "dictionaries",
    "python",
    "interested",
    "another",
    "data",
    "structure",
    "useful",
    "numerous",
    "algorithms",
    "also",
    "efficient",
    "keep",
    "mind",
    "hope",
    "guys",
    "enjoy",
    "video",
    "see",
    "next",
    "one"
  ],
  "keywords": [
    "video",
    "linked",
    "list",
    "data",
    "structure",
    "using",
    "python",
    "coding",
    "one",
    "seen",
    "start",
    "get",
    "functions",
    "structures",
    "post",
    "well",
    "address",
    "see",
    "picture",
    "array",
    "memory",
    "index",
    "zero",
    "elements",
    "first",
    "would",
    "case",
    "length",
    "next",
    "contain",
    "element",
    "node",
    "pointer",
    "say",
    "last",
    "set",
    "two",
    "nodes",
    "begin",
    "okay",
    "going",
    "class",
    "passing",
    "point",
    "none",
    "end",
    "variable",
    "creating",
    "user",
    "want",
    "head",
    "function",
    "probably",
    "append",
    "new",
    "current",
    "obviously",
    "create",
    "looking",
    "call",
    "equal",
    "dot",
    "know",
    "another",
    "incrementing",
    "iteration",
    "loop",
    "return",
    "display",
    "make",
    "sure",
    "properly",
    "check",
    "provided",
    "three",
    "erase",
    "also"
  ]
}