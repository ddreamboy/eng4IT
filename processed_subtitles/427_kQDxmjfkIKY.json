{
  "text": "hi I'm Joe James I have master's degree\nin computer science and I'm a software\nengineer in Silicon Valley and in this\ncourse we're gonna learn about data\nstructures in Python you might be\nwondering well why should I care about\ndata structures in Python let's imagine\nfor a second that your carpenter you\nwouldn't try to pound in a nail with the\nscrewdriver that just doesn't make sense\ncarpenters no you can't do that you also\nwouldn't try to drive into screw with\nthe pair of pliers so carpenters know\nthat for every task there's a best tool\nfor the job\nand that's why carpenters carry around a\ntool belt full of tools and those tools\nare specialized for different tasks and\nthat's exactly what you're going to do\nwhen you master data structures in\nPython data structures are your tool\nbelt for each task you face as a\nprogrammer you're going to know exactly\nwhich data structure to use and how to\nuse it you're going to save time write\nbetter code and do it more efficiently\nso in this course we're gonna learn\nabout pythons built-in data structures\nstrings lists tuples sets and\ndictionaries then we're going to\ncontinue to learn about queues stacks\nand heaps we're also going to learn\nabout linked lists then we're going to\ncover binary search trees and graphs\nyou're gonna learn how to use these data\nstructures how to implement them in\nPython and you're going to learn the\nstrengths and weaknesses of each of\nthese data structures so let's look at\nsome of the code first we'll look at\nsequence types string list and tupple so\nI put a link here to the documentation\nthis is the official Python\ndocumentation encourage you to check\nthat out if you have any questions or\nyou want more detail on you needing\nthese items just look at the\ndocumentation link here so first is\nindexing we can access any item in a\nsequence by using its index we put that\nindex inside square brackets an indexing\nstarts with zero the first element is\nalways zero\nso the fourth element is going to be\nindex three so here we have a string\nfrog as four letters in it if we want\nthe fourth element which is G we print\nout X of 3 that gives us the G as you\ncan see in the output here if we have a\nlist of pig cow and horse these are\nstrings we can print out X of 1 and\nthat's going to give us cow and again\nit's just square brackets and a tuple\nwith four names in it and if we want the\nvery first name we print out X of zero\nwith the zero in square brackets and\nthat gives us Kevon so that's indexing\nnow let's look at slicing we can slice\nout sub strings sub lists or sub temples\nusing indexes so the way indexing works\nis you put inside the square brackets\nseparated by colons three possible\nparameters so we can put a start and end\nplus one and a step and I'll show you\nwhat each of these means so let's just\nuse a string for this example computer\nthe word computer again the sea is index\n0 so here we're going to print out X of\n1 to 4 so since we didn't put a third\nparameter that means the step is assumed\nto be 1 that's the default step so when\nwe put 1 that means the O and that is\ninclusive the from is or the start is\nalways inclusive the end is non\ninclusive so if we look at item number 4\nthat's the U that's the fifth item it's\nnot inclusive so it's really just going\nto get OMP for us and when we look at\nthe result it prints out OMP now here's\nan example using a step so we print out\nX of 1 to 6 again we're going to start\nat the O because the 1 is inclusive and\nwe're going to go up to 6 which is the e\nbut it's non inclusive and we're going\nto do it in a step of 2 so in other\nwords we're going to get to O the P and\nthe T and that's what we print out opt\nso it takes every other item when we\nhave a step of 2\nnext we're going to not put a end\nplus-one we're just gonna leave an open\ncolon there and what happens is when we\nput the open colon 3 : nothing basically\nthe default is end of string so\neverything from the third item on so\nhere the third item is P because we\nstart counting at zero the third item is\nP and we get everything from P onward P\nUT ER so if you don't know how long a\nstring is or you just want to get all of\nthe remaining elements skip the first\nthree three items or something you use\nan open : next we're not going to\ndeclare a start so we can skip the start\nby just putting : five so in other words\nour default is we're going to start from\nthe beginning of the string we're going\nto get up to the sixth item because the\nv is not inclusive so c om p u and you\ncan see our result here are Co MP u so\nyou can see if you don't declare a start\nthe start defaults to the beginning and\nif you don't declare an end the end\ndefaults to the end and if you don't\ndeclare a step the step defaults to one\nso that's basically what's happening\nhere let's look at a negative index so\nif we print out just a negative index\nnegative one that counts from the right\nside of the string so here we want the\nvery last item in the string we put\nnegative 1 we get the are the last\nelement and then here we get the last\nthree items so we put a negative three\nas the from and to the end of the string\nso that gives us ter that gives us the\nlast 3 elements and then if we want to\nget everything except the last two\nelements of the string we leave this\nstart blank so we get everything from\nthe beginning up until the last two\nitems so that is how slicing works and\nit works exactly the same as we just\ncovered for this string example works\nexactly the same on lists and tuples\nnow let's look at adding and\nconcatenating so we can combine two\nsequences of the same type using the\nplus sign let's look at a string example\nfirst we want to combine horse and shoe\nand we just print X so we see the result\nis horseshoe if we have two separate\nlists and we want to merge those two\nlists together we can use a plus sign\nand when we print that we get a single\nlist with three elements in it and in\nthe case of tuples if we have two\nseparate tuples and we print the result\nwe get a single tuple with four elements\nin it now it's important to note here\nfor the second one to be considered a\ntupple we have to include a comma here\nif we don't have that comma it's just a\nstring in parentheses if we include this\ncomma that tells python that this is\nactually a tuple we can use the\nmultiplying function to multiply a\nsequence using the asterisk in a string\nexample if we want to print bug three\ntimes we just do bug times three and\nthen print and you can see the result\nhere is bug bug bug and the same with a\nlist we have a list eight comma five and\nwe want to multiply that by three what\nwe get is eight five eight five eight\nfive so we're not actually multiplying\nthe elements by three we're multiplying\nthe list by three and then the same with\ntuple we can multiply at up all by three\nand then we get basically a triplicate\nof that tupple now let's look at testing\nmembership we can test whether an item\nis in or not in a sequence these are\nreally easy\nit's almost English key words in Python\nthey made it so simple so with a string\nlet's say we have a string called bug\nand we want to check if the letter U is\nin our string we just say u in X and\nthat's going to give us a boolean result\ntrue or false in this case u is in X so\nit returns true and now we have a list\npig cow and horse if we print cow not in\nY it's going to print false because cow\nis in Y\nand for a couple example we have a\ncouple here with four names and if we\nprint one of those names in Z we get\ntrue because it is in Z so it's really\neasy to check membership using in or not\nin if we want to iterate through the\nitems in a sequence we can say for item\nin X an item can be any variable name\nyou want it can be for number in X or\nwhatever you like here I just use the\nvariable name item print item if you\nwant both the index and the item here we\nhave a list with 7 8 and 3 in it we say\nindex comma item in enumerate X the\nnumerator is going to return both an\nindex and an item so actually again\nthese variable names are arbitrary the\nfirst one is going to be the index the\nsecond one is going to be the item\nitself so you can name them whatever\nvariable name you like but you can get\nboth the index and the item using the\nenumerate function and then we have\naccess to both the index in the item as\nyou can see the results if you want to\nget the count or the number of items in\na sequence you can just use the Len\nfunction so in a string example we have\nbug we get Len of X 3 this list we have\nthree items in the list so we print lin\nof y we get three and our tuple the Len\nof Z is four to find the minimum item\nPython checks is lexicographically which\nmeans the smallest on the ASCII scale so\nyou can use the minimum function on\neither alpha or numeric types but you\ncannot mix alpha and numeric types into\na list or a temple you'll get an error\nso here on our string example we print\nthe min of X we get the smallest letter\nwhich is B and in the list we print the\nminimum of Y which is cow because it\nbasically is going to compare the first\nletter first and see it comes first\nalphabetically and the same with the\ntupple we print the one that comes first\nalphabetically in that's Craig so that's\nthe min\nthe maximum item in a sequence again\nlexicographically and it can be done\nalpha or numerically but not both\nso it's bug the maximum is you and with\npig cow and horse we see that pig\nactually comes last alphabetically and\nin our couple example in is the last\nletter alphabetically we can find the\nsum of items in a sequence they have to\nbe numeric so if you mix in other items\nthat are non numeric let's say strings\nor something it's going to give you an\nerror so in the case of a string we\nthrow a string in here and we find that\nwe print sum you're just going to get an\nerror but if we have a list of numbers\nand we print the sum of that list you\ncan see we get 27 you can also do\nslicing you can combine slicing to get a\nsum of part of the list so if here we\nwant to just get the last two numbers 8\nand 12 we can do negative 2 onward and\nthat gives us 20 because we adding 8 and\n12 only and for the tupple we have\nanother tuples e with 4 items in it and\nwe add those together we get 80 sorting\nreturns a new list of items in sorted\norder but it returns it as a list so\nhere we have a string bug we print the\nthe sorted version of X and what we get\nback is the letters basically separated\nand sorted as a list elements of a list\nour list example it's Caesar these are\nstrings it puts them in sorted order and\nit returns to the list in sorted order\nand it's important to understand this\ndoes not change the original list the\nsorted function is not an in-place sort\nit returns a new list with a sort result\nin our example we have four names here\nand we put those in sorted order and get\nCraig Jenny Kevin and Nicholas\nso let's say you don't want to sort by\nthe first letter that you want to sort\ninstead by the second letter well you\ncan use a lambda function to do that I'm\nnot going to cover lambda functions in\ndetail in this video but I want to make\nyou aware that you can sort stuff either\nby reverse order or using some other\nparameter and we do that using key\nequals some lambda function and here we\nfor each item K you can again you can\nuse as an arbitrary variable name k\nwe're gonna take the one item which is\nthe second letter so here it's going to\nbe e i e and r and we're going to put\nthose in sorted order based on the\nsecond letter and we can see those with\nthe second letter in sorted order if we\nwant to get the count of items in a\nsequence we can use the count function\nand here we're going to we have the word\nhippo in a string we're going to count\nthe number of times the letter P appears\nin hippo and we can see that the result\nis two here I added a word cow to the\nlist twice so if we get the count of the\nword cow we see that that also is two\nand here we just get the word count of\nKevin in this list and we can see that\nis one and we can get the index of an\nitem by passing in that item and asking\nfor the index of it and what it's going\nto give us is the index of the first\noccurrence of the item so in the case of\nhippo if we're looking for P it's going\nto give us let's see H is zero I is one\nthe first P is two so we can see the\nresult we get is two it stops looking\nafter it finds the first item that\nmatches in the sequence and our list\nexample we have cow we have two cows in\nhere and we're going to get the index of\ncow and we're going to get one as a\nreturn value and then for the tuple we\nget the index of Jenny and we can see\nthat's 0 1 2 so unpacking of items in a\nsequence and we can unpack those into a\nnumber of variables it's important that\nour number of variables exactly matches\nthe length of that list or string\nbecause we're if not we're going to get\nan error so here we have a list x equals\ncow and horse and if we won't unpack\nthose and assign each of these values to\nits own variable we can say a comma B\ncomma C equals x and then that's\nbasically going to put these in order\nassigning them to a b and c so when we\nprint out a b and c now these are each\nseparate variables pig cow and horse so\nthat's called unpacking in the next\nlecture we'll learn more detailed\nfeatures of lists tuples sets and\ndictionaries so now let's dig into some\nof the specifics of lists tuples sets\nand dictionaries again as a recap lists\nare the most general-purpose data\nstructure in python you're going to use\nthese for almost everything in Python I\nshould say a lot of stuff and this can\ngrow and shrink in size as needed so you\ncan continue adding items to them or\ndeleting items from them and the size of\nthe list will shrink accordingly\nautomatically python does that for you\nand this is our a sequence type so all\nof the sequence functions that we\ncovered above are all useful for lists\nand they're also sortable a lot of data\nstructures are not sortable lists are\nthat makes them useful for sorting data\nso let's look at some of the\nConstructors for lists how do we create\na new list so there are few different\nways of doing this one we can create an\nempty list by just saying x equals list\nand in parentheses that calls the list\nconstructor with no no parameters and it\ngives us a new empty list and another\nway to do it is this is probably the\nmost common way is to pass in the items\nwe want in that list inside square\nbrackets these square brackets we can\nseparate each item with a comma we can\npass in here we have multiple different\ndata types we have strings we have\nintegers and in floating point values\nall in the same list and that's one nice\nthing about the versatility of lists you\ncan see here we can also create a tuple\nwhich will cover tupple constructors in\na minute but as we create a new tuple\nand we can pass that tupple in to the\nlist constructor just by putting it\ninside the parentheses in the list\nconstructor and that will create a new\nlist and Pat and assign it to Z\nand lastly we can use list\ncomprehensions I'm going to have another\nsection on list comprehensions in a few\nminutes so I just wanted to give you a\nlittle teaser of what you can do with\nlist comprehensions to create new lists\nwith sets of values so here we're going\nto create a new list called a and we put\nsquare brackets and basically inside of\nthat is a for loop in the range function\nso we can say m4m in range 8 that's\ngoing to count from 0 to 7 and for each\nvalue M it's going to assign M to the\nlist so we here we get a new list with\nvalue 0 through 7 in it and then if we\nwant to do something more fancy here's\njust a taste of it I in range 10 so\nwe're going to count 0 through 9 and\nwe're only going to take the ones that\nare greater than 4 if I is greater than\n4 then it'll pass I squared into the\nlist so here we get 5 through 9 squared\ninto this new list so that's a taste of\nwhat you can do with list comprehensions\nto create a new list using a for loop\nand the range function you can also add\nif to filter items and you can do\nwhatever you want to the items that\nyou're iterating now let's take a look\nat the delete function if we want to\ndelete a single item from a list or\nwe're going to delete the entire list we\ncan do that using del here we have a\nlist called X and we have 5 3 8 6 in it\nand if we want to delete the one thigh\ntum' which is the 3 and we can just pass\nin the one in the square brackets the\nindex of the item del x of 1 that\ndeletes the one time 2 3 and we can see\nthe new list there and if we want to\ndelete the entire list we just say del X\nnext the append function if we want to\nadd an item on to the list this is going\nto add it to the tail end of the list we\ncreate a new list 5 3 8 6 when we do X\ndot append and then we pass in that 7 is\nan argument then we can append 7 to the\ntail of the list extend basically is\nsimilar to the plus function that we\nused up\nwe're basically combining two separate\nlists into one list so here we have x\nequals 5 3 8 6 y equals 12 13 and we can\nextend x with y and then we print out\nthe new x and you can see we have all 6\nitems in it we could also have used the\nplus for that so insert we can insert an\nitem at a given index in the list here\nwe have the same list we used above and\nwe insert at the one position the item 7\nso here we can see the result is 5 7 3 8\n6 this is the position or the index we\nwant to insert it at and this is the\nitem we want to insert and then we can\nsee here that you can not only insert an\ninteger or a floating point value you\ncan Sir tale' issed\ninto a list as an item we have a list\nhere with a and M min as two items and\nthen we print out the revised list and\nwe see that the second item are the 1\nthight 'm in the list is another list\nwith a and M in it so that's the insert\nfunction let's take a look at pop pop\nbasically pops off the last item from\nthe list and it returns that item so you\ncan use that item if you want to you\ndon't have to but you are basically\nshrinking your list by one item so here\nwe have 5 3 8 6 as we pop off one item\nwe're using X dot pop that pops off the\nlast item is 6 we didn't assign it to\nanything or do anything with it but we\ncan see the new list is just 5 3 8 here\nwe print X dot pop and it pops off the 8\nthe last item on the list now and we\nprint that so we can see the the return\nvalue is 8 when we do X dot Pop remove\nwe can remove the first instance of an\nitem so if there are multiple instances\nof an item Python is going to start\nsearching at the beginning of the list\nuntil it finds that item that matches\nit's going to stop searching is going to\nremove that item so here we have\nmultiple threes in this list we're just\ngoing to remove the very first one so if\nwe do X don't remove 3 we can see the\nrevised list is without the first 3\nreverse function can reverse the order\nof a list\nit's an in-place reverse which means\nthat it changes the original list the\noriginal list is no longer the same as\nit was so here we have an original list\nof x equals 5 3 8 6 and then we apply\nreverse to it it's not putting these in\nsorted order\nit's simply reversing the order of the\nitems so we get 6 8 3 5 as the reversed\nlist and then we can apply the sort\nfunction to it which is also an in-place\nsort you should note that we can use\nsorted of AX\nthese are Python functions sort there\nare two different ones and you're a\nlittle bit confusing here sort is an\nin-place sort sorted returns a new list\nso it's not an in-place sort so here\nusing the X dot sort function we don't\npass anything in as a parameter to the\nsort function we're applying the sort\nfunction to the X which is what's\ncalling the sort function and we can see\nthat we put these items in sorted order\nand then if you want to do a reverse\nsort we can pass into the sort function\na parameter called reverse equals true\nand that will give you a descending sort\nso we get 8 6 5 3 if we try and use\nreverse equals true and again this is\nthe same parameter that you would use in\nthe sorted function if you wanted to\nreverse sort using sorted function but\nthis one is an in-place sort as you can\nsee Python lists are really powerful\ndata structure and they have a lot of\nbuilt-in functions and features but\nunless you want to become the Carpenter\nwho tries to turn every problem into a\nnail by pounding on it with a hammer\nlet's continue on in the course and\nlearn other data structures and see what\nthey can be used for so let's take a\ncloser look at tuples just to recap we\nsaid that tuples are immutable that\nmeans they can't be changed and you\ncan't add items to the tupple once it's\ncreated they are useful for fixed data\nif you're gonna have a lot of changes to\nyour data then you should use lists they\nare useful for fixed data they're much\nfaster for finding items than a list is\nand these are sequence types which means\nthat all of the above functions are\nstill going to work so you can use all\nthose sequence functions that we've used\nabove on tuples so let's take a look at\nsome of the Constructors for tuples how\ndo we create a new tuple there are a few\ndifferent ways of doing this\nthe tupple uses the parentheses as its\nconstructor so here we can create an\nempty new tuple using x equals\nparentheses empty parentheses or if we\nwant to pass in items 1 2 3 the\nparentheses are actually optional so\neven when you take the parentheses away\n1 2 3 separated by commas Python notices\nthis is a tupple now if you want a\ncouple of just one item you still have\nto put the comma that comma tells python\nthat this is a one item tuple and not\njust an integer and then you can see\nthat we print here X and the type of X\nand we get a couple with just the two in\nit and the class is a tupple now let's\ncreate list one equals two four six this\nis a list with three items in it we pass\nthat list into the tupple constructor\nand it creates a tuple called X so here\nwe print out X which is that tupple two\nfour six you can now see that it doesn't\nhave square brackets it has the\nparentheses around it because it's at up\nall and we print out the type of X and\nit's a class couple so there are several\ndifferent ways there to create tuples\ntuples again are immutable however this\nmay be a little confusing so pay\nattention member objects may be mutable\nif you have a list as one of the items\ninside a couple you can't make changes\nto that list you can add or delete items\nfrom that list you can change the items\nin the list so let's take a look at what\nwe mean here if we have a couple with\none two three in it\nand then we try to delete the one theit\n'im which is the two that's going to\nfail that's going to give us an error in\nPython if we try to change the value of\nthe two to eight that also fails we\ncannot change the value of the two so it\nlooks like the tupple is totally\nimmutable and unchangeable and we get\none two three so even if you try those\nyou're just going to get an error but\nlook at this if we assign a list a two\nitem list as the zeroeth item in this\ntuple well that list we can we can just\nmutable so we can change or drop items\noff of this list if we want so here\nwe're going to pass in two indices the\nzero tells python that yeah we want the\nzeroeth item of tuple Y which is this\nlist with one and two in it and in that\nlist we want the one thight 'm which is\nthe two and that's what we're going to\ndelete so we're basically deleting this\ntwo from this list and then we're going\nto print out y and we can see that the\nresult is we get a single item list with\nthe 1 and a 3 so we were able to edit\nthis list with the one and two we're\nable to drop items off of that list and\nthen if also if we want to add items to\nthe tempo we cannot just add or append\nhowever we can use this concatenation\nfunction where we do y plus equals an\nadditional temple and it will it will\nmerge the two tuples into one so here\nagain you need the comma to tell python\nthat this is a tupple and not just an\ninteger it's a one item tuple so if we\ndo y plus equals four we can see that\nthe four is added on to our original\ntype of y so concatenating will work now\nlet's look at sets set store non\nduplicate items so unique items are\nreally what sets are ideal for you get\nvery fast access compared to lists and\nthe reason why is when you iterate\nthrough a list looking for an item the\nonly way to do it is to start at the\nbeginning and look at every single item\nand do a\ncomparison so if you have a billion\nitems in that list you're going to do a\nbill you may have to do a billion\ncomparisons to find that item but in a\nset it hashes that item so it can find\nit instantly using the hash it has much\nfaster access than lists so especially\nfor very large data sets it has much\nfaster access to items than lists it's\ngreat for checking membership the set is\nalso great for doing math set operations\nthings like Union and intersection and\nkeep in mind that sets are unordered\nwhich means you cannot sort a set so\nlet's take a look at the Constructors\nfor a set there are a few different ways\nto create a new set we can use these\ncurly braces and you'll see here as we\npass in 3535 we've got some duplicates\nthere\nwhat python does is it filters out the\ndupes and gives us a set with just three\nand five in it and if we create a new\nempty set we can just use the set\nconstructor with parentheses and then we\nprint out y you can see we get an empty\nset if we want we can also pass in a\nlist here we have two three four and we\ncall the set constructor using the\nparentheses and our pass in our set is a\nparameter and we're getting a new set Z\nand then we print that out we get two\nthree four as a set so that's a few\ndifferent ways to create sets some of\nthe set operations you can use you can\nadd an item to a set by using X dot add\nso here we add a seven to this list of\nthree eight five and then we remove a\nthree using X dot remove so you can see\nthe result here is that after you add\nthe seven you get the four item list and\nwhen you delete the three you get back\ndown to eight five and seven so add and\nremove both work for sets and then if\nyou want to get the length of a set you\njust use Lin checking membership we use\nin or not in so if we want to check if\nfive is in the set we just do five in X\nor five not in X and that's going to\ngive us a boolean return here we can see\nwe got true for five and X\nand then we can also pop a random item\nbear in mind the set is not ordered so\nwe don't know which item we're gonna get\nwe're gonna get a random item off the\nset and then here it actually the pop\nfunction returns the item itself and so\nwe're printing out that item and the new\nlist X so here we can see the item it\ngave us is 8 and the new set is 5 and 7\nand then if we want to delete all the\nitems from the set and get our empty set\nback we can do X clear let's look at\nsome of the mathematical set functions\nso we said that we can do intersection\nand union which are and and or functions\nso the intersection is done using an\nampersand with two sets and the union is\ndone using the pipe or bar so a set one\npipe set to symmetric difference or\nexclusive or in other words and items\nthat are in set one but not in set two\nor in set two but not in set one and\nthey a difference we can just use a\nsubtraction so set one - set - because\nit's the difference between those two\nand then we can check if one set is a\nsubset or fully contained and the other\nset using the less than or equal to or\ngreater than or equal to super first\nsuperset so we have two different sets\nhere set one and set two and when we do\nthe intersection we can see that the\nintersection is three they both have\nthis value three when we do the Union we\nget all the items that are in either set\nso 1 2 3 4 5 so when we do exclusive or\nusing the up caret we get 1 2 4 5 which\nis all the items that are in one set or\nthe other but not in both and then - we\nget 1 & 2 and then since neither set is\na subset of the other set both of these\nto return false so those are some of the\nmathematical set operations you can do\non sets now let's take a look at\ndictionaries so first to recap on\ndictionaries dictionaries are key value\npairs\nso most programming languages have some\nequivalent of the Python dictionary they\ndon't always call it that some of them\ncall it a hashmap\nJava calls it a hashmap dictionaries are\nunordered this means they cannot be\nsorted they can be converted to a list\nand then sorted as a list\nbut it cannot be sorted as a dictionary\nso some of the functions that we can do\nhow do we create new dictionaries let's\ntake a look at our constructors so if we\ncreate a new dictionary using the curly\nbraces then we need to pass in members\nkey value pairs separated by a colon and\nthen spaced out with commas okay so here\nwe have three key value pairs the key is\non the Left colon and then the value and\nthese are three different ways of\ncreating exactly the same dictionary so\nin the second example we pass in a list\nof tuples\nso the tuple contains two items it has\nthe string and separated by a comma that\nfloating point so there are three tuples\nin the list passed into the dictionary\nconstructor which is in parentheses and\nthen the third one passes into the\ndictionary constructor notice search\nthere are no quotation marks around the\nstrings here we just have pork equals 25\npoint 3 in Python knows that this is a\nstring so these are three different ways\nto create dictionaries in Python they\nall do exactly the same thing some of\nthe operations of dictionaries now we\nnotice that shrimp is not in our\ndictionary so if we want to add shrimp\nwe can say X of shrimp equals 38.2 this\nin this case there is no shrimp in the\ndictionary add so it's going to add a\nnew key value pair for shrimp 38.2 if\nthere already was a shrimp in the\ndictionary then it would update the\nvalue to 38.2 for shrimp it looks up\nthis key and it will update the value\nfor it so this is add or update and\npython is not going to tell you if that\nwas in there or not if you if you want\nto check you can check first right if\nshrimp\ndictionary but if you just do this X of\nshrimp equals 38.2 it's going to\noverwrite anything that was already in\nthe dictionary for shrimp if you want to\ndelete an item this is just del X of\nshrimp is going to delete shrimp for\nthem a dictionary and then you can see\nthat we print out the new dictionary\nthere's no shrimp in it and if we want\nto get the length of the dictionary you\ncan print Lin of X they'll tell you how\nmany key value pairs are in the\ndictionary and if you want delete all\nthe items from dictionary you can use X\ndot clear and lastly to delete the\nentire dictionary and free up the memory\nthat it's using you can use del X so to\naccess keys and values in the dictionary\nyou can access these separately or you\ncan access them together so here are a\nfew different ways of doing that we have\nthis dictionary Y with pork beef and\nchicken in it those are the keys the\nstrings pork beef and chicken so if we\ndo y dot keys we get a list of pork beef\nand chicken it dumps these out as a list\nif we do wideout values it dumps these\nout as a list the values those 14-point\nvalues and if we do items we can say\nprint Y dot items it's going to print\nout all the key value pairs so here at\nPrinceton amount is a list of tuples or\nkey value pairs to check membership in\njust the keys you don't have to specify\nkeys you can if you want you can say\nbeef in Y dot keys or you can just\nsimply say beef in Y and that's gonna\ncheck in wise keys only it's not going\nto check in to values if you want to\ncheck for membership only in the values\nyou can check clams in Y dot values and\nall these membership tests are going to\nhave a boolean return true or false so\nto iterate a dictionary keep in mind\nthat these items are in random order and\nyou're not going to be able to iterate\nthem in any kind of sorted order it's\ngoing to python is going to give them\nback to you in whatever order at once so\nfor key in Y print key\nthat will give you all the keys in the\ndictionary one at a time and then you\ncan get the value by saying why of key\nso here you can see we printed out each\nkey and its value if we want to iterate\nwith a separate variable for both the\nkey and the value sometimes this is\nhelpful if you're doing a lot of\noperations inside the loop you can put\nwhatever variables you want\nI used K comma V as my variable names\nand what you do is you iterate Y dot\nitems and then items returns at up all a\nto item couple of the key and the value\nand then it assigns them to whatever\nvariable names you have here so K and V\nin my case so you can see the result\nhere is the same we iterate through the\nitems we print out both the key and the\nvalue so that wraps up this video on\nbuilt-in Python data structures now you\nshould have a pretty good understanding\nof how to use pythons built-in data\nstructures strings lists tuples sets and\ndictionaries make sure you download the\ncode and get some practice using it\nbecause it's hands-on practice is going\nto make you a good programmer in the\nnext section we'll learn how to use list\ncomprehensions to create new lists hi\nI'm Joe this chapter we're going to\ncover a pretty cool feature of python\ncalled list comprehensions that enables\nyou to create new lists of values using\na comprehension are basically sort of a\nfor loop and iteration inside of a list\ncreator so our basic format is transform\nsequence and filter so we can apply a\nfilter to it if we want and we put that\ninside square brackets and that's going\nto the result is going to be assigned to\na new list so we're going to use the\nrandom module a little bit in this don't\nneed that for all this comprehension\nbefore it to my examples so I'm going to\nimport that so we have a series of about\n10 examples or something I'll show you\nand get increasingly more complex so\nhere we're going to just get values\nwithin a range typically in list\ncomprehensions or anything is the range\nfunction\nhere we just use range of 10 and you\nknow the range function returns a\nsequence of numbers in this case it\nstarts with 0 which is a default and it\ngoes up through 9 because the 10 is non\ninclusive so 0 through 9 and what we're\ngoing to add to this new list is X for X\nin that range so in this part the first\nX we could apply some sort of a\ntransform or a function on that X if we\nwanted to x squared to X whatever we\nwant and then this is where we declare\nthe variable each X in this range so the\nresult is a series of values under 10 so\n0 through 9 under 10 integers okay so\nthat's the simplest example of a list\ncomprehension now let's look at some of\nthe other more crazy stuff that you can\ndo with list comprehensions we could get\nall the squares if we want I told you we\ncan we could apply a transformation to\nthe X if we want so here we declare our\nvariable is X as we iterate through\nunder 10 which is this list we just\ncreated okay so we don't necessarily\nhave to use the range function we can\nuse any sequence here which means we\ncould use a list we could use a couple\nset or even a string or a range function\nso x squared for X in under 10 so it's\ngoing to iterate through these it's\ngoing to return the square of each one\nof them and it's going to assign that to\nthis new list called squares and then\nwe're going to print out squares so you\ncan see the result is 0 through 81 the\nsquares of the previous list ok let's\nsee what else we can do\nget odd numbers using mod ok so odds\nequals x for X in range 10 so here we're\ngoing to just basically iterate through\n0 through 9 the variable we're going to\nuse is called X and we're gonna send X\nto this odds list but here look we apply\na test a condition if X mod 2 is\n2:1 in other words if it's odd if X is\nodd then we'll send it to this odds list\nwhen we print it out we see that we get\none three five seven and nine now let's\nget them multiples of ten so we're going\nto use the arrange function again as our\nsequence zero through nine and instead\nof adding X to the list we're gonna add\nx times ten so this is not a whole lot\ndifferent from me x squared we did we\nget two multiples of ten so zero through\nnine D now let's get all the numbers\nfrom a string so we start out with a\nstring named s that has a combination of\nletters and numbers in it maybe\nsometimes you want to filter out and\ndelete all the numbers or whatever but\nhere what we're gonna do is just create\na new list with all those numbers so\nnums\nequals x for X in s in other words we're\ngoing to iterate through the letters or\ncharacters in s and we're going to test\nif each one is numeric and if it is then\nwe're gonna add it to this list and then\nwhen we print out the list\nwe're basically we get a list so I'm\ngonna use this little join function to\njoin the numbers into a single single\nstring so we get 207 3 in other words we\nmanaged to grab all the integers in this\nstring so here we're going to get the\nindex of a list item and we're going to\ndo that by using the enumerate function\nso we iterate using enumerate names name\nthis is a list the names is a list and\nwe're going to numerator\nthe enumerate returns both a key and a\nvalue for each item in the list so we\nstart out with Cosmo and 0 and then we\nget Pedro and one on you and - right so\nwe're eating each name we're getting the\nkey and the value our test is if the\nvalue is equal to Anya okay so that\nmeans here then the key is going to be\nequal to two and then what do we add to\nthe list well we add K we add K we add\nthe key we had to so at the end result\nhere we get a list with just a two in it\nbecause that's the only one that passes\nthis test and then when we print out the\nzeroeth item in the list of course it's\na twos it's a one item list and we can\nalso delete an item from a list here we\nhave a list of letters actually a string\nwe start by iterating through the string\nABCDE F converting it to a list of\nletters just by adding each letter in\nthe string to a list so now we have a\nlist of ABCDE F as individual letters we\nshuffle those using this random function\nso now we have shuffled letters ABCDE F\nand each one of them is basically a\nstring object in the letters list so\nwe're going to create a new list that\npasses this test a for a in letters if a\nis not C right in other words every\nletter in this list except for uppercase\nC so we're gonna get a B D EF and you\nsee when we print them out we get DF e a\nB but we do not get C so we get yeah\nthat works pretty cool huh\nwe basically filtered out the C wherever\nit is in the list we don't know but we\nfiltered it out that wraps up this\nlecture on list comprehensions you can\ndownload this code from my github site\nand use tests to code and run these\nexamples and I encourage you to use list\ncomprehensions these are really a useful\ntool in Python for creating lists in\nthis section we're going to learn how to\nuse stacks queues and heaps first we'll\ncover the fundamentals of each of these\ndata structures what key operations each\nof them has and then how you can\nimplement them in Python these are three\nvery useful data structures let's start\nby learning about stacks a stack is a\nlast in first out data structure that's\ncalled LIFO so what that means is that\nall the push and pop operations are to\nthe top of the stack the only effect the\ntop item on the stack the only way to\naccess\nthe bottom items on the stack like in\nthis diagram item one is to first remove\nall of the items above it we have a\ncouple of different key operations here\npush allows us to push an item on to the\ntop of the stack and we use the pop\ncommand to pop an item off of the top of\na stack some other stack operations are\npeak sometimes you might want to get an\nitem off of the top of the stack without\nactually removing it let's say we need\naccess to the top item we want to know\nwhat it is and we can use the peak\ncommand to see a copy of the top item\nwithout actually removing it from the\nstack or clear to remove all the items\nfrom the stack and empty the stack out\nthere are a lot of different use cases\nfor stacks one very common use case is\nthe command stack all computer programs\ntrack each command that you execute and\nmost programs you use have the option of\nundoing the previous command in order to\ndo that the program has to keep track of\nwhich commands you've executed in which\norder so it does that using a stack each\ntime you execute a command it pushes\nthat command on to the stack so that has\na record of it and if you click the undo\nbutton it's going to pop the last\ncommand off of the stack and it's going\nto reverse that command so the command\nstack is used to execute the undo\nfunction in programming now let's take a\nlook at how stacks can be implemented in\ncode we have the Python list which makes\na great foundational data structure to\nstore the stack in and actually Python\ngives us most of the functionality that\nwe need to create a stack with the list\nso the underlying data structure beyond\nour stack is going to be a Python list\nPython gives us the append function\nwhich we can use to push an item onto\nthe stack and it gives us a pop function\nwhich we can use to remove an item from\nthe stack we're actually pushing items\nonto a list and opting them from a list\nso here's one implementation using the\nPython\nlist we can create a new stack my stack\nequals an empty list and then we can\npush items onto the stack using a pin is\nhere we pushed for 7 12 and 19 onto the\nstack and then when we print out the\nstack we can see four items now a little\nmore test coat here when we pop an item\noff of the stack we can see that we get\nto 19 first and we pop the second item\noff we get to 12 so it's popping off the\nlast item first which is exactly what we\nwant\nso that's typical stack operation\nhowever it's using a Python list now if\nwe wanted to write a wrapper class so\nthat we can add some additional\nfunctionality to our stack that's\nactually not that hard so let's take a\nlook at how that can be done here's a\nstack using a list as the underlying\ndata structure but using a wrapper class\nso that we can rename our functions as\nwe like and we can also add additional\nfunctions and features to our stack so\nwe'll start with a constructor an init\nfunction and this basically just has a\nnew list it creates an empty list just\nas we did before the push is going to\nadd an item so we receive an item and we\njust use the append function to add that\nitem on to the list what the user is\ngoing to see is he's pushing an item on\nthe stack but what we're doing behind\nthe scenes is appending that item to a\nlist next the pop function first we want\nto check if the list actually has items\non the list if the list is empty we\ndon't want to try a pop operation if\nthere's at least one item on the list\nthen we'll pop that item off and return\nit\nthe peek function allows us to just look\nat the top item on the list and return\nthat item but without taking it off so\nhere we return the top item on the list\nbut without removing it and lastly if\nsomeone wants to print out the stack or\nshow all the items that are on the stack\nwhat we're going to do is just show the\nstring representation of the list now\nlet's look at some tests\nsee how our stack works my stack equals\nstack and then we can push an item will\npush a1 will push a3 and then when we\nprint out the stack we can see that yeah\nwe have a1 and a3 on our stack and when\nwe pop on an item off of the stack we\nget the three which was the last item\nthat we put on the stack when we peak we\nget the one which is the only item\nactually left on the stack but as\npeeking is going to give us the top item\non the stack if we pop another item we\nget one and now the stack is empty so if\nwe try to pop another item we get none\nso basically all those key features of\nour staff are all working just fine so\nthis is how we can use a wrapper class\nto implement a stack in Python with an\nunderlying data structure of the Python\nlist so the Python list is a very\nversatile data structure and here we've\nused it to create a stack now let's take\na look at queues queue is a FIFO or\nfirst in first out data structure this\nis really intuitive because we see\nqueues in every walk of life almost in\neverything you do on a daily basis you\nencounter queues queues have two key\nfunctions you in queue an item by adding\nit to the end of the line udq an item\nmeans removing it from the front of the\nline\nso some use cases for queues just about\neverything you wait in line for so bank\ntellers placing an order at McDonald's\nor your favorite restaurant\nDMV customer service supermarket\ncheckout pretty much anything that has a\nline is what a queue is and it's\nimportant to be able to model that in a\ncomputer program so the queue data\nstructure allows us to do that now let's\ntake a look at how we can implement a\nqueue in Python it's actually pretty\nsimple because python already provides\nus a built-in library called the deck or\nde quue that's a double-ended queue that\nallows you to add and remove items from\nboth ends of the queue for our simple\nqueue we don't really need that function\nnow\nwe just want to be able to add items to\none end of the queue and pop them off of\nthe other so we can use the append\nfunction to add items or push items on\nto our queue and we can use pop left to\nremove items or pop items off of the\ncube you can see the full documentation\nin Python here if you want to learn more\nabout how double into queues work so for\nbasically just using double ended queue\nin python as a single ended queue we can\nuse from collections import deck that's\ngoing to import our double ended queue\nlibrary and then we'll create a new\nqueue my queue and that's going to be a\ndouble ended queue object and then we\ncan append items or push items using the\nappend function so we can push a 5 and\nwe can push a tin on to the queue and\nthen when we print out the queue we see\nthat we have a double ended queue with a\n5 and a 10 on it and then if we want to\npop items off of the queue we use pop\nleft and here we get to 5 that pops an\nitem off the tail end of the queue or\nthe left end of the queue so it's pretty\neasy to implement a queue in Python this\nis obviously a common enough data\nstructure that Python built in a library\nfor it now as a fun exercise for you you\nmay try writing a wrapper class for the\ndouble-ended queue to make a\nsingle-ended queue using push and pop as\nwe did similar for the stack in this\nlecture we're going to learn how to use\nmax heaps now implementation wise the\nunderlying data structure is going to be\na list and it's the functions of a max\nheap are not a whole lot different from\nstack and queue so I think you're going\nto be able to pick this up fairly easily\nnow when you look at this graphical\nrepresentation of a max heap though it\nlooks a lot like a tree and I know we\nhaven't covered trees yet that's going\nto be covered in section 5 but bear with\nme I think you're going to figure this\nout pretty easily so the one condition\nof a max heap is that every node is less\nthan or equal to\nit's parent that's the key so you'll see\nthat 25 is the parent of 16 and 24 right\n25 has a left child and a right child\nand it's greater than or equal to both\nof those and then 16 is greater than or\nequal to both of its left and right\nchildren and so on so every node in the\ntree has to be less than or equal to its\nparent and every parent node has to be\ngreater than or equal to be the nodes\nbelow it so that is the core condition\nof a max-heap and the reason it's like\nthis is so that we can instantly remove\nthis max number anytime we want anytime\nwe want to pop the top number off of the\nheap we know that it's the highest\nnumber in that heap so the highest\nnumber always rises to the top of the\nheap and it can be instantly removed and\nused so max heaps are fast if you're\nfamiliar with Big O notation you can\ninsert or add an item to a max heap in\nBig O of log n time which is extremely\nfast and you can get an item you can get\nthe max item off the top of the heap and\nBig O of one time which is pretty much\ninstantaneous you can remove the max or\npop in Big O of log in time so the\nresponse time for a max heap is\nextremely fast and that's why we use max\nheaps for some things if you need to pop\nthis the maximum number off a heap you\ncan get very quickly\nmax heaps are easy to implement in\nPython using a list not as easy as the\nother two data structures we just\ncovered but not too hard so I think\nyou'll be able to follow this but I'll\nwarn you the code is a little bit longer\nand hairier than the previous two\nexamples that we just covered but I've\nalready written all the code all you\nhave to do is just follow along with the\nexplanation so you can see that using a\nlist we open index the correspond to\nlist index it corresponds to each node\nstarting with one at the top and then\n2/3 across 4 5 6 7 across on the next\ntier and then on the next tier 8 9 10 so\nit's a pretty easy indexing system that\ncorresponds to these nodes under the\ntree\n[Music]\nand then when you look at our our list\nhow we put the items into the list well\nlook 25 is an index 1 and then 16 and 24\nso look we know that 16 is not greater\nthan 24 but it looks like wow it's lower\nthan note 3 here or index 3 why is that\nwell because our rule is that 16 has to\nbe greater than everything below it on\nthe tree which it is so our condition is\nmet this is a max-heap\n16 does not have to be greater than 24\nwe didn't say greater than everything\nbehind it on the list no no on the tree\nso that this is a valid max-heap okay\nand that is how it is implemented in the\nlist using these list indices so we can\ninstantly access any node in the tree or\nany node in the max heap now let's say\nwe wanted to access the 5 we know that\nthe index is 4 this is it index number 4\nfor this this 5 node now we can also\naccess 5s parent which is the 16 we\nsimply divide the index by 2 so this 4\ndivided by 2 gives us the index of 5s\nparent node which is 16 and if we want\nto access 5 children it's the same thing\n5s left child is times 2 to get the\nindex of 5 left child 8 and then times 2\nplus 1 gives us the index of 5s right\nchild 8 9 so if we're taking take a\ngiven node at index 4 we can access his\nright and left child by x 2 and x 2 plus\n1 and we can access force parent by just\ndivided by 2 so it's pretty quick easy\noperations to access the parent and\nchildren node in this tree\nno max heap operations like I said these\nare exactly the same operations that we\njust covered for stacks and queues so we\nwant to be able to insert or push an\nitem onto the heap we want to be able to\npeek find out what is the\nitem on the heap without popping it off\nand then we want to be able to remove an\nitem from the heap and return it which\nis a pop operation so the same three\noperations for heaps as we had for the\nprevious two data structures let's look\nat how those work so push we can add a\nvalue to the end of the array and then\nwe float it up to its proper position so\nlet's look at an example we want to push\na 12 onto this heap what we're going to\ndo is put it at the very last spot in\nthe array which is here right and we\nhave a spot for it so in other words\nit's gonna be 11 right child it's the\nlast index in the array and then we need\nto float it up to its proper position\nwell how do we do that we need to\ncompare 12 to 11 if 12 is greater than\nthese two we'll swap places yeah it is\ngreater so we want the 12 and 11 to swap\nplaces now we need to compare 12 to its\nits new parent 16 is 12 greater than 16\nno it's not so there's no more swapping\n12 is already floated up to its proper\nposition in the heap so this is one of\nthe key behind-the-scenes functions that\nwe have to code which is called float up\nor bubble up when we add an item to the\nbottom of the tree we need to be able to\nbubble it up to its correct position in\nthe heap by comparing it to its parent\nnodes and in swapping so we use that\nevery time we do a push operation peek\njust returns the value at the top of the\nheap okay which is going to be heap of\nnumber one index number one and that's\npretty straightforward we don't really\nneed to pop it off or anything's we just\nget that item and return it and then pop\nfirst we're going to move this topmost\nitem we want to pop off the max which we\nknow is in index position one first\nwe're going to swap it with the item in\nthe last position then we're going to\ndelete it from the heap and then we're\ngoing to bubble down the item here to\nits proper position so let's take a look\nat the example so 11 is in the last\nposition\n25 is the item we want to pop so we're\ngoing to swap those two 25 and 11 swap\nplaces now we can remove 25 from the\nheap without affecting the rest of the\nheap it's in the last place it doesn't\naffect anything else in the heap our\nnext step is to bubble that 11 down to\nits correct position so we compare 11 to\n24 11 is less than 24 so it needs to\nmove down next we're going to compare 11\nto 19 and 11 is less than 19 so that's\ngonna swap places so we do some\ncomparisons with the child nodes to move\n11 down until there's either no further\nroom to go down or it's not greater than\nany of its children nodes so that's the\noperation for pop and now we can just\nreturn to 25 that we pulled off that's\nit so those are the three key operations\nand that's basically how they work in a\nnutshell now let's take a look at the\ncode again the underlying data structure\nwe're using is a list so you're gonna\nsee us using list indices throughout\nthis program now the public functions we\nhave here are push peek and pop for\npretty familiar with those by this point\nbut we also have supporting private\nfunctions that we need for this heap and\nwe have a basically swap a float up in a\nbubble down and we use those about\ninternal utility functions these are not\npart of the user interface and then the\nstring function is so that we can print\na heap so our constructor when we create\na new heap we have the option of passing\nin a list of items that we want to add\nto the heap if we don't pass in a list\nof items and we'll get back an empty\nheap with just a 0 in it so we put a 0\nin the very first element because we\ndon't use that we start our elements at\nindex number 1 for the max heap if we\npass in this list of items we're\nbasically going to iterate through those\nadd them one at a time to the end of the\nlist and then float it up to its proper\nposition that's the push operation so\nessentially we're pushing them all one\nat a time and when you look at the push\nmethod it does exactly the same thing\nit appends the data that you passed in\nto the end of the heap and then it\nfloats it up to its proper position in\nthe heap so that is the push operation\nwhich is almost identical to the\nconstructor if you pass in items now the\npeak operation doesn't do much it only\nreturns the top item on the heap that's\nall\nit doesn't take it off there's no pop\noperation going on it's just a peak now\nlet's look at the pop operation there\nare a few different cases here depending\non how many items we have in the list if\nthe list has exactly two items one of\nthose is the zero that we're not\ncounting we're not using that as part of\nour or max heap so if there are exactly\ntwo items that means there's really just\none item in our max heap we'll pop off\nthat number one item with index number\none and we'll return it we set past that\ninto a variable Max and then here at the\nend here we return max if there are more\nthan two items then we're going to swap\nthe maximum item which is in position\nindex 1 with the last item so we get the\nlast item in the list we swap those two\nwe pop off the last item and assign it\nto this variable Max and then we bubble\ndown the first item that we moved into\nthe top position so it's exactly what we\njust walked through in this slides and\nthen at the end we return to max so\nthat's how the pop operation works then\nin our utility functions here swap\nreally just swaps two different items we\npass in two indices we swap those two\nitems in the in the list now the float\nup function is going to receive an index\nof the item that we want to float up\nprobably the very bottom item in the\nlist initially first we'll get the index\nof its parent if it's already in the top\nposition then there's no floating up to\ndo it's already risen to the top\notherwise we're going to compare it to\nits parent and if it's greater than its\nparent then those two need to swap\nplaces\nso I'll swap the positions of the item\nat index passed in with its parent then\nwe'll call the float up function\nforcibly on the parent so this will\ncontinue to float up function until the\nelement reaches its proper position\nbubble down kind of does the opposite it\ntakes an element that's at the top of\nthe list and it bubbles it down to its\nproper position so you can pass in an\nindex we get the left child and the\nright child by multiplying the index by\n2 and times 2 plus 1 and then we'll set\nthe largest equal to index we do a\nlittle comparison if the item were\nbubbling down is less than its left\nchild then we're going to swap positions\nwith the left one if the item we're\nbubbling down is less than the right\nchild then we're going to swap positions\nwith the right child so if there's any\nswapping to be done at the very end here\nwe check do we need to swap if so we'll\ncall this swap function on the item\nwe're bubbling the target item with the\nlarger of those two and then we'll\nrecursively call the bubble down\nfunction again on the same item that we\njust bubbled until it reaches its proper\nposition and our test code here we don't\nhave a whole lot of test code we create\na new max-heap with three items in it\nobviously the 95 is the highest one and\n2221 is the second highest we push a 10\non and then we can see that our list now\nhas ignore the zero really has four\nitems in it and when we pop one off we\nget it of course the 95 and when we peek\nat the next item none - 95 is gone we\ncan see that the 21 is the next item in\nthe max heap that is how a max-heap\nworks and that's how you can implement\nit in Python and by simply changing a\nfew greater than or less than signs you\ncould change this to a min heap let's\nsay you have a collection of items that\nyou want to store and you want to be\nable to iterate through them so you\nwouldn't be able to find an item in the\nlist you wouldn't be able to insert an\nitem but you need very fast and\nsearching speed especially at the front\nof the list you want\nto insert new items at the front you\nneed to be able to remove items from the\nlist you also may want to iterate\nforward and backward through the list or\npossibly even in a continuous circle\nthrough the list so one possible storage\nsolution for these requirements is a\nlinked list we're going to learn how to\nuse linked lists and what they are and\nwe're going to learn a few different\ntypes of linked lists a standard linked\nlist a bi-directional or doubly linked\nlist and also a circular linked list\nwe'll learn how those work the major\noperations used for with linked lists\nand we're also going to go through of\ncourse how to code a linked list in\nPython so let's take a look at how\nlinked lists work every linked list is\ngoing to be composed of what we'll call\nnodes you can call it whatever you want\nin this video we're just going to call\neach item in a linked list a node you\ncould store whatever data you want in\nthe linked list it could be a student\nnode it could be an employee node\nwhatever it doesn't matter but we're\ngonna call our node and that's kind of a\ncommon nomenclature for the items in the\nlinked list just call them nodes and\neach node is connected to the next node\nso it has a pointer to the next node so\nthose two things it has a piece of data\nwhich for us is just going to be an\ninteger in this video and it has a\npointer to the next node so those are\nthe two key components of every node in\nthe linked list now a linked list looks\nsomething like this each node has its\nown piece of data and it also has a\npointer to the next node there can be\nany number of nodes it's basically\nunlimited only by the amount of memory\nyou have in your system and the very\nlast node here you'll see there's no\nnext pointer so we're going to store\nlike a nun there to indicate that\nthere's no next node that's the last\nnode in the list at the very front we\ncall that the root node that's the first\nnode in the list so we need a pointer to\npoint to the starting point for the list\nand this is what we call the root so we\nhave a pointer to the root and the\noperations that we need for each linked\nlist we need to be able to find data we\nneed to be able to add a piece of data\nwe need to be able to remove a piece of\ndata from the linked list and we need to\nbe able to print the list\nso we're gonna see how each of these\noperations works and then we're gonna\nsee how it held a code it in Python\nnow the attributes for a linked list you\nhave a pointer to that root node and\nthen we're also going to track the size\nof the linked list so it in you given\ntime you could find out how many nodes\nare in the list\nlet's look at the add operation so\nhere's our linked list we have a pointer\nto the root we want to add tend that's\nour command let's add 10 so we're first\nare gonna create a new node with that\ndata 10 in it we don't have anything in\nthe next pointer yet but what we're\ngonna do is we're going to point the\nnext pointer to where the root is\ncurrently pointing so the root currently\npoints at this five node we're going to\nput our next pointer for this new node\npointing at the root node and then we\nchange our route to the ten\nso we effectively inserted this new 10\nnode at the very beginning of the linked\nlist that's how we're going to do the\ninsert operation next we want to try and\nremove a number so let's try and remove\nfive obviously if we try to remove a\nnumber like 200 and it's not in this\nthis linked list and we'll get back your\na false or a nun or sorry dude or an\nerror or something but if we have if we\nhave a number that's in the list and we\nwant to try and remove that so we're\ngoing to remove five first we need to\nfind that five so we start at the root\nwe check if this is the number no it's\nnot oh is this the number yes it is geez\nso there's the node that we want to\nremove pretty easy to remove it we we\ntake the previous node to this five we\nchange the previous nodes next pointer\nto 5's next pointer in other words see\nfive the next node is 17 so we just\nchanged five s previous node which in\nthis case is the root the ten we change\nthat next pointer to where five next\npointer goes and so now effectively the\nfive node is just completely cut out of\nthe linked list when we iterate through\nthe linked list starting from the root\nwe're going to follow this path and\nwe're never even going to know that the\nfive is there the five note still exists\nbut we don't have access to it anymore\nit's effectively deleted from the\nlist so that's the remove operation now\nlet's take a look at how to code a\nlinked list in Python we're going to\nstart with a node class we're going to\nuse the same node class for three\ndifferent types of linked lists that we\ncover in this section so W linked lists\nand circular linked lists are going to\nuse the same node class you'll see in\nthe node class here that we have three\nattributes we have a piece of data we\nhave a next node and we have a previous\nnode now in our standard linked list we\ndo not need the previous node so we're\njust not going to use that attribute in\nthe standard linked list but it'll be\nthere for us so that we can reuse the\nnode class for the other two linked\nlists and then we also have this string\nrepresentation that gives us back\nessentially the data in parentheses so\nthat's what the string representation of\na node is so in the linked list we have\nfour methods we have an add find remove\nand a print list let's see how all those\nwork first our constructor has two\nattributes we keep track of the root\nnode and we also keep track of size so\neach time we're add or remove node we're\ngoing to increment or decrement the size\naccordingly to add a new node we pass in\nthe data that we want to create that new\nnode with we create a new node with\npassing in the data and the next note as\nthe root node keep in mind we're\ninserting this node at the very\nbeginning of the list so the current\nroot node is going to be the second node\nso we pass that in as the next node for\nthis new node and then we change the\nroot node to the new node we increment\nour size by one and we're done with the\nadd operation to find a piece of data we\npassing that piece of data we are going\nto iterate through the list one note at\na time we're going to start at the root\nnode which will call this node and as\nlong as this node is not none as long as\nthere it's a valid node we're going to\ncontinue to iterate through this list\neach time through this while loop this\nelse statement is\ngoing to bump us forward to the next\nnode if we haven't found what we're\nlooking for yet\nso what we're looking for is this nodes\ndata is equal to D and when we find that\nwe return D if we get through all the\nway through the while loop we haven't\nfound it will return none because that\ndata is not in the list the remove\nfunction we pass in a piece of data we\nneed pointers to this node and this\nnotes previous node so we're going to\nstart iterating through the lists to do\ndefined operation at the root which will\ncall this node and then we're going to\nkeep track of the previous node because\nwe need that to be able to remove the\nnode when we find the one we want to\nremove each time through this while loop\nwe have two pointers now to increment we\nhave to increment the previous node to\nthis node and we have to increment this\nnode to this node next node so if we\nhaven't found what we're looking for yet\nat the end of this while loop we'll bump\nforward both of those two pointers and\nthat's how we iterate through the list\nnow our check we check if this nodes\ndata is equal to D that we're a past end\nthat we're looking for if we find it we\nfound that data there's two\npossibilities for removing that node one\nthat node is in the root that's this\nelse here in which case we just changed\nthe pointer for the root node for our\nlinked list to this nodes next node in\nother words the second node in the list\nwe bypass the current root and we point\nour root pointer to the second node in\nthe list that effectively deletes the\nfirst node in the list now if it's not\nin the root in other words it's in some\nother node in the list then we need to\ndelete that by changing the previous\nnodes next node pointer to this nodes\nnext node so that is the remove\noperation if we get all the way through\nand we haven't found it we return false\nif we do successfully remove it return\ntrue and the print operation we print\nthe list\nwe're going to iterate through the list\none note at a time starting from the\nroot this while loop is going to check\nwhen we reach the end of the list and\nthen we're going to exit and just print\na none and for each node we're going to\nprint the string representation of that\nnode followed by a little arrow so\nyou'll see what that looks like when we\nrun the test code in a second so here's\nour test code we test a variety of\ndifferent operations yeah here's what a\nlist printed looks like so our string\nrepresentation of a node is just the\nvalue in parenthesis and then we put an\narrow between it in our print function\nso we'll create a new list called my\nlist we'll add a few items to it and\nthen we'll print the list and you can\nsee what we get here and then we can\nprint the size of the list we can see\nthe size is equal to 3 we remove one\nitem the 8 then you can see the size is\nequal to 2 and we can also find the 5\nwhen we find the 5 it actually returns a\n5 when we can print that out and we can\nalso print out the root which is 12\nthat's the last item we added so that's\nat the front of the list so that's how\nthe linked list works so a circular\nlinked list is almost identical to a\nstandard linked list except that from\nthe very end node instead of having no a\nnone pointer to the next node it's going\nto have a loop back to the very\nbeginning to the root node the add\noperation in circular linked lists works\nslightly differently because we have\nthis loop back to the first node from\nthe end node we'd rather not have to go\nback and update that every time we\ninsert a new node so we don't insert the\nnew node as the root node anymore now\ninstead we're going to insert it as the\nsecond node we leave the root pointer\nand the last pointer the loop back to\nthe root the same and instead we insert\nour new node as the roots next node and\nthen the next node for our new node is\ngoing to be what was the previously the\nsecond node so that's the add operation\nfor circular linked list so that's\nbasically yeah that's the only\ndifference with a circular linked list\nso what are the advantages of a circular\nlink list well it's great for modeling\ncontinuously looping data or objects so\nsomething like a Monopoly board or\nin-game board or a racetrack or\nsomething that continuously loops and\nthere are a lot of different looping\nobjects in the real world so if you want\nto model some continuously looping set\nof objects in a computer program a\ncircular linked list is one way to do\nthat\nthe circular link list is very similar\nto the linked list with a few\nmodifications in the add method we have\nto check whether a the list is empty and\nif it is then we add the first node then\nwe make its next node point to itself it\nsounds crazy but we need to loop back to\nsomething so we loop back to the first\nnode the root node else if there's\nalready at least one node in the list we\ncan create a new node and insert it into\nthe number two position right after the\nroot and change the roots next node to\npoint to this new node so that's how the\nadd operation works we can see the code\nhere it's only a few lines of code the\nfine method works exactly the same as in\nthe regular linked list except that in\nthis Elif statement we have to do a\ncheck if we've circled all the way back\nto the root node again because if we\nhave we have to stop our find and return\nfalse we didn't find it we search the\nentire list we didn't find the value\nwe're looking for we turn false for the\nremove method let's scroll down here for\nthe remove method we need to track both\nthis node and the previous node so we're\ngoing to set pointers for both of those\nto start out so we'll start out at the\nroot node and we'll set previous node to\nnone and you can see towards the end of\nour while loop here we advance both of\nthese pointers one node so they move\nboth move forward to the next node now\nwe test if we found the data that's this\nfirst if statement\nbingo found if we pass this test and if\nso there are two possibilities for the\nremove function\nnumber one if the previous node is not\nnone tests whether the data was found in\nthe root node and if not the remove is\nan easy bypass operation for changing\nthe previous nodes next pointer which is\nwhat we do here and taste number two\nelse if we need to delete the root we\nuse this while loop to find the very\nlast node in the list so that we can\nupdate its next node to point to the new\nroot because the root has changed so we\nfind that we find the new we find the\nlast node we update the last nodes new\nnext pointer which is the new root and\nthen we update the root pointer itself\nlastly we decrement the size by one and\nwe return true if we successfully remove\nthe data and in our print list method we\niterate through the list we print each\nnode file Bob followed by an arrow you\ncan see and our while loop has to check\nif you've made it back to the root so we\nknow when to stop so this is the test we\nhave here while this node next node is\nnot the root we continue to iterate\nthrough the list now let's take a look\nat the circular linked list test code\nhere we create a certain new circular\nlinked list we'll just call it CLL we're\ngoing to add a bunch of items to it\nusing a for loop adding one item at a\ntime and then we can print the size of\nthe list we can see down here the result\nthe size is five we try to find an\neighth if the value is actually in there\nit will return eight if we try to find\nan item that's not a no list is going to\nreturn false\nso we can see when we try to find the 12\nwe get back a false and instead of using\nour print list function here we're going\nto iterate through continuously so that\nyou can see when we pass by we're gonna\nprint eight items even though they're\nonly five in the list so we're gonna see\nif it actually does circle back to the\nnext node we're just going to\ncontinuously get the next node up until\nwe reach eight of them so we can see\nfive nine eight three seven and then it\nstarts from the beginning again five\nnine eight three it'll continue on we\nprint up\neight items so that shows you that it's\na continuous loop and we can continue to\nloop through that if we want to write a\nlittle more test code we can print the\nlist and here's the current contents of\nthe list and then we are removing eight\nand when we print out remove fifteen\nresult we see that it's false because\nthere's no 15 in the list we can see\nthat and we print the size of the list\nnow we have four items because we\nremoved one we try to remove the five\nnode that completes successfully and\nthen we print the list again and we only\nhave three items left so that wraps up\nthis lecture on a circular length list\nnow let's look at doubly linked lists\nthese are also sometimes called\nbi-directional linked lists because they\nhave arrows pointing both directions to\nthe next node and to the previous node\nso a regular linked list looks like this\na doubly linked list each node has three\npieces of data it has a pointer to the\nprevious node a pointer to the next node\nand the data itself is storing so ask\nthose three things three components to\nthe node of a doubly linked list so this\nis what a doubly linked list would look\nlike a simple one with three nodes we\nhave here four or twenty three and a\nseven so let's say we want to delete an\nitem this is a little more complicated\nbecause we have two pointers to fix not\njust one so we found this item that we\nwant to delete we're going to call that\nthis node and then the previous node to\nthis node is the four and the next note\nis the seven so how do we delete it well\nwe look at this pointer from the\nprevious node that's pointing to this\nnode and we look at the pointer from the\nnext node that's pointing to its\nprevious node right these ones that are\npointing to this node they have to be\nfixed they basically just have to bypass\nit so what we do is we change fours next\npointer instead of pointing to this it\nhas to point to this nodes next node and\nthen for sevens\nprevious pointer instead of pointing to\nsevens previous node it has to point to\nthis\nnodes previous node so we we basically\ndo two adjustments here pre done next\nequals this dot next and next up pre\nevils this dot preview changes that we\ndo to cut this node out of the list and\nyou see once we get these red arrows in\nplace once we fix these two pointers\nwe've effectively cut no.23 out of our\nlinked list we've deleted it so that's\nhow the delete operation works in a\ndoubly linked list some advantages of\nthe doubly linked list over a standard\nlinked list you can iterate through the\nlist in either direction that's pretty\nobvious but when you have a really large\nlinked list and you don't want to\niterate through all of the items because\nyou happen to know that your item is\ntowards the end of the list you can\nactually save quite a lot of time by\nstarting your iteration at the tail end\nof the list and working right back so\nyou could save a pointer to the very end\nof the list as well and you can delete a\nnode without iterating through the\nentire list that is if you have a\npointer to that node right if you know\nwhere that node is that you want to\ndelete and you don't have to iterate\nthrough the whole list to find it each\nnode already stores its previous in next\npointer so you can get the nodes on\neither side of this node that we want to\ndelete without having to iterate through\nthe entire list if you have a pointer to\nthe node you want to delete doubly\nlinked list uses an extra node attribute\ncalled priva as I showed you before when\nwe looked at the node class and it also\nhas an extra list attribute called last\nyou can see here last so that we can\nalways access the tail end of the list\nor the last item in the list now the add\nmethod has to check if the list is empty\nand if so then the root node is also the\nlast node so otherwise it adds a new\nnode to the beginning and it changes the\nroots previa fails two different\nconditions here for the add a new node\nthe find method works exactly the same\nas the find method for the standard\nlinked list so there's really no changes\non that the remove function\nit is a little different there are three\npossible cases in the remove function so\nlet's review each one of those case\nnumber one we're trying to delete a\nmiddle node that's this if statement\nhere so the node is not in either the\nroot or in the last node that's the\nstandard case that we showed in two\nslides so for this we just do a simple\nbypass we bypass the target node and by\nchanging the previous nodes next pointer\nand the next nodes previous pointer\nwhich is exactly what we're doing here\nthen we've basically bypassed the target\nnode that we're trying to delete now the\nsecond case is that we're trying to\ndelete the last node this is just like\ncase one except that the previous nodes\nnext pointer will be changed to none\nbecause the second-to-last node is now\nthe last node so that's the only\ndifference here so we we're changing the\nbasically the second-to-last nodes next\npointer to none and the third case is\nwe're trying to delete the root node and\nthis is again similar to case one except\nthat we change the root pointer to point\nto the second node in other words we\nchange root to point two roots next node\nand that's it those are the three cases\nfor remove the rest of the remove\nfunction is really straightforward the\nprint list method is pretty much the\nsame there's not no changes there so\nlet's look at the test code for the\ndoubly linked list here will create a\ndoubly linked list dll we'll call it we\nadd a bunch of items using a for loop to\nadd each one of those items in we can\nsee we print the size is 5 and we can\nprint the entire list if we want using\nour print list method and then we can\nremove an 8 will print out the size\nagain we can see the sizes for so these\nthings all work and then if we try to\nremove items that are not in the list\nyou'll l dot remove 15 that doesn't work\nif we try to find an item that's not in\nthe list we also get false back and if\nwe add some numbers 21 and 22 and then\nwe remove a 5 and then we print the list\nagain we can see that 21 and 22 were\nadded to the front of the list and the 5\nwas removed\nwas a tail node the last node in the\nlist and we successfully removed that\nand then just for fun we see that we can\nprint out the last nodes previous node\nwhich should be the node right before\nthe three of the nine which is this\nthree which is exactly what it does so\nwe can access nodes from the tail end of\nthe list also that wraps up this section\non linked lists so in this section we\ncovered a standard linked list a\ncircular linked list and a doubly linked\nlist or a bi-directional linked list we\nshowed you how those work and then we\nimplemented them in code and again I\nencourage you to download this code and\nrun it and try it out make some edits to\nit change it use your own tests on it\nand see how it works by using a code\nyou're gonna better understand how the\ncode works how linked lists work and how\nto eventually write your a linked list\ncode hopefully in this lecture we're\ngoing to talk about trees after section\none where we covered pythons built-in\ndata structures trees is definitely the\nnext most important section of this\ncourse trees are critically important\ndata structure in all programming\nlanguages and let me explain why to make\na point I'm thinking of a number between\n1 and 8 million can you guess my number\nwell you guessed 4 million I just say\nwrong and you're thinking uh-oh aren't\nyou gonna tell me higher or lower no you\nhave to guess until you get my number\nwell you might have to guess every\nnumber between 1 and 8 million to figure\nout which number it is so if you're\nusing a list an unsorted list as your\ndata structure that's what it's like you\nwould have to iterate through the entire\nlist to find the number so you may have\nto do up to 8 million comparisons to\nlocate that number that I'm thinking of\nthat is the issue with lists when you\nhave a lot of data it's really slow to\nfind data now with a tree it's a little\ndifferent you guess 4 million and I say\nlower you guessed 2 million I say higher\nyou've got 3 million lower ok Wow with 3\nguesses\nyou've shaved off 7 million\npossibilities and now you've narrowed\ndown the possibilities to between 2 and\n3 million\nyou're only 1 million possibilities left\nwith just 3 guesses so with as few as 30\nguesses you would be able to find any\npiece of data in a tree with up to 10\nmillion nodes so that is how fast binary\nsearch trees are a balanced binary\nsearch tree will let you locate data in\na very large tree with as little as 30\ncomparisons so now let's take a look at\nsome of the major operations of trees\nand how they work so first let's learn\nsome basic terminology about trees this\nis a node each part of a tree is called\na node and each connection between nodes\nis called an edge and at the very top of\nthe tree we have a root node you can see\nthat trees are actually upside down\ncompared to real-world trees this is\nmore like a root system of a tree or a\nflipped upside down tree or like a\nmanagement hierarchy in a company or\nsomething right we only have one\npresident and then you have multiple\nvice presidents and so on down trees are\ngreat for modeling organizations but\nthat's not the real benefit of tree the\nreal benefit is the speed now we have\nparent nodes and child nodes in a binary\ntree a parent can have up to two\nchildren one or two children nodes that\nhave the same parent are called sibling\nnodes and bottom nodes at the very\nbottom of the tree that don't have any\nchildren are called leaf nodes not all\ntrees are binary trees but in a binary\ntree each node can have up to two child\nnodes a left and right child node now\nsome trees may have 5/10 of up to a\nthousand child nodes for each node we\ncan see the off of five here we have a\nsub tree a sub tree connects to a root\nnode here and a sub tree is basically\nany part of a tree that in itself is a\ntree so it can be a sub tree of five\ncompared to node 4 3 & 5 rows ancestors\nwhich is a parent node and every node\nabove it's not the parent in the tree\ndescendants are every node below that\nnode in a tree so node 5's descendant\nincludes everything in its left subtree\nand everything\nright sub-tree in a binary search tree\neach node is greater than every node in\nits left subtree so here we can see that\n15 is greater than every single node in\nits left subtree and 8 is greater than\nevery node in its left subtree and the 5\nis greater than every node in this sub\ntree the 24 is look greater than every\nnode in its left subtree so this is a\nstandard requirement for binary search\ntrees each node is greater than every\nnode in its left subtree and it's also\nless than each node in its right subtree\nhere we can see that all the nodes in\n15's right subtree are greater than 15\nand all the nodes in 24 right subtree\nare greater than 20 for all the nodes in\n8 right subtree are greater than 8 so\nthose are 2 standard requirements for a\nbinary search tree some of the standard\noperations that L binary search trees\nare going to use insert I'm going to be\nable to add new data to the tree fine we\nwant to be able to locate data in the\ntree delete is to remove a node get size\ncounts all the nodes in a tree to tell\nus how many pieces of data we have in a\ntree in traversals which enable us to\nwalk through the tree node by node and\nI'll show you how some of those work\nfirst let's look at the insert method\nwe're going to always start at the root\nwhen we're doing an insert so at the top\nin this tree it's 215 we're always going\nto insert a new node as a leaf in other\nwords at the very bottom of the tree but\nwe start at the top to locate the right\nposition the correct position in the\ntree to insert that new leaf so let's\nsay we want to insert 12 in this tree\nwe're going to start out with\ncomparisons starting at the root is 12\nless than 15 yes it is so we're going to\ndescend down 15 left subtree next we're\ngoing to compare 12 to 8 is 12 less than\n8 no it's not so we're going to descend\ndown 8 right subtree towards the 11\nthere's 12 less than 11 no it's not\nand then we compare 12 to 13 and we say\nwell yeah 12 is less than 13 so we're\nagain we're going to add the 12 as a\nleaf node so we can add it as 13s left\nchild that's how the insert function\nworks now let's look at the fine method\nagain with fine we'll always start at\nthe root here it's 15 and we're going to\ndo comparisons so if we want to find 19\nin this tree we're going to start by\ncomparing 19 to 15 is 19 less than 15 no\nit's greater so we descend down the\nright subtree and then we compare 19 to\n24 19 is less than 24 so we go down 24\nleft subtree you can see how with each\ncomparison and decision we descend down\none subtree that cuts in half the number\nof remaining possibilities to locate an\nitem so now we've already in two\ncomparisons found the 19 in this tree so\nwhen we find a piece of data with define\nfunction we're always going to return\nthat piece of data and if we didn't find\nit we want to return false to let the\nuser know that data is not existing in a\ntree so with delete there are three\ndifferent possibilities one is that the\nnobody.one delete is a leaf node another\npossibility is that it has one child\nnode then there's another possibility\nthat has two child nodes so each one of\nthese we have to handle differently\ndelete is a fairly complicated operation\nso let's first look at the possibility\nthat the number we want to delete is a\nleaf node so look at these are all these\ngray nodes are all leaf nodes so in a\ncase of a leaf node it's easy for us to\njust delete the leaf node without\naffecting anything else in the tree\nthese are bottom most nodes so it\ndoesn't affect the organization of\nanything else in the tree we can just\ndelete that node if it's in the leaf\nthat's the easiest case right there now\nif we have one child\nthese are cases where we have one child\nnote 11 13 and 28 if we want to delete\none of those nodes we have to promote\nthat child node to the targets notes\nposition so for instance if we wanted to\ndelete the 28 we would promote 25 to 28\nposition if we want to delete the 11 we\nwould have to promote the 13 to 11th\nposition and the 12 comes with it you're\npromoting that entire subtree so that's\nthe one child delete and then if you\nhave two children well that gets a\nlittle trickier let's say we're going to\ndelete the 24 and we could see that 24\nhas two children we find the next higher\nnode in order to do that we're gonna\ndescend down 24s right subtree and then\nall the way to the left so here we get\nto 25 now if it was a much larger tree\nit'd be the same operation you take the\nright subtree and then the left most\nnode in the right subtree and here it's\n25 so the operation is to basically swap\nplaces the 24 and the 25 and then we can\ndelete the 24 so we put the 25 where the\n24 was and we can delete the 24 and the\nsame thing if you want to delete the 4\nhere we want to delete the 4 we can see\nthat 4 has 2 children we want to find\nthe next higher node after 4 and we find\nthat 6 we descend on the right subtree\nin the left most node and of 6 so we\ndelete the 4 and we promote the 6 to the\n4th position and the 7 comes with it\nbecause 7 is part of 6 a subtree so\nthat's the delete operation in a\nnutshell it's actually a little more\ncomplicated than that so we're not going\nto code it in this video however I do\nhave another video on youtube or we code\nthe entire delete function don't get\nsighs sometimes we may want to find out\nhow many nodes are in a tree so this is\na pretty easy operation to get size\nfunction returns the number of nodes and\nit works by using recursion actually all\nthese functions in trees most of them\nare recursive so find delete insert\nwe're doing it recursively because we\ncontinue to call the same function\nusing the same parameter until we find\nthe correct position to execute it so\nthe getsize works the same way the size\nis equal to 1 plus the size of the left\nsubtree plus the size of the right\nsubtree in other words the size of this\ntree is equal to well the 5 note is 1\nplus the left subtree is the subtree\nstarting with 3 and then the right\nsubtree is the subtree starting with 8\nso we say the size of this tree is 1\nplus the size of these two sub trees and\nthen we call the same thing the same get\nsize function on 3 s left and right\nsubtrees the size of the 3 sub tree is 1\nplus the size of 3 s left plus the size\nof threes right subtrees so we call\nrecursively the get size function as we\ndescend down the tree and eventually we\nget down to leaf nodes and return to 1\noh yeah this is a leaf node size equals\n1 and so all those ones get added back\nup as we decent as we retreat back from\nthe call stack we almost talk about\ntraversals sometimes we need to traverse\nthe data in a tree and there are\nmultiple ways of doing that a few\ndifferent traversal algorithms are\ncalled pre-order traversal level\ntraversal inorder traversal and post\norder traversal so in this video we're\ngoing to cover pre-order in-order\ntraversal the pre-order traversal we\nvisit the route before we visit the\nroute sub trees so in other words we're\nalways going to start at the root and\nthen we'll visit the root sub tree and\nthe same thing here with node 3 this is\nbasically a sub tree starting at node 3\nwe're going to visit 3 before we visited\nsub trees so we start at the top and\nthen we descend down the left sub tree\nand again we descend down the left sub\ntree and then we hit the right sub tree\nand then we'll come back up and descend\ndown 5's right sub tree\nwe'll get the left subtree and then the\nright subtree so 1 2 3 4 5 6 7 you can\nsee the order this is pre order\ntraversal and inorder traversal visits\nthe\nroute between visiting route subtrees so\nthat means that it can deliver values in\nsorted order so here we may want all\nthese values in sorted order in which\ncase we're going to start with the\nbottom left most node and work our way\nup so 1 3 4 we visit the ones parent\nnode and then it's right subtree and\nthen we visit threes parent node and\nthen it's right subtree starting with\nthe left most node so we're always in\nother words working our way up from the\nbottom and working our way to the right\nso that's an inorder traversal what are\nthe advantages of binary search trees\nnumber 1 trees use recursion to\nimplement most of their operations which\nmakes them pretty easy to implement most\nof the code is pretty easy to write it's\nnot very complicated well except for the\ndelete which has a lot of different\ncases but the big huge advantage of\nbinary search trees is speed they're\nreally really fast at locating data you\ncan insert delete and find data in a\ntree in Big O of H or the height of the\ntree depending on how many levels there\nare in a tree or put another way log in\nof the data the log of 10 million is\nabout 30 in other words if you don't\nknow a Big O means this is an order of\noperations and an approximation of how\nmany operations it takes to achieve\nsomething so you can do all of these\ndifferent operations in about the log n\nof the amount of data you have which is\nvery fast so in a balanced binary search\ntree with ten million nodes you can do\nall the insert delete and find functions\nin as little as 30 comparisons that's\nincredible that's incredible so trees\nare extremely fast now let's take a look\nat how to implement trees now let's look\nat how to implement a tree in Python so\nwe have this Jupiter and random here\nwe're going to implement a binary search\ntree we have a few functions we have a\nconstructor an insert find and get size\nmethod and then we have two different\nways to traverse the tree pre-order and\ninorder traversal and I'll walk you\nthrough how all that\nworks so in our constructor we have\nthree attributes we have a piece of data\nthat we're going to pass in as a\nrequired attribute and then optionally\nyou can pass in a left subtree in a\nright subtree in this program we're\nreally not using the left and right\nsubtrees in the constructor so I have\nthem defaulting to nine but each node is\nits own subtree and it has a left and\nright subtree so the insert function the\nkey is defined of correct location to\ninsert it and we're always going to\ninsert it at the very bottom of the tree\nas a new node the first possibility is\nthe node that we're in is equal to the\ndata that we're trying to add in which\ncase we're going to reject that we don't\nwant any duplicates in our tree so in\nthis case we're going to return false\nbecause we got a duplicate if the data\npassed in is less than the data in the\ncurrent node then we're going to descend\ndown the left subtree so we return self\nleft subtree insert so in other words\nwe're calling recursively the insert\nfunction descending down the left\nsubtree and still passing the data along\nand the reason we have this return is\nbecause we want to return either true or\nfalse at the end of the day if the data\nwas successfully inserted or not or if\nwe reach the bottom level of the tree\nand we we've found the right position to\ninsert it will create a new subtree with\nthat piece of data and we'll set it up\nas the left subtree of its parent node\nand we return true because we added that\ndata or we can descend down the right\nsubtree if we descend on the right\nsubtree again we're just doing a\nrecursive function call to the insert\nfunction or passing the data in down the\nright subtree and when we reach the\nbottom of the right subtree\nwe'll insert a new tree and we'll attach\nthat as the right child of the parent\nnode and then return true the find\nfunction works very similar except that\nwe don't actually create a new item and\ninsert it but we recursively descend\ndown the either the left subtree or the\nright subtree so if we find that piece\nof data in the current node that we're\nin will return that piece of data\nif not we'll do a comparison to the\ncurrent node to see if we should descend\ndown the left sub tree or the right sub\ntree now if we reach the bottom of the\ntree where we have a nun note we're\ngoing to return false otherwise we call\nthe find function recursively on the\nleft subtree and we pass the data along\nas the same parameter and then the same\non the right subtree when we reach the\nbottom of the right subtree and we\ndidn't find the data yet in other words\nwe reach a nun note then we're gonna\nreturn false because the data is not in\nthe tree or if we didn't reach an\nunknown yet then we'll continue to send\ndown the right subtree to find that data\nso this is a fine function we basically\nare just doing comparison and then\ndescending down either the right or left\nsubtree until we reach the bottom\ngetsize like I showed you in the\ndiagrams before if the node that we're\nin is not nun then we're going to return\none plus the size of the left subtree\nplus the size of the right subtree so\nthis works recursively we continue to\ncall get size as we descend down the\ntree the left subtree and the right\nsubtree we add all those together we add\neach one for each node we visit the\npre-order traversal checks first if the\nnode that we're in is not nun and if\nit's not then we'll print that data and\nthen we'll continue down the left\nsubtree calling the preorder traversal\nfunction recursively until we reach a\nnun note then we'll continue down the\nright subtree recursively until we reach\na nun note the inorder traversal is not\na whole lot different and you can see\nwhat's different between these two is\nthat we here in the inorder traversal we\nhave the print statement between those\ntwo subtrees and here the print\nstatement in pre-order is before we\ndescend on those two subtrees so that's\nreally the key difference between\npre-order and inorder traversal\nnow let's take a look at the test code\nso in this test code we're going to\ncreate a new tree we do that using a\nvalue of 7 we pass in as a parameter so\nnow we have a tree with a 7 as the root\nwe insert a 9 into it so we have two\nitems in the tree and then we just go\nthrough this whole list and add a whole\nbunch of different items oh look there's\na duplicate so it's not going to add\nthis\nand we insert each one of those items\nnow we're going to print out the tree\nfor I in range 16 so this will count\nfrom 0 through 15 we're going to do a\nfind operation on each one of those\nnumbers and we can see what it prints\nout is 4 0 it prints false 4 5 it prints\nfalse and 4 8 it prints false but all\nthe rest of them it returns the number\nand it prints it out so you can see that\nthere's no zero\nthere's no 5 and there's no 8 in this\nlist so it's unable to find those that\nreturn to false and that's what we print\nthe get size function returns a 13 so\nthat's the count of the nodes in the\ntree is 13 and then we do a pre-order\ntraversal we print a blank line and we\ndo an inorder traversal and you can see\nthe inorder traversal is exactly the\nnumbers in sorted order and again you\ncan see that the 0 the 5 and the 8 are\nmissing in this inorder traversal so\nthat concludes this lecture on trees I\nrecommend you to download the code try\nit out maybe try and code the postorder\ntraversal and try and ricing different\ntests to actually use the tree maybe try\nand sorting letters in it or something\nor a million numbers and see how fast\nthe tree performs so another really\nimportant data structure is graphs\ngraphs are perfect for modeling\nreal-world objects in a lot of cases a\ngraph consists of vertices and edges\nconnecting those vertices so for\ninstance in a social network the\nvertices could be people right and the\nconnections are friendships or\nrelationships between people so there\nare two different types of graphs we can\nuse undirected graphs where the\nrelationship is both ways it's\nbi-directional so in this case in a\nsocial network typically relationships\nwork both ways because both people know\neach other so here you can see there are\na bunch of vertices and then a bunch of\nedges between the people who know each\nother so an undirected graph is a very\ncommon way to model relationships in a\nsocial network or connections between a\nreal network where\nthat nodes would be computers and the\nconnections would be cables connecting\nthose computers now another type of\ngraph is a directed graph so if you\nwanted to model for instance airplane\nflights between cities well in some\ncases there may be a one-way flight or\neven a round-trip flight but each leg of\nthat flight is gonna be represented by\nan arrow in other words which direction\nis going so if you have a flight going\nfrom Chicago to Seattle well it's not\nnecessarily doesn't necessarily have a\nreturn flight so the best way to model\nthis is using a directed graph which\nshows a one-way relationship so\ntransportation and networking are just a\ncouple of very many different possible\napplications for graphs in modeling real\nworld problems so in this section we're\ngoing to cover the two most common ways\nto implement graphs which is using an\nadjacency list and an adjacency matrix\nan adjacency list stores a list of\nneighbors for each vertex in the vertex\nitself an adjacency matrix stores a 2d\narray of all the connections between the\nvertices in the graph object so let's\ntake a look at this undirected graph\nwith 5 vertices and a number of edges\nconnecting them so in an adjacency list\nimplementation each vertex would store\nits own list of vertices that is\nconnected to so in this case a is\nconnected to B C and D and that list of\nneighboring vertices would be stored in\nnode A's neighbor lists and node B is\nconnected to never to C's a and C and\nthat would be stored in node B's list of\nneighbors now using the same undirected\ngraph we could implement this using an\nadjacency matrix and the jason c matrix\nhas all the from vertices and two\nvertices and it puts a zero where\nthere's no edge and a one where there's\nan edge so here we can see from A to B\nthere is an edge now since this is an\nundirected graph this is a\nmirror image across the diagonal as you\nmight expect\nso if edge a connects to B then B also\nconnects to a and this 2d matrix would\nbe stored in the graph object itself so\neach vertex doesn't have to remember its\nown neighbors now if you have weighted\nedges it's much easier to implement this\nwith an adjacency matrix why because\ninstead of putting just a 1 you can put\nthe weight in the matrix an adjacency\nlist you'd have to probably put a tuple\nwhich includes the weight in the\ndirected graph it's fairly easy to\nimplement in either one of these so in\nan adjacency list you would just put the\noutbound edges from each vertex so from\na you can see the a has an outbound edge\nto see so we would list in AZ Jason C\nlist only node C and the directed graph\nand an adjacency matrix is similar it's\nnot going to be symmetrical across the\ndiagonal anymore because B connects to a\nbut a does not connect directly to B so\nwe can see that we have B to a is a 1\nbut a to B is a zero which\nimplementation is better well first\nlet's look at two different types of\ngraphs in a dense graph every vertex may\nbe connected to every other vertex in\nthe graph and that kind of graph there\nare are a lot of edges relative to the\nnumber of vertices so maybe each vertex\nis connected to every other vertex in\nthe graph in which case the number of\nedges would be equal to the number of\nvertices squared in a sparse graph there\nare relatively few edges or maybe\napproximately similar to the number of\nvertices\nso when adjacency matrix takes up V\nsquared space regardless of how dense\nthe graph is so because we have a list\nof vertices along the x-axis and along\nthe y-axis of this matrix it takes up V\nsquared space for the matrix so a matrix\nfor a graph with about 10,000 vertices\nwould take up at least a hundred\nmegabytes\nso some trade-offs and adjacency list is\nfaster and uses less space for a really\nsparse graph but the con is that it's\nslower for dense graphs because for\ndense graphs it would have to iterate\nthrough all of the neighbors an\nadjacency matrix is faster for dense\ngraphs because it can easily look things\nup using an index it's also simpler for\nweighted edges it's very easy to\nimplement weighted edges but the con is\nthat it uses a lot of space so as the\nnumber of vertices grows the amount of\nspace required for the adjacency matrix\ngrows by a factor of V squared next\nwe're going to learn how to implement\neach of these methods in Python now\nlet's look at the code I'll post the\ncode on my github site both in a Jupiter\nnotebook format which we're going to\nwalk through in this video as well as\nthe regular Python file so you can\ndownload that and test it in whichever\nformat you prefer and try it out and I\nstrongly recommend you do that so you\ncan really understand how graphs work\nnow in the code we basically have two\nclasses we have a vertex class which is\npretty simple and there's not a whole\nlot to it and then we have the graph\nclass which is a little bit more\nsubstance to it but we'll walk through\nexactly how everything works and then we\nhave a little bit test code and I'll\nshow you how that works so first let's\nlook at the vertex class we have two\ndifferent methods here we have a\nconstructor this init is just a\nconstructor that creates a new vertex\nand basically it just sets two different\nattributes for a vertex object you can\npass in the name in which is the name of\nthe vertex which for us is just a single\nletter and then it assigns it to this\nnamed attribute for the vertex and then\nit also creates an empty set for the\nneighbors for that vertex and then add\nneighbors you can pass in the name of a\nvertex not to vertex object but the name\nof a vertex it adds that to the\nneighbors set for that vertex and\nremember sets don't store duplicates if\nthat neighbor has already been added to\nthe vertex it doesn't matter it won't be\nadded a second time now let's look at\nthe graph class which is a little more\ncomplex so we have a few different\nmethods here\nfirst each graph object stores a\nvertices dictionary of all of the\nvertices and that is in the format of\nnamed vertex name and then vertex object\nso you can always access from vertex\nname you can always access the vertex\nobject through the dictionary and when\nwe add a vertex we pass in that vertex\nwe check if that the object passed in is\nactually a vertex object and if the name\nis in the vertex list yet and if it if\nit's already in that dictionary then we\nobviously not gonna add it a second time\nand then we if it's not then we'll add\nthat vertex to the vertex dictionary and\nreturn true otherwise we return false\nwhich says the add was unsuccessful and\nto add an edge every time we create a\nnew edge we check if the both of the\nvertices are actually existing real\nvertices in the graph because if the\nvertex does not exist in that graph we\ncan't have an edge connecting that\nvertex and assuming that both vertices\nare valid vertices then we add you two\nV's neighbor list and be to use neighbor\nlist that's why we have two different\nadd operations here and we return true\nand then to print the graph we're really\njust going to print out the neighbor\nlist for each vertex of the name of the\nvertex and then that vertex is neighbor\nlist and our test code\nwell we'll create a new graph G here and\nthen we're a few different ways to add\nvertices to that graph here's three\ndifferent ways so we can create a new\nvertex a by passing into the vertex\nconstructor the name of vertex a and\nthen we can add vertex a using the add\nvertex method another way is we can do\nthis all both of those steps in one\noperation using just add vertex and then\ncreate a new vertex called vertex B and\nthen we could also use a for loop if we\nwant to add a whole series of vertices\nhere a through K we have to use order to\nget the numerical equivalent of a so\nthat we can iterate through those using\nthe range function and then we convert\nthat back into a letter using CHR the\ncharacter equivalent of that number so\nthere's three different ways there that\nwe can add vertices to our graph when we\ndid all three and we don't have to worry\nabout duplicates because we check for\nduplicates in\nadd vertex function and then in adding\nedges well I just created a list of\nedges here basically a list consists of\ntwo letters which is the two vertices\nthat that edge connects to and then we\niterate through those and we add edge\nwith the first letter and the second\nletter passing those two in and lastly\nwe print the graph so now we have a\ngraph with a bunch of vertices and a\nbunch of edges what does that graph look\nlike\nwell our print function doesn't really\nvisualize the graph but it does show us\nwhat the adjacency lists look like look\nthe adjacency list for a it looks like\nthis it has neighbors B and E and B has\nneighbors a and F C has just a neighbor\nG so and if you take a look at the edges\nlist you can figure that out to write a\nhas an edge to B and E right and so you\nsee B and E and Hayes neighbor lists but\nyou're also going to see a in EES\nneighbor list so if we look down to E\nyep sure enough there's a so that's how\nan adjacency lists implementation works\nin code and again you can download the\ncode and run this and try it out spend a\nlittle more time getting acquainted with\nit how about that and this\nimplementation of graphs we use strings\nlists sets and dictionaries for data\nstructures that we covered in section 1\nof this course in the next lecture we're\ngoing to learn how to implement graphs\nusing adjacency matrix in this lecture\nwe're gonna look at how graphs can be\nimplemented using the adjacency matrix\nmethod so we walk through how the\nadjacency matrix works let's look at the\ncode again this this code is posted on\nmy github site both in a Python file\nand in a Jupiter notebook file you're\nwelcome to download either one this code\nor I'm going to show here is the Jupiter\nnotebook has a lot of comments in it so\nfirst we have a vertex class the vertex\nclass is extremely simple in the matrix\nimplementation because the matrix is\nbasically in the graph class so the\nvertex class really doesn't have to do\nanything we have a constructor where we\nsimply pass in the name of the vertex so\nwe assign that\nin name to a single attribute called\nname and that's it that's all vertex has\nis a name the graph class is a little\nmore complicated we have three key\nattributes here we have a dictionary of\nvertices and then we have a matrix of\nedges this is actually going to be a\ntwo-dimensional list of edges and then\nwe have edge indices because the edges\nare unlabeled all it is is a series of\nzeros and ones so this is basically the\nlabels that goes with the edges so this\nis not the only way to implement this\nthis is how I chose to do it you can you\ncan implement in a different different\nway if you want if you find this too\ncomplicated so we're gonna have a few\ndifferent functions here or methods that\nare part of the graph class we're going\nto add vertex which is going to update\nall three of these attributes we're\ngoing to add an edge which only really\nneeds to update the edges matrix and\nthen we have a print function when we\nadd a vertex we pass in that vertex\nfirst we're going to verify that that's\na valid vertex object and that it's not\nalready in the vertices list and if it's\nnot then we'll go ahead and add it so\nthe first step is to update the vertices\ndictionary by adding the name and vertex\nto that dictionary so in other words\nwe'll have a and then the vertex object\na next we're going to use a loop to\nappend a column to the rightmost side of\nthat matrix so the edges matrix so we\nuse a for loop to do that and we append\na column of zeros to the rightmost end\nof the edges matrix and then we need to\nput on the very bottom of the matrix we\nneed to append two zeros a row of zeros\non the very bottom so we do that using\nthe self dot edges append 0 times length\nof edges plus 1 in other words however\nmany edges there are we're going to add\na 0 at the very bottom row for each one\nof those now since we just added a\nvertex there's obviously no edges\nconnecting to it yet so we know these\nare all zeros but as we add edges\nconnecting to that vertex then we're\ngoing to flip them to a 1 and the last\nstep in adding a vertex is we update the\nedge vertices we add that vertex name\nand the index that we can find that\nvertex\nin the edges list and when we add an\nedge we pass in U and V which is the\nfrom and two vertices for the edge we\nhave a default weight of one that's\nnormal to have a default weight of one\nbut you can override that by passing in\nwhatever weight you want so if you want\nto use weighted edges it's pretty easy\nto do we check to make sure that both\nvertices that we passed in are valid\nvertex names in other words they're\nactually in the vertices dictionary so\nedges is a 2-dimensional list so we need\ntwo different indices to access a\nspecific position in the matrix so we\nhave U and V and then we have a B and u\nso we want to flip both of those four\nedges those two positions in this table\nset it equal to weight whatever weight\nyou passed in or 1 if this is a default\nand lastly when we print a graph well\nyou'll see how it prints out down below\nbut we're starting out by printing the\nname of the vertex and then we're going\nto print out the row of ones and zeroes\nfor that vertex so our test code we used\nexactly the same test code that we use\nfor the other implementation of the\ngraph using adjacency lists the test\ncode is identical so we create a new\ngraph we have three different ways of\nadding a vertex to the graph first we\nfor a we create a new vertex object and\nthen we do add vertex a and then for B\nwe add vertex and we'll create a new new\nvertex inside the parentheses here and\nthen we use the for loop method where we\niterate through the a through K and we\nadd them to the graph and then to add an\nedge I created a list of edges here this\nis the same list we used in the other\ntest code for edge and edges and\niterating through those edges we add\neach edge one that's one at a time we\npass into the add edge method two\nparameters in this case it would be the\na and the B so we're getting the left\ncharacter and the right character we're\npassing those in as the attributes and\nthen when we print out the graph we see\nwhat this looks like this is what our\nneighbors matrix looks like at the end\nof it is\nso you can see where we have a one is a\nneighbor for a so this would be B C D E\nso B and E are s neighbors right\nwherever there's a one and then this is\ncolumn a so we can see that a has an\nedge to B and E so in other words you\ncan see that it's symmetrical across\nthis diagonal and every place where\nthere is a one reflects an edge between\ntwo vertices so I recommend you download\nthe code test it out try to use it and\nget familiar with it these are two\ndifferent implementations for graphs and\nit's important to understand both\nbecause there is no one best method as I\nalready explained in different instances\neach method has its advantages in this\ncourse we've covered a lot of different\ndata structures we've learned how to use\ndifferent data structures as well as how\nto implement and some of the pros and\ncons of each now you'll have a lot of\nnew tools in your tool belt as a\nprogrammer to south problems as you're\ndeveloping code thank you for taking\nthis course\nyou\n",
  "words": [
    "hi",
    "joe",
    "james",
    "master",
    "degree",
    "computer",
    "science",
    "software",
    "engineer",
    "silicon",
    "valley",
    "course",
    "gon",
    "na",
    "learn",
    "data",
    "structures",
    "python",
    "might",
    "wondering",
    "well",
    "care",
    "data",
    "structures",
    "python",
    "let",
    "imagine",
    "second",
    "carpenter",
    "would",
    "try",
    "pound",
    "nail",
    "screwdriver",
    "make",
    "sense",
    "carpenters",
    "ca",
    "also",
    "would",
    "try",
    "drive",
    "screw",
    "pair",
    "pliers",
    "carpenters",
    "know",
    "every",
    "task",
    "best",
    "tool",
    "job",
    "carpenters",
    "carry",
    "around",
    "tool",
    "belt",
    "full",
    "tools",
    "tools",
    "specialized",
    "different",
    "tasks",
    "exactly",
    "going",
    "master",
    "data",
    "structures",
    "python",
    "data",
    "structures",
    "tool",
    "belt",
    "task",
    "face",
    "programmer",
    "going",
    "know",
    "exactly",
    "data",
    "structure",
    "use",
    "use",
    "going",
    "save",
    "time",
    "write",
    "better",
    "code",
    "efficiently",
    "course",
    "gon",
    "na",
    "learn",
    "pythons",
    "data",
    "structures",
    "strings",
    "lists",
    "tuples",
    "sets",
    "dictionaries",
    "going",
    "continue",
    "learn",
    "queues",
    "stacks",
    "heaps",
    "also",
    "going",
    "learn",
    "linked",
    "lists",
    "going",
    "cover",
    "binary",
    "search",
    "trees",
    "graphs",
    "gon",
    "na",
    "learn",
    "use",
    "data",
    "structures",
    "implement",
    "python",
    "going",
    "learn",
    "strengths",
    "weaknesses",
    "data",
    "structures",
    "let",
    "look",
    "code",
    "first",
    "look",
    "sequence",
    "types",
    "string",
    "list",
    "tupple",
    "put",
    "link",
    "documentation",
    "official",
    "python",
    "documentation",
    "encourage",
    "check",
    "questions",
    "want",
    "detail",
    "needing",
    "items",
    "look",
    "documentation",
    "link",
    "first",
    "indexing",
    "access",
    "item",
    "sequence",
    "using",
    "index",
    "put",
    "index",
    "inside",
    "square",
    "brackets",
    "indexing",
    "starts",
    "zero",
    "first",
    "element",
    "always",
    "zero",
    "fourth",
    "element",
    "going",
    "index",
    "three",
    "string",
    "frog",
    "four",
    "letters",
    "want",
    "fourth",
    "element",
    "g",
    "print",
    "x",
    "3",
    "gives",
    "us",
    "g",
    "see",
    "output",
    "list",
    "pig",
    "cow",
    "horse",
    "strings",
    "print",
    "x",
    "1",
    "going",
    "give",
    "us",
    "cow",
    "square",
    "brackets",
    "tuple",
    "four",
    "names",
    "want",
    "first",
    "name",
    "print",
    "x",
    "zero",
    "zero",
    "square",
    "brackets",
    "gives",
    "us",
    "kevon",
    "indexing",
    "let",
    "look",
    "slicing",
    "slice",
    "sub",
    "strings",
    "sub",
    "lists",
    "sub",
    "temples",
    "using",
    "indexes",
    "way",
    "indexing",
    "works",
    "put",
    "inside",
    "square",
    "brackets",
    "separated",
    "colons",
    "three",
    "possible",
    "parameters",
    "put",
    "start",
    "end",
    "plus",
    "one",
    "step",
    "show",
    "means",
    "let",
    "use",
    "string",
    "example",
    "computer",
    "word",
    "computer",
    "sea",
    "index",
    "0",
    "going",
    "print",
    "x",
    "1",
    "4",
    "since",
    "put",
    "third",
    "parameter",
    "means",
    "step",
    "assumed",
    "1",
    "default",
    "step",
    "put",
    "1",
    "means",
    "inclusive",
    "start",
    "always",
    "inclusive",
    "end",
    "non",
    "inclusive",
    "look",
    "item",
    "number",
    "4",
    "u",
    "fifth",
    "item",
    "inclusive",
    "really",
    "going",
    "get",
    "omp",
    "us",
    "look",
    "result",
    "prints",
    "omp",
    "example",
    "using",
    "step",
    "print",
    "x",
    "1",
    "6",
    "going",
    "start",
    "1",
    "inclusive",
    "going",
    "go",
    "6",
    "e",
    "non",
    "inclusive",
    "going",
    "step",
    "2",
    "words",
    "going",
    "get",
    "p",
    "print",
    "opt",
    "takes",
    "every",
    "item",
    "step",
    "2",
    "next",
    "going",
    "put",
    "end",
    "gon",
    "na",
    "leave",
    "open",
    "colon",
    "happens",
    "put",
    "open",
    "colon",
    "3",
    "nothing",
    "basically",
    "default",
    "end",
    "string",
    "everything",
    "third",
    "item",
    "third",
    "item",
    "p",
    "start",
    "counting",
    "zero",
    "third",
    "item",
    "p",
    "get",
    "everything",
    "p",
    "onward",
    "p",
    "ut",
    "er",
    "know",
    "long",
    "string",
    "want",
    "get",
    "remaining",
    "elements",
    "skip",
    "first",
    "three",
    "three",
    "items",
    "something",
    "use",
    "open",
    "next",
    "going",
    "declare",
    "start",
    "skip",
    "start",
    "putting",
    "five",
    "words",
    "default",
    "going",
    "start",
    "beginning",
    "string",
    "going",
    "get",
    "sixth",
    "item",
    "v",
    "inclusive",
    "c",
    "om",
    "p",
    "u",
    "see",
    "result",
    "co",
    "mp",
    "u",
    "see",
    "declare",
    "start",
    "start",
    "defaults",
    "beginning",
    "declare",
    "end",
    "end",
    "defaults",
    "end",
    "declare",
    "step",
    "step",
    "defaults",
    "one",
    "basically",
    "happening",
    "let",
    "look",
    "negative",
    "index",
    "print",
    "negative",
    "index",
    "negative",
    "one",
    "counts",
    "right",
    "side",
    "string",
    "want",
    "last",
    "item",
    "string",
    "put",
    "negative",
    "1",
    "get",
    "last",
    "element",
    "get",
    "last",
    "three",
    "items",
    "put",
    "negative",
    "three",
    "end",
    "string",
    "gives",
    "us",
    "ter",
    "gives",
    "us",
    "last",
    "3",
    "elements",
    "want",
    "get",
    "everything",
    "except",
    "last",
    "two",
    "elements",
    "string",
    "leave",
    "start",
    "blank",
    "get",
    "everything",
    "beginning",
    "last",
    "two",
    "items",
    "slicing",
    "works",
    "works",
    "exactly",
    "covered",
    "string",
    "example",
    "works",
    "exactly",
    "lists",
    "tuples",
    "let",
    "look",
    "adding",
    "concatenating",
    "combine",
    "two",
    "sequences",
    "type",
    "using",
    "plus",
    "sign",
    "let",
    "look",
    "string",
    "example",
    "first",
    "want",
    "combine",
    "horse",
    "shoe",
    "print",
    "x",
    "see",
    "result",
    "horseshoe",
    "two",
    "separate",
    "lists",
    "want",
    "merge",
    "two",
    "lists",
    "together",
    "use",
    "plus",
    "sign",
    "print",
    "get",
    "single",
    "list",
    "three",
    "elements",
    "case",
    "tuples",
    "two",
    "separate",
    "tuples",
    "print",
    "result",
    "get",
    "single",
    "tuple",
    "four",
    "elements",
    "important",
    "note",
    "second",
    "one",
    "considered",
    "tupple",
    "include",
    "comma",
    "comma",
    "string",
    "parentheses",
    "include",
    "comma",
    "tells",
    "python",
    "actually",
    "tuple",
    "use",
    "multiplying",
    "function",
    "multiply",
    "sequence",
    "using",
    "asterisk",
    "string",
    "example",
    "want",
    "print",
    "bug",
    "three",
    "times",
    "bug",
    "times",
    "three",
    "print",
    "see",
    "result",
    "bug",
    "bug",
    "bug",
    "list",
    "list",
    "eight",
    "comma",
    "five",
    "want",
    "multiply",
    "three",
    "get",
    "eight",
    "five",
    "eight",
    "five",
    "eight",
    "five",
    "actually",
    "multiplying",
    "elements",
    "three",
    "multiplying",
    "list",
    "three",
    "tuple",
    "multiply",
    "three",
    "get",
    "basically",
    "triplicate",
    "tupple",
    "let",
    "look",
    "testing",
    "membership",
    "test",
    "whether",
    "item",
    "sequence",
    "really",
    "easy",
    "almost",
    "english",
    "key",
    "words",
    "python",
    "made",
    "simple",
    "string",
    "let",
    "say",
    "string",
    "called",
    "bug",
    "want",
    "check",
    "letter",
    "u",
    "string",
    "say",
    "u",
    "x",
    "going",
    "give",
    "us",
    "boolean",
    "result",
    "true",
    "false",
    "case",
    "u",
    "x",
    "returns",
    "true",
    "list",
    "pig",
    "cow",
    "horse",
    "print",
    "cow",
    "going",
    "print",
    "false",
    "cow",
    "couple",
    "example",
    "couple",
    "four",
    "names",
    "print",
    "one",
    "names",
    "z",
    "get",
    "true",
    "z",
    "really",
    "easy",
    "check",
    "membership",
    "using",
    "want",
    "iterate",
    "items",
    "sequence",
    "say",
    "item",
    "x",
    "item",
    "variable",
    "name",
    "want",
    "number",
    "x",
    "whatever",
    "like",
    "use",
    "variable",
    "name",
    "item",
    "print",
    "item",
    "want",
    "index",
    "item",
    "list",
    "7",
    "8",
    "3",
    "say",
    "index",
    "comma",
    "item",
    "enumerate",
    "x",
    "numerator",
    "going",
    "return",
    "index",
    "item",
    "actually",
    "variable",
    "names",
    "arbitrary",
    "first",
    "one",
    "going",
    "index",
    "second",
    "one",
    "going",
    "item",
    "name",
    "whatever",
    "variable",
    "name",
    "like",
    "get",
    "index",
    "item",
    "using",
    "enumerate",
    "function",
    "access",
    "index",
    "item",
    "see",
    "results",
    "want",
    "get",
    "count",
    "number",
    "items",
    "sequence",
    "use",
    "len",
    "function",
    "string",
    "example",
    "bug",
    "get",
    "len",
    "x",
    "3",
    "list",
    "three",
    "items",
    "list",
    "print",
    "lin",
    "get",
    "three",
    "tuple",
    "len",
    "z",
    "four",
    "find",
    "minimum",
    "item",
    "python",
    "checks",
    "lexicographically",
    "means",
    "smallest",
    "ascii",
    "scale",
    "use",
    "minimum",
    "function",
    "either",
    "alpha",
    "numeric",
    "types",
    "mix",
    "alpha",
    "numeric",
    "types",
    "list",
    "temple",
    "get",
    "error",
    "string",
    "example",
    "print",
    "min",
    "x",
    "get",
    "smallest",
    "letter",
    "b",
    "list",
    "print",
    "minimum",
    "cow",
    "basically",
    "going",
    "compare",
    "first",
    "letter",
    "first",
    "see",
    "comes",
    "first",
    "alphabetically",
    "tupple",
    "print",
    "one",
    "comes",
    "first",
    "alphabetically",
    "craig",
    "min",
    "maximum",
    "item",
    "sequence",
    "lexicographically",
    "done",
    "alpha",
    "numerically",
    "bug",
    "maximum",
    "pig",
    "cow",
    "horse",
    "see",
    "pig",
    "actually",
    "comes",
    "last",
    "alphabetically",
    "couple",
    "example",
    "last",
    "letter",
    "alphabetically",
    "find",
    "sum",
    "items",
    "sequence",
    "numeric",
    "mix",
    "items",
    "non",
    "numeric",
    "let",
    "say",
    "strings",
    "something",
    "going",
    "give",
    "error",
    "case",
    "string",
    "throw",
    "string",
    "find",
    "print",
    "sum",
    "going",
    "get",
    "error",
    "list",
    "numbers",
    "print",
    "sum",
    "list",
    "see",
    "get",
    "27",
    "also",
    "slicing",
    "combine",
    "slicing",
    "get",
    "sum",
    "part",
    "list",
    "want",
    "get",
    "last",
    "two",
    "numbers",
    "8",
    "12",
    "negative",
    "2",
    "onward",
    "gives",
    "us",
    "20",
    "adding",
    "8",
    "12",
    "tupple",
    "another",
    "tuples",
    "e",
    "4",
    "items",
    "add",
    "together",
    "get",
    "80",
    "sorting",
    "returns",
    "new",
    "list",
    "items",
    "sorted",
    "order",
    "returns",
    "list",
    "string",
    "bug",
    "print",
    "sorted",
    "version",
    "x",
    "get",
    "back",
    "letters",
    "basically",
    "separated",
    "sorted",
    "list",
    "elements",
    "list",
    "list",
    "example",
    "caesar",
    "strings",
    "puts",
    "sorted",
    "order",
    "returns",
    "list",
    "sorted",
    "order",
    "important",
    "understand",
    "change",
    "original",
    "list",
    "sorted",
    "function",
    "sort",
    "returns",
    "new",
    "list",
    "sort",
    "result",
    "example",
    "four",
    "names",
    "put",
    "sorted",
    "order",
    "get",
    "craig",
    "jenny",
    "kevin",
    "nicholas",
    "let",
    "say",
    "want",
    "sort",
    "first",
    "letter",
    "want",
    "sort",
    "instead",
    "second",
    "letter",
    "well",
    "use",
    "lambda",
    "function",
    "going",
    "cover",
    "lambda",
    "functions",
    "detail",
    "video",
    "want",
    "make",
    "aware",
    "sort",
    "stuff",
    "either",
    "reverse",
    "order",
    "using",
    "parameter",
    "using",
    "key",
    "equals",
    "lambda",
    "function",
    "item",
    "k",
    "use",
    "arbitrary",
    "variable",
    "name",
    "k",
    "gon",
    "na",
    "take",
    "one",
    "item",
    "second",
    "letter",
    "going",
    "e",
    "e",
    "r",
    "going",
    "put",
    "sorted",
    "order",
    "based",
    "second",
    "letter",
    "see",
    "second",
    "letter",
    "sorted",
    "order",
    "want",
    "get",
    "count",
    "items",
    "sequence",
    "use",
    "count",
    "function",
    "going",
    "word",
    "hippo",
    "string",
    "going",
    "count",
    "number",
    "times",
    "letter",
    "p",
    "appears",
    "hippo",
    "see",
    "result",
    "two",
    "added",
    "word",
    "cow",
    "list",
    "twice",
    "get",
    "count",
    "word",
    "cow",
    "see",
    "also",
    "two",
    "get",
    "word",
    "count",
    "kevin",
    "list",
    "see",
    "one",
    "get",
    "index",
    "item",
    "passing",
    "item",
    "asking",
    "index",
    "going",
    "give",
    "us",
    "index",
    "first",
    "occurrence",
    "item",
    "case",
    "hippo",
    "looking",
    "p",
    "going",
    "give",
    "us",
    "let",
    "see",
    "h",
    "zero",
    "one",
    "first",
    "p",
    "two",
    "see",
    "result",
    "get",
    "two",
    "stops",
    "looking",
    "finds",
    "first",
    "item",
    "matches",
    "sequence",
    "list",
    "example",
    "cow",
    "two",
    "cows",
    "going",
    "get",
    "index",
    "cow",
    "going",
    "get",
    "one",
    "return",
    "value",
    "tuple",
    "get",
    "index",
    "jenny",
    "see",
    "0",
    "1",
    "2",
    "unpacking",
    "items",
    "sequence",
    "unpack",
    "number",
    "variables",
    "important",
    "number",
    "variables",
    "exactly",
    "matches",
    "length",
    "list",
    "string",
    "going",
    "get",
    "error",
    "list",
    "x",
    "equals",
    "cow",
    "horse",
    "wo",
    "unpack",
    "assign",
    "values",
    "variable",
    "say",
    "comma",
    "b",
    "comma",
    "c",
    "equals",
    "x",
    "basically",
    "going",
    "put",
    "order",
    "assigning",
    "b",
    "c",
    "print",
    "b",
    "c",
    "separate",
    "variables",
    "pig",
    "cow",
    "horse",
    "called",
    "unpacking",
    "next",
    "lecture",
    "learn",
    "detailed",
    "features",
    "lists",
    "tuples",
    "sets",
    "dictionaries",
    "let",
    "dig",
    "specifics",
    "lists",
    "tuples",
    "sets",
    "dictionaries",
    "recap",
    "lists",
    "data",
    "structure",
    "python",
    "going",
    "use",
    "almost",
    "everything",
    "python",
    "say",
    "lot",
    "stuff",
    "grow",
    "shrink",
    "size",
    "needed",
    "continue",
    "adding",
    "items",
    "deleting",
    "items",
    "size",
    "list",
    "shrink",
    "accordingly",
    "automatically",
    "python",
    "sequence",
    "type",
    "sequence",
    "functions",
    "covered",
    "useful",
    "lists",
    "also",
    "sortable",
    "lot",
    "data",
    "structures",
    "sortable",
    "lists",
    "makes",
    "useful",
    "sorting",
    "data",
    "let",
    "look",
    "constructors",
    "lists",
    "create",
    "new",
    "list",
    "different",
    "ways",
    "one",
    "create",
    "empty",
    "list",
    "saying",
    "x",
    "equals",
    "list",
    "parentheses",
    "calls",
    "list",
    "constructor",
    "parameters",
    "gives",
    "us",
    "new",
    "empty",
    "list",
    "another",
    "way",
    "probably",
    "common",
    "way",
    "pass",
    "items",
    "want",
    "list",
    "inside",
    "square",
    "brackets",
    "square",
    "brackets",
    "separate",
    "item",
    "comma",
    "pass",
    "multiple",
    "different",
    "data",
    "types",
    "strings",
    "integers",
    "floating",
    "point",
    "values",
    "list",
    "one",
    "nice",
    "thing",
    "versatility",
    "lists",
    "see",
    "also",
    "create",
    "tuple",
    "cover",
    "tupple",
    "constructors",
    "minute",
    "create",
    "new",
    "tuple",
    "pass",
    "tupple",
    "list",
    "constructor",
    "putting",
    "inside",
    "parentheses",
    "list",
    "constructor",
    "create",
    "new",
    "list",
    "pat",
    "assign",
    "z",
    "lastly",
    "use",
    "list",
    "comprehensions",
    "going",
    "another",
    "section",
    "list",
    "comprehensions",
    "minutes",
    "wanted",
    "give",
    "little",
    "teaser",
    "list",
    "comprehensions",
    "create",
    "new",
    "lists",
    "sets",
    "values",
    "going",
    "create",
    "new",
    "list",
    "called",
    "put",
    "square",
    "brackets",
    "basically",
    "inside",
    "loop",
    "range",
    "function",
    "say",
    "m4m",
    "range",
    "8",
    "going",
    "count",
    "0",
    "7",
    "value",
    "going",
    "assign",
    "list",
    "get",
    "new",
    "list",
    "value",
    "0",
    "7",
    "want",
    "something",
    "fancy",
    "taste",
    "range",
    "10",
    "going",
    "count",
    "0",
    "9",
    "going",
    "take",
    "ones",
    "greater",
    "4",
    "greater",
    "4",
    "pass",
    "squared",
    "list",
    "get",
    "5",
    "9",
    "squared",
    "new",
    "list",
    "taste",
    "list",
    "comprehensions",
    "create",
    "new",
    "list",
    "using",
    "loop",
    "range",
    "function",
    "also",
    "add",
    "filter",
    "items",
    "whatever",
    "want",
    "items",
    "iterating",
    "let",
    "take",
    "look",
    "delete",
    "function",
    "want",
    "delete",
    "single",
    "item",
    "list",
    "going",
    "delete",
    "entire",
    "list",
    "using",
    "del",
    "list",
    "called",
    "x",
    "5",
    "3",
    "8",
    "6",
    "want",
    "delete",
    "one",
    "thigh",
    "tum",
    "3",
    "pass",
    "one",
    "square",
    "brackets",
    "index",
    "item",
    "del",
    "x",
    "1",
    "deletes",
    "one",
    "time",
    "2",
    "3",
    "see",
    "new",
    "list",
    "want",
    "delete",
    "entire",
    "list",
    "say",
    "del",
    "x",
    "next",
    "append",
    "function",
    "want",
    "add",
    "item",
    "list",
    "going",
    "add",
    "tail",
    "end",
    "list",
    "create",
    "new",
    "list",
    "5",
    "3",
    "8",
    "6",
    "x",
    "dot",
    "append",
    "pass",
    "7",
    "argument",
    "append",
    "7",
    "tail",
    "list",
    "extend",
    "basically",
    "similar",
    "plus",
    "function",
    "used",
    "basically",
    "combining",
    "two",
    "separate",
    "lists",
    "one",
    "list",
    "x",
    "equals",
    "5",
    "3",
    "8",
    "6",
    "equals",
    "12",
    "13",
    "extend",
    "x",
    "print",
    "new",
    "x",
    "see",
    "6",
    "items",
    "could",
    "also",
    "used",
    "plus",
    "insert",
    "insert",
    "item",
    "given",
    "index",
    "list",
    "list",
    "used",
    "insert",
    "one",
    "position",
    "item",
    "7",
    "see",
    "result",
    "5",
    "7",
    "3",
    "8",
    "6",
    "position",
    "index",
    "want",
    "insert",
    "item",
    "want",
    "insert",
    "see",
    "insert",
    "integer",
    "floating",
    "point",
    "value",
    "sir",
    "tale",
    "issed",
    "list",
    "item",
    "list",
    "min",
    "two",
    "items",
    "print",
    "revised",
    "list",
    "see",
    "second",
    "item",
    "1",
    "thight",
    "list",
    "another",
    "list",
    "insert",
    "function",
    "let",
    "take",
    "look",
    "pop",
    "pop",
    "basically",
    "pops",
    "last",
    "item",
    "list",
    "returns",
    "item",
    "use",
    "item",
    "want",
    "basically",
    "shrinking",
    "list",
    "one",
    "item",
    "5",
    "3",
    "8",
    "6",
    "pop",
    "one",
    "item",
    "using",
    "x",
    "dot",
    "pop",
    "pops",
    "last",
    "item",
    "6",
    "assign",
    "anything",
    "anything",
    "see",
    "new",
    "list",
    "5",
    "3",
    "8",
    "print",
    "x",
    "dot",
    "pop",
    "pops",
    "8",
    "last",
    "item",
    "list",
    "print",
    "see",
    "return",
    "value",
    "8",
    "x",
    "dot",
    "pop",
    "remove",
    "remove",
    "first",
    "instance",
    "item",
    "multiple",
    "instances",
    "item",
    "python",
    "going",
    "start",
    "searching",
    "beginning",
    "list",
    "finds",
    "item",
    "matches",
    "going",
    "stop",
    "searching",
    "going",
    "remove",
    "item",
    "multiple",
    "threes",
    "list",
    "going",
    "remove",
    "first",
    "one",
    "x",
    "remove",
    "3",
    "see",
    "revised",
    "list",
    "without",
    "first",
    "3",
    "reverse",
    "function",
    "reverse",
    "order",
    "list",
    "reverse",
    "means",
    "changes",
    "original",
    "list",
    "original",
    "list",
    "longer",
    "original",
    "list",
    "x",
    "equals",
    "5",
    "3",
    "8",
    "6",
    "apply",
    "reverse",
    "putting",
    "sorted",
    "order",
    "simply",
    "reversing",
    "order",
    "items",
    "get",
    "6",
    "8",
    "3",
    "5",
    "reversed",
    "list",
    "apply",
    "sort",
    "function",
    "also",
    "sort",
    "note",
    "use",
    "sorted",
    "ax",
    "python",
    "functions",
    "sort",
    "two",
    "different",
    "ones",
    "little",
    "bit",
    "confusing",
    "sort",
    "sort",
    "sorted",
    "returns",
    "new",
    "list",
    "sort",
    "using",
    "x",
    "dot",
    "sort",
    "function",
    "pass",
    "anything",
    "parameter",
    "sort",
    "function",
    "applying",
    "sort",
    "function",
    "x",
    "calling",
    "sort",
    "function",
    "see",
    "put",
    "items",
    "sorted",
    "order",
    "want",
    "reverse",
    "sort",
    "pass",
    "sort",
    "function",
    "parameter",
    "called",
    "reverse",
    "equals",
    "true",
    "give",
    "descending",
    "sort",
    "get",
    "8",
    "6",
    "5",
    "3",
    "try",
    "use",
    "reverse",
    "equals",
    "true",
    "parameter",
    "would",
    "use",
    "sorted",
    "function",
    "wanted",
    "reverse",
    "sort",
    "using",
    "sorted",
    "function",
    "one",
    "sort",
    "see",
    "python",
    "lists",
    "really",
    "powerful",
    "data",
    "structure",
    "lot",
    "functions",
    "features",
    "unless",
    "want",
    "become",
    "carpenter",
    "tries",
    "turn",
    "every",
    "problem",
    "nail",
    "pounding",
    "hammer",
    "let",
    "continue",
    "course",
    "learn",
    "data",
    "structures",
    "see",
    "used",
    "let",
    "take",
    "closer",
    "look",
    "tuples",
    "recap",
    "said",
    "tuples",
    "immutable",
    "means",
    "ca",
    "changed",
    "ca",
    "add",
    "items",
    "tupple",
    "created",
    "useful",
    "fixed",
    "data",
    "gon",
    "na",
    "lot",
    "changes",
    "data",
    "use",
    "lists",
    "useful",
    "fixed",
    "data",
    "much",
    "faster",
    "finding",
    "items",
    "list",
    "sequence",
    "types",
    "means",
    "functions",
    "still",
    "going",
    "work",
    "use",
    "sequence",
    "functions",
    "used",
    "tuples",
    "let",
    "take",
    "look",
    "constructors",
    "tuples",
    "create",
    "new",
    "tuple",
    "different",
    "ways",
    "tupple",
    "uses",
    "parentheses",
    "constructor",
    "create",
    "empty",
    "new",
    "tuple",
    "using",
    "x",
    "equals",
    "parentheses",
    "empty",
    "parentheses",
    "want",
    "pass",
    "items",
    "1",
    "2",
    "3",
    "parentheses",
    "actually",
    "optional",
    "even",
    "take",
    "parentheses",
    "away",
    "1",
    "2",
    "3",
    "separated",
    "commas",
    "python",
    "notices",
    "tupple",
    "want",
    "couple",
    "one",
    "item",
    "still",
    "put",
    "comma",
    "comma",
    "tells",
    "python",
    "one",
    "item",
    "tuple",
    "integer",
    "see",
    "print",
    "x",
    "type",
    "x",
    "get",
    "couple",
    "two",
    "class",
    "tupple",
    "let",
    "create",
    "list",
    "one",
    "equals",
    "two",
    "four",
    "six",
    "list",
    "three",
    "items",
    "pass",
    "list",
    "tupple",
    "constructor",
    "creates",
    "tuple",
    "called",
    "x",
    "print",
    "x",
    "tupple",
    "two",
    "four",
    "six",
    "see",
    "square",
    "brackets",
    "parentheses",
    "around",
    "print",
    "type",
    "x",
    "class",
    "couple",
    "several",
    "different",
    "ways",
    "create",
    "tuples",
    "tuples",
    "immutable",
    "however",
    "may",
    "little",
    "confusing",
    "pay",
    "attention",
    "member",
    "objects",
    "may",
    "mutable",
    "list",
    "one",
    "items",
    "inside",
    "couple",
    "ca",
    "make",
    "changes",
    "list",
    "add",
    "delete",
    "items",
    "list",
    "change",
    "items",
    "list",
    "let",
    "take",
    "look",
    "mean",
    "couple",
    "one",
    "two",
    "three",
    "try",
    "delete",
    "one",
    "theit",
    "two",
    "going",
    "fail",
    "going",
    "give",
    "us",
    "error",
    "python",
    "try",
    "change",
    "value",
    "two",
    "eight",
    "also",
    "fails",
    "change",
    "value",
    "two",
    "looks",
    "like",
    "tupple",
    "totally",
    "immutable",
    "unchangeable",
    "get",
    "one",
    "two",
    "three",
    "even",
    "try",
    "going",
    "get",
    "error",
    "look",
    "assign",
    "list",
    "two",
    "item",
    "list",
    "zeroeth",
    "item",
    "tuple",
    "well",
    "list",
    "mutable",
    "change",
    "drop",
    "items",
    "list",
    "want",
    "going",
    "pass",
    "two",
    "indices",
    "zero",
    "tells",
    "python",
    "yeah",
    "want",
    "zeroeth",
    "item",
    "tuple",
    "list",
    "one",
    "two",
    "list",
    "want",
    "one",
    "thight",
    "two",
    "going",
    "delete",
    "basically",
    "deleting",
    "two",
    "list",
    "going",
    "print",
    "see",
    "result",
    "get",
    "single",
    "item",
    "list",
    "1",
    "3",
    "able",
    "edit",
    "list",
    "one",
    "two",
    "able",
    "drop",
    "items",
    "list",
    "also",
    "want",
    "add",
    "items",
    "tempo",
    "add",
    "append",
    "however",
    "use",
    "concatenation",
    "function",
    "plus",
    "equals",
    "additional",
    "temple",
    "merge",
    "two",
    "tuples",
    "one",
    "need",
    "comma",
    "tell",
    "python",
    "tupple",
    "integer",
    "one",
    "item",
    "tuple",
    "plus",
    "equals",
    "four",
    "see",
    "four",
    "added",
    "original",
    "type",
    "concatenating",
    "work",
    "let",
    "look",
    "sets",
    "set",
    "store",
    "non",
    "duplicate",
    "items",
    "unique",
    "items",
    "really",
    "sets",
    "ideal",
    "get",
    "fast",
    "access",
    "compared",
    "lists",
    "reason",
    "iterate",
    "list",
    "looking",
    "item",
    "way",
    "start",
    "beginning",
    "look",
    "every",
    "single",
    "item",
    "comparison",
    "billion",
    "items",
    "list",
    "going",
    "bill",
    "may",
    "billion",
    "comparisons",
    "find",
    "item",
    "set",
    "hashes",
    "item",
    "find",
    "instantly",
    "using",
    "hash",
    "much",
    "faster",
    "access",
    "lists",
    "especially",
    "large",
    "data",
    "sets",
    "much",
    "faster",
    "access",
    "items",
    "lists",
    "great",
    "checking",
    "membership",
    "set",
    "also",
    "great",
    "math",
    "set",
    "operations",
    "things",
    "like",
    "union",
    "intersection",
    "keep",
    "mind",
    "sets",
    "unordered",
    "means",
    "sort",
    "set",
    "let",
    "take",
    "look",
    "constructors",
    "set",
    "different",
    "ways",
    "create",
    "new",
    "set",
    "use",
    "curly",
    "braces",
    "see",
    "pass",
    "3535",
    "got",
    "duplicates",
    "python",
    "filters",
    "dupes",
    "gives",
    "us",
    "set",
    "three",
    "five",
    "create",
    "new",
    "empty",
    "set",
    "use",
    "set",
    "constructor",
    "parentheses",
    "print",
    "see",
    "get",
    "empty",
    "set",
    "want",
    "also",
    "pass",
    "list",
    "two",
    "three",
    "four",
    "call",
    "set",
    "constructor",
    "using",
    "parentheses",
    "pass",
    "set",
    "parameter",
    "getting",
    "new",
    "set",
    "z",
    "print",
    "get",
    "two",
    "three",
    "four",
    "set",
    "different",
    "ways",
    "create",
    "sets",
    "set",
    "operations",
    "use",
    "add",
    "item",
    "set",
    "using",
    "x",
    "dot",
    "add",
    "add",
    "seven",
    "list",
    "three",
    "eight",
    "five",
    "remove",
    "three",
    "using",
    "x",
    "dot",
    "remove",
    "see",
    "result",
    "add",
    "seven",
    "get",
    "four",
    "item",
    "list",
    "delete",
    "three",
    "get",
    "back",
    "eight",
    "five",
    "seven",
    "add",
    "remove",
    "work",
    "sets",
    "want",
    "get",
    "length",
    "set",
    "use",
    "lin",
    "checking",
    "membership",
    "use",
    "want",
    "check",
    "five",
    "set",
    "five",
    "x",
    "five",
    "x",
    "going",
    "give",
    "us",
    "boolean",
    "return",
    "see",
    "got",
    "true",
    "five",
    "x",
    "also",
    "pop",
    "random",
    "item",
    "bear",
    "mind",
    "set",
    "ordered",
    "know",
    "item",
    "gon",
    "na",
    "get",
    "gon",
    "na",
    "get",
    "random",
    "item",
    "set",
    "actually",
    "pop",
    "function",
    "returns",
    "item",
    "printing",
    "item",
    "new",
    "list",
    "x",
    "see",
    "item",
    "gave",
    "us",
    "8",
    "new",
    "set",
    "5",
    "7",
    "want",
    "delete",
    "items",
    "set",
    "get",
    "empty",
    "set",
    "back",
    "x",
    "clear",
    "let",
    "look",
    "mathematical",
    "set",
    "functions",
    "said",
    "intersection",
    "union",
    "functions",
    "intersection",
    "done",
    "using",
    "ampersand",
    "two",
    "sets",
    "union",
    "done",
    "using",
    "pipe",
    "bar",
    "set",
    "one",
    "pipe",
    "set",
    "symmetric",
    "difference",
    "exclusive",
    "words",
    "items",
    "set",
    "one",
    "set",
    "two",
    "set",
    "two",
    "set",
    "one",
    "difference",
    "use",
    "subtraction",
    "set",
    "one",
    "set",
    "difference",
    "two",
    "check",
    "one",
    "set",
    "subset",
    "fully",
    "contained",
    "set",
    "using",
    "less",
    "equal",
    "greater",
    "equal",
    "super",
    "first",
    "superset",
    "two",
    "different",
    "sets",
    "set",
    "one",
    "set",
    "two",
    "intersection",
    "see",
    "intersection",
    "three",
    "value",
    "three",
    "union",
    "get",
    "items",
    "either",
    "set",
    "1",
    "2",
    "3",
    "4",
    "5",
    "exclusive",
    "using",
    "caret",
    "get",
    "1",
    "2",
    "4",
    "5",
    "items",
    "one",
    "set",
    "get",
    "1",
    "2",
    "since",
    "neither",
    "set",
    "subset",
    "set",
    "return",
    "false",
    "mathematical",
    "set",
    "operations",
    "sets",
    "let",
    "take",
    "look",
    "dictionaries",
    "first",
    "recap",
    "dictionaries",
    "dictionaries",
    "key",
    "value",
    "pairs",
    "programming",
    "languages",
    "equivalent",
    "python",
    "dictionary",
    "always",
    "call",
    "call",
    "hashmap",
    "java",
    "calls",
    "hashmap",
    "dictionaries",
    "unordered",
    "means",
    "sorted",
    "converted",
    "list",
    "sorted",
    "list",
    "sorted",
    "dictionary",
    "functions",
    "create",
    "new",
    "dictionaries",
    "let",
    "take",
    "look",
    "constructors",
    "create",
    "new",
    "dictionary",
    "using",
    "curly",
    "braces",
    "need",
    "pass",
    "members",
    "key",
    "value",
    "pairs",
    "separated",
    "colon",
    "spaced",
    "commas",
    "okay",
    "three",
    "key",
    "value",
    "pairs",
    "key",
    "left",
    "colon",
    "value",
    "three",
    "different",
    "ways",
    "creating",
    "exactly",
    "dictionary",
    "second",
    "example",
    "pass",
    "list",
    "tuples",
    "tuple",
    "contains",
    "two",
    "items",
    "string",
    "separated",
    "comma",
    "floating",
    "point",
    "three",
    "tuples",
    "list",
    "passed",
    "dictionary",
    "constructor",
    "parentheses",
    "third",
    "one",
    "passes",
    "dictionary",
    "constructor",
    "notice",
    "search",
    "quotation",
    "marks",
    "around",
    "strings",
    "pork",
    "equals",
    "25",
    "point",
    "3",
    "python",
    "knows",
    "string",
    "three",
    "different",
    "ways",
    "create",
    "dictionaries",
    "python",
    "exactly",
    "thing",
    "operations",
    "dictionaries",
    "notice",
    "shrimp",
    "dictionary",
    "want",
    "add",
    "shrimp",
    "say",
    "x",
    "shrimp",
    "equals",
    "case",
    "shrimp",
    "dictionary",
    "add",
    "going",
    "add",
    "new",
    "key",
    "value",
    "pair",
    "shrimp",
    "already",
    "shrimp",
    "dictionary",
    "would",
    "update",
    "value",
    "shrimp",
    "looks",
    "key",
    "update",
    "value",
    "add",
    "update",
    "python",
    "going",
    "tell",
    "want",
    "check",
    "check",
    "first",
    "right",
    "shrimp",
    "dictionary",
    "x",
    "shrimp",
    "equals",
    "going",
    "overwrite",
    "anything",
    "already",
    "dictionary",
    "shrimp",
    "want",
    "delete",
    "item",
    "del",
    "x",
    "shrimp",
    "going",
    "delete",
    "shrimp",
    "dictionary",
    "see",
    "print",
    "new",
    "dictionary",
    "shrimp",
    "want",
    "get",
    "length",
    "dictionary",
    "print",
    "lin",
    "x",
    "tell",
    "many",
    "key",
    "value",
    "pairs",
    "dictionary",
    "want",
    "delete",
    "items",
    "dictionary",
    "use",
    "x",
    "dot",
    "clear",
    "lastly",
    "delete",
    "entire",
    "dictionary",
    "free",
    "memory",
    "using",
    "use",
    "del",
    "x",
    "access",
    "keys",
    "values",
    "dictionary",
    "access",
    "separately",
    "access",
    "together",
    "different",
    "ways",
    "dictionary",
    "pork",
    "beef",
    "chicken",
    "keys",
    "strings",
    "pork",
    "beef",
    "chicken",
    "dot",
    "keys",
    "get",
    "list",
    "pork",
    "beef",
    "chicken",
    "dumps",
    "list",
    "wideout",
    "values",
    "dumps",
    "list",
    "values",
    "values",
    "items",
    "say",
    "print",
    "dot",
    "items",
    "going",
    "print",
    "key",
    "value",
    "pairs",
    "princeton",
    "amount",
    "list",
    "tuples",
    "key",
    "value",
    "pairs",
    "check",
    "membership",
    "keys",
    "specify",
    "keys",
    "want",
    "say",
    "beef",
    "dot",
    "keys",
    "simply",
    "say",
    "beef",
    "gon",
    "na",
    "check",
    "wise",
    "keys",
    "going",
    "check",
    "values",
    "want",
    "check",
    "membership",
    "values",
    "check",
    "clams",
    "dot",
    "values",
    "membership",
    "tests",
    "going",
    "boolean",
    "return",
    "true",
    "false",
    "iterate",
    "dictionary",
    "keep",
    "mind",
    "items",
    "random",
    "order",
    "going",
    "able",
    "iterate",
    "kind",
    "sorted",
    "order",
    "going",
    "python",
    "going",
    "give",
    "back",
    "whatever",
    "order",
    "key",
    "print",
    "key",
    "give",
    "keys",
    "dictionary",
    "one",
    "time",
    "get",
    "value",
    "saying",
    "key",
    "see",
    "printed",
    "key",
    "value",
    "want",
    "iterate",
    "separate",
    "variable",
    "key",
    "value",
    "sometimes",
    "helpful",
    "lot",
    "operations",
    "inside",
    "loop",
    "put",
    "whatever",
    "variables",
    "want",
    "used",
    "k",
    "comma",
    "v",
    "variable",
    "names",
    "iterate",
    "dot",
    "items",
    "items",
    "returns",
    "item",
    "couple",
    "key",
    "value",
    "assigns",
    "whatever",
    "variable",
    "names",
    "k",
    "v",
    "case",
    "see",
    "result",
    "iterate",
    "items",
    "print",
    "key",
    "value",
    "wraps",
    "video",
    "python",
    "data",
    "structures",
    "pretty",
    "good",
    "understanding",
    "use",
    "pythons",
    "data",
    "structures",
    "strings",
    "lists",
    "tuples",
    "sets",
    "dictionaries",
    "make",
    "sure",
    "download",
    "code",
    "get",
    "practice",
    "using",
    "practice",
    "going",
    "make",
    "good",
    "programmer",
    "next",
    "section",
    "learn",
    "use",
    "list",
    "comprehensions",
    "create",
    "new",
    "lists",
    "hi",
    "joe",
    "chapter",
    "going",
    "cover",
    "pretty",
    "cool",
    "feature",
    "python",
    "called",
    "list",
    "comprehensions",
    "enables",
    "create",
    "new",
    "lists",
    "values",
    "using",
    "comprehension",
    "basically",
    "sort",
    "loop",
    "iteration",
    "inside",
    "list",
    "creator",
    "basic",
    "format",
    "transform",
    "sequence",
    "filter",
    "apply",
    "filter",
    "want",
    "put",
    "inside",
    "square",
    "brackets",
    "going",
    "result",
    "going",
    "assigned",
    "new",
    "list",
    "going",
    "use",
    "random",
    "module",
    "little",
    "bit",
    "need",
    "comprehension",
    "examples",
    "going",
    "import",
    "series",
    "10",
    "examples",
    "something",
    "show",
    "get",
    "increasingly",
    "complex",
    "going",
    "get",
    "values",
    "within",
    "range",
    "typically",
    "list",
    "comprehensions",
    "anything",
    "range",
    "function",
    "use",
    "range",
    "10",
    "know",
    "range",
    "function",
    "returns",
    "sequence",
    "numbers",
    "case",
    "starts",
    "0",
    "default",
    "goes",
    "9",
    "10",
    "non",
    "inclusive",
    "0",
    "9",
    "going",
    "add",
    "new",
    "list",
    "x",
    "x",
    "range",
    "part",
    "first",
    "x",
    "could",
    "apply",
    "sort",
    "transform",
    "function",
    "x",
    "wanted",
    "x",
    "squared",
    "x",
    "whatever",
    "want",
    "declare",
    "variable",
    "x",
    "range",
    "result",
    "series",
    "values",
    "10",
    "0",
    "9",
    "10",
    "integers",
    "okay",
    "simplest",
    "example",
    "list",
    "comprehension",
    "let",
    "look",
    "crazy",
    "stuff",
    "list",
    "comprehensions",
    "could",
    "get",
    "squares",
    "want",
    "told",
    "could",
    "apply",
    "transformation",
    "x",
    "want",
    "declare",
    "variable",
    "x",
    "iterate",
    "10",
    "list",
    "created",
    "okay",
    "necessarily",
    "use",
    "range",
    "function",
    "use",
    "sequence",
    "means",
    "could",
    "use",
    "list",
    "could",
    "use",
    "couple",
    "set",
    "even",
    "string",
    "range",
    "function",
    "x",
    "squared",
    "x",
    "10",
    "going",
    "iterate",
    "going",
    "return",
    "square",
    "one",
    "going",
    "assign",
    "new",
    "list",
    "called",
    "squares",
    "going",
    "print",
    "squares",
    "see",
    "result",
    "0",
    "81",
    "squares",
    "previous",
    "list",
    "ok",
    "let",
    "see",
    "else",
    "get",
    "odd",
    "numbers",
    "using",
    "mod",
    "ok",
    "odds",
    "equals",
    "x",
    "x",
    "range",
    "10",
    "going",
    "basically",
    "iterate",
    "0",
    "9",
    "variable",
    "going",
    "use",
    "called",
    "x",
    "gon",
    "na",
    "send",
    "x",
    "odds",
    "list",
    "look",
    "apply",
    "test",
    "condition",
    "x",
    "mod",
    "2",
    "words",
    "odd",
    "x",
    "odd",
    "send",
    "odds",
    "list",
    "print",
    "see",
    "get",
    "one",
    "three",
    "five",
    "seven",
    "nine",
    "let",
    "get",
    "multiples",
    "ten",
    "going",
    "use",
    "arrange",
    "function",
    "sequence",
    "zero",
    "nine",
    "instead",
    "adding",
    "x",
    "list",
    "gon",
    "na",
    "add",
    "x",
    "times",
    "ten",
    "whole",
    "lot",
    "different",
    "x",
    "squared",
    "get",
    "two",
    "multiples",
    "ten",
    "zero",
    "nine",
    "let",
    "get",
    "numbers",
    "string",
    "start",
    "string",
    "named",
    "combination",
    "letters",
    "numbers",
    "maybe",
    "sometimes",
    "want",
    "filter",
    "delete",
    "numbers",
    "whatever",
    "gon",
    "na",
    "create",
    "new",
    "list",
    "numbers",
    "nums",
    "equals",
    "x",
    "x",
    "words",
    "going",
    "iterate",
    "letters",
    "characters",
    "going",
    "test",
    "one",
    "numeric",
    "gon",
    "na",
    "add",
    "list",
    "print",
    "list",
    "basically",
    "get",
    "list",
    "gon",
    "na",
    "use",
    "little",
    "join",
    "function",
    "join",
    "numbers",
    "single",
    "single",
    "string",
    "get",
    "207",
    "3",
    "words",
    "managed",
    "grab",
    "integers",
    "string",
    "going",
    "get",
    "index",
    "list",
    "item",
    "going",
    "using",
    "enumerate",
    "function",
    "iterate",
    "using",
    "enumerate",
    "names",
    "name",
    "list",
    "names",
    "list",
    "going",
    "numerator",
    "enumerate",
    "returns",
    "key",
    "value",
    "item",
    "list",
    "start",
    "cosmo",
    "0",
    "get",
    "pedro",
    "one",
    "right",
    "eating",
    "name",
    "getting",
    "key",
    "value",
    "test",
    "value",
    "equal",
    "anya",
    "okay",
    "means",
    "key",
    "going",
    "equal",
    "two",
    "add",
    "list",
    "well",
    "add",
    "k",
    "add",
    "k",
    "add",
    "key",
    "end",
    "result",
    "get",
    "list",
    "two",
    "one",
    "passes",
    "test",
    "print",
    "zeroeth",
    "item",
    "list",
    "course",
    "twos",
    "one",
    "item",
    "list",
    "also",
    "delete",
    "item",
    "list",
    "list",
    "letters",
    "actually",
    "string",
    "start",
    "iterating",
    "string",
    "abcde",
    "f",
    "converting",
    "list",
    "letters",
    "adding",
    "letter",
    "string",
    "list",
    "list",
    "abcde",
    "f",
    "individual",
    "letters",
    "shuffle",
    "using",
    "random",
    "function",
    "shuffled",
    "letters",
    "abcde",
    "f",
    "one",
    "basically",
    "string",
    "object",
    "letters",
    "list",
    "going",
    "create",
    "new",
    "list",
    "passes",
    "test",
    "letters",
    "c",
    "right",
    "words",
    "every",
    "letter",
    "list",
    "except",
    "uppercase",
    "c",
    "gon",
    "na",
    "get",
    "b",
    "ef",
    "see",
    "print",
    "get",
    "df",
    "e",
    "b",
    "get",
    "c",
    "get",
    "yeah",
    "works",
    "pretty",
    "cool",
    "huh",
    "basically",
    "filtered",
    "c",
    "wherever",
    "list",
    "know",
    "filtered",
    "wraps",
    "lecture",
    "list",
    "comprehensions",
    "download",
    "code",
    "github",
    "site",
    "use",
    "tests",
    "code",
    "run",
    "examples",
    "encourage",
    "use",
    "list",
    "comprehensions",
    "really",
    "useful",
    "tool",
    "python",
    "creating",
    "lists",
    "section",
    "going",
    "learn",
    "use",
    "stacks",
    "queues",
    "heaps",
    "first",
    "cover",
    "fundamentals",
    "data",
    "structures",
    "key",
    "operations",
    "implement",
    "python",
    "three",
    "useful",
    "data",
    "structures",
    "let",
    "start",
    "learning",
    "stacks",
    "stack",
    "last",
    "first",
    "data",
    "structure",
    "called",
    "lifo",
    "means",
    "push",
    "pop",
    "operations",
    "top",
    "stack",
    "effect",
    "top",
    "item",
    "stack",
    "way",
    "access",
    "bottom",
    "items",
    "stack",
    "like",
    "diagram",
    "item",
    "one",
    "first",
    "remove",
    "items",
    "couple",
    "different",
    "key",
    "operations",
    "push",
    "allows",
    "us",
    "push",
    "item",
    "top",
    "stack",
    "use",
    "pop",
    "command",
    "pop",
    "item",
    "top",
    "stack",
    "stack",
    "operations",
    "peak",
    "sometimes",
    "might",
    "want",
    "get",
    "item",
    "top",
    "stack",
    "without",
    "actually",
    "removing",
    "let",
    "say",
    "need",
    "access",
    "top",
    "item",
    "want",
    "know",
    "use",
    "peak",
    "command",
    "see",
    "copy",
    "top",
    "item",
    "without",
    "actually",
    "removing",
    "stack",
    "clear",
    "remove",
    "items",
    "stack",
    "empty",
    "stack",
    "lot",
    "different",
    "use",
    "cases",
    "stacks",
    "one",
    "common",
    "use",
    "case",
    "command",
    "stack",
    "computer",
    "programs",
    "track",
    "command",
    "execute",
    "programs",
    "use",
    "option",
    "undoing",
    "previous",
    "command",
    "order",
    "program",
    "keep",
    "track",
    "commands",
    "executed",
    "order",
    "using",
    "stack",
    "time",
    "execute",
    "command",
    "pushes",
    "command",
    "stack",
    "record",
    "click",
    "undo",
    "button",
    "going",
    "pop",
    "last",
    "command",
    "stack",
    "going",
    "reverse",
    "command",
    "command",
    "stack",
    "used",
    "execute",
    "undo",
    "function",
    "programming",
    "let",
    "take",
    "look",
    "stacks",
    "implemented",
    "code",
    "python",
    "list",
    "makes",
    "great",
    "foundational",
    "data",
    "structure",
    "store",
    "stack",
    "actually",
    "python",
    "gives",
    "us",
    "functionality",
    "need",
    "create",
    "stack",
    "list",
    "underlying",
    "data",
    "structure",
    "beyond",
    "stack",
    "going",
    "python",
    "list",
    "python",
    "gives",
    "us",
    "append",
    "function",
    "use",
    "push",
    "item",
    "onto",
    "stack",
    "gives",
    "us",
    "pop",
    "function",
    "use",
    "remove",
    "item",
    "stack",
    "actually",
    "pushing",
    "items",
    "onto",
    "list",
    "opting",
    "list",
    "one",
    "implementation",
    "using",
    "python",
    "list",
    "create",
    "new",
    "stack",
    "stack",
    "equals",
    "empty",
    "list",
    "push",
    "items",
    "onto",
    "stack",
    "using",
    "pin",
    "pushed",
    "7",
    "12",
    "19",
    "onto",
    "stack",
    "print",
    "stack",
    "see",
    "four",
    "items",
    "little",
    "test",
    "coat",
    "pop",
    "item",
    "stack",
    "see",
    "get",
    "19",
    "first",
    "pop",
    "second",
    "item",
    "get",
    "12",
    "popping",
    "last",
    "item",
    "first",
    "exactly",
    "want",
    "typical",
    "stack",
    "operation",
    "however",
    "using",
    "python",
    "list",
    "wanted",
    "write",
    "wrapper",
    "class",
    "add",
    "additional",
    "functionality",
    "stack",
    "actually",
    "hard",
    "let",
    "take",
    "look",
    "done",
    "stack",
    "using",
    "list",
    "underlying",
    "data",
    "structure",
    "using",
    "wrapper",
    "class",
    "rename",
    "functions",
    "like",
    "also",
    "add",
    "additional",
    "functions",
    "features",
    "stack",
    "start",
    "constructor",
    "init",
    "function",
    "basically",
    "new",
    "list",
    "creates",
    "empty",
    "list",
    "push",
    "going",
    "add",
    "item",
    "receive",
    "item",
    "use",
    "append",
    "function",
    "add",
    "item",
    "list",
    "user",
    "going",
    "see",
    "pushing",
    "item",
    "stack",
    "behind",
    "scenes",
    "appending",
    "item",
    "list",
    "next",
    "pop",
    "function",
    "first",
    "want",
    "check",
    "list",
    "actually",
    "items",
    "list",
    "list",
    "empty",
    "want",
    "try",
    "pop",
    "operation",
    "least",
    "one",
    "item",
    "list",
    "pop",
    "item",
    "return",
    "peek",
    "function",
    "allows",
    "us",
    "look",
    "top",
    "item",
    "list",
    "return",
    "item",
    "without",
    "taking",
    "return",
    "top",
    "item",
    "list",
    "without",
    "removing",
    "lastly",
    "someone",
    "wants",
    "print",
    "stack",
    "show",
    "items",
    "stack",
    "going",
    "show",
    "string",
    "representation",
    "list",
    "let",
    "look",
    "tests",
    "see",
    "stack",
    "works",
    "stack",
    "equals",
    "stack",
    "push",
    "item",
    "push",
    "a1",
    "push",
    "a3",
    "print",
    "stack",
    "see",
    "yeah",
    "a1",
    "a3",
    "stack",
    "pop",
    "item",
    "stack",
    "get",
    "three",
    "last",
    "item",
    "put",
    "stack",
    "peak",
    "get",
    "one",
    "item",
    "actually",
    "left",
    "stack",
    "peeking",
    "going",
    "give",
    "us",
    "top",
    "item",
    "stack",
    "pop",
    "another",
    "item",
    "get",
    "one",
    "stack",
    "empty",
    "try",
    "pop",
    "another",
    "item",
    "get",
    "none",
    "basically",
    "key",
    "features",
    "staff",
    "working",
    "fine",
    "use",
    "wrapper",
    "class",
    "implement",
    "stack",
    "python",
    "underlying",
    "data",
    "structure",
    "python",
    "list",
    "python",
    "list",
    "versatile",
    "data",
    "structure",
    "used",
    "create",
    "stack",
    "let",
    "take",
    "look",
    "queues",
    "queue",
    "fifo",
    "first",
    "first",
    "data",
    "structure",
    "really",
    "intuitive",
    "see",
    "queues",
    "every",
    "walk",
    "life",
    "almost",
    "everything",
    "daily",
    "basis",
    "encounter",
    "queues",
    "queues",
    "two",
    "key",
    "functions",
    "queue",
    "item",
    "adding",
    "end",
    "line",
    "udq",
    "item",
    "means",
    "removing",
    "front",
    "line",
    "use",
    "cases",
    "queues",
    "everything",
    "wait",
    "line",
    "bank",
    "tellers",
    "placing",
    "order",
    "mcdonald",
    "favorite",
    "restaurant",
    "dmv",
    "customer",
    "service",
    "supermarket",
    "checkout",
    "pretty",
    "much",
    "anything",
    "line",
    "queue",
    "important",
    "able",
    "model",
    "computer",
    "program",
    "queue",
    "data",
    "structure",
    "allows",
    "us",
    "let",
    "take",
    "look",
    "implement",
    "queue",
    "python",
    "actually",
    "pretty",
    "simple",
    "python",
    "already",
    "provides",
    "us",
    "library",
    "called",
    "deck",
    "de",
    "quue",
    "queue",
    "allows",
    "add",
    "remove",
    "items",
    "ends",
    "queue",
    "simple",
    "queue",
    "really",
    "need",
    "function",
    "want",
    "able",
    "add",
    "items",
    "one",
    "end",
    "queue",
    "pop",
    "use",
    "append",
    "function",
    "add",
    "items",
    "push",
    "items",
    "queue",
    "use",
    "pop",
    "left",
    "remove",
    "items",
    "pop",
    "items",
    "cube",
    "see",
    "full",
    "documentation",
    "python",
    "want",
    "learn",
    "double",
    "queues",
    "work",
    "basically",
    "using",
    "double",
    "ended",
    "queue",
    "python",
    "single",
    "ended",
    "queue",
    "use",
    "collections",
    "import",
    "deck",
    "going",
    "import",
    "double",
    "ended",
    "queue",
    "library",
    "create",
    "new",
    "queue",
    "queue",
    "going",
    "double",
    "ended",
    "queue",
    "object",
    "append",
    "items",
    "push",
    "items",
    "using",
    "append",
    "function",
    "push",
    "5",
    "push",
    "tin",
    "queue",
    "print",
    "queue",
    "see",
    "double",
    "ended",
    "queue",
    "5",
    "10",
    "want",
    "pop",
    "items",
    "queue",
    "use",
    "pop",
    "left",
    "get",
    "5",
    "pops",
    "item",
    "tail",
    "end",
    "queue",
    "left",
    "end",
    "queue",
    "pretty",
    "easy",
    "implement",
    "queue",
    "python",
    "obviously",
    "common",
    "enough",
    "data",
    "structure",
    "python",
    "built",
    "library",
    "fun",
    "exercise",
    "may",
    "try",
    "writing",
    "wrapper",
    "class",
    "queue",
    "make",
    "queue",
    "using",
    "push",
    "pop",
    "similar",
    "stack",
    "lecture",
    "going",
    "learn",
    "use",
    "max",
    "heaps",
    "implementation",
    "wise",
    "underlying",
    "data",
    "structure",
    "going",
    "list",
    "functions",
    "max",
    "heap",
    "whole",
    "lot",
    "different",
    "stack",
    "queue",
    "think",
    "going",
    "able",
    "pick",
    "fairly",
    "easily",
    "look",
    "graphical",
    "representation",
    "max",
    "heap",
    "though",
    "looks",
    "lot",
    "like",
    "tree",
    "know",
    "covered",
    "trees",
    "yet",
    "going",
    "covered",
    "section",
    "5",
    "bear",
    "think",
    "going",
    "figure",
    "pretty",
    "easily",
    "one",
    "condition",
    "max",
    "heap",
    "every",
    "node",
    "less",
    "equal",
    "parent",
    "key",
    "see",
    "25",
    "parent",
    "16",
    "24",
    "right",
    "25",
    "left",
    "child",
    "right",
    "child",
    "greater",
    "equal",
    "16",
    "greater",
    "equal",
    "left",
    "right",
    "children",
    "every",
    "node",
    "tree",
    "less",
    "equal",
    "parent",
    "every",
    "parent",
    "node",
    "greater",
    "equal",
    "nodes",
    "core",
    "condition",
    "reason",
    "like",
    "instantly",
    "remove",
    "max",
    "number",
    "anytime",
    "want",
    "anytime",
    "want",
    "pop",
    "top",
    "number",
    "heap",
    "know",
    "highest",
    "number",
    "heap",
    "highest",
    "number",
    "always",
    "rises",
    "top",
    "heap",
    "instantly",
    "removed",
    "used",
    "max",
    "heaps",
    "fast",
    "familiar",
    "big",
    "notation",
    "insert",
    "add",
    "item",
    "max",
    "heap",
    "big",
    "log",
    "n",
    "time",
    "extremely",
    "fast",
    "get",
    "item",
    "get",
    "max",
    "item",
    "top",
    "heap",
    "big",
    "one",
    "time",
    "pretty",
    "much",
    "instantaneous",
    "remove",
    "max",
    "pop",
    "big",
    "log",
    "time",
    "response",
    "time",
    "max",
    "heap",
    "extremely",
    "fast",
    "use",
    "max",
    "heaps",
    "things",
    "need",
    "pop",
    "maximum",
    "number",
    "heap",
    "get",
    "quickly",
    "max",
    "heaps",
    "easy",
    "implement",
    "python",
    "using",
    "list",
    "easy",
    "two",
    "data",
    "structures",
    "covered",
    "hard",
    "think",
    "able",
    "follow",
    "warn",
    "code",
    "little",
    "bit",
    "longer",
    "hairier",
    "previous",
    "two",
    "examples",
    "covered",
    "already",
    "written",
    "code",
    "follow",
    "along",
    "explanation",
    "see",
    "using",
    "list",
    "open",
    "index",
    "correspond",
    "list",
    "index",
    "corresponds",
    "node",
    "starting",
    "one",
    "top",
    "across",
    "4",
    "5",
    "6",
    "7",
    "across",
    "next",
    "tier",
    "next",
    "tier",
    "8",
    "9",
    "10",
    "pretty",
    "easy",
    "indexing",
    "system",
    "corresponds",
    "nodes",
    "tree",
    "music",
    "look",
    "list",
    "put",
    "items",
    "list",
    "well",
    "look",
    "25",
    "index",
    "1",
    "16",
    "24",
    "look",
    "know",
    "16",
    "greater",
    "24",
    "looks",
    "like",
    "wow",
    "lower",
    "note",
    "3",
    "index",
    "3",
    "well",
    "rule",
    "16",
    "greater",
    "everything",
    "tree",
    "condition",
    "met",
    "16",
    "greater",
    "24",
    "say",
    "greater",
    "everything",
    "behind",
    "list",
    "tree",
    "valid",
    "okay",
    "implemented",
    "list",
    "using",
    "list",
    "indices",
    "instantly",
    "access",
    "node",
    "tree",
    "node",
    "max",
    "heap",
    "let",
    "say",
    "wanted",
    "access",
    "5",
    "know",
    "index",
    "4",
    "index",
    "number",
    "4",
    "5",
    "node",
    "also",
    "access",
    "5s",
    "parent",
    "16",
    "simply",
    "divide",
    "index",
    "2",
    "4",
    "divided",
    "2",
    "gives",
    "us",
    "index",
    "5s",
    "parent",
    "node",
    "16",
    "want",
    "access",
    "5",
    "children",
    "thing",
    "5s",
    "left",
    "child",
    "times",
    "2",
    "get",
    "index",
    "5",
    "left",
    "child",
    "8",
    "times",
    "2",
    "plus",
    "1",
    "gives",
    "us",
    "index",
    "5s",
    "right",
    "child",
    "8",
    "9",
    "taking",
    "take",
    "given",
    "node",
    "index",
    "4",
    "access",
    "right",
    "left",
    "child",
    "x",
    "2",
    "x",
    "2",
    "plus",
    "1",
    "access",
    "force",
    "parent",
    "divided",
    "2",
    "pretty",
    "quick",
    "easy",
    "operations",
    "access",
    "parent",
    "children",
    "node",
    "tree",
    "max",
    "heap",
    "operations",
    "like",
    "said",
    "exactly",
    "operations",
    "covered",
    "stacks",
    "queues",
    "want",
    "able",
    "insert",
    "push",
    "item",
    "onto",
    "heap",
    "want",
    "able",
    "peek",
    "find",
    "item",
    "heap",
    "without",
    "popping",
    "want",
    "able",
    "remove",
    "item",
    "heap",
    "return",
    "pop",
    "operation",
    "three",
    "operations",
    "heaps",
    "previous",
    "two",
    "data",
    "structures",
    "let",
    "look",
    "work",
    "push",
    "add",
    "value",
    "end",
    "array",
    "float",
    "proper",
    "position",
    "let",
    "look",
    "example",
    "want",
    "push",
    "12",
    "onto",
    "heap",
    "going",
    "put",
    "last",
    "spot",
    "array",
    "right",
    "spot",
    "words",
    "gon",
    "na",
    "11",
    "right",
    "child",
    "last",
    "index",
    "array",
    "need",
    "float",
    "proper",
    "position",
    "well",
    "need",
    "compare",
    "12",
    "11",
    "12",
    "greater",
    "two",
    "swap",
    "places",
    "yeah",
    "greater",
    "want",
    "12",
    "11",
    "swap",
    "places",
    "need",
    "compare",
    "12",
    "new",
    "parent",
    "16",
    "12",
    "greater",
    "16",
    "swapping",
    "12",
    "already",
    "floated",
    "proper",
    "position",
    "heap",
    "one",
    "key",
    "functions",
    "code",
    "called",
    "float",
    "bubble",
    "add",
    "item",
    "bottom",
    "tree",
    "need",
    "able",
    "bubble",
    "correct",
    "position",
    "heap",
    "comparing",
    "parent",
    "nodes",
    "swapping",
    "use",
    "every",
    "time",
    "push",
    "operation",
    "peek",
    "returns",
    "value",
    "top",
    "heap",
    "okay",
    "going",
    "heap",
    "number",
    "one",
    "index",
    "number",
    "one",
    "pretty",
    "straightforward",
    "really",
    "need",
    "pop",
    "anything",
    "get",
    "item",
    "return",
    "pop",
    "first",
    "going",
    "move",
    "topmost",
    "item",
    "want",
    "pop",
    "max",
    "know",
    "index",
    "position",
    "one",
    "first",
    "going",
    "swap",
    "item",
    "last",
    "position",
    "going",
    "delete",
    "heap",
    "going",
    "bubble",
    "item",
    "proper",
    "position",
    "let",
    "take",
    "look",
    "example",
    "11",
    "last",
    "position",
    "25",
    "item",
    "want",
    "pop",
    "going",
    "swap",
    "two",
    "25",
    "11",
    "swap",
    "places",
    "remove",
    "25",
    "heap",
    "without",
    "affecting",
    "rest",
    "heap",
    "last",
    "place",
    "affect",
    "anything",
    "else",
    "heap",
    "next",
    "step",
    "bubble",
    "11",
    "correct",
    "position",
    "compare",
    "11",
    "24",
    "11",
    "less",
    "24",
    "needs",
    "move",
    "next",
    "going",
    "compare",
    "11",
    "19",
    "11",
    "less",
    "19",
    "gon",
    "na",
    "swap",
    "places",
    "comparisons",
    "child",
    "nodes",
    "move",
    "11",
    "either",
    "room",
    "go",
    "greater",
    "children",
    "nodes",
    "operation",
    "pop",
    "return",
    "25",
    "pulled",
    "three",
    "key",
    "operations",
    "basically",
    "work",
    "nutshell",
    "let",
    "take",
    "look",
    "code",
    "underlying",
    "data",
    "structure",
    "using",
    "list",
    "gon",
    "na",
    "see",
    "us",
    "using",
    "list",
    "indices",
    "throughout",
    "program",
    "public",
    "functions",
    "push",
    "peek",
    "pop",
    "pretty",
    "familiar",
    "point",
    "also",
    "supporting",
    "private",
    "functions",
    "need",
    "heap",
    "basically",
    "swap",
    "float",
    "bubble",
    "use",
    "internal",
    "utility",
    "functions",
    "part",
    "user",
    "interface",
    "string",
    "function",
    "print",
    "heap",
    "constructor",
    "create",
    "new",
    "heap",
    "option",
    "passing",
    "list",
    "items",
    "want",
    "add",
    "heap",
    "pass",
    "list",
    "items",
    "get",
    "back",
    "empty",
    "heap",
    "0",
    "put",
    "0",
    "first",
    "element",
    "use",
    "start",
    "elements",
    "index",
    "number",
    "1",
    "max",
    "heap",
    "pass",
    "list",
    "items",
    "basically",
    "going",
    "iterate",
    "add",
    "one",
    "time",
    "end",
    "list",
    "float",
    "proper",
    "position",
    "push",
    "operation",
    "essentially",
    "pushing",
    "one",
    "time",
    "look",
    "push",
    "method",
    "exactly",
    "thing",
    "appends",
    "data",
    "passed",
    "end",
    "heap",
    "floats",
    "proper",
    "position",
    "heap",
    "push",
    "operation",
    "almost",
    "identical",
    "constructor",
    "pass",
    "items",
    "peak",
    "operation",
    "much",
    "returns",
    "top",
    "item",
    "heap",
    "take",
    "pop",
    "operation",
    "going",
    "peak",
    "let",
    "look",
    "pop",
    "operation",
    "different",
    "cases",
    "depending",
    "many",
    "items",
    "list",
    "list",
    "exactly",
    "two",
    "items",
    "one",
    "zero",
    "counting",
    "using",
    "part",
    "max",
    "heap",
    "exactly",
    "two",
    "items",
    "means",
    "really",
    "one",
    "item",
    "max",
    "heap",
    "pop",
    "number",
    "one",
    "item",
    "index",
    "number",
    "one",
    "return",
    "set",
    "past",
    "variable",
    "max",
    "end",
    "return",
    "max",
    "two",
    "items",
    "going",
    "swap",
    "maximum",
    "item",
    "position",
    "index",
    "1",
    "last",
    "item",
    "get",
    "last",
    "item",
    "list",
    "swap",
    "two",
    "pop",
    "last",
    "item",
    "assign",
    "variable",
    "max",
    "bubble",
    "first",
    "item",
    "moved",
    "top",
    "position",
    "exactly",
    "walked",
    "slides",
    "end",
    "return",
    "max",
    "pop",
    "operation",
    "works",
    "utility",
    "functions",
    "swap",
    "really",
    "swaps",
    "two",
    "different",
    "items",
    "pass",
    "two",
    "indices",
    "swap",
    "two",
    "items",
    "list",
    "float",
    "function",
    "going",
    "receive",
    "index",
    "item",
    "want",
    "float",
    "probably",
    "bottom",
    "item",
    "list",
    "initially",
    "first",
    "get",
    "index",
    "parent",
    "already",
    "top",
    "position",
    "floating",
    "already",
    "risen",
    "top",
    "otherwise",
    "going",
    "compare",
    "parent",
    "greater",
    "parent",
    "two",
    "need",
    "swap",
    "places",
    "swap",
    "positions",
    "item",
    "index",
    "passed",
    "parent",
    "call",
    "float",
    "function",
    "forcibly",
    "parent",
    "continue",
    "float",
    "function",
    "element",
    "reaches",
    "proper",
    "position",
    "bubble",
    "kind",
    "opposite",
    "takes",
    "element",
    "top",
    "list",
    "bubbles",
    "proper",
    "position",
    "pass",
    "index",
    "get",
    "left",
    "child",
    "right",
    "child",
    "multiplying",
    "index",
    "2",
    "times",
    "2",
    "plus",
    "1",
    "set",
    "largest",
    "equal",
    "index",
    "little",
    "comparison",
    "item",
    "bubbling",
    "less",
    "left",
    "child",
    "going",
    "swap",
    "positions",
    "left",
    "one",
    "item",
    "bubbling",
    "less",
    "right",
    "child",
    "going",
    "swap",
    "positions",
    "right",
    "child",
    "swapping",
    "done",
    "end",
    "check",
    "need",
    "swap",
    "call",
    "swap",
    "function",
    "item",
    "bubbling",
    "target",
    "item",
    "larger",
    "two",
    "recursively",
    "call",
    "bubble",
    "function",
    "item",
    "bubbled",
    "reaches",
    "proper",
    "position",
    "test",
    "code",
    "whole",
    "lot",
    "test",
    "code",
    "create",
    "new",
    "three",
    "items",
    "obviously",
    "95",
    "highest",
    "one",
    "2221",
    "second",
    "highest",
    "push",
    "10",
    "see",
    "list",
    "ignore",
    "zero",
    "really",
    "four",
    "items",
    "pop",
    "one",
    "get",
    "course",
    "95",
    "peek",
    "next",
    "item",
    "none",
    "95",
    "gone",
    "see",
    "21",
    "next",
    "item",
    "max",
    "heap",
    "works",
    "implement",
    "python",
    "simply",
    "changing",
    "greater",
    "less",
    "signs",
    "could",
    "change",
    "min",
    "heap",
    "let",
    "say",
    "collection",
    "items",
    "want",
    "store",
    "want",
    "able",
    "iterate",
    "would",
    "able",
    "find",
    "item",
    "list",
    "would",
    "able",
    "insert",
    "item",
    "need",
    "fast",
    "searching",
    "speed",
    "especially",
    "front",
    "list",
    "want",
    "insert",
    "new",
    "items",
    "front",
    "need",
    "able",
    "remove",
    "items",
    "list",
    "also",
    "may",
    "want",
    "iterate",
    "forward",
    "backward",
    "list",
    "possibly",
    "even",
    "continuous",
    "circle",
    "list",
    "one",
    "possible",
    "storage",
    "solution",
    "requirements",
    "linked",
    "list",
    "going",
    "learn",
    "use",
    "linked",
    "lists",
    "going",
    "learn",
    "different",
    "types",
    "linked",
    "lists",
    "standard",
    "linked",
    "list",
    "doubly",
    "linked",
    "list",
    "also",
    "circular",
    "linked",
    "list",
    "learn",
    "work",
    "major",
    "operations",
    "used",
    "linked",
    "lists",
    "also",
    "going",
    "go",
    "course",
    "code",
    "linked",
    "list",
    "python",
    "let",
    "take",
    "look",
    "linked",
    "lists",
    "work",
    "every",
    "linked",
    "list",
    "going",
    "composed",
    "call",
    "nodes",
    "call",
    "whatever",
    "want",
    "video",
    "going",
    "call",
    "item",
    "linked",
    "list",
    "node",
    "could",
    "store",
    "whatever",
    "data",
    "want",
    "linked",
    "list",
    "could",
    "student",
    "node",
    "could",
    "employee",
    "node",
    "whatever",
    "matter",
    "gon",
    "na",
    "call",
    "node",
    "kind",
    "common",
    "nomenclature",
    "items",
    "linked",
    "list",
    "call",
    "nodes",
    "node",
    "connected",
    "next",
    "node",
    "pointer",
    "next",
    "node",
    "two",
    "things",
    "piece",
    "data",
    "us",
    "going",
    "integer",
    "video",
    "pointer",
    "next",
    "node",
    "two",
    "key",
    "components",
    "every",
    "node",
    "linked",
    "list",
    "linked",
    "list",
    "looks",
    "something",
    "like",
    "node",
    "piece",
    "data",
    "also",
    "pointer",
    "next",
    "node",
    "number",
    "nodes",
    "basically",
    "unlimited",
    "amount",
    "memory",
    "system",
    "last",
    "node",
    "see",
    "next",
    "pointer",
    "going",
    "store",
    "like",
    "nun",
    "indicate",
    "next",
    "node",
    "last",
    "node",
    "list",
    "front",
    "call",
    "root",
    "node",
    "first",
    "node",
    "list",
    "need",
    "pointer",
    "point",
    "starting",
    "point",
    "list",
    "call",
    "root",
    "pointer",
    "root",
    "operations",
    "need",
    "linked",
    "list",
    "need",
    "able",
    "find",
    "data",
    "need",
    "able",
    "add",
    "piece",
    "data",
    "need",
    "able",
    "remove",
    "piece",
    "data",
    "linked",
    "list",
    "need",
    "able",
    "print",
    "list",
    "gon",
    "na",
    "see",
    "operations",
    "works",
    "gon",
    "na",
    "see",
    "held",
    "code",
    "python",
    "attributes",
    "linked",
    "list",
    "pointer",
    "root",
    "node",
    "also",
    "going",
    "track",
    "size",
    "linked",
    "list",
    "given",
    "time",
    "could",
    "find",
    "many",
    "nodes",
    "list",
    "let",
    "look",
    "add",
    "operation",
    "linked",
    "list",
    "pointer",
    "root",
    "want",
    "add",
    "tend",
    "command",
    "let",
    "add",
    "10",
    "first",
    "gon",
    "na",
    "create",
    "new",
    "node",
    "data",
    "10",
    "anything",
    "next",
    "pointer",
    "yet",
    "gon",
    "na",
    "going",
    "point",
    "next",
    "pointer",
    "root",
    "currently",
    "pointing",
    "root",
    "currently",
    "points",
    "five",
    "node",
    "going",
    "put",
    "next",
    "pointer",
    "new",
    "node",
    "pointing",
    "root",
    "node",
    "change",
    "route",
    "ten",
    "effectively",
    "inserted",
    "new",
    "10",
    "node",
    "beginning",
    "linked",
    "list",
    "going",
    "insert",
    "operation",
    "next",
    "want",
    "try",
    "remove",
    "number",
    "let",
    "try",
    "remove",
    "five",
    "obviously",
    "try",
    "remove",
    "number",
    "like",
    "200",
    "linked",
    "list",
    "get",
    "back",
    "false",
    "nun",
    "sorry",
    "dude",
    "error",
    "something",
    "number",
    "list",
    "want",
    "try",
    "remove",
    "going",
    "remove",
    "five",
    "first",
    "need",
    "find",
    "five",
    "start",
    "root",
    "check",
    "number",
    "oh",
    "number",
    "yes",
    "geez",
    "node",
    "want",
    "remove",
    "pretty",
    "easy",
    "remove",
    "take",
    "previous",
    "node",
    "five",
    "change",
    "previous",
    "nodes",
    "next",
    "pointer",
    "5",
    "next",
    "pointer",
    "words",
    "see",
    "five",
    "next",
    "node",
    "17",
    "changed",
    "five",
    "previous",
    "node",
    "case",
    "root",
    "ten",
    "change",
    "next",
    "pointer",
    "five",
    "next",
    "pointer",
    "goes",
    "effectively",
    "five",
    "node",
    "completely",
    "cut",
    "linked",
    "list",
    "iterate",
    "linked",
    "list",
    "starting",
    "root",
    "going",
    "follow",
    "path",
    "never",
    "even",
    "going",
    "know",
    "five",
    "five",
    "note",
    "still",
    "exists",
    "access",
    "anymore",
    "effectively",
    "deleted",
    "list",
    "remove",
    "operation",
    "let",
    "take",
    "look",
    "code",
    "linked",
    "list",
    "python",
    "going",
    "start",
    "node",
    "class",
    "going",
    "use",
    "node",
    "class",
    "three",
    "different",
    "types",
    "linked",
    "lists",
    "cover",
    "section",
    "w",
    "linked",
    "lists",
    "circular",
    "linked",
    "lists",
    "going",
    "use",
    "node",
    "class",
    "see",
    "node",
    "class",
    "three",
    "attributes",
    "piece",
    "data",
    "next",
    "node",
    "previous",
    "node",
    "standard",
    "linked",
    "list",
    "need",
    "previous",
    "node",
    "going",
    "use",
    "attribute",
    "standard",
    "linked",
    "list",
    "us",
    "reuse",
    "node",
    "class",
    "two",
    "linked",
    "lists",
    "also",
    "string",
    "representation",
    "gives",
    "us",
    "back",
    "essentially",
    "data",
    "parentheses",
    "string",
    "representation",
    "node",
    "linked",
    "list",
    "four",
    "methods",
    "add",
    "find",
    "remove",
    "print",
    "list",
    "let",
    "see",
    "work",
    "first",
    "constructor",
    "two",
    "attributes",
    "keep",
    "track",
    "root",
    "node",
    "also",
    "keep",
    "track",
    "size",
    "time",
    "add",
    "remove",
    "node",
    "going",
    "increment",
    "decrement",
    "size",
    "accordingly",
    "add",
    "new",
    "node",
    "pass",
    "data",
    "want",
    "create",
    "new",
    "node",
    "create",
    "new",
    "node",
    "passing",
    "data",
    "next",
    "note",
    "root",
    "node",
    "keep",
    "mind",
    "inserting",
    "node",
    "beginning",
    "list",
    "current",
    "root",
    "node",
    "going",
    "second",
    "node",
    "pass",
    "next",
    "node",
    "new",
    "node",
    "change",
    "root",
    "node",
    "new",
    "node",
    "increment",
    "size",
    "one",
    "done",
    "add",
    "operation",
    "find",
    "piece",
    "data",
    "passing",
    "piece",
    "data",
    "going",
    "iterate",
    "list",
    "one",
    "note",
    "time",
    "going",
    "start",
    "root",
    "node",
    "call",
    "node",
    "long",
    "node",
    "none",
    "long",
    "valid",
    "node",
    "going",
    "continue",
    "iterate",
    "list",
    "time",
    "loop",
    "else",
    "statement",
    "going",
    "bump",
    "us",
    "forward",
    "next",
    "node",
    "found",
    "looking",
    "yet",
    "looking",
    "nodes",
    "data",
    "equal",
    "find",
    "return",
    "get",
    "way",
    "loop",
    "found",
    "return",
    "none",
    "data",
    "list",
    "remove",
    "function",
    "pass",
    "piece",
    "data",
    "need",
    "pointers",
    "node",
    "notes",
    "previous",
    "node",
    "going",
    "start",
    "iterating",
    "lists",
    "defined",
    "operation",
    "root",
    "call",
    "node",
    "going",
    "keep",
    "track",
    "previous",
    "node",
    "need",
    "able",
    "remove",
    "node",
    "find",
    "one",
    "want",
    "remove",
    "time",
    "loop",
    "two",
    "pointers",
    "increment",
    "increment",
    "previous",
    "node",
    "node",
    "increment",
    "node",
    "node",
    "next",
    "node",
    "found",
    "looking",
    "yet",
    "end",
    "loop",
    "bump",
    "forward",
    "two",
    "pointers",
    "iterate",
    "list",
    "check",
    "check",
    "nodes",
    "data",
    "equal",
    "past",
    "end",
    "looking",
    "find",
    "found",
    "data",
    "two",
    "possibilities",
    "removing",
    "node",
    "one",
    "node",
    "root",
    "else",
    "case",
    "changed",
    "pointer",
    "root",
    "node",
    "linked",
    "list",
    "nodes",
    "next",
    "node",
    "words",
    "second",
    "node",
    "list",
    "bypass",
    "current",
    "root",
    "point",
    "root",
    "pointer",
    "second",
    "node",
    "list",
    "effectively",
    "deletes",
    "first",
    "node",
    "list",
    "root",
    "words",
    "node",
    "list",
    "need",
    "delete",
    "changing",
    "previous",
    "nodes",
    "next",
    "node",
    "pointer",
    "nodes",
    "next",
    "node",
    "remove",
    "operation",
    "get",
    "way",
    "found",
    "return",
    "false",
    "successfully",
    "remove",
    "return",
    "true",
    "print",
    "operation",
    "print",
    "list",
    "going",
    "iterate",
    "list",
    "one",
    "note",
    "time",
    "starting",
    "root",
    "loop",
    "going",
    "check",
    "reach",
    "end",
    "list",
    "going",
    "exit",
    "print",
    "none",
    "node",
    "going",
    "print",
    "string",
    "representation",
    "node",
    "followed",
    "little",
    "arrow",
    "see",
    "looks",
    "like",
    "run",
    "test",
    "code",
    "second",
    "test",
    "code",
    "test",
    "variety",
    "different",
    "operations",
    "yeah",
    "list",
    "printed",
    "looks",
    "like",
    "string",
    "representation",
    "node",
    "value",
    "parenthesis",
    "put",
    "arrow",
    "print",
    "function",
    "create",
    "new",
    "list",
    "called",
    "list",
    "add",
    "items",
    "print",
    "list",
    "see",
    "get",
    "print",
    "size",
    "list",
    "see",
    "size",
    "equal",
    "3",
    "remove",
    "one",
    "item",
    "8",
    "see",
    "size",
    "equal",
    "2",
    "also",
    "find",
    "5",
    "find",
    "5",
    "actually",
    "returns",
    "5",
    "print",
    "also",
    "print",
    "root",
    "12",
    "last",
    "item",
    "added",
    "front",
    "list",
    "linked",
    "list",
    "works",
    "circular",
    "linked",
    "list",
    "almost",
    "identical",
    "standard",
    "linked",
    "list",
    "except",
    "end",
    "node",
    "instead",
    "none",
    "pointer",
    "next",
    "node",
    "going",
    "loop",
    "back",
    "beginning",
    "root",
    "node",
    "add",
    "operation",
    "circular",
    "linked",
    "lists",
    "works",
    "slightly",
    "differently",
    "loop",
    "back",
    "first",
    "node",
    "end",
    "node",
    "rather",
    "go",
    "back",
    "update",
    "every",
    "time",
    "insert",
    "new",
    "node",
    "insert",
    "new",
    "node",
    "root",
    "node",
    "anymore",
    "instead",
    "going",
    "insert",
    "second",
    "node",
    "leave",
    "root",
    "pointer",
    "last",
    "pointer",
    "loop",
    "back",
    "root",
    "instead",
    "insert",
    "new",
    "node",
    "roots",
    "next",
    "node",
    "next",
    "node",
    "new",
    "node",
    "going",
    "previously",
    "second",
    "node",
    "add",
    "operation",
    "circular",
    "linked",
    "list",
    "basically",
    "yeah",
    "difference",
    "circular",
    "linked",
    "list",
    "advantages",
    "circular",
    "link",
    "list",
    "well",
    "great",
    "modeling",
    "continuously",
    "looping",
    "data",
    "objects",
    "something",
    "like",
    "monopoly",
    "board",
    "board",
    "racetrack",
    "something",
    "continuously",
    "loops",
    "lot",
    "different",
    "looping",
    "objects",
    "real",
    "world",
    "want",
    "model",
    "continuously",
    "looping",
    "set",
    "objects",
    "computer",
    "program",
    "circular",
    "linked",
    "list",
    "one",
    "way",
    "circular",
    "link",
    "list",
    "similar",
    "linked",
    "list",
    "modifications",
    "add",
    "method",
    "check",
    "whether",
    "list",
    "empty",
    "add",
    "first",
    "node",
    "make",
    "next",
    "node",
    "point",
    "sounds",
    "crazy",
    "need",
    "loop",
    "back",
    "something",
    "loop",
    "back",
    "first",
    "node",
    "root",
    "node",
    "else",
    "already",
    "least",
    "one",
    "node",
    "list",
    "create",
    "new",
    "node",
    "insert",
    "number",
    "two",
    "position",
    "right",
    "root",
    "change",
    "roots",
    "next",
    "node",
    "point",
    "new",
    "node",
    "add",
    "operation",
    "works",
    "see",
    "code",
    "lines",
    "code",
    "fine",
    "method",
    "works",
    "exactly",
    "regular",
    "linked",
    "list",
    "except",
    "elif",
    "statement",
    "check",
    "circled",
    "way",
    "back",
    "root",
    "node",
    "stop",
    "find",
    "return",
    "false",
    "find",
    "search",
    "entire",
    "list",
    "find",
    "value",
    "looking",
    "turn",
    "false",
    "remove",
    "method",
    "let",
    "scroll",
    "remove",
    "method",
    "need",
    "track",
    "node",
    "previous",
    "node",
    "going",
    "set",
    "pointers",
    "start",
    "start",
    "root",
    "node",
    "set",
    "previous",
    "node",
    "none",
    "see",
    "towards",
    "end",
    "loop",
    "advance",
    "pointers",
    "one",
    "node",
    "move",
    "move",
    "forward",
    "next",
    "node",
    "test",
    "found",
    "data",
    "first",
    "statement",
    "bingo",
    "found",
    "pass",
    "test",
    "two",
    "possibilities",
    "remove",
    "function",
    "number",
    "one",
    "previous",
    "node",
    "none",
    "tests",
    "whether",
    "data",
    "found",
    "root",
    "node",
    "remove",
    "easy",
    "bypass",
    "operation",
    "changing",
    "previous",
    "nodes",
    "next",
    "pointer",
    "taste",
    "number",
    "two",
    "else",
    "need",
    "delete",
    "root",
    "use",
    "loop",
    "find",
    "last",
    "node",
    "list",
    "update",
    "next",
    "node",
    "point",
    "new",
    "root",
    "root",
    "changed",
    "find",
    "find",
    "new",
    "find",
    "last",
    "node",
    "update",
    "last",
    "nodes",
    "new",
    "next",
    "pointer",
    "new",
    "root",
    "update",
    "root",
    "pointer",
    "lastly",
    "decrement",
    "size",
    "one",
    "return",
    "true",
    "successfully",
    "remove",
    "data",
    "print",
    "list",
    "method",
    "iterate",
    "list",
    "print",
    "node",
    "file",
    "bob",
    "followed",
    "arrow",
    "see",
    "loop",
    "check",
    "made",
    "back",
    "root",
    "know",
    "stop",
    "test",
    "node",
    "next",
    "node",
    "root",
    "continue",
    "iterate",
    "list",
    "let",
    "take",
    "look",
    "circular",
    "linked",
    "list",
    "test",
    "code",
    "create",
    "certain",
    "new",
    "circular",
    "linked",
    "list",
    "call",
    "cll",
    "going",
    "add",
    "bunch",
    "items",
    "using",
    "loop",
    "adding",
    "one",
    "item",
    "time",
    "print",
    "size",
    "list",
    "see",
    "result",
    "size",
    "five",
    "try",
    "find",
    "eighth",
    "value",
    "actually",
    "return",
    "eight",
    "try",
    "find",
    "item",
    "list",
    "going",
    "return",
    "false",
    "see",
    "try",
    "find",
    "12",
    "get",
    "back",
    "false",
    "instead",
    "using",
    "print",
    "list",
    "function",
    "going",
    "iterate",
    "continuously",
    "see",
    "pass",
    "gon",
    "na",
    "print",
    "eight",
    "items",
    "even",
    "though",
    "five",
    "list",
    "gon",
    "na",
    "see",
    "actually",
    "circle",
    "back",
    "next",
    "node",
    "going",
    "continuously",
    "get",
    "next",
    "node",
    "reach",
    "eight",
    "see",
    "five",
    "nine",
    "eight",
    "three",
    "seven",
    "starts",
    "beginning",
    "five",
    "nine",
    "eight",
    "three",
    "continue",
    "print",
    "eight",
    "items",
    "shows",
    "continuous",
    "loop",
    "continue",
    "loop",
    "want",
    "write",
    "little",
    "test",
    "code",
    "print",
    "list",
    "current",
    "contents",
    "list",
    "removing",
    "eight",
    "print",
    "remove",
    "fifteen",
    "result",
    "see",
    "false",
    "15",
    "list",
    "see",
    "print",
    "size",
    "list",
    "four",
    "items",
    "removed",
    "one",
    "try",
    "remove",
    "five",
    "node",
    "completes",
    "successfully",
    "print",
    "list",
    "three",
    "items",
    "left",
    "wraps",
    "lecture",
    "circular",
    "length",
    "list",
    "let",
    "look",
    "doubly",
    "linked",
    "lists",
    "also",
    "sometimes",
    "called",
    "linked",
    "lists",
    "arrows",
    "pointing",
    "directions",
    "next",
    "node",
    "previous",
    "node",
    "regular",
    "linked",
    "list",
    "looks",
    "like",
    "doubly",
    "linked",
    "list",
    "node",
    "three",
    "pieces",
    "data",
    "pointer",
    "previous",
    "node",
    "pointer",
    "next",
    "node",
    "data",
    "storing",
    "ask",
    "three",
    "things",
    "three",
    "components",
    "node",
    "doubly",
    "linked",
    "list",
    "doubly",
    "linked",
    "list",
    "would",
    "look",
    "like",
    "simple",
    "one",
    "three",
    "nodes",
    "four",
    "twenty",
    "three",
    "seven",
    "let",
    "say",
    "want",
    "delete",
    "item",
    "little",
    "complicated",
    "two",
    "pointers",
    "fix",
    "one",
    "found",
    "item",
    "want",
    "delete",
    "going",
    "call",
    "node",
    "previous",
    "node",
    "node",
    "four",
    "next",
    "note",
    "seven",
    "delete",
    "well",
    "look",
    "pointer",
    "previous",
    "node",
    "pointing",
    "node",
    "look",
    "pointer",
    "next",
    "node",
    "pointing",
    "previous",
    "node",
    "right",
    "ones",
    "pointing",
    "node",
    "fixed",
    "basically",
    "bypass",
    "change",
    "fours",
    "next",
    "pointer",
    "instead",
    "pointing",
    "point",
    "nodes",
    "next",
    "node",
    "sevens",
    "previous",
    "pointer",
    "instead",
    "pointing",
    "sevens",
    "previous",
    "node",
    "point",
    "nodes",
    "previous",
    "node",
    "basically",
    "two",
    "adjustments",
    "pre",
    "done",
    "next",
    "equals",
    "dot",
    "next",
    "next",
    "pre",
    "evils",
    "dot",
    "preview",
    "changes",
    "cut",
    "node",
    "list",
    "see",
    "get",
    "red",
    "arrows",
    "place",
    "fix",
    "two",
    "pointers",
    "effectively",
    "cut",
    "linked",
    "list",
    "deleted",
    "delete",
    "operation",
    "works",
    "doubly",
    "linked",
    "list",
    "advantages",
    "doubly",
    "linked",
    "list",
    "standard",
    "linked",
    "list",
    "iterate",
    "list",
    "either",
    "direction",
    "pretty",
    "obvious",
    "really",
    "large",
    "linked",
    "list",
    "want",
    "iterate",
    "items",
    "happen",
    "know",
    "item",
    "towards",
    "end",
    "list",
    "actually",
    "save",
    "quite",
    "lot",
    "time",
    "starting",
    "iteration",
    "tail",
    "end",
    "list",
    "working",
    "right",
    "back",
    "could",
    "save",
    "pointer",
    "end",
    "list",
    "well",
    "delete",
    "node",
    "without",
    "iterating",
    "entire",
    "list",
    "pointer",
    "node",
    "right",
    "know",
    "node",
    "want",
    "delete",
    "iterate",
    "whole",
    "list",
    "find",
    "node",
    "already",
    "stores",
    "previous",
    "next",
    "pointer",
    "get",
    "nodes",
    "either",
    "side",
    "node",
    "want",
    "delete",
    "without",
    "iterate",
    "entire",
    "list",
    "pointer",
    "node",
    "want",
    "delete",
    "doubly",
    "linked",
    "list",
    "uses",
    "extra",
    "node",
    "attribute",
    "called",
    "priva",
    "showed",
    "looked",
    "node",
    "class",
    "also",
    "extra",
    "list",
    "attribute",
    "called",
    "last",
    "see",
    "last",
    "always",
    "access",
    "tail",
    "end",
    "list",
    "last",
    "item",
    "list",
    "add",
    "method",
    "check",
    "list",
    "empty",
    "root",
    "node",
    "also",
    "last",
    "node",
    "otherwise",
    "adds",
    "new",
    "node",
    "beginning",
    "changes",
    "roots",
    "previa",
    "fails",
    "two",
    "different",
    "conditions",
    "add",
    "new",
    "node",
    "find",
    "method",
    "works",
    "exactly",
    "find",
    "method",
    "standard",
    "linked",
    "list",
    "really",
    "changes",
    "remove",
    "function",
    "little",
    "different",
    "three",
    "possible",
    "cases",
    "remove",
    "function",
    "let",
    "review",
    "one",
    "case",
    "number",
    "one",
    "trying",
    "delete",
    "middle",
    "node",
    "statement",
    "node",
    "either",
    "root",
    "last",
    "node",
    "standard",
    "case",
    "showed",
    "two",
    "slides",
    "simple",
    "bypass",
    "bypass",
    "target",
    "node",
    "changing",
    "previous",
    "nodes",
    "next",
    "pointer",
    "next",
    "nodes",
    "previous",
    "pointer",
    "exactly",
    "basically",
    "bypassed",
    "target",
    "node",
    "trying",
    "delete",
    "second",
    "case",
    "trying",
    "delete",
    "last",
    "node",
    "like",
    "case",
    "one",
    "except",
    "previous",
    "nodes",
    "next",
    "pointer",
    "changed",
    "none",
    "node",
    "last",
    "node",
    "difference",
    "changing",
    "basically",
    "nodes",
    "next",
    "pointer",
    "none",
    "third",
    "case",
    "trying",
    "delete",
    "root",
    "node",
    "similar",
    "case",
    "one",
    "except",
    "change",
    "root",
    "pointer",
    "point",
    "second",
    "node",
    "words",
    "change",
    "root",
    "point",
    "two",
    "roots",
    "next",
    "node",
    "three",
    "cases",
    "remove",
    "rest",
    "remove",
    "function",
    "really",
    "straightforward",
    "print",
    "list",
    "method",
    "pretty",
    "much",
    "changes",
    "let",
    "look",
    "test",
    "code",
    "doubly",
    "linked",
    "list",
    "create",
    "doubly",
    "linked",
    "list",
    "dll",
    "call",
    "add",
    "bunch",
    "items",
    "using",
    "loop",
    "add",
    "one",
    "items",
    "see",
    "print",
    "size",
    "5",
    "print",
    "entire",
    "list",
    "want",
    "using",
    "print",
    "list",
    "method",
    "remove",
    "8",
    "print",
    "size",
    "see",
    "sizes",
    "things",
    "work",
    "try",
    "remove",
    "items",
    "list",
    "l",
    "dot",
    "remove",
    "15",
    "work",
    "try",
    "find",
    "item",
    "list",
    "also",
    "get",
    "false",
    "back",
    "add",
    "numbers",
    "21",
    "22",
    "remove",
    "5",
    "print",
    "list",
    "see",
    "21",
    "22",
    "added",
    "front",
    "list",
    "5",
    "removed",
    "tail",
    "node",
    "last",
    "node",
    "list",
    "successfully",
    "removed",
    "fun",
    "see",
    "print",
    "last",
    "nodes",
    "previous",
    "node",
    "node",
    "right",
    "three",
    "nine",
    "three",
    "exactly",
    "access",
    "nodes",
    "tail",
    "end",
    "list",
    "also",
    "wraps",
    "section",
    "linked",
    "lists",
    "section",
    "covered",
    "standard",
    "linked",
    "list",
    "circular",
    "linked",
    "list",
    "doubly",
    "linked",
    "list",
    "linked",
    "list",
    "showed",
    "work",
    "implemented",
    "code",
    "encourage",
    "download",
    "code",
    "run",
    "try",
    "make",
    "edits",
    "change",
    "use",
    "tests",
    "see",
    "works",
    "using",
    "code",
    "gon",
    "na",
    "better",
    "understand",
    "code",
    "works",
    "linked",
    "lists",
    "work",
    "eventually",
    "write",
    "linked",
    "list",
    "code",
    "hopefully",
    "lecture",
    "going",
    "talk",
    "trees",
    "section",
    "one",
    "covered",
    "pythons",
    "data",
    "structures",
    "trees",
    "definitely",
    "next",
    "important",
    "section",
    "course",
    "trees",
    "critically",
    "important",
    "data",
    "structure",
    "programming",
    "languages",
    "let",
    "explain",
    "make",
    "point",
    "thinking",
    "number",
    "1",
    "8",
    "million",
    "guess",
    "number",
    "well",
    "guessed",
    "4",
    "million",
    "say",
    "wrong",
    "thinking",
    "gon",
    "na",
    "tell",
    "higher",
    "lower",
    "guess",
    "get",
    "number",
    "well",
    "might",
    "guess",
    "every",
    "number",
    "1",
    "8",
    "million",
    "figure",
    "number",
    "using",
    "list",
    "unsorted",
    "list",
    "data",
    "structure",
    "like",
    "would",
    "iterate",
    "entire",
    "list",
    "find",
    "number",
    "may",
    "8",
    "million",
    "comparisons",
    "locate",
    "number",
    "thinking",
    "issue",
    "lists",
    "lot",
    "data",
    "really",
    "slow",
    "find",
    "data",
    "tree",
    "little",
    "different",
    "guess",
    "4",
    "million",
    "say",
    "lower",
    "guessed",
    "2",
    "million",
    "say",
    "higher",
    "got",
    "3",
    "million",
    "lower",
    "ok",
    "wow",
    "3",
    "guesses",
    "shaved",
    "7",
    "million",
    "possibilities",
    "narrowed",
    "possibilities",
    "2",
    "3",
    "million",
    "1",
    "million",
    "possibilities",
    "left",
    "3",
    "guesses",
    "30",
    "guesses",
    "would",
    "able",
    "find",
    "piece",
    "data",
    "tree",
    "10",
    "million",
    "nodes",
    "fast",
    "binary",
    "search",
    "trees",
    "balanced",
    "binary",
    "search",
    "tree",
    "let",
    "locate",
    "data",
    "large",
    "tree",
    "little",
    "30",
    "comparisons",
    "let",
    "take",
    "look",
    "major",
    "operations",
    "trees",
    "work",
    "first",
    "let",
    "learn",
    "basic",
    "terminology",
    "trees",
    "node",
    "part",
    "tree",
    "called",
    "node",
    "connection",
    "nodes",
    "called",
    "edge",
    "top",
    "tree",
    "root",
    "node",
    "see",
    "trees",
    "actually",
    "upside",
    "compared",
    "trees",
    "like",
    "root",
    "system",
    "tree",
    "flipped",
    "upside",
    "tree",
    "like",
    "management",
    "hierarchy",
    "company",
    "something",
    "right",
    "one",
    "president",
    "multiple",
    "vice",
    "presidents",
    "trees",
    "great",
    "modeling",
    "organizations",
    "real",
    "benefit",
    "tree",
    "real",
    "benefit",
    "speed",
    "parent",
    "nodes",
    "child",
    "nodes",
    "binary",
    "tree",
    "parent",
    "two",
    "children",
    "one",
    "two",
    "children",
    "nodes",
    "parent",
    "called",
    "sibling",
    "nodes",
    "bottom",
    "nodes",
    "bottom",
    "tree",
    "children",
    "called",
    "leaf",
    "nodes",
    "trees",
    "binary",
    "trees",
    "binary",
    "tree",
    "node",
    "two",
    "child",
    "nodes",
    "left",
    "right",
    "child",
    "node",
    "trees",
    "may",
    "thousand",
    "child",
    "nodes",
    "node",
    "see",
    "five",
    "sub",
    "tree",
    "sub",
    "tree",
    "connects",
    "root",
    "node",
    "sub",
    "tree",
    "basically",
    "part",
    "tree",
    "tree",
    "sub",
    "tree",
    "five",
    "compared",
    "node",
    "4",
    "3",
    "5",
    "rows",
    "ancestors",
    "parent",
    "node",
    "every",
    "node",
    "parent",
    "tree",
    "descendants",
    "every",
    "node",
    "node",
    "tree",
    "node",
    "5",
    "descendant",
    "includes",
    "everything",
    "left",
    "subtree",
    "everything",
    "right",
    "binary",
    "search",
    "tree",
    "node",
    "greater",
    "every",
    "node",
    "left",
    "subtree",
    "see",
    "15",
    "greater",
    "every",
    "single",
    "node",
    "left",
    "subtree",
    "8",
    "greater",
    "every",
    "node",
    "left",
    "subtree",
    "5",
    "greater",
    "every",
    "node",
    "sub",
    "tree",
    "24",
    "look",
    "greater",
    "every",
    "node",
    "left",
    "subtree",
    "standard",
    "requirement",
    "binary",
    "search",
    "trees",
    "node",
    "greater",
    "every",
    "node",
    "left",
    "subtree",
    "also",
    "less",
    "node",
    "right",
    "subtree",
    "see",
    "nodes",
    "15",
    "right",
    "subtree",
    "greater",
    "15",
    "nodes",
    "24",
    "right",
    "subtree",
    "greater",
    "20",
    "nodes",
    "8",
    "right",
    "subtree",
    "greater",
    "8",
    "2",
    "standard",
    "requirements",
    "binary",
    "search",
    "tree",
    "standard",
    "operations",
    "l",
    "binary",
    "search",
    "trees",
    "going",
    "use",
    "insert",
    "going",
    "able",
    "add",
    "new",
    "data",
    "tree",
    "fine",
    "want",
    "able",
    "locate",
    "data",
    "tree",
    "delete",
    "remove",
    "node",
    "get",
    "size",
    "counts",
    "nodes",
    "tree",
    "tell",
    "us",
    "many",
    "pieces",
    "data",
    "tree",
    "traversals",
    "enable",
    "us",
    "walk",
    "tree",
    "node",
    "node",
    "show",
    "work",
    "first",
    "let",
    "look",
    "insert",
    "method",
    "going",
    "always",
    "start",
    "root",
    "insert",
    "top",
    "tree",
    "215",
    "always",
    "going",
    "insert",
    "new",
    "node",
    "leaf",
    "words",
    "bottom",
    "tree",
    "start",
    "top",
    "locate",
    "right",
    "position",
    "correct",
    "position",
    "tree",
    "insert",
    "new",
    "leaf",
    "let",
    "say",
    "want",
    "insert",
    "12",
    "tree",
    "going",
    "start",
    "comparisons",
    "starting",
    "root",
    "12",
    "less",
    "15",
    "yes",
    "going",
    "descend",
    "15",
    "left",
    "subtree",
    "next",
    "going",
    "compare",
    "12",
    "8",
    "12",
    "less",
    "8",
    "going",
    "descend",
    "8",
    "right",
    "subtree",
    "towards",
    "11",
    "12",
    "less",
    "11",
    "compare",
    "12",
    "13",
    "say",
    "well",
    "yeah",
    "12",
    "less",
    "13",
    "going",
    "add",
    "12",
    "leaf",
    "node",
    "add",
    "13s",
    "left",
    "child",
    "insert",
    "function",
    "works",
    "let",
    "look",
    "fine",
    "method",
    "fine",
    "always",
    "start",
    "root",
    "15",
    "going",
    "comparisons",
    "want",
    "find",
    "19",
    "tree",
    "going",
    "start",
    "comparing",
    "19",
    "15",
    "19",
    "less",
    "15",
    "greater",
    "descend",
    "right",
    "subtree",
    "compare",
    "19",
    "24",
    "19",
    "less",
    "24",
    "go",
    "24",
    "left",
    "subtree",
    "see",
    "comparison",
    "decision",
    "descend",
    "one",
    "subtree",
    "cuts",
    "half",
    "number",
    "remaining",
    "possibilities",
    "locate",
    "item",
    "already",
    "two",
    "comparisons",
    "found",
    "19",
    "tree",
    "find",
    "piece",
    "data",
    "define",
    "function",
    "always",
    "going",
    "return",
    "piece",
    "data",
    "find",
    "want",
    "return",
    "false",
    "let",
    "user",
    "know",
    "data",
    "existing",
    "tree",
    "delete",
    "three",
    "different",
    "possibilities",
    "one",
    "delete",
    "leaf",
    "node",
    "another",
    "possibility",
    "one",
    "child",
    "node",
    "another",
    "possibility",
    "two",
    "child",
    "nodes",
    "one",
    "handle",
    "differently",
    "delete",
    "fairly",
    "complicated",
    "operation",
    "let",
    "first",
    "look",
    "possibility",
    "number",
    "want",
    "delete",
    "leaf",
    "node",
    "look",
    "gray",
    "nodes",
    "leaf",
    "nodes",
    "case",
    "leaf",
    "node",
    "easy",
    "us",
    "delete",
    "leaf",
    "node",
    "without",
    "affecting",
    "anything",
    "else",
    "tree",
    "bottom",
    "nodes",
    "affect",
    "organization",
    "anything",
    "else",
    "tree",
    "delete",
    "node",
    "leaf",
    "easiest",
    "case",
    "right",
    "one",
    "child",
    "cases",
    "one",
    "child",
    "note",
    "11",
    "13",
    "28",
    "want",
    "delete",
    "one",
    "nodes",
    "promote",
    "child",
    "node",
    "targets",
    "notes",
    "position",
    "instance",
    "wanted",
    "delete",
    "28",
    "would",
    "promote",
    "25",
    "28",
    "position",
    "want",
    "delete",
    "11",
    "would",
    "promote",
    "13",
    "11th",
    "position",
    "12",
    "comes",
    "promoting",
    "entire",
    "subtree",
    "one",
    "child",
    "delete",
    "two",
    "children",
    "well",
    "gets",
    "little",
    "trickier",
    "let",
    "say",
    "going",
    "delete",
    "24",
    "could",
    "see",
    "24",
    "two",
    "children",
    "find",
    "next",
    "higher",
    "node",
    "order",
    "gon",
    "na",
    "descend",
    "24s",
    "right",
    "subtree",
    "way",
    "left",
    "get",
    "25",
    "much",
    "larger",
    "tree",
    "operation",
    "take",
    "right",
    "subtree",
    "left",
    "node",
    "right",
    "subtree",
    "25",
    "operation",
    "basically",
    "swap",
    "places",
    "24",
    "25",
    "delete",
    "24",
    "put",
    "25",
    "24",
    "delete",
    "24",
    "thing",
    "want",
    "delete",
    "4",
    "want",
    "delete",
    "4",
    "see",
    "4",
    "2",
    "children",
    "want",
    "find",
    "next",
    "higher",
    "node",
    "4",
    "find",
    "6",
    "descend",
    "right",
    "subtree",
    "left",
    "node",
    "6",
    "delete",
    "4",
    "promote",
    "6",
    "4th",
    "position",
    "7",
    "comes",
    "7",
    "part",
    "6",
    "subtree",
    "delete",
    "operation",
    "nutshell",
    "actually",
    "little",
    "complicated",
    "going",
    "code",
    "video",
    "however",
    "another",
    "video",
    "youtube",
    "code",
    "entire",
    "delete",
    "function",
    "get",
    "sighs",
    "sometimes",
    "may",
    "want",
    "find",
    "many",
    "nodes",
    "tree",
    "pretty",
    "easy",
    "operation",
    "get",
    "size",
    "function",
    "returns",
    "number",
    "nodes",
    "works",
    "using",
    "recursion",
    "actually",
    "functions",
    "trees",
    "recursive",
    "find",
    "delete",
    "insert",
    "recursively",
    "continue",
    "call",
    "function",
    "using",
    "parameter",
    "find",
    "correct",
    "position",
    "execute",
    "getsize",
    "works",
    "way",
    "size",
    "equal",
    "1",
    "plus",
    "size",
    "left",
    "subtree",
    "plus",
    "size",
    "right",
    "subtree",
    "words",
    "size",
    "tree",
    "equal",
    "well",
    "5",
    "note",
    "1",
    "plus",
    "left",
    "subtree",
    "subtree",
    "starting",
    "3",
    "right",
    "subtree",
    "subtree",
    "starting",
    "8",
    "say",
    "size",
    "tree",
    "1",
    "plus",
    "size",
    "two",
    "sub",
    "trees",
    "call",
    "thing",
    "get",
    "size",
    "function",
    "3",
    "left",
    "right",
    "subtrees",
    "size",
    "3",
    "sub",
    "tree",
    "1",
    "plus",
    "size",
    "3",
    "left",
    "plus",
    "size",
    "threes",
    "right",
    "subtrees",
    "call",
    "recursively",
    "get",
    "size",
    "function",
    "descend",
    "tree",
    "eventually",
    "get",
    "leaf",
    "nodes",
    "return",
    "1",
    "oh",
    "yeah",
    "leaf",
    "node",
    "size",
    "equals",
    "1",
    "ones",
    "get",
    "added",
    "back",
    "decent",
    "retreat",
    "back",
    "call",
    "stack",
    "almost",
    "talk",
    "traversals",
    "sometimes",
    "need",
    "traverse",
    "data",
    "tree",
    "multiple",
    "ways",
    "different",
    "traversal",
    "algorithms",
    "called",
    "traversal",
    "level",
    "traversal",
    "inorder",
    "traversal",
    "post",
    "order",
    "traversal",
    "video",
    "going",
    "cover",
    "traversal",
    "traversal",
    "visit",
    "route",
    "visit",
    "route",
    "sub",
    "trees",
    "words",
    "always",
    "going",
    "start",
    "root",
    "visit",
    "root",
    "sub",
    "tree",
    "thing",
    "node",
    "3",
    "basically",
    "sub",
    "tree",
    "starting",
    "node",
    "3",
    "going",
    "visit",
    "3",
    "visited",
    "sub",
    "trees",
    "start",
    "top",
    "descend",
    "left",
    "sub",
    "tree",
    "descend",
    "left",
    "sub",
    "tree",
    "hit",
    "right",
    "sub",
    "tree",
    "come",
    "back",
    "descend",
    "5",
    "right",
    "sub",
    "tree",
    "get",
    "left",
    "subtree",
    "right",
    "subtree",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "see",
    "order",
    "pre",
    "order",
    "traversal",
    "inorder",
    "traversal",
    "visits",
    "route",
    "visiting",
    "route",
    "subtrees",
    "means",
    "deliver",
    "values",
    "sorted",
    "order",
    "may",
    "want",
    "values",
    "sorted",
    "order",
    "case",
    "going",
    "start",
    "bottom",
    "left",
    "node",
    "work",
    "way",
    "1",
    "3",
    "4",
    "visit",
    "ones",
    "parent",
    "node",
    "right",
    "subtree",
    "visit",
    "threes",
    "parent",
    "node",
    "right",
    "subtree",
    "starting",
    "left",
    "node",
    "always",
    "words",
    "working",
    "way",
    "bottom",
    "working",
    "way",
    "right",
    "inorder",
    "traversal",
    "advantages",
    "binary",
    "search",
    "trees",
    "number",
    "1",
    "trees",
    "use",
    "recursion",
    "implement",
    "operations",
    "makes",
    "pretty",
    "easy",
    "implement",
    "code",
    "pretty",
    "easy",
    "write",
    "complicated",
    "well",
    "except",
    "delete",
    "lot",
    "different",
    "cases",
    "big",
    "huge",
    "advantage",
    "binary",
    "search",
    "trees",
    "speed",
    "really",
    "really",
    "fast",
    "locating",
    "data",
    "insert",
    "delete",
    "find",
    "data",
    "tree",
    "big",
    "h",
    "height",
    "tree",
    "depending",
    "many",
    "levels",
    "tree",
    "put",
    "another",
    "way",
    "log",
    "data",
    "log",
    "10",
    "million",
    "30",
    "words",
    "know",
    "big",
    "means",
    "order",
    "operations",
    "approximation",
    "many",
    "operations",
    "takes",
    "achieve",
    "something",
    "different",
    "operations",
    "log",
    "n",
    "amount",
    "data",
    "fast",
    "balanced",
    "binary",
    "search",
    "tree",
    "ten",
    "million",
    "nodes",
    "insert",
    "delete",
    "find",
    "functions",
    "little",
    "30",
    "comparisons",
    "incredible",
    "incredible",
    "trees",
    "extremely",
    "fast",
    "let",
    "take",
    "look",
    "implement",
    "trees",
    "let",
    "look",
    "implement",
    "tree",
    "python",
    "jupiter",
    "random",
    "going",
    "implement",
    "binary",
    "search",
    "tree",
    "functions",
    "constructor",
    "insert",
    "find",
    "get",
    "size",
    "method",
    "two",
    "different",
    "ways",
    "traverse",
    "tree",
    "inorder",
    "traversal",
    "walk",
    "works",
    "constructor",
    "three",
    "attributes",
    "piece",
    "data",
    "going",
    "pass",
    "required",
    "attribute",
    "optionally",
    "pass",
    "left",
    "subtree",
    "right",
    "subtree",
    "program",
    "really",
    "using",
    "left",
    "right",
    "subtrees",
    "constructor",
    "defaulting",
    "nine",
    "node",
    "subtree",
    "left",
    "right",
    "subtree",
    "insert",
    "function",
    "key",
    "defined",
    "correct",
    "location",
    "insert",
    "always",
    "going",
    "insert",
    "bottom",
    "tree",
    "new",
    "node",
    "first",
    "possibility",
    "node",
    "equal",
    "data",
    "trying",
    "add",
    "case",
    "going",
    "reject",
    "want",
    "duplicates",
    "tree",
    "case",
    "going",
    "return",
    "false",
    "got",
    "duplicate",
    "data",
    "passed",
    "less",
    "data",
    "current",
    "node",
    "going",
    "descend",
    "left",
    "subtree",
    "return",
    "self",
    "left",
    "subtree",
    "insert",
    "words",
    "calling",
    "recursively",
    "insert",
    "function",
    "descending",
    "left",
    "subtree",
    "still",
    "passing",
    "data",
    "along",
    "reason",
    "return",
    "want",
    "return",
    "either",
    "true",
    "false",
    "end",
    "day",
    "data",
    "successfully",
    "inserted",
    "reach",
    "bottom",
    "level",
    "tree",
    "found",
    "right",
    "position",
    "insert",
    "create",
    "new",
    "subtree",
    "piece",
    "data",
    "set",
    "left",
    "subtree",
    "parent",
    "node",
    "return",
    "true",
    "added",
    "data",
    "descend",
    "right",
    "subtree",
    "descend",
    "right",
    "subtree",
    "recursive",
    "function",
    "call",
    "insert",
    "function",
    "passing",
    "data",
    "right",
    "subtree",
    "reach",
    "bottom",
    "right",
    "subtree",
    "insert",
    "new",
    "tree",
    "attach",
    "right",
    "child",
    "parent",
    "node",
    "return",
    "true",
    "find",
    "function",
    "works",
    "similar",
    "except",
    "actually",
    "create",
    "new",
    "item",
    "insert",
    "recursively",
    "descend",
    "either",
    "left",
    "subtree",
    "right",
    "subtree",
    "find",
    "piece",
    "data",
    "current",
    "node",
    "return",
    "piece",
    "data",
    "comparison",
    "current",
    "node",
    "see",
    "descend",
    "left",
    "sub",
    "tree",
    "right",
    "sub",
    "tree",
    "reach",
    "bottom",
    "tree",
    "nun",
    "note",
    "going",
    "return",
    "false",
    "otherwise",
    "call",
    "find",
    "function",
    "recursively",
    "left",
    "subtree",
    "pass",
    "data",
    "along",
    "parameter",
    "right",
    "subtree",
    "reach",
    "bottom",
    "right",
    "subtree",
    "find",
    "data",
    "yet",
    "words",
    "reach",
    "nun",
    "note",
    "gon",
    "na",
    "return",
    "false",
    "data",
    "tree",
    "reach",
    "unknown",
    "yet",
    "continue",
    "send",
    "right",
    "subtree",
    "find",
    "data",
    "fine",
    "function",
    "basically",
    "comparison",
    "descending",
    "either",
    "right",
    "left",
    "subtree",
    "reach",
    "bottom",
    "getsize",
    "like",
    "showed",
    "diagrams",
    "node",
    "nun",
    "going",
    "return",
    "one",
    "plus",
    "size",
    "left",
    "subtree",
    "plus",
    "size",
    "right",
    "subtree",
    "works",
    "recursively",
    "continue",
    "call",
    "get",
    "size",
    "descend",
    "tree",
    "left",
    "subtree",
    "right",
    "subtree",
    "add",
    "together",
    "add",
    "one",
    "node",
    "visit",
    "traversal",
    "checks",
    "first",
    "node",
    "nun",
    "print",
    "data",
    "continue",
    "left",
    "subtree",
    "calling",
    "preorder",
    "traversal",
    "function",
    "recursively",
    "reach",
    "nun",
    "note",
    "continue",
    "right",
    "subtree",
    "recursively",
    "reach",
    "nun",
    "note",
    "inorder",
    "traversal",
    "whole",
    "lot",
    "different",
    "see",
    "different",
    "two",
    "inorder",
    "traversal",
    "print",
    "statement",
    "two",
    "subtrees",
    "print",
    "statement",
    "descend",
    "two",
    "subtrees",
    "really",
    "key",
    "difference",
    "inorder",
    "traversal",
    "let",
    "take",
    "look",
    "test",
    "code",
    "test",
    "code",
    "going",
    "create",
    "new",
    "tree",
    "using",
    "value",
    "7",
    "pass",
    "parameter",
    "tree",
    "7",
    "root",
    "insert",
    "9",
    "two",
    "items",
    "tree",
    "go",
    "whole",
    "list",
    "add",
    "whole",
    "bunch",
    "different",
    "items",
    "oh",
    "look",
    "duplicate",
    "going",
    "add",
    "insert",
    "one",
    "items",
    "going",
    "print",
    "tree",
    "range",
    "16",
    "count",
    "0",
    "15",
    "going",
    "find",
    "operation",
    "one",
    "numbers",
    "see",
    "prints",
    "4",
    "0",
    "prints",
    "false",
    "4",
    "5",
    "prints",
    "false",
    "4",
    "8",
    "prints",
    "false",
    "rest",
    "returns",
    "number",
    "prints",
    "see",
    "zero",
    "5",
    "8",
    "list",
    "unable",
    "find",
    "return",
    "false",
    "print",
    "get",
    "size",
    "function",
    "returns",
    "13",
    "count",
    "nodes",
    "tree",
    "13",
    "traversal",
    "print",
    "blank",
    "line",
    "inorder",
    "traversal",
    "see",
    "inorder",
    "traversal",
    "exactly",
    "numbers",
    "sorted",
    "order",
    "see",
    "0",
    "5",
    "8",
    "missing",
    "inorder",
    "traversal",
    "concludes",
    "lecture",
    "trees",
    "recommend",
    "download",
    "code",
    "try",
    "maybe",
    "try",
    "code",
    "postorder",
    "traversal",
    "try",
    "ricing",
    "different",
    "tests",
    "actually",
    "use",
    "tree",
    "maybe",
    "try",
    "sorting",
    "letters",
    "something",
    "million",
    "numbers",
    "see",
    "fast",
    "tree",
    "performs",
    "another",
    "really",
    "important",
    "data",
    "structure",
    "graphs",
    "graphs",
    "perfect",
    "modeling",
    "objects",
    "lot",
    "cases",
    "graph",
    "consists",
    "vertices",
    "edges",
    "connecting",
    "vertices",
    "instance",
    "social",
    "network",
    "vertices",
    "could",
    "people",
    "right",
    "connections",
    "friendships",
    "relationships",
    "people",
    "two",
    "different",
    "types",
    "graphs",
    "use",
    "undirected",
    "graphs",
    "relationship",
    "ways",
    "case",
    "social",
    "network",
    "typically",
    "relationships",
    "work",
    "ways",
    "people",
    "know",
    "see",
    "bunch",
    "vertices",
    "bunch",
    "edges",
    "people",
    "know",
    "undirected",
    "graph",
    "common",
    "way",
    "model",
    "relationships",
    "social",
    "network",
    "connections",
    "real",
    "network",
    "nodes",
    "would",
    "computers",
    "connections",
    "would",
    "cables",
    "connecting",
    "computers",
    "another",
    "type",
    "graph",
    "directed",
    "graph",
    "wanted",
    "model",
    "instance",
    "airplane",
    "flights",
    "cities",
    "well",
    "cases",
    "may",
    "flight",
    "even",
    "flight",
    "leg",
    "flight",
    "gon",
    "na",
    "represented",
    "arrow",
    "words",
    "direction",
    "going",
    "flight",
    "going",
    "chicago",
    "seattle",
    "well",
    "necessarily",
    "necessarily",
    "return",
    "flight",
    "best",
    "way",
    "model",
    "using",
    "directed",
    "graph",
    "shows",
    "relationship",
    "transportation",
    "networking",
    "couple",
    "many",
    "different",
    "possible",
    "applications",
    "graphs",
    "modeling",
    "real",
    "world",
    "problems",
    "section",
    "going",
    "cover",
    "two",
    "common",
    "ways",
    "implement",
    "graphs",
    "using",
    "adjacency",
    "list",
    "adjacency",
    "matrix",
    "adjacency",
    "list",
    "stores",
    "list",
    "neighbors",
    "vertex",
    "vertex",
    "adjacency",
    "matrix",
    "stores",
    "2d",
    "array",
    "connections",
    "vertices",
    "graph",
    "object",
    "let",
    "take",
    "look",
    "undirected",
    "graph",
    "5",
    "vertices",
    "number",
    "edges",
    "connecting",
    "adjacency",
    "list",
    "implementation",
    "vertex",
    "would",
    "store",
    "list",
    "vertices",
    "connected",
    "case",
    "connected",
    "b",
    "c",
    "list",
    "neighboring",
    "vertices",
    "would",
    "stored",
    "node",
    "neighbor",
    "lists",
    "node",
    "b",
    "connected",
    "never",
    "c",
    "c",
    "would",
    "stored",
    "node",
    "b",
    "list",
    "neighbors",
    "using",
    "undirected",
    "graph",
    "could",
    "implement",
    "using",
    "adjacency",
    "matrix",
    "jason",
    "c",
    "matrix",
    "vertices",
    "two",
    "vertices",
    "puts",
    "zero",
    "edge",
    "one",
    "edge",
    "see",
    "b",
    "edge",
    "since",
    "undirected",
    "graph",
    "mirror",
    "image",
    "across",
    "diagonal",
    "might",
    "expect",
    "edge",
    "connects",
    "b",
    "b",
    "also",
    "connects",
    "2d",
    "matrix",
    "would",
    "stored",
    "graph",
    "object",
    "vertex",
    "remember",
    "neighbors",
    "weighted",
    "edges",
    "much",
    "easier",
    "implement",
    "adjacency",
    "matrix",
    "instead",
    "putting",
    "1",
    "put",
    "weight",
    "matrix",
    "adjacency",
    "list",
    "probably",
    "put",
    "tuple",
    "includes",
    "weight",
    "directed",
    "graph",
    "fairly",
    "easy",
    "implement",
    "either",
    "one",
    "adjacency",
    "list",
    "would",
    "put",
    "outbound",
    "edges",
    "vertex",
    "see",
    "outbound",
    "edge",
    "see",
    "would",
    "list",
    "az",
    "jason",
    "c",
    "list",
    "node",
    "c",
    "directed",
    "graph",
    "adjacency",
    "matrix",
    "similar",
    "going",
    "symmetrical",
    "across",
    "diagonal",
    "anymore",
    "b",
    "connects",
    "connect",
    "directly",
    "b",
    "see",
    "b",
    "1",
    "b",
    "zero",
    "implementation",
    "better",
    "well",
    "first",
    "let",
    "look",
    "two",
    "different",
    "types",
    "graphs",
    "dense",
    "graph",
    "every",
    "vertex",
    "may",
    "connected",
    "every",
    "vertex",
    "graph",
    "kind",
    "graph",
    "lot",
    "edges",
    "relative",
    "number",
    "vertices",
    "maybe",
    "vertex",
    "connected",
    "every",
    "vertex",
    "graph",
    "case",
    "number",
    "edges",
    "would",
    "equal",
    "number",
    "vertices",
    "squared",
    "sparse",
    "graph",
    "relatively",
    "edges",
    "maybe",
    "approximately",
    "similar",
    "number",
    "vertices",
    "adjacency",
    "matrix",
    "takes",
    "v",
    "squared",
    "space",
    "regardless",
    "dense",
    "graph",
    "list",
    "vertices",
    "along",
    "along",
    "matrix",
    "takes",
    "v",
    "squared",
    "space",
    "matrix",
    "matrix",
    "graph",
    "vertices",
    "would",
    "take",
    "least",
    "hundred",
    "megabytes",
    "adjacency",
    "list",
    "faster",
    "uses",
    "less",
    "space",
    "really",
    "sparse",
    "graph",
    "con",
    "slower",
    "dense",
    "graphs",
    "dense",
    "graphs",
    "would",
    "iterate",
    "neighbors",
    "adjacency",
    "matrix",
    "faster",
    "dense",
    "graphs",
    "easily",
    "look",
    "things",
    "using",
    "index",
    "also",
    "simpler",
    "weighted",
    "edges",
    "easy",
    "implement",
    "weighted",
    "edges",
    "con",
    "uses",
    "lot",
    "space",
    "number",
    "vertices",
    "grows",
    "amount",
    "space",
    "required",
    "adjacency",
    "matrix",
    "grows",
    "factor",
    "v",
    "squared",
    "next",
    "going",
    "learn",
    "implement",
    "methods",
    "python",
    "let",
    "look",
    "code",
    "post",
    "code",
    "github",
    "site",
    "jupiter",
    "notebook",
    "format",
    "going",
    "walk",
    "video",
    "well",
    "regular",
    "python",
    "file",
    "download",
    "test",
    "whichever",
    "format",
    "prefer",
    "try",
    "strongly",
    "recommend",
    "really",
    "understand",
    "graphs",
    "work",
    "code",
    "basically",
    "two",
    "classes",
    "vertex",
    "class",
    "pretty",
    "simple",
    "whole",
    "lot",
    "graph",
    "class",
    "little",
    "bit",
    "substance",
    "walk",
    "exactly",
    "everything",
    "works",
    "little",
    "bit",
    "test",
    "code",
    "show",
    "works",
    "first",
    "let",
    "look",
    "vertex",
    "class",
    "two",
    "different",
    "methods",
    "constructor",
    "init",
    "constructor",
    "creates",
    "new",
    "vertex",
    "basically",
    "sets",
    "two",
    "different",
    "attributes",
    "vertex",
    "object",
    "pass",
    "name",
    "name",
    "vertex",
    "us",
    "single",
    "letter",
    "assigns",
    "named",
    "attribute",
    "vertex",
    "also",
    "creates",
    "empty",
    "set",
    "neighbors",
    "vertex",
    "add",
    "neighbors",
    "pass",
    "name",
    "vertex",
    "vertex",
    "object",
    "name",
    "vertex",
    "adds",
    "neighbors",
    "set",
    "vertex",
    "remember",
    "sets",
    "store",
    "duplicates",
    "neighbor",
    "already",
    "added",
    "vertex",
    "matter",
    "wo",
    "added",
    "second",
    "time",
    "let",
    "look",
    "graph",
    "class",
    "little",
    "complex",
    "different",
    "methods",
    "first",
    "graph",
    "object",
    "stores",
    "vertices",
    "dictionary",
    "vertices",
    "format",
    "named",
    "vertex",
    "name",
    "vertex",
    "object",
    "always",
    "access",
    "vertex",
    "name",
    "always",
    "access",
    "vertex",
    "object",
    "dictionary",
    "add",
    "vertex",
    "pass",
    "vertex",
    "check",
    "object",
    "passed",
    "actually",
    "vertex",
    "object",
    "name",
    "vertex",
    "list",
    "yet",
    "already",
    "dictionary",
    "obviously",
    "gon",
    "na",
    "add",
    "second",
    "time",
    "add",
    "vertex",
    "vertex",
    "dictionary",
    "return",
    "true",
    "otherwise",
    "return",
    "false",
    "says",
    "add",
    "unsuccessful",
    "add",
    "edge",
    "every",
    "time",
    "create",
    "new",
    "edge",
    "check",
    "vertices",
    "actually",
    "existing",
    "real",
    "vertices",
    "graph",
    "vertex",
    "exist",
    "graph",
    "ca",
    "edge",
    "connecting",
    "vertex",
    "assuming",
    "vertices",
    "valid",
    "vertices",
    "add",
    "two",
    "v",
    "neighbor",
    "list",
    "use",
    "neighbor",
    "list",
    "two",
    "different",
    "add",
    "operations",
    "return",
    "true",
    "print",
    "graph",
    "really",
    "going",
    "print",
    "neighbor",
    "list",
    "vertex",
    "name",
    "vertex",
    "vertex",
    "neighbor",
    "list",
    "test",
    "code",
    "well",
    "create",
    "new",
    "graph",
    "g",
    "different",
    "ways",
    "add",
    "vertices",
    "graph",
    "three",
    "different",
    "ways",
    "create",
    "new",
    "vertex",
    "passing",
    "vertex",
    "constructor",
    "name",
    "vertex",
    "add",
    "vertex",
    "using",
    "add",
    "vertex",
    "method",
    "another",
    "way",
    "steps",
    "one",
    "operation",
    "using",
    "add",
    "vertex",
    "create",
    "new",
    "vertex",
    "called",
    "vertex",
    "b",
    "could",
    "also",
    "use",
    "loop",
    "want",
    "add",
    "whole",
    "series",
    "vertices",
    "k",
    "use",
    "order",
    "get",
    "numerical",
    "equivalent",
    "iterate",
    "using",
    "range",
    "function",
    "convert",
    "back",
    "letter",
    "using",
    "chr",
    "character",
    "equivalent",
    "number",
    "three",
    "different",
    "ways",
    "add",
    "vertices",
    "graph",
    "three",
    "worry",
    "duplicates",
    "check",
    "duplicates",
    "add",
    "vertex",
    "function",
    "adding",
    "edges",
    "well",
    "created",
    "list",
    "edges",
    "basically",
    "list",
    "consists",
    "two",
    "letters",
    "two",
    "vertices",
    "edge",
    "connects",
    "iterate",
    "add",
    "edge",
    "first",
    "letter",
    "second",
    "letter",
    "passing",
    "two",
    "lastly",
    "print",
    "graph",
    "graph",
    "bunch",
    "vertices",
    "bunch",
    "edges",
    "graph",
    "look",
    "like",
    "well",
    "print",
    "function",
    "really",
    "visualize",
    "graph",
    "show",
    "us",
    "adjacency",
    "lists",
    "look",
    "like",
    "look",
    "adjacency",
    "list",
    "looks",
    "like",
    "neighbors",
    "b",
    "e",
    "b",
    "neighbors",
    "f",
    "c",
    "neighbor",
    "g",
    "take",
    "look",
    "edges",
    "list",
    "figure",
    "write",
    "edge",
    "b",
    "e",
    "right",
    "see",
    "b",
    "e",
    "hayes",
    "neighbor",
    "lists",
    "also",
    "going",
    "see",
    "ees",
    "neighbor",
    "list",
    "look",
    "e",
    "yep",
    "sure",
    "enough",
    "adjacency",
    "lists",
    "implementation",
    "works",
    "code",
    "download",
    "code",
    "run",
    "try",
    "spend",
    "little",
    "time",
    "getting",
    "acquainted",
    "implementation",
    "graphs",
    "use",
    "strings",
    "lists",
    "sets",
    "dictionaries",
    "data",
    "structures",
    "covered",
    "section",
    "1",
    "course",
    "next",
    "lecture",
    "going",
    "learn",
    "implement",
    "graphs",
    "using",
    "adjacency",
    "matrix",
    "lecture",
    "gon",
    "na",
    "look",
    "graphs",
    "implemented",
    "using",
    "adjacency",
    "matrix",
    "method",
    "walk",
    "adjacency",
    "matrix",
    "works",
    "let",
    "look",
    "code",
    "code",
    "posted",
    "github",
    "site",
    "python",
    "file",
    "jupiter",
    "notebook",
    "file",
    "welcome",
    "download",
    "either",
    "one",
    "code",
    "going",
    "show",
    "jupiter",
    "notebook",
    "lot",
    "comments",
    "first",
    "vertex",
    "class",
    "vertex",
    "class",
    "extremely",
    "simple",
    "matrix",
    "implementation",
    "matrix",
    "basically",
    "graph",
    "class",
    "vertex",
    "class",
    "really",
    "anything",
    "constructor",
    "simply",
    "pass",
    "name",
    "vertex",
    "assign",
    "name",
    "single",
    "attribute",
    "called",
    "name",
    "vertex",
    "name",
    "graph",
    "class",
    "little",
    "complicated",
    "three",
    "key",
    "attributes",
    "dictionary",
    "vertices",
    "matrix",
    "edges",
    "actually",
    "going",
    "list",
    "edges",
    "edge",
    "indices",
    "edges",
    "unlabeled",
    "series",
    "zeros",
    "ones",
    "basically",
    "labels",
    "goes",
    "edges",
    "way",
    "implement",
    "chose",
    "implement",
    "different",
    "different",
    "way",
    "want",
    "find",
    "complicated",
    "gon",
    "na",
    "different",
    "functions",
    "methods",
    "part",
    "graph",
    "class",
    "going",
    "add",
    "vertex",
    "going",
    "update",
    "three",
    "attributes",
    "going",
    "add",
    "edge",
    "really",
    "needs",
    "update",
    "edges",
    "matrix",
    "print",
    "function",
    "add",
    "vertex",
    "pass",
    "vertex",
    "first",
    "going",
    "verify",
    "valid",
    "vertex",
    "object",
    "already",
    "vertices",
    "list",
    "go",
    "ahead",
    "add",
    "first",
    "step",
    "update",
    "vertices",
    "dictionary",
    "adding",
    "name",
    "vertex",
    "dictionary",
    "words",
    "vertex",
    "object",
    "next",
    "going",
    "use",
    "loop",
    "append",
    "column",
    "rightmost",
    "side",
    "matrix",
    "edges",
    "matrix",
    "use",
    "loop",
    "append",
    "column",
    "zeros",
    "rightmost",
    "end",
    "edges",
    "matrix",
    "need",
    "put",
    "bottom",
    "matrix",
    "need",
    "append",
    "two",
    "zeros",
    "row",
    "zeros",
    "bottom",
    "using",
    "self",
    "dot",
    "edges",
    "append",
    "0",
    "times",
    "length",
    "edges",
    "plus",
    "1",
    "words",
    "however",
    "many",
    "edges",
    "going",
    "add",
    "0",
    "bottom",
    "row",
    "one",
    "since",
    "added",
    "vertex",
    "obviously",
    "edges",
    "connecting",
    "yet",
    "know",
    "zeros",
    "add",
    "edges",
    "connecting",
    "vertex",
    "going",
    "flip",
    "1",
    "last",
    "step",
    "adding",
    "vertex",
    "update",
    "edge",
    "vertices",
    "add",
    "vertex",
    "name",
    "index",
    "find",
    "vertex",
    "edges",
    "list",
    "add",
    "edge",
    "pass",
    "u",
    "v",
    "two",
    "vertices",
    "edge",
    "default",
    "weight",
    "one",
    "normal",
    "default",
    "weight",
    "one",
    "override",
    "passing",
    "whatever",
    "weight",
    "want",
    "want",
    "use",
    "weighted",
    "edges",
    "pretty",
    "easy",
    "check",
    "make",
    "sure",
    "vertices",
    "passed",
    "valid",
    "vertex",
    "names",
    "words",
    "actually",
    "vertices",
    "dictionary",
    "edges",
    "list",
    "need",
    "two",
    "different",
    "indices",
    "access",
    "specific",
    "position",
    "matrix",
    "u",
    "v",
    "b",
    "u",
    "want",
    "flip",
    "four",
    "edges",
    "two",
    "positions",
    "table",
    "set",
    "equal",
    "weight",
    "whatever",
    "weight",
    "passed",
    "1",
    "default",
    "lastly",
    "print",
    "graph",
    "well",
    "see",
    "prints",
    "starting",
    "printing",
    "name",
    "vertex",
    "going",
    "print",
    "row",
    "ones",
    "zeroes",
    "vertex",
    "test",
    "code",
    "used",
    "exactly",
    "test",
    "code",
    "use",
    "implementation",
    "graph",
    "using",
    "adjacency",
    "lists",
    "test",
    "code",
    "identical",
    "create",
    "new",
    "graph",
    "three",
    "different",
    "ways",
    "adding",
    "vertex",
    "graph",
    "first",
    "create",
    "new",
    "vertex",
    "object",
    "add",
    "vertex",
    "b",
    "add",
    "vertex",
    "create",
    "new",
    "new",
    "vertex",
    "inside",
    "parentheses",
    "use",
    "loop",
    "method",
    "iterate",
    "k",
    "add",
    "graph",
    "add",
    "edge",
    "created",
    "list",
    "edges",
    "list",
    "used",
    "test",
    "code",
    "edge",
    "edges",
    "iterating",
    "edges",
    "add",
    "edge",
    "one",
    "one",
    "time",
    "pass",
    "add",
    "edge",
    "method",
    "two",
    "parameters",
    "case",
    "would",
    "b",
    "getting",
    "left",
    "character",
    "right",
    "character",
    "passing",
    "attributes",
    "print",
    "graph",
    "see",
    "looks",
    "like",
    "neighbors",
    "matrix",
    "looks",
    "like",
    "end",
    "see",
    "one",
    "neighbor",
    "would",
    "b",
    "c",
    "e",
    "b",
    "e",
    "neighbors",
    "right",
    "wherever",
    "one",
    "column",
    "see",
    "edge",
    "b",
    "e",
    "words",
    "see",
    "symmetrical",
    "across",
    "diagonal",
    "every",
    "place",
    "one",
    "reflects",
    "edge",
    "two",
    "vertices",
    "recommend",
    "download",
    "code",
    "test",
    "try",
    "use",
    "get",
    "familiar",
    "two",
    "different",
    "implementations",
    "graphs",
    "important",
    "understand",
    "one",
    "best",
    "method",
    "already",
    "explained",
    "different",
    "instances",
    "method",
    "advantages",
    "course",
    "covered",
    "lot",
    "different",
    "data",
    "structures",
    "learned",
    "use",
    "different",
    "data",
    "structures",
    "well",
    "implement",
    "pros",
    "cons",
    "lot",
    "new",
    "tools",
    "tool",
    "belt",
    "programmer",
    "south",
    "problems",
    "developing",
    "code",
    "thank",
    "taking",
    "course"
  ],
  "keywords": [
    "course",
    "gon",
    "na",
    "learn",
    "data",
    "structures",
    "python",
    "well",
    "let",
    "second",
    "would",
    "try",
    "make",
    "also",
    "know",
    "every",
    "different",
    "exactly",
    "going",
    "structure",
    "use",
    "time",
    "code",
    "strings",
    "lists",
    "tuples",
    "sets",
    "dictionaries",
    "continue",
    "queues",
    "linked",
    "cover",
    "binary",
    "search",
    "trees",
    "graphs",
    "implement",
    "look",
    "first",
    "sequence",
    "types",
    "string",
    "list",
    "tupple",
    "put",
    "check",
    "want",
    "items",
    "access",
    "item",
    "using",
    "index",
    "inside",
    "square",
    "brackets",
    "zero",
    "always",
    "three",
    "four",
    "letters",
    "print",
    "x",
    "3",
    "gives",
    "us",
    "see",
    "cow",
    "1",
    "give",
    "tuple",
    "names",
    "name",
    "sub",
    "way",
    "works",
    "start",
    "end",
    "plus",
    "one",
    "step",
    "show",
    "means",
    "example",
    "0",
    "4",
    "parameter",
    "inclusive",
    "number",
    "u",
    "really",
    "get",
    "result",
    "6",
    "e",
    "2",
    "words",
    "p",
    "next",
    "basically",
    "everything",
    "elements",
    "something",
    "five",
    "beginning",
    "v",
    "c",
    "right",
    "last",
    "except",
    "two",
    "covered",
    "adding",
    "single",
    "case",
    "important",
    "note",
    "comma",
    "parentheses",
    "actually",
    "function",
    "bug",
    "times",
    "eight",
    "test",
    "easy",
    "key",
    "say",
    "called",
    "letter",
    "true",
    "false",
    "returns",
    "couple",
    "iterate",
    "variable",
    "whatever",
    "like",
    "7",
    "8",
    "return",
    "count",
    "find",
    "either",
    "b",
    "compare",
    "numbers",
    "part",
    "12",
    "another",
    "add",
    "new",
    "sorted",
    "order",
    "back",
    "change",
    "sort",
    "instead",
    "functions",
    "video",
    "reverse",
    "equals",
    "k",
    "take",
    "added",
    "passing",
    "looking",
    "value",
    "assign",
    "values",
    "lecture",
    "lot",
    "size",
    "create",
    "ways",
    "empty",
    "constructor",
    "pass",
    "point",
    "comprehensions",
    "section",
    "little",
    "loop",
    "range",
    "10",
    "9",
    "greater",
    "squared",
    "5",
    "delete",
    "entire",
    "append",
    "dot",
    "used",
    "could",
    "insert",
    "position",
    "pop",
    "anything",
    "remove",
    "without",
    "much",
    "work",
    "class",
    "may",
    "looks",
    "yeah",
    "able",
    "need",
    "set",
    "fast",
    "comparisons",
    "operations",
    "call",
    "less",
    "equal",
    "dictionary",
    "left",
    "25",
    "shrimp",
    "already",
    "update",
    "many",
    "keys",
    "pretty",
    "download",
    "previous",
    "else",
    "whole",
    "object",
    "stack",
    "push",
    "top",
    "bottom",
    "command",
    "cases",
    "implementation",
    "19",
    "operation",
    "none",
    "queue",
    "max",
    "heap",
    "tree",
    "yet",
    "node",
    "parent",
    "16",
    "24",
    "child",
    "children",
    "nodes",
    "starting",
    "float",
    "proper",
    "11",
    "swap",
    "bubble",
    "method",
    "recursively",
    "standard",
    "doubly",
    "circular",
    "pointer",
    "piece",
    "nun",
    "root",
    "attributes",
    "pointing",
    "found",
    "reach",
    "15",
    "million",
    "edge",
    "leaf",
    "subtree",
    "descend",
    "traversal",
    "inorder",
    "graph",
    "vertices",
    "edges",
    "adjacency",
    "matrix",
    "neighbors",
    "vertex",
    "neighbor"
  ]
}