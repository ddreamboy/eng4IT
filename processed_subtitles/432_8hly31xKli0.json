{
  "text": "this is a full-length course from\ntreehouse we at free code camp are\nlongtime fans of their learning platform\nthey were kind enough to let our\nnon-profit make this course freely\navailable on our youtube channel if you\nlike this course treehouse has a lot\nmore courses like this one the link is\nin the description\nalong with time codes to the different\nsections in this course\n[Music]\nhi my name is passan i'm an instructor\nhere at treehouse and welcome to\nintroduction to algorithms\nwhether you are a high school or college\nstudent a developer in the industry or\nsomeone who is learning to code you have\nundoubtedly run into the term algorithm\nfor many people this word is kind of\nscary it represents this body of\nknowledge that seems just out of reach\nonly people with computer science\ndegrees know about algorithms now to\nothers this brings up feelings of\nimposter syndrome\nyou might already know how to code but\nyou're not a real developer because you\ndon't know anything about algorithms\npersonally it made me frame certain jobs\nas above my skill level because the\ninterview contained algorithm questions\nwell whatever your reasons are in this\ncourse our goal is to dispel all those\nfeelings and get you comfortable with\nthe basics of algorithms\nlike any other subject i like to start\nmy courses with what the course is and\nis not\nin this course we're going to cover the\nvery basic set of knowledge that you\nneed as a foundation for learning about\nalgorithms\nthis course is less about specific\nalgorithms and more about the tools you\nwill need to evaluate algorithms\nunderstand how they perform\ncompare them to each other and make a\nstatement about the utility of an\nalgorithm in a given context\nnow don't worry none of this will be\ntheoretical and we will learn these\nconcepts by using well-known algorithms\nin this course we will also be writing\ncode so i do expect you to have some\nprogramming experience if you intend to\ncontinue with this topic\nyou can definitely stick around even if\nyou don't know how to code but you might\nwant to learn the basics of programming\nin the meantime\nin this course we will be using the\npython programming language python reads\na lot like regular english and is the\nlanguage you will most likely encounter\nwhen learning about algorithms these\ndays\nif you don't know how to code or if you\nknow how to code in a different language\ncheck out the notes section of this\nvideo for links to other content that\nmight be useful to you\nas long as you understand the\nfundamentals of programming you should\nbe able to follow along pretty well\nif you're a javascript developer or a\nstudent who's learning javascript for\nexample chances are good that you'll\nstill be able to understand the code we\nwrite later i'll be sure to provide\nlinks along the way if you need anything\nto follow up on\nlet's start with something simple\nwhat is an algorithm\nan algorithm is a set of steps or\ninstructions for completing a task\nthis might sound like an over\nsimplification but really that's\nprecisely what an algorithm is\na recipe is an algorithm your morning\nroutine when you wake up is an algorithm\nand the driving directions you follow to\nget to a destination is also an\nalgorithm\nin computer science the term algorithm\nmore specifically means the set of steps\na program takes to finish a task\nif you've written code before any code\nreally generally speaking you have\nwritten an algorithm\ngiven that much of the code we write can\nbe considered an algorithm what do\npeople mean when they say you should\nknow about algorithms\nnow consider this\nlet's say i'm a teacher in a classroom\nand i tell everyone i have an assignment\nfor them on their desks they have a\npicture of a maze and their task is to\ncome up with a way to find the quickest\nway out of the maze\neveryone does their thing and comes up\nwith a solution\nevery single one of these solutions is a\nviable solution and is a valid example\nof an algorithm the steps one needs to\ntake to get out of the maze but from\nbeing in classrooms or any group of any\nsort you know that some people will have\nbetter ideas than others we all have a\ndiverse array of skill sets\nover time our class picks the best of\nthese solutions and any time we want to\nsolve a maze we go with one of these\nsolutions this is what the field of\nalgorithms is about\nthere are many problems in computer\nscience but some of them are pretty\ncommon regardless of what project you're\nworking on\ndifferent people have come up with\ndifferent solutions to these common\nproblems and over time the field of\ncomputer science has identified several\nthat do the job well for a given task\nwhen we talk of algorithms we're\nreferring to two points\nwe're primarily saying there's an\nestablished body of knowledge on how to\nsolve particular problems well and it's\nimportant to know what the solutions are\nnow why is it important\nif you're unaware that a solution exists\nyou might try to come up with one\nyourself and there's a likelihood that\nyour solution won't be as good or\nefficient whatever that means compared\nto those that have been thoroughly\nreviewed\nbut there's a second component to it as\nwell\npart of understanding algorithms is not\njust knowing that an algorithm exists\nbut understanding when to apply it\nunderstanding when to apply an algorithm\nrequires properly understanding the\nproblem at hand and this arguably is the\nmost important part of learning about\nalgorithms and data structures\nas you progress through this content you\nshould be able to look at a problem and\nbreak it down into distinct steps\nwhen you have a set of steps you should\nthen be able to identify which algorithm\nor data structure is best for the task\nat hand\nthis concept is called algorithmic\nthinking and it's something we're going\nto try and cultivate together as we work\nthrough our content\nlastly learning about algorithms gives\nyou a deeper understanding about\ncomplexity and efficiency in programming\nhaving a better sense of how your code\nwill perform in different situations is\nsomething that you'll always want to\ndevelop in hone\nalgorithmic thinking is why algorithms\nalso come up in big tech interviews\ninterviewers don't care as much that you\nare able to write a specific algorithm\nin code but more about the fact that you\ncan break a seemingly insurmountable\nproblem into distinct components and\nidentify the right tools to solve each\ndistinct component\nand that is what we plan on doing in\nthis course though we're going to focus\non some of the tools and concepts you'll\nneed to be aware of before we can dive\ninto the topic of algorithms if you're\nready let's get started\nhey again in this video we're going to\ndo something unusual we're going to play\na game and by we i mean me and my two\nfriends here brittany and john\nthis game is really simple and you may\nhave played it before it goes something\nlike this i'm going to think of a number\nbetween 1 and 10 and they have to guess\nwhat the number is easy right\nwhen they guess a number i'll tell them\nif their guess is too high or too low\nthe winner is the one with the fewest\ntries all right john let's start with\nyou i'm thinking of a number between one\nand ten what is it\nbetween you and me the answer is three\nuh quick question does the range include\none and ten\nthat is a really good question so what\njohn did right there was to establish\nthe bounds of our problem\nno solution works on every problem and\nan important part of algorithmic\nthinking is to clearly define what the\nproblem set is and clarify what values\ncount as inputs\nyeah 1 and ten are both included is it\none too low is it two too low is it\nthree correct\nokay so that was an easy one it took\njohn three tries to get the answer let's\nswitch over to brittany and play another\nround using the same number as the\nanswer okay brittany i'm thinking of a\nnumber between 1 and 10 inclusive so\nboth 1 and 10 are in the range what\nnumber am i thinking of\nis it 5 too high\n2 too low\nis it 3 correct all right so what we had\nthere was two very different ways of\nplaying the same game\nsomehow with even such a simple game we\nsaw different approaches to figuring out\na solution\nto go back to algorithmic thinking for a\nsecond this means that with any given\nproblem there's no one best solution\ninstead what we should try and figure\nout is what solution works better for\nthe current problem\nin this first pass at the game they both\ntook the same amount of turns to find\nthe answer so it's not obvious who has\nthe better approach and that's mostly\nbecause the game was easy\nlet's try this one more time now this\ntime the answer is 10.\nall right john you first is it one too\nlow is it two still too low is it three\ntoo low is it four too low is it five\nstill too low is it six too low is it\nseven too low is it eight low is it nine\ndo low is it ten correct you got it okay\nso now same thing but with britney this\ntime\nis it five too low\neight too low is it nine still too low\nit's ten\nall right so here we start to see a\ndifference between their strategies when\nthe answer was three they both took the\nsame number of turns this is important\nwhen the number was larger but not that\nmuch larger 10 in this case we start to\nsee that britney strategy did better she\ntook four tries while john took 10.\nwe've played two rounds so far and we've\nseen a different set of results based on\nthe number they were looking for\nif you look at john's way of doing\nthings then the answer being 10 the\nround we just played is his worst case\nscenario he will take the maximum number\nof turns 10 to guess it\nwhen we picked a random number like\nthree it was hard to differentiate which\nstrategy was better because they both\nperformed exactly the same\nbut in john's worst case scenario a\nclear winner in terms of strategy\nemerges\nin terms of algorithmic thinking we're\nstarting to get a sense that the\nspecific value they're searching for may\nnot matter as much as where that value\nlies in the range that they've been\ngiven\nidentifying this helps us understand our\nproblem better\nlet's do this again for a range of\nnumbers from one to one hundred we'll\nstart by picking five as an answer to\ntrick them\nokay so this time we're going to run\nthrough the exercise again this time\nfrom one to one hundred and both one and\none hundred are included is it one at\nthis point without even having to run\nthrough it we can guess how many tries\njohn is going to take since he starts at\none and keeps going he's going to take\nfive tries as we're about to see is it\nfive cool correct\nokay now for brittany's turn\nis it 50 too high is it 25 still too\nhigh\nis it 13 too high is it seven\ntoo high\nis it four too low\nis it six too high is it five correct\nlet's evaluate john took five tries\nbrittany on the other hand takes seven\ntries so john wins this round but again\nin determining whose strategy is\npreferred there's no clear winner right\nnow\nwhat this tells us is that it's not\nparticularly useful to look at the easy\nanswers where we arrive at the number\nfairly quickly because it's at the start\nof the range\ninstead let's try one where we know john\nis going to do poorly let's look at his\nworst case scenario where the answer is\n100 and see how britney performs in such\na scenario\nokay john let's do this one more time\none through 100 again\nis it one we can fast forward this scene\nbecause well we know what happens john\ntakes 100 tries\nhi brittany you're up\nis it 50 too low is it 75 too low 88 too\nlow\n94 too low is it 97 too low\n99 too low\n100.\nokay so that took brittney seven turns\nagain and this time she is the clear\nwinner if you compare their individual\nperformances for the same number set\nyou'll see that britney's approach\nleaves john's in the dust\nwhen the answer was five so right around\nthe start of the range john took five\nturns but when the answer was 100 right\nat the end of the range he took 100\ntries it took him 20 times the amount of\ntries to get that answer compared to\nbritney\non the other hand if you compare\nbritney's efforts when the number was 5\nshe took seven tries but when the number\nwas 100 she took the same amount of\ntries this is pretty impressive if we\npretend that the number of tries is the\nnumber of seconds it takes britney and\njohn to run through their attempts this\nis a good estimate for how fast their\nsolutions are\nok we've done this a couple times and\nbrittany and john are getting tired\nlet's take a break in the next video\nwe'll talk about the point of this\nexercise\nin the last video we ran through an\nexercise where i had some of my\nco-workers guess what number i was\nthinking so was the point of that\nexercise you might be thinking hey i\nthought i was here to learn about\nalgorithms\nthe exercise we just did was an example\nof a real life situation you will run\ninto when building websites apps and\nwriting code\nboth approaches taken by john and\nbrittany to find the number i was\nthinking of are examples of searching\nfor a value\nit might be weird to think that there's\nmore than one way to search but as you\nsaw in the game the speed at which the\nresult was obtained differed between\njohn and brittany think about this\nproblem from the perspective of a\ncompany like facebook\nat the time of this recording facebook\nhas 2.19 billion active users\nlet's say you're traveling in a\ndifferent country and meet someone you\nwant to add on facebook\nyou go into the search bar and type out\nthis person's name\nif we simplify how the facebook app\nworks it has to search across these 2.19\nbillion records and find the person you\nare looking for\nthe speed at which you find this person\nreally matters imagine what kind of\nexperience it would be if when you\nsearch for a friend facebook put up a\nspinning activity indicator and said\ncome back in a couple hours\ni don't think we'd use facebook as much\nif that was the case\nfrom the company's perspective working\non making search as fast as possible\nusing different strategies really\nmatters\nnow i said that the two strategies\nbritney and john used were examples of\nsearch\nmore specifically these are search\nalgorithms\nthe strategy john took where he started\nat the beginning of the range and just\ncounted one number after the other is a\ntype of search called linear search\nit is also called sequential search\nwhich is a better description of how it\nworks or even simple search since it\nreally is quite simple\nbut what makes his approach an algorithm\nas opposed to just looking for something\nremember we said that an algorithm is a\nset of steps or instructions to complete\na task\nlinear search is a search algorithm and\nwe can define it like this\nwe start at the beginning of the list or\nthe range of values\nthen we compare the current value to the\ntarget\nif the current value is the target value\nthat we're looking for we're done\nif it's not we'll move on sequentially\nto the next value in the list and then\nrepeat step 2.\nif we reach the end of the list then the\ntarget value is not in the list\nthis definition has nothing to do with\nprogramming and in fact you can use it\nin the real world for example\ni could tell you to walk into a\nbookstore and find me a particular book\nand one of the ways you could do it is\nusing the linear search algorithm\nyou could start at the front of the\nbookstore and read the cover or the\nspine of every book to check that it\nmatches the book that you're looking for\nif it doesn't you go to the next book\nand repeat until you find it or run out\nof books\nwhat makes this an algorithm is the\nspecificity of how it is defined\nin contrast to just jumping into a\nproblem and solving it as we go along an\nalgorithm follows a certain set of\nguidelines and we use the same steps to\nsolve the problem each time we face it\nan important first step to defining the\nalgorithm isn't the algorithm itself but\nthe problem we're trying to solve\nour first guideline is that an algorithm\nmust have a clear problem statement\nit's pretty hard to define an\ninstruction set when you don't have a\nclear idea of what problem you're trying\nto solve\nin defining the problem we need to\nspecify how the input is defined and\nwhat the output looks like when the\nalgorithm has done its job\nfor linear search the input can be\ngenerally described as a series of\nvalues and the output is a value\nmatching the one we're looking for\nright now we're trying to stay away from\nanything code related so this problem\nstatement definition is pretty generic\nbut once we get to code we can actually\ntighten this up\nonce we have a problem an algorithm is a\nset of steps that solves this problem\ngiven that the next guideline is that an\nalgorithm definition must contain a\nspecific set of instructions in a\nparticular order\nwe really need to be clear about the\norder in which these instructions are\nexecuted\ntaking our simple definition of linear\nsearch if i switched up the order and\nsaid move sequentially to the next value\nbefore specifying that first comparison\nstep if the first value were the target\none our algorithm wouldn't find it\nbecause we moved to the second value\nbefore comparing\nnow you might think okay that's just an\navoidable mistake and kind of common\nsense\nthe thing is computers don't know any of\nthat and just do exactly as we tell them\nso specific order is really important\nthe third guideline is that each step in\nour algorithm definition must not be a\ncomplex one and needs to be explicitly\nclear what i mean by that is that you\nshouldn't be able to break down any of\nthe steps into further into additional\nsubtasks\neach step needs to be a distinct one we\ncan't define linear search as search\nuntil you find this value because that\ncan be interpreted in many ways and\nfurther broken down into many more steps\nit's not clear\nnext and this one might seem obvious but\nalgorithms should produce a result\nif it didn't how would we know whether\nthe algorithm works or not\nto be able to verify that our algorithm\nworks correctly we need a result\nnow when using a search algorithm the\nend result can actually be nothing which\nindicates that the value wasn't found\nbut that's perfectly fine\nthere are several ways to represent\nnothing in code and as long as the\nalgorithm can produce some results we\ncan understand its behavior\nthe last guideline is that the algorithm\nshould actually complete and cannot take\nan infinite amount of time\nif we let john loose in the world's\nlargest library and asked him to find a\nnovel we have no way of knowing whether\nhe succeeded or not unless he came back\nto us with a result\nokay so quick recap what makes an\nalgorithm an algorithm and not just\nsomething you do\none it needs to have a clearly defined\nproblem statement input and output\nwhen using linear search the input needs\nto be just a series of values but to\nactually use brittany's strategy there's\none additional precondition so to speak\nif you think about her strategy it\nrequired that the numbers be sorted in\nascending order\nthis means that where the input for john\nis just a series of values to solve the\nproblem the input to brittany's\nalgorithm needs to be a sorted series of\nvalues\nso clearly defined problem statement\nclearly defined input and clearly\ndefined output\nsecond the steps in the algorithm need\nto be in a very specific order\nthe steps also need to be distinct you\nshould not be able to break it down into\nfurther subtasks\nnext the algorithm should produce a\nresult\nand finally the algorithm should\ncomplete in a finite amount of time\nthese guidelines not only help us define\nwhat an algorithm is but also helps us\nverify that the algorithm is correct\nexecuting the steps in an algorithm for\na given input must result in the same\noutput every time\nif in the game i played the answer was\n50 every time then every single time\njohn must take 50 turns to find out that\nthe answer is 50. if somehow he takes 50\nturns in one round then 30 the next and\nwe technically don't have a correct\nalgorithm\nconsistent results for the same set of\nvalues is how we know that the algorithm\nis correct\ni should stress that we're not going to\nbe designing any algorithms on our own\nand we'll start off and spend most of\nour time learning the tried and true\nalgorithms that are known to efficiently\nsolve problems\nthe reason for talking about what makes\nfor a good algorithm though is that the\nsame set of guidelines makes for good\nalgorithmic thinking which is one of the\nmost important skills we want to\ncultivate\nwhen we encounter a problem before\nrushing in and thinking about solutions\nwhat we want to do is work through the\nguidelines\nfirst we break down the problem into any\npossible number of smaller problems\nwhere each problem can be clearly\ndefined in terms of an input and an\noutput\nnow that we know how to generally define\nan algorithm let's talk about what it\nmeans to have a good algorithm\nan important thing to keep in mind is\nthat there's no one single way to\nmeasure whether an algorithm is the\nright solution because it is all about\ncontext\nearlier we touched on two concepts\ncorrectness and efficiency\nlet's define correctness more clearly\nbecause before we can evaluate an\nalgorithm on efficiency we need to\nensure its correctness\nbefore we define our algorithms we start\nby defining our problem\nin the definition of that problem we\nhave a clearly defined input satisfying\nany preconditions and a clearly defined\noutput\nan algorithm is deemed correct if on\nevery run of the algorithm against all\npossible values in the input data we\nalways get the output we expect\npart of correctness means that for any\npossible input the algorithm should\nalways terminate or end\nif these two are not true then our\nalgorithm isn't correct\nif you were to pick up an algorithm's\ntextbook and look up correctness you\nwill run into a bunch of mathematical\ntheory this is because traditionally\nalgorithm correctness is proved by\nmathematical induction which is a form\nof reasoning used in mathematics to\nverify that a statement is correct\nthis approach involves writing what is\ncalled a specification and a correctness\nproof\nwe won't be going into that in this\ncourse\nproof through induction is an important\npart of designing algorithms but we're\nconfident that you can understand\nalgorithms both in terms of how and when\nto use them without getting into the\nmath so if you pick up a textbook and\nfeel daunted don't worry i do too but we\ncan still figure things out without it\nall right so once we have a correct\nalgorithm we can start to talk about how\nefficient an algorithm is\nremember that this efficiency ultimately\nmatters because they help us solve\nproblems faster and deliver a better end\nuser experience in a variety of fields\nfor example algorithms are used in the\nsequencing of dna and more efficient\nsequencing algorithms allow us to\nresearch and understand diseases better\nand faster but let's not get ahead of\nourselves we'll start simple by\nevaluating john's linear search\nalgorithm in terms of its efficiency\nfirst what do we mean by efficiency\nthere are two measures of efficiency\nwhen it comes to algorithms time and\nspace sounds really cool and very sci-fi\nhuh\nefficiency measured by time something\nyou'll hear called time complexity is a\nmeasure of how long it takes the\nalgorithm to run\ntime complexity can be understood\ngenerally outside the context of code\nand computers because how long it takes\nto complete a job is a universal measure\nof efficiency the less time you take the\nmore efficient you are\nthe second measure of efficiency is\ncalled space complexity and this is\npretty computer specific\nit deals with the amount of memory taken\nup on the computer\ngood algorithms need to balance between\nthese two measures to be useful\nfor example you can have a blazingly\nfast algorithm but it might not matter\nif the algorithm consumes more memory\nthan you have available\nboth of these concepts time and space\ncomplexity are measured using the same\nmetric but it is a very technical\nsounding metric so let's build up to it\nslowly and start simple\na few videos ago i played a game with\nbrittany and john where they tried to\nguess the number i was thinking of\neffectively they were searching for a\nvalue\nso how do we figure out how efficient\neach algorithm is and which algorithm\nwas more suited to our purposes\nif we consider the number of tries they\ntook to guess or search for the value as\nan indicator of the time they take to\nrun through the exercise this is a good\nindicator of how long the algorithm runs\nfor a given set of values\nthis measurement is called the running\ntime of an algorithm and we'll use it to\ndefine time complexity\nin the game we play it four rounds let's\nrecap those here focusing on john's\nperformance\nin round one we had 10 values the target\nwas 3 and john took 3 turns\nin round 2 we had 10 values the target\nwas 10 and john took 10 turns\nin round 3 we had 100 values the target\nwas\njohn took five tries and finally in\nround four when the target was 100 given\n100 values john took 100 tries\non paper it's hard to gauge anything\nabout this performance\nwhen it comes to anything with numbers\nthough i like to put it up on a graph\nand compare visually\non the vertical or y-axis let's measure\nthe number of tries it took john to\nguess the answer or the running time of\nthe algorithm on the horizontal or\nx-axis what do we put\nfor each turn we have a number of values\nas well as a target value\nwe could plot the target value on the\nhorizontal axis but that leaves some\ncontext and meaning behind it's far more\nimpressive that john took five tries\nwhen the range went up to 100 then when\nhe took three tries for a maximum of 10\nvalues\nwe could plot the maximum range of\nvalues but then we're leaving out the\nother half of the picture\nthere are data points however that\nsatisfy both requirements\nif we only plot the values where the\ntarget the number john was looking for\nwas the same as the maximum range of\nvalues we have a data point that\nincludes both the size of the data set\nas well as his effort\nthere's an additional benefit to this\napproach as well\nthere are three ways we can measure how\nwell john does or in general how well\nany algorithm does\nfirst we can check how well john does in\nthe best case or good scenarios from the\nperspective of his strategy\nin the range of 100 values the answer\nbeing a low number like three at the\nstart of the range is a good scenario he\ncan guess it fairly quickly one is his\nbest case scenario\nor we could check how well he does on\naverage we could run this game a bunch\nof times and average out the running\ntime\nthis would give us a much better picture\nof john's performance over time but our\nestimates would be too high if the value\nhe was searching for was at the start of\nthe range or far too low if it was at\nthe end of the range\nlet's imagine a scenario where facebook\nnaively implements linear search when\nfinding friends\nthey looked at the latest u.s census saw\nthat 50 of names start with the letters\na through j which is the first 40 of the\nalphabet and thought okay on average\nlinear search serves us well\nbut what about the rest of those whose\nnames start with the letter after j in\nthe alphabet\nsearching for my name would take longer\nthan the average and much longer for\nsomeone whose name starts with the\nletter z\nso while measuring the run time of an\nalgorithm on average might seem like a\ngood strategy it won't necessarily\nprovide an accurate picture\nby picking the maximum in the range\nwe're measuring how our algorithm does\nin the worst case scenario\nanalyzing the worst case scenario is\nquite useful because it indicates that\nthe algorithm will never perform worse\nthan we expect there's no room for\nsurprises\nback to our graph we're going to plot\nthe number of tries a proxy for running\ntime of the algorithm against the number\nof values in the range which will\nshorten to n\nn here also represents john's worst case\nscenario when n is 10 he takes 10 turns\nwhen n is 100 he takes 100 turns\nbut these two values alone are\ninsufficient to really get any sort of\nvisual understanding moreover it's not\nrealistic\njohn may take a long time to work\nthrough 100 numbers but a computer can\ndo that in no time\nto evaluate the performance of linear\nsearch in the context of a computer we\nshould probably throw some harder and\nlarger ranges of values at it\nthe nice thing is by evaluating a worst\ncase scenario we don't actually have to\ndo that work\nwe know what the result will be for a\ngiven value of n using linear search it\nwill take n tries to find the value in\nthe worst case scenario so let's add a\nfew values in here to build out this\ngraph\nokay so we have a good picture of what\nthis is starting to look like as the\nvalues get really large the running time\nof the algorithm gets large as well\nwe sort of already knew that\nbefore we dig into this runtime any\ndeeper let's switch tracks and evaluate\nbrittany's work\nby having something to compare against\nit should become easier to build a\nmental model around time complexity\nthe algorithm john used linear search\nseemed familiar to us and you could\nunderstand it because it's how most of\nus search for things in real life anyway\nbrittany's approach on the other hand\ngot results quickly but it was a bit\nharder to understand so let's break it\ndown\njust like john's approach britney\nstarted with a series of values or a\nlist of numbers as her input\nwhere john just started at the beginning\nof the list and searched sequentially\nbrittany's strategy is to always start\nin the middle of the range\nfrom there she asks a comparison\nquestion\nis the number in the middle of the range\nequal to the answer she's looking for\nand if it's not is it greater than or\nless than the answer\nif it's greater than she can eliminate\nall the values less than the one she's\ncurrently evaluating if it's lesser than\nthe answer she can eliminate all the\nvalues greater than the one she's\ncurrently evaluating\nwith the range of values that she's left\nover with she repeats this process until\nshe arrives at the answer\nlet's visualize how she did this by\nlooking at round three\nin round three the number of values in\nthe range was 100 the answer was 5.\nthe bar here represents the range of\nvalues one of the left 100 at the right\nand this pointer represents the value\nbritney chooses to evaluate\nso she starts in the middle at 50. she\nasks is it equal to the answer i say\nit's too high so this tells her that the\nvalue she is evaluating is greater than\nour target value which means there's no\npoint in searching any of the values to\nthe right of 50 that is values greater\nthan 50 in this range so she can discard\nthose values altogether\nshe only has to consider values from 1\nto 50 now\nthe beauty of this strategy and the\nreason why britney was able to find the\nanswer in such few turns is that with\nevery value she evaluates she can\ndiscard half of the current range\non her second turn she picks the value\nin the middle of the current range which\nis 25. she asks the same question i say\nthat the value is too high again and\nthis tells her that she can discard\neverything greater than 25 and the range\nof values drops from 1 to 25.\nagain she evaluates the number in the\nmiddle roughly so that'd be 13 here i\ntell her this is still too high she\ndiscards the values greater moves to\nvalue at 7 which is still too high\nthen she moves to 4 which is now too low\nshe can discard everything less than 4\nwhich leaves the numbers 4 through 7.\nhere she picked 6 which was too high\nwhich only leaves one value 5.\nthis seems like a lot of work but being\nable to get rid of half the values with\neach turn is what makes this algorithm\nmuch more efficient\nnow there's one subtlety to using binary\nsearch and you might have caught on to\nthis\nfor this search method to work as we've\nmentioned the values need to be sorted\nwith linear search it doesn't matter if\nthe values are sorted since a linear\nsearch algorithm just progresses\nsequentially checking every element in\nthe list if the target value exists in\nthe list it will be fouled but let's say\nthis range of values 100 was unsorted\nbritney would start at the middle with\nsomething like 14 and ask if this value\nwas too low or too high i say it's too\nhigh so she discards everything less\nthan 14.\nnow this example starts to fall apart\nhere because well britney knows what\nnumbers are less than 14 and greater\nthan one she doesn't need an actual\nrange of values to solve this a computer\nhowever does need that\nremember search algorithms are run\nagainst lists containing all sorts of\ndata it's not always just a range of\nvalues containing numbers\nin a real use case of binary search\nwhich we're going to implement in a bit\nthe algorithm wouldn't return the target\nvalue because we already know that it's\na search algorithm so we're providing\nsomething to search for instead what it\nreturns is the position in the list that\nthe target occupies without the list\nbeing sorted a binary search algorithm\nwould discard all the values to the left\nof 14 which over here could include the\nposition where our target value is\neventually we'd get a result back saying\nthe target value doesn't exist in the\nlist which is inaccurate\nearlier when defining linear simple\nsearch i said that the input was a list\nof values and the output was the target\nvalue or more specifically the position\nof the target value in the list\nso with binary search there's also that\nprecondition the input list must be\nsorted so let's formally define binary\nsearch\nfirst the input a sorted list of values\nthe output the position in the list of\nthe target value we're searching for or\nsome sort of values indicate that the\ntarget does not exist in the list\nremember our guidelines for defining an\nalgorithm let me put those up again\nreally quick\nthe steps in the algorithm need to be in\na specific order the steps also need to\nbe very distinct\nthe algorithms should produce a result\nand finally the algorithm should\ncomplete in a finite amount of time\nlet's use those to define this algorithm\nstep one we determine the middle\nposition of the sorted list\nstep two we compare the element in the\nmiddle position to the target element\nstep three if the elements match we\nreturn the middle position and end\nif they don't match in step 4 we check\nwhether the element in the middle\nposition is smaller than the target\nelement\nif it is then we go back to step 2 with\na new list that goes from the middle\nposition of the current list to the end\nof the current list\nin step five if the element in the\nmiddle position is greater than the\ntarget element then again we go back to\nstep two with a new list that goes from\nthe start of the current list to the\nmiddle position of the current list\nwe repeat this process until the target\nelement is found or until a sub list\ncontains only one element\nif that single element sublist does not\nmatch the target element then we end the\nalgorithm indicating that the element\ndoes not exist in the list\nokay so that is the magic behind how\nbritney managed to solve the round much\nfaster\nin the next video let's talk about the\nefficiency of binary search\n[Music]\nwe have a vague understanding that\nbritney's approach is better in most\ncases but just like with linear search\nit helps to visualize this\nmuch like we did with linear search when\ndetermining the efficiency of an\nalgorithm and remember we're still only\nlooking at efficiency in terms of time\ntime complexity as it's called we always\nwant to evaluate how the algorithm\nperforms in the worst case scenario now\nyou might be thinking well that doesn't\nseem fair because given a series of data\nif the target value we're searching for\nis somewhere near the front of the list\nthen linear search may perform just as\nwell if not slightly better than binary\nsearch and that is totally true\nremember a crucial part of learning\nalgorithms is understanding what works\nbetter in a given context\nwhen measuring efficiency though we\nalways use the worst case scenarios as a\nbenchmark because remember it can never\nperform worse than the worst case\nlet's plot these values on the graph we\nstarted earlier with the number of tris\nor the runtime of the algorithm on the y\naxis and the maximum number of values in\nthe series or n on the horizontal axis\nto represent the worst case scenario we\nhave two data points when n equals 10\nbritney took four tries using binary\nsearch and when n equals 100 it took\nseven tries\nbut even side by side these data points\nare sort of meaningless\nremember that while there is quite a\ndifference between the run time of\nlinear search and binary search at an n\nvalue of 100 for a computer that\nshouldn't matter\nwhat we should check out is how the\nalgorithm performs at levels of n that\nmight actually slow a computer down\nas n grows larger and larger how do\nthese algorithms compare to one another\nlet's add that to the graph\nokay now a picture starts to emerge\nas n gets really large the performance\nof these two algorithms differs\nsignificantly\nthe difference is kind of staggering\nactually\neven with the simple game we saw that\nbinary search was better but now we have\na much more complete idea of how much\nbetter\nfor example when n is 1000 the runtime\nof linear search measured by the number\nof operations or turns is also 1000.\nfor binary search it takes just 10\noperations\nnow let's look at what happens when we\nincrease n by factor of 10\nat 10 000 linear search takes 10 000\noperations while binary search takes 14\noperations\nand increased by a factor of 10 in\nbinary search only needs four more\noperations to find a value\nif we increase it again by a factor of\n10 once more to an n value of 100 000\nbinary search takes only 17 operations\nit is blazing fast\nwhat we've done here is plotted on a\ngraph how the algorithm performs as the\ninput set it is working on increases\nin other words we've plotted the growth\nrate of the algorithm also known as the\norder of growth\ndifferent algorithms grow at different\nrates and by evaluating their growth\nrates we get a much better picture of\ntheir performance because we know how\nthe algorithm will hold up as n grows\nlarger\nthis is so important in fact it is the\nstandard way of evaluating an algorithm\nand brings us to a concept called big o\nyou might have heard this word thrown\nabout and if you found it confusing\ndon't worry we've already built up a\ndefinition in the past few videos we\njust need to bring it all together\nlet's start with a common statement\nyou'll see in studies on algorithms\nbig o is a theoretical definition of the\ncomplexity of an algorithm as a function\nof the size\nwow what a mouthful this sounds really\nintimidating but it's really not let's\nbreak it down\nbig o is a notation used to describe\ncomplexity and what i mean by notation\nis that it simplifies everything we've\ntalked about down into a single variable\nan example of complexity written in\nterms of big o looks like this\nas you can see it starts with an\nuppercase letter o that's why we call it\nbig o it's literally a big o\nthe o comes from order of magnitude of\ncomplexity so that's where we get the\nbig o from now complexity here refers to\nthe exercise we've been carrying out in\nmeasuring efficiency\nif it takes brittany 4 tries when n is\n10\nhow long does the algorithm take when n\nis 10 million\nwhen we use big o for this the variable\nused which we'll get to distills that\ninformation down so that by reading the\nvariable you get a big picture view\nwithout having to run through data\npoints and graphs just like we did\nit's important to remember that\ncomplexity is relative\nwhen we evaluate the complexity of the\nbinary search algorithm we're doing it\nrelative to other search algorithms not\nall algorithms\nbigo is a useful notation for\nunderstanding both time and space\ncomplexity but only when comparing\namongst algorithms that solve the same\nproblem\nthe last bit in that definition of big o\nis a function of the size and all this\nmeans is that big o measures complexity\nas the input size grows because it's not\nimportant to understand how an algorithm\nperforms in a single data set but in all\npossible data sets\nyou will also see big o referred to as\nthe upper bound of the algorithm and\nwhat that means is that big o measures\nhow the algorithm performs in the worst\ncase scenario\nso that's all big o is\nnothing special it's just a notation\nthat condenses the data points and\ngraphs that we've built up down to one\nvariable okay so what do these variables\nlook like\nfor john's strategy linear search we say\nthat it has a time complexity of big o\nand then n so that's again big o with an\nn inside parentheses\nfor britney strategy binary search we\nsay that it has a time complexity of big\no of log n that's big o with something\ncalled a log and an n inside parentheses\nnow don't worry if you don't understand\nthat we'll go into that in more detail\nlater on in the course\neach of these has a special meaning but\nit helps to work through all of them to\nget a big picture view so over the next\nfew videos let's examine what are called\ncommon complexities or common values of\nbig o that you will run into and should\ninternalize\nin our discussions of complexity we made\none assumption that the algorithm as a\nwhole had a single measure of complexity\nthat isn't true and we'll get at how we\narrive at these measures for the entire\nalgorithm at the end of this exercise\nbut each step in the algorithm has its\nown space and time complexity\nin linear search for example there are\nmultiple steps and the algorithm goes\nlike this\nstart at the beginning of the list or\nrange of values compare the current\nvalue to the target if the current value\nis the target value that we're looking\nfor we're done\nif it's not we'll move on sequentially\nto the next value in the list and repeat\nstep two\nif we reach the end of the list then the\ntarget value is not in the list\nlet's go back to step two for a second\ncomparing the current value to the\ntarget\ndoes the size of the data set matter for\nthis step\nwhen we're at step two we're already at\nthat position in the list and all we're\ndoing is reading the value to make a\ncomparison reading the value is a single\noperation and if we were to plot it on a\ngraph of runtime per operations against\nn it looks like this a straight line\nthat takes constant time regardless of\nthe size of n since this takes the same\namount of time in any given case we say\nthat the run time is constant time it\ndoesn't change\nin big o notation we represent this as\nbig o with a 1 inside parentheses now\nwhen i first started learning all this i\nwas really confused as to how to read\nthis even if it was in my own head\nshould i say big o of one\nwhen you see this written you're going\nto read this as constant time so reading\na value in a list is a constant time\noperation\nthis is the most ideal case when it\ncomes to run times because input size\ndoes not matter and we know that\nregardless of the size of n the\nalgorithm runtime will remain the same\nthe next step up in complexity so to\nspeak is the situation we encountered\nwith the binary search algorithm\ntraditionally explaining the time\ncomplexity of binary search involves\nmath i'm going to try to do it both with\nand without\nwhen we played the game using binary\nsearch we notice that with every turn we\nwere able to discard half of the data\nbut there's another pattern that emerges\nthat we didn't explore\nlet's say n equals 10. how long does it\ntake to find an item at the 10th\nposition of the list we can write this\nout so we go from 10 to 5 to 8 to 9 and\nthen down to 10.\nhere it takes us four tries to cut down\nthe list to just one element and find\nthe value we're looking for\nlet's double the value of n to 20 and\nsee how long it takes for us to find an\nitem at the 20th position so we start at\n20 and then we pick 10 from there we go\nto 15 17 19 and finally 20.\nso here it takes us five tries\nokay let's double it again so that n is\n40 and we try to find the item in the\n40th position\nso when we start at 40 the first\nmidpoint we're going to pick is 20 from\nthere we go to 30 then 35 37 39 and then\n40.\nnotice that every time we double the\nvalue of n the number of operations it\ntakes to reduce the list down to a\nsingle element only increases by 1.\nthere's a mathematical relationship to\nthis pattern and it's called a logarithm\nof n\nyou don't really have to know what\nlogarithms truly are but i know that\nsome of you like underlying explainers\nso i'll give you a quick one\nif you've taken algebra classes you may\nhave learned about exponents here's a\nquick refresher\n2 times 1 equals 2. now this can be\nwritten as 2 raised to the first power\nbecause it is our base case two times\none is two\nnow two times two is four this can be\nwritten as two raised to the second\npower because we're multiplying two\ntwice first we multiply two times one\nthen the result of that times 2.\n2 times 2 times 2 is 8 and we can write\nthis as 2 raised to the 3rd power\nbecause we're multiplying 2 3 times\nin 2 raised to 2 and 2 raised to 3 the 2\nand 3 there are called exponents and\nthey define how the number grows\nwith 2 raised to 3 we start with the\nbase value and multiply itself 3 times\nthe inverse of an exponent is called a\nlogarithm so if i say log to the base 2\nof 8 equals 3 i'm basically saying the\nopposite of an exponent\ninstead of saying how many times do i\nhave to multiply this value i'm asking\nhow many times do i have to divide 8 by\ntwo to get the value one\nthis takes three operations\nwhat about the result of log to the base\ntwo of sixteen that evaluates to four\nso why does any of this matter\nnotice that this is sort of how binary\nsearch works\nlog to the base 2 of 16 is 4.\nif n was 16 how many triads does it take\nto get to that last element\nwell we start in the middle at 8 that's\ntoo low so we move to 12 then we move to\n14 then to 15 and then to 16 which is 5\ntries or log to the base 2 of 16 plus 1.\nin general for a given value of n the\nnumber of tries it takes to find the\nworst case scenario\nis log of n plus one\nand because this pattern is overall a\nlogarithmic pattern we say that the\nruntime of such algorithms is\nlogarithmic\nif we plot these data points on our\ngraph a logarithmic runtime looks like\nthis\nin big o notation we represent a\nlogarithmic runtime as big o of log n\nwhich is written as big o with log n\ninside parentheses or even sometimes as\nl n n inside parentheses\nwhen you see this read it as logarithmic\ntime\nas you can see on the graph as n grows\nreally large the number of operations\ngrows very slowly and eventually\nflattens out\nsince this line is below the line for a\nlinear runtime which we'll look at in a\nsecond you might often hear algorithms\nwith logarithmic runtimes being called\nsublinear\nlogarithmic or sub-linear runtimes are\npreferred to linear because they're more\nefficient but in practice linear search\nhas its own set of advantages which\nwe'll take a look at in the next video\nnext up let's look at the situation we\nencountered with the linear search\nalgorithm\nwe saw that in the worst case scenario\nwhatever the value of n was john took\nexactly that many tries to find the\nanswer\nas in linear search when the number of\noperations to determine the result in\nthe worst case scenario is at most the\nsame as n\nwe say that the algorithm runs in linear\ntime\nwe represent this as big o of n now you\ncan read that as big o of n like i just\nsaid or you can say linear time which is\nmore common\nwhen we put that up on a graph against\nconstant time and logarithmic time we\nget a line that looks like this\nany algorithm that sequentially reads\nthe input will have linear time\nso remember anytime you know a problem\ninvolves reading every item in a list\nthat means a linear run time as you saw\nfrom the game we played brittany's\nstrategy using binary search was clearly\nbetter and we can see that on the graph\nso if we had the option why would we use\nlinear search which runs in linear time\nremember that binary search had a\nprecondition the input set had to be\nsorted\nwhile we won't be looking at sorting\nalgorithms in this course as you learn\nmore about algorithms you'll find that\nsorting algorithms have varying\ncomplexities themselves just like search\ndoes so we have to do additional work\nprior to using binary search\nfor this reason in practice linear\nsearch ends up being more performant up\nto a certain value of n because the\ncombination of sorting first and then\nsearching using binary search adds up\nthe next common complexity you will hear\nabout is when an algorithm runs in\nquadratic time if the word quadratic\nsounds familiar to you it's because you\nmight have heard about it in math class\nquadratic is a word that means an\noperation raised to the second power or\nwhen something is squared\nlet's say you and your friends are\nplaying a tower defense game and to\nstart it off you're going to draw a map\nof the terrain\nthis map is going to be a grid and you\npick a random number to determine how\nlarge this grid is let's set n the size\nof the grid to four\nnext you need to come up with a list of\ncoordinates so you can place towers and\nenemies and stuff on this map so how\nwould we do this\nif we start out horizontally we'd have\ncoordinate points that go 1 1 1 2 1 3\nand 1 4.\nthen you go up one level vertically and\nwe have points 2 1 2 2 2 3 and 2 4.\ngo up one more and you have the points 3\n1 3 2 3 3 and 3 4 and on that last row\nyou have the points 4 1 4 2 4 3 and 4 4.\nnotice that we have a pattern here\nfor each row we take the value and then\ncreate a point by adding to that every\ncolumn value\nthe range of values go from 1 to the\nvalue of n\nso we can generally think of it this way\nfor the range of values from 1 to n for\neach value in that range we create a\npoint by combining that value with the\nrange of values from 1 to n again\ndoing it this way for each value in the\nrange of 1 to n we create an n number of\nvalues and we end up with 16 points\nwhich is also n times n or n squared\nthis is an algorithm with a quadratic\nruntime because for any given value of n\nwe carry out n squared number of\noperations\nnow i picked a relatively easy so to\nspeak example here because in english at\nleast we often denote map sizes by\nheight times width so we would call this\na 4 by 4 grid which is just another way\nof saying 4 squared or n squared\nin big o notation we would write this as\nbig o of n squared or say that this is\nan algorithm with a quadratic runtime\nmany search algorithms have a worst case\nquadratic runtime which you'll learn\nabout soon\nnow in addition to quadratic runtimes\nyou may also run into cubic runtimes as\nyou encounter different algorithms in\nsuch an algorithm for a given value of n\nthe algorithm executes n raised to the\nthird power number of operations\nthese aren't as common as quadratic\nalgorithms though so we won't look at\nany examples but i think it's worth\nmentioning\nthrown up on our graph quadratic and\ncubic runtimes look like this\nso this is starting to look pretty\nexpensive computationally as they say we\ncan see here that for small changes in n\nthere's a pretty significant change in\nthe number of operations that we need to\ncarry out\nthe next worst case runtime we're going\nto look at is one that's called\nquasi-linear and a sort of easier to\nunderstand for lack of better word by\nstarting with the big o notation\nquasi-linear runtimes are written out as\nbig o of n times log n\nwe learned what log n was right a\nlogarithmic runtime whereas n grew the\nnumber of operations only increased by a\nsmall factor with a quasi-linear runtime\nwhat we're saying is that for every\nvalue of n we're going to execute a log\nn number of operations hence the run\ntime of n times log n\nso you saw earlier with the quadratic\nruntime that for each value of n we\nconducted n operations it's sort of the\nsame in that as we go through the range\nof values in n we're executing login\noperations\nin comparison to other runtimes a\nquasi-linear algorithm has a runtime\nthat lies somewhere between a linear\nruntime and a quadratic runtime\nso where would we expect to see this\nkind of runtime in practical use\nwell sorting algorithms is one place you\nwill definitely see it\nmerge sort for example is a sorting\nalgorithm that has a worst case runtime\nof big o of n log n\nlet's take a look at a quick example\nlet's say we start off with a list of\nnumbers that looks like this and we need\nto sort it\nmerge sort starts by splitting this list\ninto two lists down the middle\nit then takes each sub list and splits\nthat in half down the middle again\nit keeps doing this until we end up with\na list of just a single number\nwhen we're down to single numbers we can\ndo one sort operation and merge these\nsub-lists back in the opposite direction\nthe first part of merge sort cuts those\nlists into sub-lists with half the\nnumbers\nthis is similar to binary search where\neach comparison operation cuts down the\nrange to half the values\nyou know the worst case runtime in\nbinary search is log n so these\nsplitting operations have the same\nruntime big o of log n or logarithmic\nbut splitting into half isn't the only\nthing we need to do with merge sort we\nalso need to carry out comparison\noperations so we can sort those values\nand if you look at each step of this\nalgorithm we carry out an n number of\ncomparison operations and that brings\nthe worst case runtime of this algorithm\nto n times log n also known as quasi\nlinear don't worry if you didn't\nunderstand how merge sort works that\nwasn't the point of this demonstration\nwe will be covering merge sorts soon in\na future course\nthe run times we've looked at so far are\nall called polynomial runtimes an\nalgorithm is considered to have a\npolynomial runtime if for a given value\nof n its worst case runtime is in the\nform of n raised to the k power where k\njust means some value so it could be n\nsquared where k equals 2 for a quadratic\nruntime n cubed for a cubic runtime and\nso on\nall of those are in the form of n raised\nto some power\nanything that is bounded by this and\nwhat i mean by that is if we had a\nhypothetical line on our graph of n\nraised to the k power anything that\nfalls under this graph is considered to\nhave a polynomial runtime\nalgorithms with an upper bound or a\nruntime with a big o value that is\npolynomial are considered efficient\nalgorithms and are likely to be used in\npractice\nnow the next class of runtimes that\nwe're going to look at are a runtimes\nthat we don't consider efficient and\nthese are called exponential runtimes\nwith these runtimes as n increases\nslightly the number of operations\nincreases exponentially and as we'll see\nin a second these algorithms are far too\nexpensive to be used\nan exponential runtime is an algorithm\nwith a big o value of some number raised\nto the nth power\nimagine that you wanted to break into a\nlocker that had a padlock on it let's\nassume you forgot your code\nthis lock takes a two digit code and the\ndigit for the code ranges from zero to\nnine\nyou start by setting the dials to zero\nand then with the first dial remaining\non zero you change the second dial to\none and try and open it if it doesn't\nwork you set it to two then try again\nyou would keep doing this and if you\nstill haven't succeeded with the second\ndial set to 9 then you go back to that\nfirst dial set it to 1 and start the\nsecond dial over\nthe range of values you'd have to go\nthrough is 0 0 to 9 9 which is 100\nvalues\nthis can be generalized as 10 to the\nsecond power since there are 10 values\non each dial raised to two dials\nsearching through each individual value\nuntil you stumble on the right one is a\nstrategy called brute force and brute\nforce algorithms have exponential run\ntimes\nhere there are two dials so n is 2 and\neach dial has 10 values so again we can\ngeneralize this algorithm as 10 raised\nto n where n represents the number of\ndials\nthe reason that this algorithm is so\ninefficient is because with just one\nmore dial on the lock the number of\noperations increases significantly\nwith three dials the number of\ncombinations in the worst case scenario\nwhere the correct code is the last digit\nin the range is 10 raised to 3 or 1 000\nvalues\nwith an additional wheel it becomes 10\nraised to 4 or 10 000 values\nas n increases the number of operations\nincreases exponentially to a point where\nit's unsolvable in a realistic amount of\ntime\nnow you might think well any computer\ncan crack a four digit numerical lock\nand that's true because n here is\nsufficiently small but this is the same\nprinciple that we use for passwords\nin a typical password field implemented\nwell users are allowed to use letters of\nthe english alphabet so up to 26\ncharacters numbers from 0 to 9 and a set\nof special characters of which there can\nbe around 33\nso typically that means each character\nin a password can be one out of 69\nvalues\nthis means that for a one character\npassword it takes 69 to the nth power so\n1 which equals 69 operations in the\nworst case scenario to figure out the\npassword\njust increasing n to 2 increases the\nnumber of operations needed to guess the\npassword to 69 squared or\n4761 operations\nnow usually on a secure website there\nisn't really a limit but in general\npasswords are limited to around 20\ncharacters in length\nwith each character being a possible 69\nvalues and there being 20 characters the\nnumber of operations needed to guess the\npassword in the worst case scenario is\n69 raised to the 20th power or\napproximately 6 followed by 36 zeros\nnumber of operations\nan intel cpu with five cores can carry\nout roughly about 65 000 million\ninstructions per second that's a funny\nnumber i know to crack our 20-digit\npasscode in this very simplistic model\nit would take this intel cpu\nto race to 20th power years to brute\nforce the password\nso while this algorithm would eventually\nproduce a result it is so inefficient\nthat it's pointless\nthis is one of the reasons why people\nrecommend you have longer passwords\nsince brute forcing is exponential in\nthe worst case each character you add\nincreases the number of combinations by\nan exponent\nthe next class of exponential algorithms\nis best highlighted by a popular problem\nknown as the traveling salesman\nthe problem statement goes like this\ngiven a list of cities and the distance\nbetween each pair of cities what is the\nshortest possible route that visits each\ncity and then returns to the origin city\nthis seems like a simple question but\nlet's start with a simple case three\ncities a b and c\nto figure out what the shortest route is\nwe need to come up with all the possible\nroutes\nwith three cities we have six routes in\ntheory at least some of these routes can\nbe discarded because abc is the same as\nc b a but in the opposite direction\nbut as we do know sometimes going from a\nto c through b may go through a\ndifferent route than c to a through b so\nwe'll stick to the six routes and from\nthere we could determine the shortest no\nbig deal\nnow if we increase this to four cities\nwe jump to 24 combinations\nthe mathematical relationship that\ndefines this is called a factorial and\nis written out as n followed by an\nexclamation point\nfactorials are basically n times n minus\none repeated until you reach the number\none so for example the factorial of\nthree is three times two times one which\nis six which is the number of\ncombinations we came up with for three\ncities\nthe factorial of four is four times\nthree times two times one or 24 which is\nthe number of combinations we arrived at\nwith four cities\nin solving the traveling salesman\nproblem the most efficient algorithm\nwill have a factorial runtime or a\ncombinatorial runtime as it's also\ncalled\nat low values of n algorithms with a\nfactorial runtime may be used but with\nan n value of say 200 it would take\nlonger than humans have been alive to\nsolve the problem\nfor sake of completeness let's plot a\ncombinatorial runtime on our graph so\nthat we can compare\nan algorithm such as one that solves the\ntraveling salesman problem as a worst\ncase run time of big o of n factorial\nstudying exponential runtimes like this\nare useful for two reasons\nfirst in studying how to make such\nalgorithms efficient we develop\nstrategies that are useful across the\nboard and can potentially be used to\nmake existing algorithms even more\nefficient\nsecond it's important to be aware of\nproblems that take a long time to solve\nknowing right off the bat that a problem\nis somewhat unsolvable in a realistic\ntime means you can focus your efforts on\nother aspects of the problem\nas beginners though we're going to steer\nclear of all this and focus our efforts\non algorithms with polynomial runtimes\nsince we're much more likely to work\nwith and learn about such algorithms\nnow that we know some of the common\ncomplexities in the next video let's\ntalk about how we determine the\ncomplexity of an algorithm because there\nare some nuances\nover the last few videos we took a look\nat common complexities that we would\nencounter in studying algorithms but the\nquestion remains how do we determine\nwhat the worst case complexity of an\nalgorithm is\nearlier i mentioned that even though we\nsay that an algorithm has a particular\nupper bound or worst case runtime each\nstep in a given algorithm can have\ndifferent run times\nlet's bring up the steps for binary\nsearch again\nassuming the list is sorted the first\nstep is to determine the middle position\nof the list\nin general this is going to be a\nconstant time operation\nmany programming languages hold on to\ninformation about the size of the list\nso we don't actually need to walk\nthrough the list to determine the size\nnow if we didn't have information about\nthe size of the list we would need to\nwalk through counting each item one by\none until we reached the end of the list\nand this is a linear time operation but\nrealistically this is a big o of 1 or\nconstant time\nstep 2 is to compare the element in the\nmiddle position to the target element\nwe can assume that in most modern\nprogramming languages this is also a\nconstant time operation because the\ndocumentation for the language tells us\nit is\nstep 3 is our success case and the\nalgorithm ends\nthis is our best case and so far we have\nonly incurred two constant time\noperations\nso we would say that the best case run\ntime of binary search is constant time\nwhich is actually true\nbut remember that best case is not a\nuseful metric\nstep 4 if we don't match is splitting\nthe list into sub-lists\nassuming the worst case scenario the\nalgorithm would keep splitting into\nsub-lists until a single element list is\nreached with the value that we're\nsearching for\nthe run time for this step is\nlogarithmic since we discard half the\nvalues each time\nso in our algorithm we have a couple\nsteps that are constant time and one\nstep that is logarithmic overall\nwhen evaluating the run time for an\nalgorithm we say that the algorithm has\nas its upper bound the same runtime as\nthe least efficient step in the\nalgorithm\nthink of it this way let's say you're\nparticipating in a triathlon which is a\nrace that has a swimming running and a\ncycling component\nyou could be a phenomenal swimmer and a\nreally good cyclist but you're a pretty\nterrible runner\nno matter how fast you are at swimming\nor cycling your overall race time is\ngoing to be impacted the most by your\nrunning race time because that's the\npart that takes you the longest\nif you take an hour 30 to finish the\nrunning component 55 minutes to swim and\n38 minutes to bike it won't matter if\nyou can fine tune your swimming\ntechnique down to finish in 48 minutes\nand your cycle time to 35 because you're\nstill bounded at the top by your running\ntime which is close to almost double\nyour bike time\nsimilarly with the binary search\nalgorithm it doesn't matter how fast we\nmake the other steps they're already as\nfast as they can be\nin the worst case scenario the splitting\nof the list down to a single element\nlist is what will impact the overall\nrunning time of your algorithm\nthis is why we say that the time\ncomplexity or run time of the algorithm\nin the worst case is big o of log n or\nlogarithmic\nas i alluded to though your algorithm\nmay hit a best case runtime and in\nbetween the two best and worst case have\nan average run time as well\nthis is important to understand because\nalgorithms don't always hit their worst\ncase but this is getting a bit too\ncomplex for us for now we can safely\nignore average case performances and\nfocus only on the worst case in the\nfuture if you decide to stick around\nwe'll circle back and talk about this\nmore\nnow that you know about algorithms\ncomplexities and big o let's take a\nbreak from all of that and write code in\nthe next video\n[Music]\nso far we've spent a lot of time in\ntheory and while these things are all\nimportant things to know you get a much\nbetter understanding of how algorithms\nwork when you start writing some code as\ni mentioned earlier we're going to be\nwriting python code in this and all\nsubsequent algorithm courses\nif you do have programming experience\nbut in another language check the notes\nsection of this video for an\nimplementation in your language\nif you don't have any experience i'll\ntry my best explain as we go along\non the video you're watching right now\nyou should see a launch workspaces\nbutton\nwe're going to use a treehouse coding\nenvironment call workspaces to write all\nof our code\nif you're familiar with using python in\na local environment then feel free to\nkeep doing so workspaces is an\nin-browser coding environment and will\ntake care of all the setup and\ninstallation so you can focus on just\nwriting and evaluating code workspaces\nis quite straightforward to use on the\nleft here we have a file navigator pane\nwhich is currently empty since we\nhaven't created a new file\non the top we have an editor where we\nwrite all our code and then below that\nwe have a terminal or a command line\nprompt where we can execute the scripts\nthat we write let's add a new file here\nso at the top in the editor area we're\ngoing to go to file new file and we'll\nname this linear\nunderscore search\ndot pi\nin here we're going to define our linear\nsearch algorithm as a standalone\nfunction\nwe start with the keyword def which\ndefines a function or a block of code\nand then we give it the name linear\nunderscore search\nthis function will accept two arguments\nfirst the list we're searching through\nand then the target value we're looking\nfor both of these arguments are enclosed\nin a set of parentheses and there's no\nspace between the name of the function\nand the arguments\nafter that we have a colon\nnow there might be a bit of confusion\nhere since we already have this target\nvalue what are we searching for unlike\nthe game we played at the beginning\nwhere john's job was to find the value\nin a true implementation of linear\nsearch we're looking for the position in\nthe list where the value exists\nif the target is in the list then we\nreturn its position\nand since this is a list that position\nis going to be denoted by an index value\nnow if the target is not found we're\ngoing to return none the choice of what\nto return in the failure case may be\ndifferent in other implementations of\nlinear search\nyou can return -1 since that isn't\ntypically an index value\nyou can also raise an exception which is\npython speak for indicating an error\noccurred\nnow i think for us the most\nstraightforward value we can return here\nis none now let's add a comment to\nclarify this so hit enter to go to the\nnext line\nand then we're going to add\nthree\nsingle quotes\nand then below that on the next line\nwe'll say returns\nthe position or the index\nposition\nof the target\nif found\nelse returns none\nand then on the next line we'll close\noff those three quotes\nthis is called a doc string and is a\npython convention for documenting your\ncode the linear search algorithm is a\nsequential algorithm that compares each\nitem in the list until the target is\nfound\nto iterate or loop or walk through our\nlist sequentially we're going to use a\nfor loop\nnow typically when iterating over a list\nin python we would use a loop like this\nwe'd say for item in list\nthis assigns the value at each index\nposition to that local variable item\nwe don't want this though since we\nprimarily care about the index position\ninstead we're going to use the range\nfunction in python to create a range of\nvalues that start at 0 and end at the\nnumber of items in the list\nso we'll say 4 i i stands for index here\nin range\nstarting at 0 and going all the way up\nto the length of the list\nwe can get the number of items in the\nlist using the len function\nnow going back to our talk on complexity\nand how individual steps in an algorithm\ncan have its own run times this is a\nline of code that we would have to be\ncareful about\npython keeps track of the length of a\nlist so this function call here len list\nis a constant time operation now if this\nwere a naive implementation let's say we\nwrote the implementation of the list\nand we iterate over the list every time\nwe call this length function then we've\nalready incurred a linear cost\nokay so once we have a range of values\nthat represent index positions in this\nlist we're going to iterate over that\nusing the for loop and assign each index\nvalue to this local variable i using\nthis index value we can obtain the item\nat that position using subscript\nnotation on the list\nnow this is also a constant time\noperation because the language says so\nso we'll do if list so once we have this\nvalue which we'll get by using subscript\nnotation so we'll say list i\nonce we have this value we'll check if\nit matches the target so if the value at\ni\nequals target\nwell if it does then we'll return that\nindex value because we want the position\nand once we hit this return statement\nwe're going to terminate our function if\nthe entire for loop is executed and we\ndon't hit this return statement then the\ntarget does not exist in the list so at\nthe bottom here we'll say return none\neven though all the individual\noperations in our algorithm run in\nconstant time\nin the worst case scenario this for loop\nhere will have to go through the entire\nrange of values and read every single\nelement in the list\ntherefore giving the algorithm a big o\nvalue of n or running in linear time now\nif you've written code before you've\ndefinitely written code like this a\nnumber of times and i bet you didn't\nknow but all along you are implementing\nwhat is essentially a well-known\nalgorithm\nso i hope this goes to show you that\nalgorithms are pretty approachable topic\nlike everything else this does get\nadvanced but as long as you take things\nslow there's no reason for it to be\nimpossible remember that not any block\nof code counts as an algorithm to be a\nproper implementation of linear search\nthis block of code must return a value\nmust complete execution in a finite\namount of time and must output the same\nresult every time for a given input set\nso let's verify this with a small test\nlet's write a function called verify\nthat accepts an index value\nif the value is not none it prints the\nindex position if it is none it informs\nus that the target was not found in the\nlist so def verify\nand this is going to take an index value\nand we'll say if index is not none\nthen we'll print\ntarget\nfound at index\noops that's a colon here\nindex else\nthat needs to go back\nthere we go\nelse we'll say target\nnot found in list\nokay using this function let's define a\nrange of numbers now so this will be a\nlist numbers\nand we'll just go from 1 to\nlet's say 10.\nnow if you've written python code before\nyou know that i can use a list\ncomprehension to make this easier but\nwe'll keep things simple\nwe can now use our linear search\nfunction to search for the position of a\ntarget value in this list so we can say\nresult\nequal\nlinear underscore search\nand we're going to pass in the numbers\nlist that's the one we're searching\nthrough and we want to look for the\nposition where the value 12 exists\nand then we'll verify\nthis result\nif our algorithm works correctly the\nverify function should inform us that\nthe target did not exist so make sure\nyou save the file which you can do by\ngoing up to file and save or hitting\ncommand s\nand then below in the terminal\nyou're going to type out python\nlinear search or you can hit tab and it\nshould auto complete linear search dot\npi\nas you can see correct the target was\nnot found in the list so the output of\nour script is what we expect\nfor our second test let's search for the\nvalue 6 in the list so you can copy this\ncommand c to copy and then paste it\nagain and we'll just change 12 here to 6\nand then come back down to the terminal\nhit the up arrow to execute the same\ncommand again and hit enter you'll\nnotice that i forgot to hit save so it\ndid not account for that new change\nwe'll try that again\nand there you'll see that if it works\ncorrectly which it did the index should\nbe number five run the program on your\nend and make sure everything works as\nexpected\nour algorithm returned a result in each\ncase it executed in a finite time and\nthe results were the ones we expect in\nthe next video let's tackle binary\nsearch\nin the last video we left off with an\nimplementation of linear search\nlet's do the same for binary search so\nthat we get an understanding of how this\nis represented in code\nso we'll do this in a new file back to\nfile new file\nand we'll name this one binary\nsearch\ndot\npy\nlike before we're going to start with a\nfunction named binary search so we'll\nsay def\nbinary underscore search\nthat takes a list and a target\nif you remember binary search works by\nbreaking the array or list down into\nsmaller sets until we find the value\nwe're looking for\nwe need a way to keep track of the\nposition of the list that we're working\nwith so let's create two variables first\nand last to point to the beginning and\nend of the array so first equal\nzero now if you're new to programming\nlist positions are represented by index\nvalues that start at zero instead of one\nso here we're setting first to zero to\npoint to the first element in the list\nlast is going to point to the last\nelement in the list so we'll say last\nequal\nlen list\nminus one now this may be confusing to\nyou so a quick sidebar to explain what's\ngoing on\nlet's say we have a list containing 5\nelements if we called len on that list\nwe should get 5 back because there are 5\nelements\nbut remember that because the position\nnumbers start at 0 the last value is not\nat position 5 but at 4. in nearly all\nprogramming languages getting the\nposition of the last element in the list\nis obtained by determining the length of\nthe list and deducting 1 which is what\nwe're doing\nokay so we know what the first and last\npositions are when we start the\nalgorithm\nfor our next line of code we're going to\ncreate a while loop\na while loop takes a condition and keeps\nexecuting the code inside the loop until\nthe condition evaluates to false\nfor our condition we're going to say to\nkeep executing this loop until the value\nof first is less than or equal to the\nvalue of last\nso while first less than or equal to\nlast\nwell why you ask why is this our\ncondition well let's work through this\nimplementation and then a visualization\nshould help\ninside the while loop we're going to\ncalculate the midpoint of our list since\nthat's the first step of binary search\nmidpoint equal\nso we'll say first\nplus last\nand then we'll use the floor division\ndouble slash here\ndivided by two\nnow the two forward slashes here are\nwhat python calls a floor division\noperator what it does is it rounds down\nto the nearest whole number so if we\nhave an eight element array first is\nzero last is 7 if we divided 0 plus 7\nwhich is 7 by 2 we would get 3.5 now 3.5\nis not a valid index position so we\nround that down to 3 using the floor\ndivision operator okay so now we have a\nmidpoint the next step of binary search\nis to evaluate whether the value at this\nmidpoint is the same as the target we're\nlooking for so say if list\nvalue at midpoint\nequals the target\nwell if it is then we'll go ahead and\nreturn the midpoint\nso we'll say return\nmidpoint\nthe return statement terminates our\nalgorithm and over here we're done this\nis our best case scenario\nnext we'll say else if\nlist at midpoint\nor value at midpoint is less than the\ntarget now here if the value is less the\nvalue at midpoint is less than the\ntarget then we don't care about any of\nthe values lower than the midpoint so we\nredefine first\nto point to the value after the midpoint\nso we'll say midpoint plus 1.\nnow if the value at the midpoint is\ngreater than the target then we can\ndiscard the values after the midpoint\nand redefine last to point to the value\nprior to the midpoint so we'll say else\nlast equal midpoint\nminus 1.\nlet's visualize this we're going to\nstart with a list of nine integers\nto make this easier to understand let's\nspecify these integers to be of the same\nvalue as its index position so we have a\nrange of values from 0 to 8.\nour target is the worst case scenario\nwe're looking for the position of the\nvalue 8. at the start our algorithm sets\nfirst to point to the index 0 and last\nto point to the length of the list minus\n1 which is 8.\nnext we hit our while loop the logic of\nthis loop is going to be executed as\nlong as the value of first is not\ngreater than the value of last or as\nwe've defined it we're going to keep\nexecuting the contents of the loop as\nlong as first is less than or equal to\nlast\non the first pass this is true so we\nenter the body of the loop\nthe midpoint is first plus last divided\nby two and rounded down so we get a nice\neven four the value at this position is\nfour now this is not equal to the target\nso we move to the first else if\nfour is less than eight so now we\nredefine first to point to midpoint plus\none which is five\nfirst is still less than last so we run\nthrough the body of the loop again the\nmidpoint is now six\nsix is less than eight so we move first\nto point to seven\nseven is still less than or equal to\neight so we go for another iteration of\nthe loop\nthe midpoint is seven oddly enough and\nseven is still less than the target so\nwe move first to point to eight first is\nequal to last now but our condition says\nkeep the loop going as long as first is\nless than or equal to last so this is\nour final time through the loop\nthe midpoint is now 8 which makes the\nvalue at the midpoint equal to the\ntarget and we finally exit our algorithm\nand return the position of the target\nnow what if we had executed all this\ncode and never hit a case where midpoint\nequal the target well that would mean\nthe list did not contain the target\nvalue so after the while loop at the\nbottom\nwill return\nnone\nwe have several operations that make up\nour binary search algorithm so let's\nlook at the runtime of each step we\nstart by assigning values to first and\nlast\nthe value assigned to last involves a\ncall to the len function to get the size\nof the list but we already know this is\na constant time operation in python so\nboth of these operations run in constant\ntime\ninside the loop we have another value\nassignment and this is a simple division\noperation so again the runtime is\nconstant\nin the next line of code we're reading a\nvalue from the list and comparing the\nmidpoint to the target both of these\nagain are constant time operations the\nremainder of the code is just a series\nof comparisons and value assignments and\nwe know that these are all constant time\noperations as well\nso if all we have are a series of\nconstant time operations why does this\nalgorithm have in the worst case a\nlogarithmic runtime\nit's hard to evaluate by just looking at\nthe code but the while loop is what\ncauses the run time to grow\neven though all we're doing is a\ncomparison operation by redefining first\nand last\nover here or rather in the last two\nsteps over here we're asking the\nalgorithm to run as many times as it\nneeds until first is equal or greater\nthan last\nnow each time the loop does this the\nsize of the data set the size of the\nlist grows smaller by a certain factor\nuntil it approaches a single element\nwhich is what results in the logarithmic\nruntime\nokay just like with linear search let's\ntest that our algorithm works so we'll\ngo back to linear search.hi\nand we're going to copy paste\nso command c to copy if you're on a mac\nthen go back to binary search and at the\nbottom\noops\nwe're going to paste in that verify\nfunction\nokay we'll also go back and grab this\nnumbers\nyou know what let's go ahead and copy\nall all of these things so numbers and\nthe two verify cases we'll paste that in\nas well\nand the only thing we need to change\nhere is instead of calling linear search\nthis is going to call binary search\nokay we'll hit command s to save the\nfile and then i'm going to drag up my\nconsole and we'll run python binary\nsearch dot\nand hit enter and you'll see like just\nlike before we get the same results back\nnow note that an extremely important\ndistinction needs to be made here\nthe numbers list that we've defined\nfor our test cases\nright here\nhas to be sorted the basic logic of\nbinary search relies on the fact that if\nthe target is greater than the midpoint\nthen our potential values lie to the\nleft or vice versa since the values are\nsorted in ascending order if the values\nare unsorted our implementation of\nbinary search may return none even if\nthe value exists in the list\nand just like that you've written code\nto implement two search algorithms how\nfun was that\nhopefully this course has shown you that\nit isn't a topic to be afraid of and\nthat algorithms like any other topic\nwith code can be broken down and\nunderstood piece by piece\nnow we have a working implementation of\nbinary search but there's actually more\nthan one way to write it so in the next\nvideo let's write a second version\ni'm going to create a new file\nas always file new file\nand we'll name this recursive\nunderscore binary underscore search dot\np\ny\nokay so we're going to add our new\nimplementation here so that we don't get\nrid of that first implementation we\nwrote let's call this new function\nrecursive binary search\nunlike our previous implementation this\nversion is going to behave slightly\ndifferently in that it won't return the\nindex value of the target element if it\nexists\ninstead it will just return a true value\nif it exists and a false if it doesn't\nso recursive\nunderscore binary underscore search\nand like before this is going to take a\nlist it accepts a list and a target to\nlook for in that list\nwe'll start the body of the function by\nconsidering what happens if an empty\nlist is passed in in that case we would\nreturn false so i would say if the\nlength of the list which is one way to\nfigure out if it's empty if it's equal\nto zero\nthen we'll return false\nnow you might be thinking that in the\nprevious version of binary search we\ndidn't care if the list was empty well\nwe actually did but in a roundabout sort\nof way so in the previous version of\nbinary search our function had a loop\nand that loop condition was true when\nfirst was less than or equal to last so\nas long as it's less than or equal to\nlast we continue the loop\nnow if we have an empty list then first\nis greater than last and the loop would\nnever execute and we return none at the\nbottom\nso this is the same logic we're\nimplementing here we're just doing it in\na slightly different way if the list is\nnot empty we'll implement an else clause\nnow here we'll calculate the midpoint\nby dividing the length of the list by 2\nand rounding down\nagain there's no use of first and last\nhere so we'll say length of list\nand then using the floor division\noperator we'll divide that by 2.\nif the value at the midpoint which we'll\ncheck by saying if list\nusing\nsubscript notation we'll say midpoint as\nthe index now if this value at the\nmidpoint is the same as the target\nthen we'll go ahead and return true\nso far this is more or less the same\nexcept for the value that we're\nreturning\nlet me actually get rid of all that\nokay\nall right so if this isn't the case\nlet's implement an else clause now here\nwe have two situations so first if the\nvalue at the midpoint is less than the\ntarget so if\nvalue at midpoint\nis less than the target\nthen we're going to do something new\nwe're going to call this function again\nthis recursive binary search function\nthat we're in the process of defining\nwe're going to call that again and we're\ngoing to give it the portion of the list\nthat we want to focus on in the previous\nversion of binary search we moved the\nfirst value to point to the value after\nthe midpoint\nnow here we're going to create a new\nlist using what is called a slice\noperation and create a sub list that\nstarts at midpoint plus 1 and goes all\nthe way to the end\nwe're going to specify the same target\nas a search target and when this\nfunction call is done we'll return the\nvalue so we'll say return the return is\nimportant\nthen we'll call this function again\nrecursive\nbinary search\nand this function takes a list and here\nwe're going to use that subscript\nnotation to perform a slice operation by\nusing two indexes a start and an end so\nwe'll say our new list that we're\npassing in needs to start at midpoint\nplus one\nand then we'll go all the way to the end\nand this is a\npython syntactic sugar so to speak if i\ndon't specify an end index python knows\nto just go all the way to the end all\nright so this is our new list that we're\nworking with\nand we need a target we'll just pass it\nthrough if you're confused bear with me\njust like before we'll visualize this at\nthe end\nokay we have another else case here\nand this is a scenario where the value\nat the midpoint is greater than the\ntarget\nwhich means we only care about the\nvalues in the list from the start going\nup to the midpoint now in this case as\nwell we're going to call the binary\nsearch function again and specify a new\nlist to work with this time the list is\ngoing to start at the beginning and then\ngo all the way up to the midpoint so it\nlooks the same we'll say return\nrecursive\nbinary search\nwe're going to pass in a list here so if\nwe just put a colon here\nwithout a start index python knows to\nstart at the beginning and we're going\nto go all the way up to the midpoint\nthe target here is the same\nand this is our new binary search\nfunction so let's see if this works\nactually\nyes\ndown here we'll make some space\nand we'll define a verify function\nwe're not going to copy paste the\nprevious one\nbecause we're not returning none or an\ninteger here so we'll verify the result\nthat we pass in and we'll say print\ntarget found\nand this is just going to say true or\nfalse whether we found it\nokay so like before we need a numbers\nlist\nand we'll do something one two three\nfour all the way up to eight\nokay and now let's test this out so\nwe'll call\nour recursive\nbinary search function\nand we'll pass in the numbers list\nand the target here is 12.\nwe're going to verify this\nverify the result make sure it works and\nthen we'll call it again this time\nmaking sure that we give it a target\nthat is actually in the list so here\nwe'll say 6\nand we'll verify this again\nmake sure you hit command s to save\nand then in the console below we're\ngoing to type out\npython recursive binarysearch.pi\nrun it and you'll see that we've\nverified that search works\nwhile we can't verify the index position\nof the target value which is a\nmodification to how our algorithm works\nwe can guarantee by running across all\nvalid inputs that search works as\nintended\nso why write a different search\nalgorithm here a different binary search\nalgorithm and what's the difference\nbetween these two implementations anyway\nthe difference lies in these last four\nlines of code that you see here\nwe did something unusual here now before\nwe get into this a small word of advice\nthis is a confusing topic and people get\nconfused by it all the time\ndon't worry that doesn't make you any\nless of a programmer in fact i have\ntrouble with it often and always look it\nup including when i made this video\nthis version of binary search is a\nrecursive binary search\na recursive function is one that calls\nitself\nthis is hard for people to grasp\nsometimes because there's few easy\nanalogies that make sense but you can\nthink of it and sort this way so let's\nsay you have this book that contains\nanswers to multiplication problems\nyou're working on a problem and you look\nup an answer\nin the book the answer for your problem\nsays add 10 to the answer for problem 52\nokay so you look up problem 52 and there\nit says add 12 to the answer for problem\n85\nwell then you go and look up the answer\nto problem 85 and finally instead of\nredirecting you somewhere else that\nanswer says 10. so you take that 10 and\nthen you go back to problem 52 because\nremember the answer for problem 52 was\nto add 12 to the answer for problem 85\nso you take that 10 and then you now\nhave the answer to problem 85 so you add\n10 to 12 to get 22.\nthen you go back to your original\nproblem where it said to add 10 to the\nanswer for problem 52 so you add 10 to\n22 and you get 32 to end up with your\nfinal answer so that's a weird way of\ndoing it but this is an example of\nrecursion\nthe solution to your first lookup in the\nbook was the value obtained by another\nlookup in the same book which was\nfollowed by yet another lookup in the\nsame book the book told you to check the\nbook until you arrived at some base\nvalue\nour function works in a similar manner\nso let's visualize this with an example\nof list\nlike before we have a nine element list\nhere with values zero through eight\nthe target we're searching for is the\nvalue eight\nwe'll check if the list is empty by\ncalling len on it this list is not empty\nso we go to the else clause next we\ncalculate the midpoint 9 divided by 2 is\n4.5 rounded down is 4 so our first\nmidpoint value is 4.\nwe'll perform our first check is the\nvalue at the midpoint equal to the\ntarget\nnot true so we go to our else clause\nwe'll perform another check here is the\nvalue at the midpoint less than the\ntarget now in our case this is true\nearlier when we evaluated this condition\nwe simply change the value of first\nhere we're going to call the recursive\nbinary search function again and give it\na new list to work with\nthe list starts at midpoint plus 1 so at\nindex position 5 all the way to the end\nnotice that this call to recursive\nbinary search inside of recursive binary\nsearch includes a return statement\nthis is important and we'll come back to\nthat in a second\nso now we're back at the top\nof a new call to recursive binary search\nwith effectively a new list although\ntechnically just a sub list of the first\none\nthe list here contains the numbers 6 7\nand 8.\nstarting with the first check the list\nis not empty so we move to the else\nthe midpoint in this case length of the\nlist 3 divided by 2 rounded down is 1.\nis the value of the midpoint equal to\nthe target well the value at that\nposition is 7 so no in the else we\nperform the first check is the value at\nthe midpoint less than the target indeed\nit is so we call recursive binary search\nagain and provided a new list\nthis list starts at midpoint plus 1 and\ngoes to the end so in this case that's a\nsingle element list\nsince this is a new call to recursive\nbinary search we start back up at the\ntop\nis the list empty no the midpoint is\nzero\nis the value at the midpoint the same as\nthe target it is so now we can return\ntrue\nremember a minute ago i pointed out that\nwhen we call recursive binary search\nfrom inside the function itself it's\npreceded by a return statement\nthat plays a pretty important role here\nso back to our visualization\nwe start at the top and recall binary\nsearch with a new list but because\nthat's got a return statement before it\nwhat we're saying is hey when you run\nbinary search on this whatever value you\nget back return it to the function that\ncalled you\nthen at the second level we call binary\nsearch again along with another return\nstatement like with the first call we're\ninstructing the function to return a\nvalue back to the code that called it\nat this level we find the target so the\nfunction returns true back to the caller\nbut since this inner function was also\ncalled by a function with instructions\nto return it keeps returning that true\nvalue back up until we reach the very\nfirst function that called it going back\nto our book of answers recursive binary\nsearch instructs itself to keep working\non the problem until it has a concrete\nanswer\nonce it does it works its way backwards\ngiving the answer to every function that\ncalled it until the original caller has\nan answer\nnow like i said at the beginning this is\npretty complicated so you should not be\nconcerned if this doesn't click honestly\nthis is not one thing that you're going\nto walk away with knowing fully how to\nunderstand recursion after your first\ntry i'm really not lying when i say i\nhave a pretty hard time with recursion\nnow before we move on i do want to point\nout one thing\neven though the implementation of\nrecursion is harder to understand\nit is easier in this case to understand\nhow we arrive at the logarithmic run\ntime since we keep calling the function\nwith smaller lists let's take a break\nhere in the next video let's talk a bit\nmore about recursion and why it matters\n[Music]\nin the last video we wrote a version of\nbinary search that uses a concept called\nrecursion\nrecursion might be a new concept for you\nso let's formalize how we use it\na recursive function is one that calls\nitself\nin our example the recursive binary\nsearch function called itself inside the\nbody of the function\nwhen writing a recursive function you\nalways need a stopping condition\nand typically we start the body of the\nrecursive function with this stopping\ncondition it's common to call this\nstopping condition the base case\nin our recursive binary search function\nwe had two stopping conditions\nthe first was what the function should\nreturn if an empty list is passed in\nit seems weird to evaluate an empty list\nbecause you wouldn't expect to run\nsearch on an empty list but if you look\nat how our function works recursive\nbinary search keeps calling itself and\nwith each call to itself the size of the\nlist is cut in half\nif we searched for a target that didn't\nexist in the list then the function\nwould keep halving itself until it got\nto an empty list\nconsider a three element list with\nnumbers one two three where we're\nsearching for a target of four\non the first pass the midpoint is 2 so\nthe function would call itself with the\nlist 3.\non the next pass the midpoint is 0 and\nthe target is still greater so the\nfunction would call itself this time\npassing in an empty list because an\nindex of 0 plus 1 in a single element\nlist doesn't exist\nwhen we have an empty list this means\nthat after searching through the list\nthe value wasn't found\nthis is why we define an empty list as a\nstopping condition or a base case that\nreturns false if it's not an empty list\nthen we have an entirely different set\nof instructions we want to execute\nfirst we obtain the midpoint of the list\nonce we have the midpoint we can\nintroduce our next base case or stopping\ncondition\nif the value at the midpoint is the same\nas the target then we return true\nwith these two stopping conditions we've\ncovered all possible paths of logic\nthrough the search algorithm you can\neither find the value or you don't\nonce you have the base cases the rest of\nthe implementation of the recursive\nfunction is to call the function on\nsmaller sub-lists until we hit one of\nthese base cases going back to our\nvisualization for a second we see that\nrecursive binary search calls itself a\nfirst time which then calls itself again\nfor the initial list we started with the\nfunction only calls itself a few times\nbefore a stopping condition is reached\nthe number of times a recursive function\ncalls itself is called recursive depth\nnow the reason i bring all of this up is\nbecause if after you start learning\nabout algorithms you decide you want to\ngo off and do your own research you may\nstart to see a lot of algorithms\nimplemented using recursion\nthe way we implemented binary search the\nfirst time is called an iterative\nsolution\nnow when you see the word iterative it\ngenerally means the solution was\nimplemented using a loop structure of\nsome kind\na recursive solution on the other hand\nis one that involves a set of stopping\nconditions and a function that calls\nitself computer scientists and computer\nscience textbooks particularly from back\nin the day\nfavor and are written in what are called\nfunctional languages\nin functional languages we try to avoid\nchanging data that is given to a\nfunction\nin our first version of binary search we\ncreated first and last variables using\nthe list and then modified first and\nlast as we needed to arrive at a\nsolution\nfunctional languages don't like to do\nthis all this modification of variables\nand prefer a solution using recursion\na language like python which is what\nwe're using is the opposite and doesn't\nlike recursion in fact python has a\nmaximum recursion depth after which our\nfunction will halt execution python\nprefers an iterative solution now i\nmentioned all of this for two reasons\nif you decide that you want to learn how\nto implement the algorithm in a language\nof your choice that's not python then\nyou might see a recursive solution as\nthe best implementation in that\nparticular language\ni'm an ios developer for example and i\nwork with a language called swift\nswift is different from python in that\nit doesn't care about recursion depth\nand does some neat tricks where it\ndoesn't even matter how many times your\nfunction calls itself\nso if you want to see this in swift code\nthen you need to know how recursion\nworks\nwell and now you have some idea now the\nsecond reason i bring it up is actually\nway more important and to find out on to\nthe next video\nat the beginning of this series i\nmentioned that there were two ways of\nmeasuring the efficiency of an algorithm\nthe first was time complexity or how the\nrun time of an algorithm grows as n\ngrows larger\nthe second is space complexity\nwe took a pretty long route to build up\nthis example but now we're in a good\nplace to discuss space complexity\nspace complexity is a measure of how\nmuch working storage or extra storage is\nneeded as a particular algorithm grows\nwe don't think about it much these days\nbut every single thing we do on a\ncomputer takes up space in memory in the\nearly days of computing considering\nmemory usage was of paramount importance\nbecause memory was limited and really\nexpensive\nthese days were spoiled our devices are\nrich with memory this is okay when we\nwrite everyday code because most of us\naren't dealing with enormously large\ndata sets\nwhen we write algorithms however we need\nto think about this because we want to\ndesign our algorithms to perform as\nefficiently as it can as the size of the\ndata set n grows really large\nlike time complexity space complexity is\nmeasured in the worst case scenario\nusing big-o notation\nsince you are familiar with the\ndifferent kinds of complexities let's\ndive right into an example\nin our iterative implementation of\nbinary search the first one we wrote\nthat uses a while loop let's look at\nwhat happens to our memory usage as n\ngets large\nlet's bring up that function\nlet's say we start off with a list of 10\nelements now inspecting the code we see\nthat our solution relies heavily on\nthese two variables first and last\nfirst points to the start of the list\nand last to the end\nwhen we eliminate a set of values we\ndon't actually create a sub list instead\nwe just redefine first\nand last as you see here\nto point to a different section of the\nlist\nsince the algorithm only considers the\nvalues between first and last when\ndetermining the midpoint\nby redefining first and last as the\nalgorithm proceeds we can find a\nsolution using just the original list\nthis means that for any value of n\nthe space complexity of the iterative\nversion of binary search is constant or\nthat the iterative version of binary\nsearch takes constant space\nremember that we would write this as big\no of one\nthis might seem confusing because as n\ngrows we need more storage to account\nfor that larger list size\nnow this is true but that storage is not\nwhat space complexity cares about\nmeasuring\nwe care about what additional storage is\nneeded as the algorithm runs and tries\nto find a solution\nif we assume something simple say that\nfor a given size of a list represented\nby a value n it takes n amount of space\nto store it whatever that means\nthen for the iterative version of binary\nsearch regardless of how large the list\nis at the start middle and end of the\nalgorithm process the amount of storage\nrequired does not get larger than n\nand this is why we consider it to run in\nconstant space\nnow this is an entirely different story\nwith the recursive version however in\nthe recursive version of binary search\nwe don't make use of variables to keep\ntrack of which portion of the list we're\nworking with\ninstead we create new lists every time\nwith a subset of values or sub-lists\nwith every recursive function call\nlet's assume we have a list of size n\nand in the worst case scenario the\ntarget element is the last in the list\ncalling the recursive implementation of\nbinary search on this list and target\nwould lead to a scenario like this\nthe function would call itself and\ncreate a new list that goes from the\nmidpoint to the end of the list\nsince we're discarding half the values\nthe size of the sub list is n by 2.\nthis function will keep calling itself\ncreating a new sub list that's half the\nsize of the current one until it arrives\nat a single element list and a stopping\ncondition\nthis pattern that you see here where the\nsize of the sublist is reduced by a\nfactor on each execution of the\nalgorithmic logic well we've seen that\npattern before do you remember where\nthis is exactly how binary search works\nit discards half the values every time\nuntil it finds a solution now we know\nthat because of this pattern the running\ntime of binary search is logarithmic\nin fact the space complexity of the\nrecursive version of binary search is\nthe same\nif we start out with a memory allocation\nof size n that matches the list\non each function call of recursive\nbinary search we need to allocate\nadditional memory of size n by 2 n by 4\nand so on until we have a sub list that\nis either empty or contains a single\nvalue because of this we say that the\nrecursive version of the binary search\nalgorithm runs in logarithmic time with\na big o of log n\nnow there's an important caveat here\nthis totally depends on the language\nremember how i said that a programming\nlanguage like swift can do some tricks\nto where recursion depth doesn't matter\nthe same concept applies here if you\ncare to read more about this concept\nit's called tail\noptimization it's called tail\noptimization because if you think of a\nfunction as having a head and a tail\nif the recursive function call is the\nlast line of code in the function as it\nis in our case\nwe call this tail recursion since it's\nthe last part of the function that calls\nitself\nnow the trick that swift does to reduce\nthe amount of space and therefore\ncomputing overhead to keep track of this\nrecursive calls is called tail call\noptimization or tail call elimination\nit's one of those things that you'll see\nthrown around a loss in algorithm\ndiscussions but may not always be\nrelevant to you\nnow what if any of this is relevant to\nus well python does not implement tail\ncall optimization so the recursive\nversion of binary search takes\nlogarithmic space\nif we had to choose between the two\nimplementations given that time\ncomplexity or run time of both versions\nthe iterative and the recursive version\nare the same we should definitely go\nwith the iterative implementation in\npython since it runs in constant space\nokay that was a lot but all of this with\nall of this we've now established two\nimportant ways to distinguish between\nalgorithms that handle the same task and\ndetermine which one we should use\nwe've arrived at what i think is a good\nspot to take a long break and let all of\nthese new concepts sink in but before\nyou go off to the next course let's take\na few minutes to recap everything we've\nlearned so far\nwhile we did implement two algorithms in\nthis course in actual code much of what\nwe learned here was conceptual and will\nserve as building blocks for everything\nwe're going to learn in the future so\nlet's list all of it out\nthe first thing we learned about and\narguably the most important was\nalgorithmic thinking\nalgorithmic thinking is an approach to\nproblem solving that involves breaking a\nproblem down into a clearly defined\ninput and output along with a distinct\nset of steps that solves the problem by\ngoing from input to output\nalgorithmic thinking is not something\nyou develop overnight by taking one\ncourse so don't worry if you're thinking\ni still don't truly know how to apply\nwhat i learned here\nalgorithmic thinking sinks in after you\ngo through several examples in a similar\nfashion to what we did today\nit also helps to apply these concepts in\nthe context of a real example which is\nanother thing we will strive to do\nmoving forward\nregardless it is important to keep in\nmind that the main goal here is not to\nlearn how to implement a specific data\nstructure or algorithm off the top of\nyour head i'll be honest i had to look\nup a couple code snippets for a few of\nthe algorithms myself in writing this\ncourse\nbut in going through this you now know\nthat binary search exists and can apply\nto a problem where you need a faster\nsearch algorithm\nunlike most courses where you can\nimmediately apply what you have learned\nto build something cool learning about\nalgorithms and data structures will pay\noff more in the long run\nthe second thing we learned about is how\nto define and implement algorithms we've\ngone over these guidelines several times\ni won't bore you here again at the end\nbut i will remind you that if you're\noften confused about how to effectively\nbreak down a problem in code to\nsomething more manageable following\nthose algorithm guidelines is a good\nplace to start\nnext we learned about big o and\nmeasuring the time complexity of\nalgorithms this is a mildly complicated\ntopic but once you've abstracted the\nmath away it isn't as hazy a topic as it\nseems\nnow don't get me wrong the math is\npretty important but only for those\ndesigning and analyzing algorithms\nour goal is more about how to understand\nand evaluate algorithms\nwe learned about common run times like\nconstant linear logarithmic and\nquadratic runtimes these are all fairly\nnew concepts but in time you will\nimmediately be able to distinguish the\nruntime of an algorithm based on the\ncode you write and have an understanding\nof where it sits on an efficiency scale\nyou will also in due time internalize\nruntimes of popular algorithms like the\nfact that binary search runs in\nlogarithmic time and constant space\nand be able to recommend alternative\nalgorithms for a given problem\nall in all over time the number of tools\nin your tool belt will increase\nnext we learned about two important\nsearch algorithms and the situations in\nwhich we select one over the other\nwe also implemented these algorithms in\ncode so that you got a chance to see\nthem work\nwe did this in python but if you are\nmore familiar with a different language\nand haven't gotten the chance to check\nout the code snippets we've provided you\nshould try your hand at implementing it\nyourself it's a really good exercise to\ngo through\nfinally we learned about an important\nconcept and a way of writing algorithmic\ncode through recursion recursion is a\ntricky thing and depending on the\nlanguage you write code with you may run\ninto it more than others\nit is also good to be aware of because\nas we saw in our implementation of\nbinary search\nwhether recursion was used or not\naffected the amount of space we used\ndon't worry if you don't fully\nunderstand how to write recursive\nfunctions i don't truly know either the\ngood part is you can always look these\nthings up and understand how other\npeople do it\nanytime you encounter recursion in our\ncourses moving forward you'll get a full\nexplanation of how and why the function\nis doing what it's doing\nand that brings us to the end of this\ncourse i'll stress again that the goal\nof this course was to get you prepared\nfor learning about more specific\nalgorithms by introducing you to some of\nthe tools and concepts you will need\nmoving forward\nso if you're sitting there thinking i\nstill don't know how to write many\nalgorithms or how to use algorithmic\nthinking that's okay we'll get there\njust stick with it\nas always have fun and happy coding\n[Music]\nhi my name is passant i'm an instructor\nat treehouse and welcome to the\nintroduction to data structures course\nin this course we're going to answer one\nfundamental question why do we need more\ndata structures than a programming\nlanguage provides\nbefore we answer that question some\nhousekeeping if you will\nin this course we're going to rely on\nconcepts we learned in the introduction\nto algorithms course\nnamely big-o notation space and time\ncomplexity and recursion\nif you're unfamiliar with those concepts\nor just need a refresher check out the\nprerequisites courses listed\nin addition this course does assume that\nyou have some programming experience\nwe're going to use data structures that\ncome built into nearly all programming\nlanguages as our point of reference\nwhile we will explain the basics of how\nthese structures work we won't be going\nover how to use them in practice\nif you're looking to learn how to\nprogram before digging into this content\ncheck the notes section of this video\nfor helpful links\nif you're good to go then awesome let's\nstart with an overview of this course\nthe first thing we're going to do is to\nexplore a data structure we are somewhat\nalready familiar with arrays\nif you've written code before there's a\nhigh chance you have used an array\nin this course we're going to spend some\ntime understanding how arrays work what\nare the common operations on an array\nand what are the run times associated\nwith those operations\nonce we've done that we're going to\nbuild a data type of our own called a\nlinked list\nin doing so we're going to learn that\nthere's more than one way to store data\nin fact there's way more than just one\nway\nwe're also going to explore what\nmotivates us to build specific kinds of\nstructures and look at the pros and cons\nof these structures\nwe'll do that by exploring four common\noperations accessing a value searching\nfor a value inserting a value and\ndeleting a value\nafter that we're actually going to\ncircle back to algorithms and implement\na new one a sorting algorithm\nin the introductions to algorithms\ncourse we implemented a binary search\nalgorithm a precondition to binary\nsearch was that the list needed to be\nsorted\nwe're going to try our hand at sorting a\nlist and open the door to an entirely\nnew category of algorithms\nwe're going to implement our sorting\nalgorithm on two different data\nstructures and explore how the\nimplementation of one algorithm can\ndiffer based on the data structure being\nused\nwe'll also look at how the choice of\ndata structure potentially influences\nthe run time of the algorithm\nin learning about sorting we're also\ngoing to encounter another general\nconcept of algorithmic thinking called\ndivide and conquer\nalong with recursion dividing conquer\nwill be a fundamental tool that we will\nuse to solve complex problems all in due\ntime in the next video let's talk about\narrays\na common data structure built into\nnearly every programming language is the\narray\narrays are a fundamental data structure\nand can be used to represent a\ncollection of values but it is much more\nthan that arrays are also used as\nbuilding blocks to create even more\ncustom data types and structures\nin fact in most programming languages\ntext is represented using the string\ntype and under the hood strings are just\na bunch of characters stored in a\nparticular order in an array\nbefore we go further and dig into arrays\nwhat exactly is a data structure\na data structure is a way of storing\ndata when programming it's not just a\ncollection of values and the format\nthey're stored in but the relationship\nbetween the values in the collection as\nwell as the operations applied on the\ndata stored in the structure\nan array is one of very many data\nstructures in general an array is a data\nstructure that stores a collection of\nvalues where each value is referenced\nusing an index or a key\na common analogy for thinking about\narrays is as a set of train cars\neach car has a number and these cars are\nordered sequentially\ninside each car the array or the train\nin this analogy stores some data\nwhile this is the general representation\nof an array it can differ slightly from\none language to another but for the most\npart all these fundamentals remain the\nsame in a language like swift or java\narrays are homogeneous containers which\nmeans they can only contain values of\nthe same type\nif you use an array to store integers in\njava it can only store integers\nin other languages arrays are\nheterogeneous structures that can store\nany kind of value in python for example\nyou can mix numbers and text with no\nissues\nnow regardless of this nuance the\nfundamental concept of an array is the\nindex\nthis index value is used for every\noperation on the array from accessing\nvalues to inserting updating and\ndeleting\nin python the language we're going to be\nusing for this course it's a tiny bit\nconfusing\nthe type that we generally refer to as\nan array in most languages is best\nrepresented by the list type in python\npython does have a type called array as\nwell but it's something different so\nwe're not going to use it\nwhile python calls it a list when we use\na list in this course we'll be talking\nabout concepts that apply to arrays as\nwell in other languages so definitely\ndon't skip any of this there's one more\nthing\nin computer science a list is actually a\ndifferent data structure than an array\nand in fact we're going to build a list\nlater on in this course\ngenerally though this structure is\ncalled a linked list as opposed to just\nlist so hopefully the terminology isn't\ntoo confusing\nto properly understand how arrays work\nlet's take a peek at how arrays are\nstored under the hood\nan array is a contiguous data structure\nthis means that the array is stored in\nblocks of memory that are right beside\neach other with no gaps\nthe advantage of doing this is that\nretrieving values is very easy\nin a non-contiguous data structure we're\ngoing to build one soon the structure\nstores a value as well as a reference to\nwhere the next value is\nto retrieve that next value the language\nhas to follow that reference also called\na pointer to the next block of memory\nthis adds some overhead which as you\nwill see increases the runtime of common\noperations a second ago i mentioned that\ndepending on the language arrays can\neither be homogeneous containing the\nsame type of value or heterogeneous\nwhere any kind of value can be mixed\nthis choice also affects the memory\nlayout of the array\nfor example in a language like c swift\nor java where arrays are homogeneous\nwhen an array is created since the kind\nof value is known to the language\ncompiler and you can think of the\ncompiler as the brains behind the\nlanguage\nit can choose a contiguous block of\nmemory that fits the array size and\nvalues created\nif the values were integers assuming an\ninteger took up space represented by one\nof these blocks then for a five item\narray the compiler can allocate five\nblocks of equally sized memory\nin python however this is not the case\nwe can put any value in a python list\nthere's no restriction\nthe way this works is a combination of\ncontiguous memory and the pointers or\nreferences i mentioned earlier\nwhen we create a list in python there is\nno information about what will go into\nthat array which makes it hard to\nallocate contiguous memory of the same\nsize\nthere are several advantages to having\ncontiguous memory\nsince the values are stored beside each\nother accessing the values happens in\nalmost constant time so this is a\ncharacteristic we want to preserve\nthe way python gets around this is by\nallocating contiguous memory and storing\ninit not the value we want to store but\na reference or a pointer to the value\nthat's stored somewhere else in memory\nby doing this it can allocate equally\nsized contiguous memory since regardless\nof the value size the size of the\npointer to that value is always going to\nbe equal this incurs an additional cost\nin that when a value is accessed we need\nto follow the pointer to the block of\nmemory where the value is actually\nstored but python has ways of dealing\nwith these costs that are outside the\nscope of this course\nnow that we know how an array stores its\nvalues let's look at common operations\nthat we execute on an array\nregardless of the kind of data structure\nyou work with all data structures are\nexpected to carry out four kinds of\noperations at minimum\nwe need to be able to access and read\nvalues stored in the structure we need\nto be able to search for an arbitrary\nvalue\nwe also need to be able to insert a\nvalue at any point into the structure\nand finally we need to be able to delete\nstructures\nlet's look at how these operations are\nimplemented on the array structure in\nsome detail starting with access\nelements in an array are identified\nusing a value known as an index and we\nuse this index to access and read the\nvalue\nmost programming languages follow a\nzero-based numbering system when it\ncomes to arrays and all this means is\nthat the first index value is equal to\nzero not one\ngenerally speaking when an array is\ndeclared a base amount of contiguous\nmemory is allocated as the array storage\ncomputers refer to memory through the\nuse of an address but instead of keeping\na reference to all the memory allocated\nfor an array the array only has to store\nthe address of the first location\nbecause the memory is contiguous using\nthe base address the array can calculate\nthe address of any value by using the\nindex position of that value as an\noffset\nif you want to be more specific think of\nit this way\nlet's say we want to create an array of\nintegers and then each integer takes up\na certain amount of space in memory that\nwe'll call m\nlet's also assume that we know how many\nelements we're going to create so the\nsize of the array is some number of\nelements we'll call n\nthe total amount of space that we need\nto allocate is n times the space per\nitem m\nif the array keeps track of the location\nin memory where the first value is held\nso let's label that m0 then it has all\nthe information it needs to find any\nother element in the list\nwhen accessing a value in an array we\nuse the index\nto get the first element in the list we\nuse the zeroth index to get the second\nwe use the index value 1 and so on\ngiven that the array knows how much\nstorage is needed for each element it\ncan get the address of any element by\nstarting off with the address for the\nfirst element and adding to that the\nindex value times the amount of storage\nper element\nfor example to access the second value\nwe can start with m0 and to that add m\ntimes the index value 1 giving us m1 as\nthe location in memory for the second\naddress\nthis is a very simplified model but\nthat's more or less how it works\nthis is only possible because we know\nthat array memory is contiguous with no\ngaps\nlet's switch over to some code\nas i mentioned earlier we're going to be\nusing python in this course\nif you don't know how to code or you're\ninterested in this content but know a\nlanguage other than python check the\nnotes section of this video for more\ninformation while the code will be in\npython the concepts are universal and\nmore importantly simple enough that you\nshould have no issue following along in\nyour favorite programming language\nand to get started click on the launch\nworkspaces button on the video page that\nyou're watching right now\nthis should spin up an instance of a\ntreehouse workspace an in-browser coding\nenvironment right now your workspace\nshould be empty and that's expected so\nlet's add a new file in here i'm going\nto go to file new file\nand we'll call this arrays\ndot py pi\ncreating a list in python is quite\nsimple so we'll call this new underscore\nlist\nwe use a set of square brackets around a\nset of values to create a list so one\nand we comma separate them so space two\nand space three this allocates a base\namount of memory for the array to use or\nwhen i say array know that in python i\nmean a list\nsince this is python the values aren't\nstored in memory\ninstead the values 1 2 and 3 are stored\nelsewhere in memory and the array stores\nreferences to each of those objects\nto access a value we use a subscript\nalong with an index value so to get the\nfirst value we use the index 0 and if we\nwere to assign this to another variable\nwe would say result\nequal new list\nwe write out new lists since this is the\narray that we're accessing the value\nfrom and then a subscript notation which\nis a square bracket\nand then the index value\nas we saw since the array has a\nreference to the base location in memory\nthe position of any element can be\ndetermined pretty easily\nwe don't have to iterate over the entire\nlist\nall we need to do is a simple\ncalculation of an offset from the base\nmemory since we're guaranteed that the\nmemory is contiguous\nfor this reason access is a constant\ntime operation on an array or a python\nlist\nthis is also why an array crashes if you\ntry to access a value using an index\nthat is out of bounds of what the array\nstores\nif you've used an array before you've\nundoubtedly run into an error or a crash\nwhere you try to access a value using an\nindex that was larger than the number of\nelements in the array since the array\ncalculates the memory address on the fly\nwhen you access a value with an out of\nbounds index as it's called the memory\naddress returned is not one that's part\nof the array structure and therefore\ncannot be read by the array now in\npython this is represented by an index\nerror and we can make this happen by\nusing an index we know our array won't\ncontain\nnow i'm writing out my code here inside\nof a text editor which obviously doesn't\nrun the code so let's drag up this\nconsole area here\nand i'm going to write python\nto bring up the python interpreter\nand in here we can do the same thing so\ni can say new\nlist equal one\ncomma two comma three and now this is an\ninterpreter so it's actually going to\nevaluate our code\nall right so now we have a new list if i\ntype out new list it gets printed out\ninto the console\nokay i can also do new list square\nbracket 0 and you'll see that i get the\nvalue 1 which is the value stored at the\nzeroth index\nnow to highlight that index error we can\ndo new list\nand inside the square brackets we can\nprovide an index that we know our array\ndoesn't contain so here i'll say index\n10\nand if i hit enter you'll see it say\nindex error list index out of range\nand those are the basics of how we\ncreate and read values from an array in\nthe next video let's take a look at\nsearching\nin the last video we learned what\nhappens under the hood when we create an\narray and read a value using an index\nin this video we're going to look at how\nthe remaining data structure operations\nwork on arrays\nif you took the introduction to\nalgorithms course we spent time learning\nabout two search algorithms linear\nsearch and binary search\nwhile arrays are really fast at\naccessing values they're pretty bad at\nsearching\ntaking an array as is the best we can do\nis use linear search for a worst case\nlinear runtime linear search works by\naccessing and reading each value in the\nlist until the element in concern is\nfound\nif the element we're looking for is at\nthe end of the list then every single\nelement in the list will have been\naccessed and compared\neven though accessing and comparing our\nconstant time operations having to do\nthis for every element results in an\noverall linear time\nlet's look at how search works in code\nin python we can search for an item in\nan array in one of two ways\nwe can use the in operator to check\nwhether a list contains an item so i can\nsay if\none in new underscore\nlist\nthen print\ntrue\nthe in operator actually calls a\ncontains method that is defined on the\nlist type which runs a linear search\noperation\nin addition to this we can also use a\nfor loop to iterate over the list\nmanually and perform a comparison\noperation\nso i can say\nfor\nn in new list\nif n equals one then print\ntrue\nand then after that break out of the\nloop\nthis is more or less the implementation\nof linear search\nif the array were sorted however we\ncould use binary search but because sort\noperations incur a cost of their own\nlanguages usually stay away from sorting\nthe list and running binary search since\nfor smaller arrays linear search on its\nown may be faster\nnow again remember that\nsince this is an editor this is just a\ntext file none of these lines of code\nare evaluated so you can try that out in\nhere so we'll copy that we can come down\nhere and say python and hit enter and\nthen when it starts up we can paste in\nour list\nand now we can try what we just did so\nif one in new list\nprint\ntrue\nand there you go it prints true now\nbecause we've already learned about\nlinear and binary search in a previous\ncourse there's nothing new going on here\nwhat's more interesting to look at in my\nopinion is inserting and deleting values\nin an array let's start with inserting\nin general most array implementations\nsupport three types of insert operations\nthe first is a true insert using an\nindex value where we can insert an\nelement anywhere in the list this\noperation has a linear runtime imagine\nyou wanted to insert an item at the\nstart of the list when we insert into\nthe first position what happens to the\nitem that is currently in that spot\nwell it has to move to the next spot at\nindex value one what happens to the\nsecond item at index position one\nthat one moves to the next spot at index\nposition two\nthis keeps happening until all elements\nhave been shifted forward one index\nposition\nso in the worst case scenario inserting\nat the zeroth position of an array every\nsingle item in the array has to be\nshifted forward and we know that any\noperation that involves iterating\nthrough every single value means a\nlinear runtime\nnow the second way we can insert an item\ninto an array is by appending appending\nalthough technically an insert operation\nin that it inserts an item into an\nexisting array doesn't incur the same\nruntime cost because appends simply add\nthe item to the end of the list\nwe can simplify and say that this is\nconstant time this is a constant time\noperation but it depends on the language\nimplementation of array\nto highlight why that matters let's\nconsider how lists in python work in\npython when we create a list the list\ndoesn't know anything about the size of\nthe list and how many elements we're\ngoing to store\ncreating a new empty list like so so\nnumbers equal and two empty brackets\nso this creates a list and allocates a\nspace of size n plus one\nsince n here is zero there are no\nelements in this array in this list\nspace is allocated for a one element\nlist to start off\nbecause the space allocated for the list\nand the space used by the list are not\nthe same\nwhat do you think happens when we ask\npython for the length of this list so i\ncan say len numbers\nwe correctly get 0 back\nthis means that the list doesn't use the\nmemory allocation as an indicator of its\nsize because as i mentioned it has\nallocated space for a one element list\nbut it returns zero so it determines it\nin other ways\nokay so numbers this list currently has\nspace for one element\nlet's use the append method defined on\nthe type to insert a number at the end\nof the list so you can say numbers dot\nappend and i'll pass in 2.\nnow the memory allocation and the size\nof the list are the same since the list\ncontains one element\nnow what if i were to do something like\nthis numbers.append\nthere needs to be a dot\nand i'll add another value 200.\nnow since the list only has an\nallocation for one item at this point\nbefore it can add the new element to the\nlist it needs to increase the memory\nallocation and thereby the size of the\nlist it does this by calling a list\nresize operation list resizing is quite\ninteresting because it shows the\ningenuity in solving problems like this\npython doesn't resize the list to\naccommodate just the element we want to\nadd\ninstead in this case it would allocate\nfour blocks of memory to increase the\nsize to a total of four contiguous\nblocks of memory\nit does this so that it doesn't have to\nresize the list every single time we add\nan element but at very specific points\nthe growth pattern of the list type in\npython is 0 4 8 16 25 35 46 and so on\nthis means that as the list size\napproaches these specific values\nresize is called again if you look at\nwhen the size of the list is four\nthis means that when appending four more\nvalues until the size of eight\neach of those append operations do not\nincrease the amount of space taken\nat specific points however when resizing\nis triggered space required increases as\nmemory allocation increases\nthis might signify that the append\nmethod has a non-constant space\ncomplexity but it turns out that because\nsome operations don't increase space and\nothers do\nwhen you average all of them out append\noperations take constant space\nwe say that it has an amortized constant\nspace complexity this also happens with\ninsert operations\nif we had a four element array we would\nhave four elements and a memory\nallocation of four\nan insert operation at that point\ndoesn't matter where it happens on the\nlist but at that point it would trigger\na resize\ninserting is still more expensive though\nbecause after the resize every element\nneeds to be shifted over one\nthe last insert operation that is\nsupported in most languages is the\nability to add one list to another\nin python this is called an extend and\nlooks like this\nso i'll say numbers now if you let me\nactually clear out the console\noh actually you will let's exit python\nwe'll clear this out so we're back at\nthe top and we'll start again\nso i'll say numbers\nand we'll set it to an empty list and\nnow we can say numbers dot extend\nand as an argument we're going to pass\nin a new list entirely so here we'll say\n4 comma 5 comma 6\nand then once i hit enter if i were to\nprint out numbers you'll see that it now\ncontains the values 4 5 and 6.\nso extend takes another list to add\nextend effectively makes a series of\nappend calls on each of the elements in\nthe new list until all of them have been\nappended to the original list this\noperation has a run time of big o of k\nwhere k represents the number of\nelements in the list that we're adding\nto our existing list\nthe last type of operation we need to\nconsider are delete operations deletes\nare similar to inserts in that when a\ndelete operation occurs the list needs\nto maintain correct index values so\nwhere an insert shifts every element to\nthe right a delete operation shifts\nevery element to the left\njust like an insert as well if we delete\nthe first element in the list every\nsingle element in the list needs to be\nshifted to the left\ndelete operations have an upper bound of\nbig o of n also known as a linear\nruntime now that we've seen how common\noperations work on a data structure that\nwe're quite familiar with let's switch\ntracks and build our own data structure\n[Music]\nover the next few videos we're going to\nbuild a data structure that you may have\nworked with before a linked list\nbefore we get into what a linked list is\nlet's talk about why we build data\nstructures instead of just using the\nones that come built into our languages\neach data structure solves a particular\nproblem\nwe just went over the basics of the\narray data structure and looked at the\ncost of common operations that we carry\nout on arrays\nwe found that arrays were particularly\ngood at accessing reading values happens\nin constant time but arrays are pretty\nbad at inserting and deleting both of\nwhich run in linear time\nlinked lists on the other hand are\nsomewhat better at this although there\nare some caveats and if we're trying to\nsolve a problem that involves far more\ninserts and deletes than accessing a\nlinked list can be a better tool than an\narray\nso what is a linked list\na linked list is a linear data structure\nwhere each element in the list is\ncontained in a separate object called a\nnode a node models two pieces of\ninformation an individual item of the\ndata we want to store and a reference to\nthe next node in the list\nthe first node in the linked list is\ncalled the head of the list while the\nlast node is called the tail\nthe head and the tail nodes are special\nthe list only maintains a reference to\nthe head although in some\nimplementations it keeps a reference to\nthe tail as well\nthis aspect of linked lists is very\nimportant and as you'll see most of the\noperations on the list need to be\nimplemented quite differently compared\nto an array\nthe opposite of the head the tail\ndenotes the end of the list\nevery node other than the tail points to\nthe next node in the list but tail\ndoesn't point to anything this is\nbasically how we know it's the end of\nthe list nodes are what are called\nself-referential objects the definition\nof a node includes a link to another\nnode and self-referential here means the\ndefinition of node includes the node\nitself linked lists often come in two\nforms a singly linked list where each\nnode stores a reference to the next node\nin the list or a doubly linked list\nwhere each node stores a reference to\nboth the node before and after if an\narray is a train with a bunch of cars in\norder then a linked list is like a\ntreasure hunt\nwhen you start the hunt you have a piece\nof paper with the location of the first\ntreasure you go to that location and you\nfind an item along with a location to\nthe next item of treasure\nwhen you finally find an item that\ndoesn't also include a location you know\nthat the hunt has ended\nnow that we have a high level view of\nwhat a linked list is let's jump into\ncode and build one together we'll focus\non building a singly linked list for\nthis course there are advantages to\nhaving a doubly linked list but we don't\nwant to get ahead of ourselves\nlet's start here by creating a new file\nwe're going to put all our code for our\nlinked list so we'll call this linked\nunderscore list\ndot pi and first we're going to create a\nclass to represent a node\nsay class\nnode\nnow node is a simple object in that it\nwon't model much so first we'll add a\ndata variable\nit's an instance variable here called\ndata and we'll assign the value none\ninitially\nand then we'll add one more we'll call\nthis next node and to this we'll assign\nnone as well so we've created two\ninstance variables data to hold on to\nthe data that we're storing and next\nnode to point to the next node in the\nlist\nnow we need to add a constructor to make\nthis class easy to create so we'll add\nan init\nmethod here that takes self and some\ndata to start off\nand all we're going to do is assign\ndata to that instance variable we\ncreated so that's all we need to model\nnode\nbefore we do anything else though let's\ndocument this so right after the class\ndefinition let's create a docs string so\nthree quotes\nnext line and we'll say an object\nfor storing\na single\nnode of a linked list\nand then on the next line we'll say\nmodels two attributes\ndata\nand\nthe link to the next\nnode in the list\nand then we'll close this doc string off\nwith three more quotation marks okay\nusing the node class is fairly\nstraightforward so we can create a new\ninstance of node with some data to store\nnow the way we're going to do this is\nwe're going to bring up the console\nand we're going to type out like we've\nbeen typing out before python followed\nby the name of the script that we wrote\nwhich is linked list linked underscore\nlist.pi but before we do that we're\ngoing to pass an argument to the python\ncommand we're going to say dash or\npython i and then the name of the script\nlinked underscore list dot pi so what\nthis does is this is going to run the\npython repl\nthe read evaluate print loop in the\nconsole but it's going to load the\ncontents of our file into that so that\nwe can use it\nso i'll hit enter and we have a new\ninstance going and now we can use the\nnode in here so we can say n1\nequal node\nand since we defined that constructor we\ncan pass it some data so we'll say 10\nhere\nnow if we try to inspect this object the\nrepresentation returned isn't very\nuseful\nwhich will make things really hard to\ndebug as our code grows so for example\nif i type out n1 you'll see that\nwe have a valid instance here but it's\nnot very helpful the way it's printed\nout\nso we can customize this by adding a\nrepresentation of the object using the\nwrapper function now in the terminal\nstill we'll type out exit\nlike that hit enter to exit the console\nand then down here\nlet's add in some room\nokay and here we'll say def\ndouble underscore\nwrapper another set of double\nunderscores\nand then this function takes the\nargument self\nand in here we can provide a string\nrepresentation of what we want printed\nto the console when we inspect that\nobject inside of it inside of a console\nso here we'll say return\nagain\nthis is a string representation so\ninside quotes we'll say\nnode so this represents a node instance\nand the data it contains here we'll say\npercent s\nwhich is a python way of substituting\nsomething into a string string\ninterpolation and outside of the string\nwe can say percent again\nand here we're saying we want to replace\nthis percent s with\nself.data okay\nlet's hit save and before we move on\nlet's verify that this works so i'm\ngoing to come in here\ntype clear to get rid of everything\nand then we'll do what we did again and\nyou can just hit the up arrow a couple\ntimes to get that command\nall right so hit enter and now just so\nyou know every time you run this you\nstart off you know from scratch so n1\nthat we created earlier not there\nanymore so let's go ahead and create it\nn1 equal node\n10\nand we can type n1 again and hit enter\nand you have a much better\nrepresentation now so we can see that we\nhave a node and it contains the data 10.\nwe can also create another one n2 equal\nnode that contains the data 20 and now\nwe can say n1.next n1.nextnode\nequal n2 so n1 now points to n2 and if\nwe say n1.nextnode\nyou'll see that it points to that node\nthe node containing 20.\nnodes are the building blocks for a list\nand now that we have a node object we\ncan use it to create a singly linked\nlist so again i'm going to exit out of\nthis\nand then go back to the text editor\nand here we'll create a new class so\nclass\nlinked\nlist\nthe linked list class is going to define\na head and this attribute models the\nonly node that the list is going to have\na reference to so here we'll say head\nand we'll assign none initially and then\nlike we did earlier let's create a\nconstructor\nso double underscore init double\nunderscore this takes self\nand then inside like before we'll say\nself dot head\nequal none this is the same\nas doing this so we can actually get rid\nof that and just use the constructor\nokay so again this head attribute models\nthe only node that the list will have a\nreference to since every node points to\nthe next node to find a particular node\nwe can go from one node to the next in a\nprocess called list traversal\nso in the class constructor here we've\nset the default value of head to none so\nthat new lists created are always empty\nagain you'll notice here that i didn't\nexplicitly declare the head attribute at\nthe top of the class definition\nand don't worry that's not an oversight\nthe self.head in the initializer means\nthat it's still created okay so that's\nall there is to modeling a linked list\nnow we can add methods that make it\neasier to use this data structure\nfirst a really simple docstring to\nprovide some information\nso here we'll to create a docstring\nthree quotation marks\nand then we'll say singly linked list\nand then close it off\na common operation carried out on data\nstructures is checking whether it\ncontains any data or whether it's empty\nat the moment to check if a list is\nempty we would need to query these\ninstance variables head and so on every\ntime\nideally we would like to not expose the\ninner workings of our data structure to\ncode that uses it\ninstead let's make this operation more\nexplicit by defining a method so we'll\nsay def is empty\nand this method takes self as an\nargument and here we'll say return\nself.head double equal none\nall we're doing here is checking to see\nif head is none\nif it is this condition evaluates to\ntrue which indicates the list is empty\nnow before we end this video let's add\none more convenience method to calculate\nthe size of our list the name\nconvenience method indicates that what\nthis method is doing is not providing\nany additional functionality that our\ndata structure can't handle right now\nbut instead making existing\nfunctionality easier to use\nwe could calculate the size of our\nlinked list by traversing it every time\nusing a loop until we hit a tail node\nbut doing that every time is a hassle\nokay so we'll call this method\nsize and as always it takes self\nunlike calling len on a python list not\nto be confused with a linked list which\nis a constant time operation our size\noperation is going to run in linear time\nthe only way we can count how many items\nwe have is to visit each node and call\nnext until we hit the tail node\nso we'll start by getting a reference to\nthe head we'll say current\nequal self.head let's also define a\nlocal variable named count with an\ninitial value of 0 that will increment\nevery time we visit a node once we hit\nthe tail count will reflect the size of\nthat list\nnext we'll define a while loop that will\nkeep going until there are no more nodes\nso say while current\nwhile current is the same as writing out\nwhile current does not equal none but\nit's more succinct so we'll go with this\nformer\nif the ladder is more precise for you\nyou can go with that\nnow inside this loop we'll increment the\ncount value so count plus equal one\nplus equal if you haven't encountered it\nbefore is the same as writing count\nequal count plus one so if count is zero\ninitially so it's zero plus one is one\nand then we'll assign that back to count\nokay so count plus equal one\nnext we're going to assign the next node\nin the list to current so current equal\ncurrent dot next\nnode\nthis way once we get to the tail and\ncall next node current will equal none\nand the while loop terminates so the end\nwe can return\ncount\nas you can see we need to visit every\nnode to determine the size meaning our\nalgorithm runs in linear time so let's\ndocument this\nup in our docs string which we'll add\nnow to size\nwe'll say\nreturns\nthe number of nodes in the list\ntakes\nlinear time\nlet's take a break here we can now\ncreate lists check if they're empty and\ncheck the size\nin the next video let's start\nimplementing some common operations\nat the moment we can create an empty\nlist but nothing else let's define a\nmethod to add data to our list\ntechnically speaking there are three\nways we can add data to a list\nwe can add nodes at the head of the list\nwhich means that the most recent node we\ncreated will be the head and the first\nnode we created will be the tail\nor we could flip that around most recent\nnodes are the tail of the list and the\nfirst node to be added is the head i\nmentioned that one of the advantages of\nlinked lists over arrays is that\ninserting data into the list is much\nmore efficient than to the array\nthis is only true if we're inserting at\nthe head or the tail\ntechnically speaking this isn't an\ninsert and you'll often see this method\ncalled add prepend if the data is added\nto the head or append if it's added to\nthe tail\na true insert is where you can insert\nthe data at any point in the list which\nis our third way of adding data we're\ngoing to circle back on that if we\nwanted to insert at the tail then the\nlist needs a reference to the tail node\notherwise we would have to start at the\nhead and walk down the length of the\nlist or traverse it to find the tail\nsince our list only keeps a reference to\nthe head we're going to add new items at\nthe head of the list\nnow before we add our new method i\nforgot that i didn't show you in the\nlast video how to actually use the code\nwe just added and how to check every\ntime you know when we add new code that\nit works correctly\nso like before we're gonna bring up the\nconsole and here we're gonna say python\ndash i\nlinked underscore list dot pi which\nshould load it\nload the contents of our file\nand now we'll start here by creating a\nlinked list so l equal linked list\nand then we'll use a node so n1 equal\nnode\nwith the value 10\nand now we can assign n1 to the nodes or\nto the linked lists head attribute so l1\ndot head equal n1\nand then\nwe can see if size works correctly so if\nwe call l1 dot size and since this is a\nmethod we need a set of parentheses at\nthe end\nand enter you'll see that we get back\none correctly okay so it works\nnow let's add our new method which we're\ngoing to call add\nadd is going to accept some data to add\nto the list inside of a node\nso we'll say def\nadd\nand every python method takes self as an\nargument and then we want to add some\ndata to this node so we're going to say\ndata for the second argument\ninside the method first we'll create a\nnew node to hold on to the data so new\nunderscore node equal\nnode with the data\nbefore we set the new node as the head\nof the list we need to point the new\nnode's next property at whatever node is\ncurrently at head this way when we set\nthe new node as the head of the list we\ndon't lose a reference to the old head\nso new underscore node dot next node\nequal self.head\nnow if there was no node at head this\ncorrectly sets next node to none\nnow we can set the new node as the head\nof the node so say self.head equal\nnew underscore node because the insert\noperation is simply a reassignment of\nthe head and next node properties this\nis a constant time operation so let's\nadd that in as a docs string\nfirst what the method does so it adds a\nnew node\ncontaining data\nat the head of the list\nthis operation takes\nconstant time which is our best case\nscenario\nokay let's test this out so i'm going to\nbring the console back up we'll exit out\nof\nour current reply\nand we'll load\nthe contents of the file again\nand now we don't need to create a node\nlike we did earlier so we can say l\nequal linked\nlist\nl.add one\nokay let's see if this works we'll call\nsize\nand if it worked\nthe linked list should now have a size\nof one there we go you can also do\nl.add2\nl.add three\nand l dot size should now be three there\nwe go now if we i were to type l and\njust hit print\nagain what we get in the repel is\nnothing useful\nso like before we'll implement the\nwrapper function for our linked list\nnow\ni'm just going to copy paste this in and\nwe'll walk through it\nokay so this is what our implementation\nof wrapper looks like for the linked\nlist object you can grab this code from\nthe notes section of this video\nokay so at the top you'll see a docs\nstring where it says it returns a string\nrepresentation of the list and like\neverything we need to do with a linked\nlist we need to traverse it so this is\ngoing to take linear time we start by\ncreating an empty list now i need to\ndistinguish this is a python list not a\nlinked list so we create an empty list\ncalled nodes and two nodes we're going\nto add strings that have a description\nthat provide a description of each node\nbut we're not going to use the\ndescription that we implemented in the\nnode class because we're going to\ncustomize it a bit here\nnext we start by assigning self.head to\ncurrent so we sort of have a pointer to\nthe head node as long as current does\nnot equal none which means we're not at\nthe tail we're going to implement some\nlogic\nso in the first scenario if the node\nassigned to current is the same as the\nhead\nthen we're going to append this string\nto our nodes list\nand the string is simply\ngoing to say that hey this is a head\nnode and it contains some data which\nwill extract using current.data\nnext scenario is if the node assigned to\ncurrent's next node is none meaning\nwe're at the tail node then we'll assign\na different kind of string so it's the\nsame as earlier except we're saying tail\nhere and then finally in any other\nscenario which means we're not at the\nhead or not of the tail we'll simply\nprint the node's value inside and again\nwe'll extract it using current.data with\nevery iteration of the loop we'll move\ncurrent forward by calling\ncurrent.nextnode and reassigning it\nand then at the very end when we're done\nwe'll join all the strings that are\ninside the nodes list together using the\npython join method and we'll say that\nwith every join so when you join these\ntwo strings together to make one string\nyou need to put this set of characters\nin between all right so let's see what\nthis looks like\nso i'm going to come down here exit out\nof the console again\nclear it out\nload the contents of the file again and\nlet's try that so we'll say l equal\nlinked list\nall right so l dot add one l dot add two\nl dot add three that seems enough\nand then now if i type out l and hit\nenter we get a nice string\nrepresentation of the list so you can\nsee that we add every new node to the\nhead so we added one first one ends up\nbeing the tail because it keeps getting\npushed out\nthen two and then finally three so three\nis at the head\nso far we've only implemented a single\nmethod which functions much like the\nappend method on a python list or an\narray\nexcept it adds it to the start of the\nlinked list it pre-pens it\nlike append this happens in constant\ntime in the next video let's add the\nability to search through our list for\nthe search operation we're going to\ndefine a method that takes a value to\nsearch for and returns either the node\ncontaining the value if the value is\nfound or none if it isn't\nso right after actually you know what\nwe'll make sure wrapper is the last\nfunction our last method\nin our class so we'll add it above it so\nhere we'll say def search\nself\nand then key\nin the last video we implemented the\nwrapper method to provide a string\nrepresentation of the list\nso we're going to use similar logic here\nto implement the search function we'll\nstart by setting a local variable\ncurrent to point to the head of the list\nwhile the value assigned to current is a\nvalid node that is it isn't none\nwe'll check if the data on that node\nmatches the key that we're searching for\nso while current\nwe'll say if\ncurrent.data\nis the key\nthen we'll return current\nif it does match we'll go ahead and\nreturn it like we've done here but if it\ndoesn't we'll assign the next node in\nthe list to current and check again so\nsay else\ncurrent equal current dot next node\nonce we hit the tail node and haven't\nfound the key\ncurrent gets set to none and the while\nloop exits\nat this point we know the list doesn't\ncontain the key so we can return\nnone\nokay that completes the body of our\nmethod\nlet's add a docs string to document this\nso up at the top we'll say search\nfor the first node\ncontaining data that matches\nthe key\nnow this is important because if our\nlinked list contains more than one node\nwith the same value it doesn't matter\nwe're going to return the first one with\nthis implementation\nwe'll also say here that it returns the\nnode or none\nif not found\nin the worst case scenario we'll need to\ncheck every single node in the list\nbefore we find the key or fail and as a\nresult this operation runs in linear\ntime so i'll say takes\no of n or linear time\nso far we haven't seen anything that\nindicates this data structure has any\nadvantage over an array or a python list\nbut we knew that\ni mentioned the strength of linked lists\ncomes in inserts and deletes at specific\npositions we'll check that out in the\nnext video but as always before we end\nthis one let's make sure everything\nworks\nso we'll load the contents of the file\nagain\nl equal linked\nlist\nand then we'll say l.add 10\nl dot add\n20 2 doesn't matter l dot add\n45 and one more metal dot add\n15.\nnow we can say\nl.search and we need to give it a value\nso we'll say 45 and this returns a node\nor none so we'll say n equal\nand then we'll hit enter if this works\nn should be a node\nokay weirdly n\ndoes not work here\nat least it says it's not a node which\nmeans i made a mistake in typing out our\ncode\nand looking at it immediately it's\nfairly obvious so this return none needs\nto be outside of the while loop okay so\ni'm going to hit save now so make sure\nit's on the same indentation here which\nmeans it's outside the while loop\nand then we'll run through this again\nokay so l is linked list\nl.add 10\nl dot add 2\nl.add\n45 and what was the last one we did i\nbelieve it was 15\nand now we should be able to say\nl.search remember we're assigning this\nto a node to a variable so l.search\n45\nand there you go we get that node back\nand we can hit l\nand we'll see a representation of our\nlist\nokay so again in the next video inserts\nand deletes at specific positions\ninsert operations on linked lists are\nquite interesting\nunlike arrays where when you insert an\nelement into the array all elements\nafter the particular index need to be\nshifted with a linked list we just need\nto change the references to next on a\nfew nodes and we're good to go\nsince each node points to the next one\nby swapping out these references we can\ninsert a node at any point in the list\nin constant time\nmuch like binary search though there's a\ncatch\nto find the node at that position we\nwant to insert we need to traverse the\nlist and get to that point\nwe just implemented our search algorithm\nfor the linked list type and we know\nthat this runs in linear time so while\nactually inserting is fast finding the\nposition in the list you want to insert\nit is not\nthis is why i mentioned that there were\nsome caveats to inserting\nanyway let's see what this looks like in\ncode\nwe'll define a method named insert that\ntakes data to insert along with an index\nposition so we'll do this after search\nright here\nsay def\ninsert\nand this takes some data to insert and a\nposition to insert it at\nyou may be thinking wait a minute linked\nlists don't have index positions right\nand you're correct but we can mimic that\nbehavior by just counting the number of\ntimes we access next node\nif the index value passed into this\nargument is 0 that means we want to\ninsert the new node at the head of the\nlist this is effectively the same\nbehavior as calling add which means the\nlogic is the same so we don't need to\nrepeat it we can call the add method we\nwrote earlier so we'll say if\nindex if index equals 0 or if index is 0\nthen self dot add\ndata\nif the index is greater than 0 then we\nneed to traverse the list to find the\ncurrent node at that index\nso if index is greater than zero\nnow before we do that we need to create\na new node containing the data we want\nto insert so we'll say new equal node\nwith some data\ni'm going to assign index the argument\npassed to our function to a local\nvariable named position and the head of\nthe list to a variable named current\nposition\nequal index\ncurrent equal self.head\nevery time we call\ncurrent.nextnode meaning we're moving to\nthe next node in the list we'll decrease\nthe value of position by 1.\nwhen position is zero we'll have arrived\nat the node that's currently at the\nposition we want to insert in\nin reality though we don't want to\ndecrease it all the way to zero\nimagine we have a list with five nodes\nand we want to insert a node at position\n3. to insert a node at position 3 we\nneed to modify the nodes at positions 2\nand 3.\nnode 2's next node attribute is going to\npoint to the new node and the new node's\nnext node attribute will point to node\n3.\nin this way an insert is a constant time\noperation we don't need to shift every\nsingle element we just modify a few next\nnode references\nin a doubly linked list we can use node\n3 to carry out both of these operations\nnode 3 in a doubly linked list would\nhave a reference to node 2 and we can\nuse this reference to modify all the\nunnecessary links\nand a singly linked list though which is\nwhat we have if we kept decreasing\nposition until we're at 0 we arrive at\nnode 3.\nwe can then set the new node's next node\nproperty to point to node 3 but we have\nno way of getting a reference to node 2\nwhich we also need\nfor this reason it's easier to decrease\nposition to just 1 when it equals 1 and\nstop at node 2. so in here we'll say\nwhile\nposition\nis greater than one\nnow while the position is greater than\none we'll keep calling next node and\nreassigning the current node so current\nequal node.next\nnode and at the same time we'll\ndecrement position so position\nequal to position\nminus one which you can also succinctly\nwrite as minus equal\none\nthis way when the position equals one\nthe loop exits and current will refer to\nthe node at the position before the\ninsert point so outside the while loop\nwe'll say previous equal current\nand next equal current dot next\nnode\nto make things more clear what i've done\nhere is name the node before the new one\nprevious and the node after the new one\nnext\nall that's left to do now is to insert\nthe new node between previous and next\nso we'll say previous dot next\nnode\nequal\nnew\nand then new dot next node\nequal next\nnow it seems like there's an issue with\nvariable naming here and i'm most\nprobably conflicting with some globally\nnamed next variable so actually go ahead\nand call this next node\nand\nprevious node so that we don't mess\nthings up here\nprevious node\nso the dot next node is obviously the\nattribute on a node but this is just a\nlocal variable let's document this\nmethod so up at the top\nwe'll add a docs string and it will say\ninserts a new node\ncontaining\ndata at index\nposition\ninsertion takes\nconstant time\nbut finding the node\nat the insertion point\ntakes linear\ntime\nlet's add this to the next line\nthere we go\nand then we'll say therefore it takes an\noverall\nlinear time\nthis is why even though we can easily\ninsert a new node without having to\nshift the rest ultimately adding to\neither the head or the tail if you have\na reference is much more efficient\nwe have one more operation to add to our\nlinked list that will make it a robust\ndata structure\nmuch like inserts removing a node is\nactually quite fast and occurs in\nconstant time but to actually get to the\nnode that we want to remove and modify\nthe next connections we need to traverse\nthe entire list in our worst case so in\nthe worst case this takes linear time\nlet's add this operation to our data\nstructure\nthere are two ways we can define the\nremove method one where we provide a key\nto remove as an argument and one where\nwe provide an index now in the former\nthe key refers to the data the node\nstores so in order to remove that node\nwe would first need to search for data\nthat matches the key i'm going to\nimplement that first method which we'll\ncall remove and i'll leave it up to you\nto get some practice in and implement a\nremove at index method to complete our\ndata structure so we'll add this after\nthe insert method right here\nremove\nis going to accept a key which we'll\nneed to search for before we can remove\na node earlier we defined a search\nmethod that found a node containing data\nthat matches a key but we can't use that\nmethod as is for the implementation of\nremove when we remove a node much like\nthe insert operation we need to modify\nthe next node references\nthe node before the match needs to point\nto the node after the match\nif we use the search method we defined\nearlier we get the node we want to\nremove as a return value but because\nthis is a singly linked list we can't\nobtain a reference to the previous node\nlike i said earlier if this was a doubly\nlinked list we could use the search\nmethod since we would have a reference\nto that previous node\nwe'll start here by setting a local\nvariable named current to point to the\nhead let's also define a variable named\nprevious\nthat will set to none to keep track of\nthe previous node as we traverse the\nlist\nfinally let's declare a variable named\nfound that we'll set to false\nfound is going to serve as a stopping\ncondition for the loop that we'll define\nwe'll use the loop to keep traversing\nthe linked list as long as found is\nfalse meaning we haven't found the key\nthat we're looking for once we've found\nit we'll set found to true and the loop\nterminates so let's set up our loop so\nwe'll say while current\nand\nnot\nfound\nhere we're defining a while loop that\ncontains two conditions\nfirst we tell the loop to keep iterating\nas long as current does not equal none\nwhen current equals none this means\nwe've gone past the tail node and the\nkey doesn't exist\nthe second condition asks the loop to\nkeep evaluating as long as not found\nequals true now this might be tricky\nbecause it involves a negation here\nright now found is set to false so not\nfound not false equals true this not\noperator flips the value\nwhen we find the key and we set found to\ntrue\nnot true not found we'll equal false\nthen and the loop will stop\nthe end in the while loop means that\nboth conditions current being a valid\nnode and not found equalling true both\nhave to be true\nif either one of them evaluates to false\nthen the loop will terminate\nnow inside the loop there are three\nsituations that we can run into\nfirst the key matches the current node's\ndata and current is still at the head of\nthe list\nthis is a special case because the head\ndoesn't have a previous node and it's\nthe only node being referenced by the\nlist let's handle this case so we'll say\nif current.data\ndouble equals the key and current\nis self.head which you can write out as\ncurrent equal self.head or current is\nself.head\nnow if we hit this case\nwe'll indicate that we found the key by\nsetting found to true\nand then this means that on the next\npass\nthis is going to evaluate to false\nbecause not true will be false\nand then the loop terminates once we do\nthat we want to remove the current node\nand since it's the head node all we need\nto do is point head to the second node\nin the list which we can get by\nreferencing the next node attribute on\ncurrent self.head equal current.nextnode\nso when we do this there's nothing\npointing to that first node so it's\nautomatically removed the next scenario\nis when the key matches data in the node\nand it's a node that's not the head\nso here we'll say else if current dot\ndata equal key\nif the current node contains the key\nwe're looking for we need to remove it\nto remove the current node we need to go\nto the previous node and modify its next\nnode reference to point to the node\nafter current\nbut first we'll set found\nto true\nand then we'll switch out the references\nso\nprevious.nextnode\nequal\ncurrent.nextnode\nso far we haven't written any code to\nkeep track of the previous node\nwe'll do that in our else case here\nso if we hit the else case it means that\nthe current node we're evaluating\ndoesn't contain the data that matches\nthe key so in this case we'll make\nprevious point to the current node and\nthen set current to the next node so\nprevious equal current\nand current equal current.nextnode\nand that's it for the implementation of\nremove\nnow we're not doing anything at the\nmoment with the node we're removing but\nit's common for remove operations to\nreturn the value being removed so at the\nbottom\noutside the while loop\nlet's return\ncurrent\nand with that we have a minimal\nimplementation of a linked list and your\nfirst custom data structure how cool is\nthat\nthere's quite a bit we can do here to\nimprove our data structure particularly\nin making it easy to use but this is a\ngood place to stop\nbefore we move on to the next topic\nlet's document our method so the top\nanother docs string\nand here we'll say removes node\ncontaining data that matches the key\nalso it returns the node or none\nif the key doesn't exist\nand finally this takes\nlinear time because in the worst case\nscenario we need to search the entire\nlist\nif you'd like to get in some additional\npractice implementing functionality for\nlinked lists two methods you can work on\nare remove it index and node at index to\nallow you to easily delete or read\nvalues in a list at a given index\nnow that we have a linked list let's\ntalk about where you can use them the\nhonest answer is not a lot of places\nlinked lists are really useful\nstructures to build for learning\npurposes because they're relatively\nsimple and are a good place to start to\nintroduce the kinds of operations we\nneed to implement for various data\nstructures it is quite rare however that\nyou will need to implement a linked list\non your own\nthere are typically much better and by\nthat i mean much more efficient data\nstructures that you can use\nin addition many languages like java for\nexample provide an implementation of a\nlinked list already\nnow that we have a custom data structure\nlet's do something with it let's combine\nthe knowledge we have and look at how a\nsorting algorithm can be implemented\nacross two different data structures\n[Music]\nnow that we've seen two different data\nstructures let's circle back and apply\nwhat we know about algorithms to these\nnew concepts\none of the first algorithms you learned\nabout was binary search and we learned\nthat with binary search there was one\nprecondition the data collection needs\nto be sorted\nover the next few videos let's implement\nthe merge sort algorithm which is one of\nmany sorting algorithms on both arrays\nor python lists and the singly linked\nlist we just created\nthis way we can learn a new sorting\nalgorithm that has real world use cases\nand see how a single algorithm can be\nimplemented on different data structures\nbefore we get into code let's take a\nlook at how merge sort works\nconceptually and we'll use an array to\nwork through this\nwe start with an unsorted array of\nintegers and our goal is to end up with\nan array sorted in ascending order\nmerge sort works like binary sort by\nsplitting up the problem into sub\nproblems but it takes the process one\nstep further\non the first pass we're going to split\nthe array into two smaller arrays now in\nbinary search one of these subarrays\nwould be discarded but that's not what\nhappens here\non the second pass we're going to split\neach of those subarrays into further\nsmaller evenly sized arrays and we're\ngoing to keep doing this until we're\ndown to single element arrays\nafter that the merge sort algorithm\nworks backwards repeatedly merging the\nsingle element arrays and sorting them\nat the same time\nsince we start at the bottom by merging\nto single element arrays we only need to\nmake a single comparison to sort the\nresulting merge array by starting with\nsmaller arrays that are sorted as they\ngrow\nmerge sort has to execute fewer sort\noperations than if it sorted the entire\narray at once\nsolving a problem like this by\nrecursively breaking down the problem\ninto subparts until it is easily solved\nis an algorithmic strategy known as\ndivide and conquer but instead of\ntalking about all of this in the\nabstract let's dive into the code this\nway we can analyze the runtime as we\nimplement it\nfor our first implementation of merge\nsort we're going to use an array or a\npython list\nwhile the implementation won't be\ndifferent conceptually for a linked list\nwe will have to write more code because\nof list traversal and how nodes are\narranged so once we have these concepts\nsquared away we'll come back to that\nlet's add a new file here\nwe'll call this merge underscore sort\ndot pi\nin our file let's create a new function\nnamed merge sort that takes a list and\nremember when i say list unless i\nspecify linked list i mean a python list\nwhich is the equivalent of an array so\nwe'll say def\nmerge underscore sort\nand takes a list\nin the introduction to algorithms course\nwe started our study of each algorithm\nby defining the specific steps that\ncomprise the algorithm\nlet's write that out as a docstring\nin here the steps of the algorithm so\nthat we can refer to it right in our\ncode\nthis algorithm is going to sort the\ngiven list in an ascending order so\nwe'll start by putting that in here as a\nsimple definition\nsorts a list in ascending\norder\nthere are many variations of merge sort\nand in the one we're going to implement\nwe'll create and return a new sorted\nlist other implementations will sort the\nlist we pass in and this is less typical\nin an operation known as sort in place\nbut i think that returning a new list\nmakes it easier to understand the code\nnow these choices do have implications\nthough and we'll talk about them as we\nwrite this code\nfor our next bit of the docs string\nlet's write down the output of this\nalgorithm so returns\na new\nsorted list\nmerge sort has three main steps\nthe first is the divide step where we\nfind the midpoint of the list so i'll\nsay divide\nfind the mid point of the list and\ndivide\ninto sub-lists\nthe second step is the conquer step\nwhere we sort the sub-list that we\ncreated in the divide step so we'll say\nrecursively\nsort the sub-lists created in previous\nstep\nand finally the combine the combined\nstep where we merge these recursively\nsorted sub-lists back into a single list\nso merge the sorted sub-lists\ncreated in previous\nstep\nwhen we learned about algorithms we\nlearned that a recursive function has a\nbasic pattern first we start with a base\ncase that includes a stopping condition\nafter that we have some logic that\nbreaks down the problem and recursively\ncalls itself\nour stopping condition is our end goal a\nsorted array\nnow to come up with a stopping condition\nor a base case we need to come up with\nthe simplest condition that satisfies\nthis end result\nso there are two possible values that\nfit a single element list or an empty\nlist\nnow in both of these situations we don't\nhave any work to do\nif we give the merge sort function an\nempty list or a list with one element\nit's technically already sorted we call\nthis naively sorting so let's add that\nas our stopping condition we'll say if\nlen list if the length of the list is\nless than or equal to one\nthen we can return the list\nokay so this is a stopping condition\nand now that we have a stopping\ncondition we can proceed with the list\nof steps\nfirst we need to divide the list into\nsub lists\nto make our functions easier to\nunderstand we're going to put our logic\nin a couple different functions instead\nof one large one so i'll say it left\nhalf\ncomma right half\nequal\nsplit\nlist so here we're calling a split\nfunction that splits the list we pass in\nand returns two lists split at the\nmidpoint because we're returning two\nlists we can capture them in two\nvariables\nnow you should know that this split\nfunction is not something that comes\nbuilt into python this is a global\nfunction that we're about to write\nnext is the conquer step where we sort\neach sub-list and return a new sorted\nsub-list\nso we'll say left equal\nmerge sort\nleft half\nand right equal merge sort\nright half\nthis is the recursive portion of our\nfunction so here we're calling merge\nsort on this divided sub list so we\ndivide the list into two here and then\nwe call merge sort on it again\nthis further splits that sublist into\ntwo in the next pass through of merge\nsort this is going to be called again\nand again and again until we reach our\nstopping condition where we have single\nelement lists or empty lists\nwhen we've subdivided until we cannot\ndivide any more then we'll end up with a\nleft and a right half\nand we can\nstart merging backwards so we'll say\nreturn\nmerge\nleft and right\nthat brings us to the combined step\nonce two sub-lists are sorted and\ncombined we can return it\nnow obviously none of these functions\nmerge merge sort well merge sort is\nwritten but merge and split haven't been\nwritten so all we're going to do here if\nwe run it is raise an error so in the\nnext video let's implement the split\noperation\nthe first bit of logic we're going to\nwrite is the divide step of the\nalgorithm this step is fairly\nstraightforward and only requires a few\nlines of code but is essential to get\nthe sorting process going\nall right so as we saw earlier we're\ngoing to call the function for the\ndivide step split so we'll say def split\nand split is going to take as an\nargument a list to split up\nlet's document how this function works\nso we'll say\ndivide the unsorted list at midpoint\ninto sub lists and it's always good to\nsay what we're returning as well so\nwe'll say returns to sub-lists\nleft and right\nall right so the first step is to\ndetermine the midpoint of this list of\nthis array\nwe're going to use the floor division\noperator for this\nfloor division carries out a division\noperation and if we get a non-integer\nvalue like 2.5 back it just gets rounded\ndown to two we'll define the midpoint to\nbe the length of the list divided by two\nand then rounded down\nso\nlan list\nand using the\ntwo forward slashes for the floor\ndivision operator we'll put number two\nafter it\nokay once we have the midpoint we can\nuse the slicing notation in python to\nextract portions of the list we want to\nreturn\nfor instance we can define left\nas the left sub-list that goes all the\nway from the start of the list\nall the way up to the midpoint without\nincluding the midpoint\nnow over here we're using the slicing\nsyntax where it's like using the you\nknow subscript notation to access a\nvalue from a list but instead we give\ntwo index values as a start and stop\nif we don't include a start value as\ni've done here python interprets that as\nstarting from the zeroth index or the\nstart of the list now similarly we can\ndefine right\n[Music]\nto be values on the right of the\nmidpoint so starting at the midpoint and\ngoing all the way up to the end of the\nlist\nso a couple things to note as i said\nearlier when you don't include the\nstarting index it interprets it as to\nstart at the very beginning of the list\nthe index you give as the stopping\ncondition that value is not included in\nthe slice so over here we're starting at\nthe very beginning of list and we go all\nthe way up to midpoint but not including\nmidpoint and then right starts at\nmidpoint so it includes that value and\nthen goes all the way to the end of the\nlist\nnow once we have these two sub-lists we\ncan return them\nso we'll return left and right notice\nthat we're returning two values here and\nthen in the merge sort function when we\ncall that split function\nwe're declaring two variables left half\nand right half to assign so that we can\nassign these two sub lists to them\nokay and that's all there is to the\nsplit function in the next video let's\nimplement the crucial portion of the\nmerge sort logic\nonce we run the split function\nrecursively over the array we should end\nup with several single member or empty\narrays\nat this point we need to merge them all\nback and sort them in the process which\nis what our merge function is for\nthe merge function is going to take two\narrays or lists as arguments and to\nmatch the naming conventions we used in\nthe split function we'll call this left\nand right as well so we'll say def merge\ntakes a left and a right list\nnow like before let's add some\ndocumentation to our function so this\nfunction merges to lists or arrays\nsorting them in the process\nand then it returns a new merged list\nsince our function is going to return a\nnew list let's start by creating one\nnow in the process of merging we need to\nsort the values in both lists\nto sort we need to compare values from\neach array or each list so next let's\ncreate two local variables to keep track\nof index values that we're using for\neach list\nso the convention here is i and j so\nwe'll stick to it\nso i equals 0 j equals 0.\nas we inspect each value in either list\nwe'll use the variables to keep track of\nthe indexes of those values so we'll use\ni to keep track of indexes in the left\nlist and j for indexes in the right list\nwhen merging we want to keep sorting the\nvalues until we've worked through both\nlists so for our loop let's set up two\nconditions with an and operator so we'll\nsay while\nlet's just stay up here while i is less\nthan\nwhile i is less than the length of the\nleft list\nand j\nis less than the length\nof the right list then we'll keep\nexecuting our loop so here we're\nensuring that as long as i is less than\nthe length of the left list\nand the and is important and j is less\nthan the length of the right list we're\ngoing to keep executing the code now i\nand j are both set to zero initially\nwhich means that our first comparison\noperation will be on the first element\nof each list respectively so we'll say\nif\nleft i so i zero so this is going to get\nthe first value out of the left list\nis less than right\nj\nand again here\nj is zero so we're going to get the\nfirst value out of the right list now if\nthe value at index i in the left list is\nless than the value at index j in the\nright list what do we do well that means\nthe value being compared in left is less\nthan the value in the right and can be\nplaced at position 0 in the new array l\nthat we created earlier so here we'll\nsay l dot append\nleft\ni\nsince we've read and done something with\nthe value at position i let's increment\nthat value so we move forward to\nevaluate the next item in the left list\ni plus one or we can say i plus equal\none okay next is an else statement\nand here we'll say\nif the value at index i so i don't have\nto write out the actual logic because\nit's implied so here we're saying that\nleft the value at left is less than the\nvalue at right now in the else clause if\nthe value at so i equal\nis greater and i haven't written out\nthat condition because it's implied so\nhere we're saying if the value in the\nleft is less than the value in the right\nso in the else clause it's going to mean\nthat the value in the left is either\ngreater than or equal to the value in\nthe right but when we hit the else\nclause if the value at index i in the\nleft list is greater\nthen we place the value at index j from\nthe right list at the start of the new\none list l\nand similarly increment j so here we'll\nsay l dot append\nright\nj and then j equal j plus one\ndoing this doesn't necessarily mean that\nin one step we'll have a completely\nsorted array but remember that because\nwe start with single element arrays and\ncombine with each merge step we will\neventually sort all the values more than\none time and by the time the entire\nprocess is done all the values are\ncorrectly sorted\nnow this isn't all we need to do in the\nmerge step however there are two\nsituations we can run into one where the\nleft array is larger than the right and\nvice versa so this can occur when an\narray containing an odd number of\nelements needs to be split so how do you\nsplit a three element array or list well\nthe left can have two elements and the\nright can have one or the other way\naround\nin either case our while loop uses an\nand condition\nwhere the variables used to store the\nindexes need to be less than the length\nof the lists if the left list is shorter\nthan the right then the first condition\nreturns false and the entire loop\nreturns false because it's an and\ncondition\nthis means that in such an event when\nthe while loop terminates not all the\nvalues in the right list will have been\nmoved over to the new combined list\nso to account for this let's add two\nmore while loops\nthe first while loop is going to account\nfor a situation where the right list is\nshorter than the left and the previous\nloop terminated because we reached the\nend of the right list first\nso in this case what we're going to do\nis simply add the remaining elements in\nthe left to the new list\nwe're not going to compare elements\nbecause we're going to assume that\nwithin a list the elements are already\nsorted\nso while i\nis less than length of left\nthen\nit's the same logic l dot append left\ni\nand i\nplus equal one\nso the while loop is going to have the\nsimilar condition keep the loop going\nuntil it's at the last index\ninside the body we're incrementing the\nindex with every iteration of the loop\nour final loop accounts for the opposite\nscenario where the left was shorter than\nthe right\nthe only difference here is that we're\ngoing to use the variable j along with\nthe right list so we'll say while j\nis less than length of right\nl dot append\nright\nj\nand j plus equal one okay let's stop\nhere in the next video let's test out\nmerge sort make sure our code is running\ncorrectly and everything is written well\nand then we'll wrap up this stage by\ndocumenting our code and evaluating the\nrun time of our algorithm in the last\nvideo we completed our implementation\nfor the merge sort algorithm but we\ndidn't test it in any way let's define a\nnew list at the bottom that contains\nseveral numbers\nyou can put whatever you want in there\nbut make sure that the numbers are not\nin order i'll call mine a list\nand in here\nwe'll say 54\n26 or 62 doesn't matter 93 17\n77\n31\njust add enough so that you can make out\nthat it's sorted okay next we're going\nto call the merge sort algorithm\nand pass in our list let's assign this\nto some variables so we'll say l equal\nmerge\nunderscore sort\na list\nand then if it works correctly we should\nbe able to print this list and see what\nit looks like so i'm going to hit save\ndown here in the console we'll tap out\npython\nmerge sort dot pi\nand before i hit enter i actually\nnoticed i made an error in the last\nvideo but i'll hit enter anyway and you\nshould see the error pop up okay so what\ni forgot to do which is a pretty crucial\npart of our algorithm is in the merge\nfunction i forgot to return the list\ncontaining the sorted numbers after\ncarrying out all this logic\nso here at the bottom\nwe'll say return\nl\nall right we'll save again\nand now we'll clear this out and try\nthat one more time\nand there we go\nyou should see a sorted list printed out\nwe can write out a more robust function\nto test this because with bigger arrays\nvisually evaluating that printed list\nwon't always be feasible so bring this\nback down\nlet's get rid of this\nand we'll call our\nfunction verify sorted\nand this will take a list\nfirst we're going to check inside the\nbody of the function we'll check the\nlength of the list\nif the list is a single element list or\nan empty list we don't need to do any\nunnecessary work because remember it is\nnaively sorted so we'll say if n\nequals 0 or\nif n equals\n1\nthen we'll return true we've verified\nthat it's sorted\nnow to conclude our function we're going\nto write out one line of code that will\nactually do quite a bit of work\nso first we'll say return\nlist\nzero so we'll take the first element out\nof the list and we'll compare and see if\nthat's less than the second element in\nthe list okay so first we'll check that\nthe first element in the list is less\nthan the second element in the list\nthis returns either true or false so we\ncan return that directly\nbut this isn't sufficient if it were we\ncould trick the verify function by only\nsorting the first two elements in the\nlist\nso to this return statement we're going\nto use an and operator to add on one\nmore condition for this condition we're\ngoing to make a recursive function call\nback to verify\nsorted\nand for the argument we're going to pass\nin the list\ngoing from the second element all the\nway\nto the end let's visualize how this\nwould work\nwe'll use a five element list as an\nexample so we'll call verify sorted and\npass in the entire list\nthis list is not one or zero elements\nlong so we skip that first if statement\nthere's only one line of code left in\nthe function and first we check that the\nelement at index 0 is less than the\nelement at index 1. if this is false the\nfunction returns immediately with a\nfalse value\nan and operator requires both conditions\nto be true for the entire line of code\nto return true\nsince the first condition evaluates to\nfalse we don't need to bother evaluating\nthe second the second condition is a\nrecursive call with a sub-list\ncontaining elements from the original\nlist starting at position 1 and going to\nthe end\nso on the second call again we can skip\nthat first if statement and proceed to\ncheck whether the value at element 0 is\nless than the value at element 1.\nremember that because this list is a\nsub-list of the original starting at the\nelement that was the second element in\nthe original list\nby comparing the elements at position 0\nand 1 in the sub list we're effectively\ncomparing the elements at position 1 and\n2 in the original list with each\nrecursive call as we create new sub\nlists that start at index position 1\nwe're able to check the entire list\nwithout having to specify any checks\nother than the first two elements\nsince this is a recursive function it\nmeans we need a stopping condition and\nwe have it already it's that first if\ncondition\nas we keep making sub lists once we\nreach a single element list that element\nis already sorted by definition so we\ncan return true since this recursive\nfunction call is part of an and\ncondition\nit means that every single recursive\ncall has to return true all the way back\nto the beginning for our top level\nfunction to return true and for the\nfunction to say yes this is sorted\nnow we could have easily done this using\nan iterative solution and a for loop but\nthis way you get another example of\nrecursion to work through and understand\nso let's use this function\nat the bottom we'll say print\nverify sorted and first we'll pass in a\nlist\noops we got rid of that didn't we\nokay let me write it out again so a list\nequal\nand i think i have those original\nnumbers here somewhere so we'll say 54\n26 93\nokay and then we assigned to l the\nresult of calling merge\nsort\non a list\nokay so now here we're going to use the\nverify sorted function\nand we'll check first that a list is\nsorted that should return false and then\nwe'll check the same call on we'll pass\nan l and this should return true\nokay so now at the bottom here in the\nconsole\nwe'll call python merge sort dot pi and\nthere we go it returned false for a list\nmeaning it's not sorted but l is sorted\ncool so our merge sort function works in\nthe next video let's talk about the cost\nof this algorithm\nif we go back to the top level the merge\nsort function what is the run time of\nthis function look like and what about\nspace complexity how does memory usage\ngrow as the algorithm runs\nto answer those questions let's look at\nthe individual steps starting with the\nsplit function in the split function all\nwe're doing is finding the midpoint of\nthe list and splitting the list at the\nmidpoint\nthis seems like a constant time\noperation but remember that the split\nfunction isn't called once it's called\nas many times as we need it to to go\nfrom the initial list down to a single\nelement list\nnow this is a pattern we've seen a\ncouple times now and we know that\noverall this runs in logarithmic time so\nlet's add that as a comment so here i'll\nsay\ntakes\noverall\nbig o of log\nn time now there's a caveat here but\nwe'll come back to that\nso next up is the merge step in the\nmerge step we've broken the original\nlist down into single element lists and\nnow we need to make comparison\noperations and merge them back in the\nreverse order\nfor a list of size n we will always need\nto make an n number of merge operations\nto get back from single element lists to\na merge list\nthis makes our overall runtime big o of\nn times log n because that's an n number\nof merge steps multiplied by log n\nnumber of splits of the original list\nso to our merge step here let's add a\ncomment we'll say it runs\nin overall\noops there we go runs an overall linear\ntime\nright it takes an n number of steps\nnumber of merge steps but now that we\nhave these two so linear here and\nlogarithmic here we can multiply these\nand say that the merge sort function the\ntop level function we can conclude that\nthe runtime of the overall sorting\nprocess is big o of n times log n\nnow what about that caveat i mentioned\nearlier\nso if we go back to our split function\nhere\nright here there we go\nlet's take a look at the way we're\nactually splitting the list so we're\nusing python's list slicing operation\nhere\nand passing in two indexes where the\nsplit occurs\nnow if you go and poke around the python\ndocumentation which i've done it says\nthat a slicing operation is not a\nconstant time operation and in fact has\na runtime of big o of k where k\nrepresents the slice size\nthis means that in reality our\nimplementation of split this\nimplementation of split does not run in\nlogarithmic time but k times logarithmic\ntime because there is a slice operation\nfor each split\nthis means that our implementation is\nmuch more expensive so\noverall\nthat makes our overall top level merge\nsort function not n times log n but k n\ntimes log n which is much more expensive\nnow let's get rid of all that\nto fix this we would need to remove this\nslicing operation now we can do that by\nusing a technique we learned in a\nprevious course\nin the introduction to algorithms course\nwe looked at two versions of binary\nsearch in python a recursive and an\niterative version\nin the recursive one we use list slicing\nwith every recursion call but we achieve\nthe same end result using an iterative\napproach without using list slicing\nover there we declared two variables to\nkeep track of the starting and ending\npositions in the list\nwe could rewrite merge sort to do the\nsame but i'll leave that as an exercise\nfor you if you want some hints if you\nwant any direction i've included a link\nin the notes with an implementation so\nthat is time complexity now just so we\nknow before moving on for python here\nour\noverall run time is not what i've listed\nhere but this is what the actual run\ntime of the merge sort algorithm looks\nlike so the merge step runs in linear\ntime and the split step takes\nlogarithmic time for an overall n times\nlog n and that is how merge sort\nactually works\nokay so what about space complexity\nthe merge sort algorithm takes linear\nspace and this is weird to think about\nit first but as always a visualization\nhelps\nso if we start at the top again with our\nfull list and carry out the split method\nuntil we have single element lists each\nof these new lists take up a certain\namount of space\nso the second level here we have two\nlists where each take up an n by two\namount of space\nnow this makes it seem that the sum of\nall this space is the additional space\nneeded for merge sort but that's not\nactually the case in reality there are\ntwo factors that make a difference\nfirst not every single one of these sub\nlists are created simultaneously\nat step two we create two n by two size\nsub lists\nwhen we move to the next step however we\ndon't hold on to the n by two sub lists\nand then create four n by four size sub\nlists for the next split\ninstead after the four n by four size\nsub lists are created the n by two ones\nare deleted from memory there's no\nreason to hold on to them any longer now\nthe second point is that our code\ndoesn't execute every path\nsimultaneously\nthink of it this way when we pass our\nlist to the top level merge sort\nfunction\nour implementation calls split\nwhich returns a left half and a right\nhalf\nthe next line of code then calls merge\nsort on the left half again\nthis runs the function the merge sort\nfunction again with a new list\nin that second run of the function split\nis called again we get a second left and\nright half and then again like before we\ncall merge sort on this left half as\nwell what this means is that the code\nwalks down the left path all the way\ndown until that initial left half is\nsorted and merged back into one array\nthen it's going to walk all the way down\nthe right path and sort that until we're\nback to that first split with two n by\ntwo sized sublists\nessentially we don't run all these paths\nof code at once so the algorithm doesn't\nneed additional space for every sub-list\nin fact it is the very last step that\nmatters\nin the last step the two sub-lists are\nmerged back into the new sorted list and\nreturned\nthat sorted list has an equal number of\nitems as the original unsorted list\nand since this is a new list it means\nthat at most the additional space the\nalgorithm will require at a given time\nis n\nyes at different points in the algorithm\nwe require log n amount of space but log\nn is smaller than n and so we consider\nthe space complexity of merge sort to be\nlinear because that is the overall\nfactor\nokay that was a lot so let's stop here\ndon't worry if you've got questions\nabout merge sort because we're not done\nyet\nover the next few videos let's wrap up\nthis course by implementing merge sort\non a linked list\n[Music]\nover the last few videos we implemented\nthe merge sort algorithm on the array or\nlist type in python merge sort is\nprobably the most complicated algorithm\nwe've written so far but in doing so we\nlearned about an important concept\ndivide and conquer\nwe also concluded the last video by\nfiguring out the run time of merge sort\nbased on our implementation\nover the next few videos we're going to\nimplement merge sort again this time on\nthe linked list type\nin doing so we're going to get a chance\nto see how the implementation differs\nbased on the data structure while still\nkeeping the fundamentals of the\nalgorithm the same and we'll also see\nhow the run time may be affected by the\nkinds of operations we need to implement\nlet's create a new file to put our\nsecond implementation of merge sort in\nso file over here new file\nand it's going to have a rather long\nname we'll call this linked\nlist\nmerge sort with underscores everywhere\ndot pi\nwe're going to need the linked list\nclass that we created earlier so we'll\nstart at the top by importing the linked\nlist class from the linkedlist.pi file\nthe way we do that is we'll say from\nlinked\nlist\nimport linked list\nright so that imports the class\nuh let's test if this works really quick\nwe'll just do something like l equal\nlinked\nlist\nl.add\nten\nor one doesn't matter print l\nokay and if i hit save\nand then down here we'll say python\nlinked list\nmerge sword dot pi\nokay it works so this is how we get some\nof the code how we reuse the code that\nwe've written in other files into this\ncurrent file\nand get rid of this now\nokay like we did with the first\nimplementation of merge sort we're going\nto split the code up across three\nfunctions\nthe main function merge sort\na split function and a merge function\nnow if you were to look up a merge sort\nimplementation in python both for a\nregular list an array or a linked list\nyou would find much more concise\nversions out there but they're kind of\nhard to explain so splitting it up into\nthree will sort of help it you know be\neasier to understand so we'll call this\nmerge sort at the top level and this\ntime it's going to take a linked list\nlet's add a dog string to document the\nfunction\nso say that this function sorts a linked\nlist in ascending order\nand like before we'll add the steps in\nhere so we'll say you first recursively\ndivide the linked list into sub lists\ncontaining\na single\nnode\nthen\nwe repeatedly\nmerge these sub-lists\nto produce sorted sub-lists\nuntil one remains\nand then finally this function returns a\nsorted\nlinked list\nthe implementation of this top level\nmerge function is nearly identical to\nthe array or list version we wrote\nearlier so first we'll provide a\nstopping condition or two if the size of\nthe list is one or it's an empty list\nwe'll return the linked list since it's\nnaively sorted so if linked\nlist dot size remember that function we\nrun equal one\nthen we'll return\nlinked\nlist\nelse if\nlinked list dot head\nis none meaning it's an empty list then\nwe'll return linked list as well okay\nnext let's split the linked list into a\nleft and right half\nconceptually this is no different but in\npractice we need to actually traverse\nthe list we'll implement a helper method\nto make this easier\nbut we'll say left half\ncomma right half\nequal split\nlinked list\nnow once we have two sub lists like\nbefore we can call merge sort the top\nlevel function on each\nso left equal merge sort\nleft half\nand right equal merge sort\non the right half\nfinally we'll merge these two top-level\nsub-lists and return it so merge left\nand right\nokay nothing new here but in the next\nvideo let's implement the split logic\nthe next step in the merge sort\nalgorithm is the divide step or rather\nan implementation of the split function\nso down here\nwe'll call this split like before and\nthis is going to take a linked\nlist\ndocumenting things is good and we've\nbeen doing it so far so let's add a\ndocstring\ndivide the unsorted list at midpoint\ninto sub-lists\nnow of course when i say sub-lists here\ni mean sub-linked lists but that's a\nlong word to say\nnow here's where things start to deviate\nfrom the previous version\nwith the list type we could rely on the\nfact that finding the midpoint using an\nindex and list slicing to split into two\nlists would work even if an empty list\nwas passed in\nsince we have no automatic behavior like\nthat we need to account for this when\nusing a linked list so our first\ncondition is if the linked list is none\nor if it's empty that is if head is\nequal to none\nso we'll say if linked list\nequal none\nor you can write is there it doesn't\nmatter or linked list dot head is none\nwell linked list can be none for example\nif we call split on a linked list\ncontaining a single node a split on such\na list would mean left would contain the\nsingle node while right would be none\nnow in either case we're going to assign\nthe entire list to the left half and\nassign none to the right so we'll say\nleft half\nequal linked list\nand then right half\nequal none\nyou could also assign the single element\nlist or none to left and then create a\nnew empty linked list assigned to the\nright half but that's unnecessary work\nso now that we've done this we can\nreturn\nleft half\nand right half\nso that's our first condition let's add\nan else clause to account for non-empty\nlinked lists first we'll calculate the\nsize of the list now this is easy\nbecause we've done the work already and\nwe can just call the size method that\nwe've defined we'll say size equal\nlinked underscore list dot size\nusing this size we can determine the\nmidpoint so mid equal size and here\nwe'll use that floor division operator\nto divide it by two once we have the\nmidpoint we need to get the node at that\nmidpoint\nnow make sure you hit command s to save\nhere and we're going to navigate back to\nlinkedlist.hi\nin here we're going to add a convenience\nmethod at the very bottom right before\nthe wrapper function right here\nand this convenience method is going to\nreturn a node at a given index so i'll\ncall this node\nat\nindex and it's going to take an index\nvalue\nthis way instead of having to traverse\nthe list inside of our split function we\ncan simply call node at index and pass\nit the midpoint index we calculated to\ngive us the node right there so we can\nperform the split\nokay so this method accepts as an\nargument the index we want to get the\nnode for if this index is zero then\nwe'll return the head of the list so if\nindex double equals zero return\nself.head\nthe rest of the implementation involves\ntraversing the linked list and counting\nup to the index as we visit each node\nthe rest of the implementation involves\ntraversing the linked list and counting\nup to the index as we visit each node so\ni'll add an else clause here\nand we'll start at the head so we'll say\ncurrent equal self.head\nlet's also declare a variable called\nposition\nto indicate where we are in the list\nwe can use a while loop to walk down the\nlist our condition here is as long as\nthe position is less than the index\nvalue\nso i'll say while position\nis less than index\ninside the loop we'll assign the next\nnode to current and increment the value\nof position by one\nso current equal current dot next node\nposition\nplus equal one\nonce the position value equals the index\nvalue current refers to the node we're\nlooking for and\nwe can return it we'll say return\ncurrent\nlet's get rid of all this empty space\nthere we go now back in linked list\nmerge sort\ndot pi\nwe can use this method to get at the\nnode after we've calculated the midpoint\nto get the node at the midpoint of the\nlist\nso we'll say mid node\nequal\nlinked\nlist\ndot node at index\nand here i'm going to do something\nslightly confusing i'm going to do mid\nminus 1. remember we're subtracting 1\nhere\nbecause we used size\nto calculate the midpoint and like the\nlen function size will always return a\nvalue greater than the maximum index\nvalue\nso think of a linked list with two nodes\nsize would return two\nthe midpoint though and the way we're\ncalculating the index we always start at\nzero which means size is going to be one\ngreater than that so we're going to\ndeduct one from it to get the value we\nwant but we're using the floor division\noperator so it's going to round that\ndown even more no big deal with the node\nat the midpoint now that we have this\nmidnote we can actually split the list\nso first we're going to assign the\nentire linked list to a variable named\nleft half so left half\nequal linked list\nthis seems counterintuitive but make\nsense in a second\nfor the right half we're going to assign\na new instance of linked list so right\nhalf equal\nlinked list\nthis newly created list is empty but we\ncan fix that by assigning the node that\ncomes after the midpoint so after the\nmidpoint of the original linked list we\ncan assign the node that comes after\nthat midpoint node as the head of this\nnewly created\nright linked list\nso here we'll say right half\ndot head\nequal mid node dot\nnode\nonce we do that we can assign none to\nthe next node property on mid node to\neffectively sever that connection and\nmake what was the mid node now the tail\nnode of the left linked list so i'll say\nmid node\ndot next node\nequal none\nif that's confusing here's a quick\nvisualization of what just happened\nwe start off with a single linked list\nand find the midpoint the node that\ncomes after the node at midpoint is\nassigned to the head of a newly created\nlinked list and the connection between\nthe midpoint node and the one after is\nremoved\nwe now have two distinct linked lists\nsplit at the midpoint\nand with that we can return the two sub\nlists so we'll return left half\nand right half\nin the next video let's tackle our merge\nfunction in the last video we defined an\nimplementation for the version of the\nsplit function that works on linked\nlists it contained a tiny bit more code\nthan the array or list version that was\nexpected the merge function is no\ndifferent because like with the split\nfunction after we carry out a comparison\noperation we also need to swap\nreferences to corresponding nodes all\nright let's add our merge function over\nhere at the bottom below\nthe split functions we'll call this\nmerge and it's going to take a left\nand right\nnow because this can get complicated\nwe're going to document this function\nextensively and as always we're going to\nstart with a doc string\nso we'll say that this function merges\ntwo linked lists\nsorting\nby data in the nodes\nand it returns a new\nmerged list\nremember that in the merge step we're\ngoing to compare values across two\nlinked lists and then return a new\nlinked list with nodes where the data is\nsorted\nso first we need to create that new\nlinked list let's add a comment in here\nwe'll say create\na new linked list\nthat contains nodes from\nlet's add a new line merging left and\nright\nokay and then create the list so merged\nequal\nnew linked list\nto this list we're going to do something\nunusual we're going to add a fake head\nthis is so that when adding sorted nodes\nwe can reduce the amount of code we have\nto write by not worrying about whether\nwe're at the head of the list once we're\ndone we can assign the first sorted node\nas the head and discard the fake head\nnow this might not make sense at first\nbut not having to worry about whether\nthe new linked list already contains a\nhead or not makes the code simpler we'll\nadd another comment\nand a fake hand that is discarded\nlater\nwe'll say merged dot add zero\nlike we've been doing so far we'll\ndeclare a variable named current to\npoint to the head of the list\nset current to the head of the linked\nlist and then current equal\nmerged dot head\nnext we'll get a reference to the head\non each of the linked lists left and\nright\nso we'll say obtain\nhead nodes\nfor left and right linked lists\nand here's call this left head\nequal\nleft dot head\nand right hand equal right dot head\nokay so with that setup out of the way\nlet's start iterating over both lists\nso another comment\niterate over left and right\nas long\nor we'll say until\nthe\nuntil we reach the tail node\nof either\nand we'll do that by saying while\nleft head\nor right head\nso this is a pattern that we've been\nfollowing all along we're going to\niterate until we hit the tail nodes of\nboth lists and we'll move this pointer\nforward every time so that we traverse\nthe list with every iteration if you\nremember the logic behind this from the\nearlier version once we hit the tail\nnote of one list if there are nodes left\nover in the other linked list we don't\nneed to carry out a comparison operation\nanymore and we can simply add those\nnodes to the merged list\nthe first scenario we'll consider is if\nthe head of the left linked list is none\nthis means we're already past the tail\nof left and we can add all the nodes\nfrom the right linked list to the final\nmerge list so here i'll say if\nthe head node of left is none\nwe're past the tail\nadd the node\nfrom the right from right to merged\nlinked\nlist so here we'll say if\nleft head\nis none\ncurrent dot next node\nremember current points to the head of\nthe merge list that we're going to\nreturn so here we're setting its next\nnode reference to the head node on the\nright link list so we'll say right head\nthen when we do that we'll move the\nright head forward to the next node so\nlet's say right\nhead\nequal right hand\ndot next node\nthis terminates the loop on the next\niteration let's look at a visualization\nto understand why\nlet's say we start off with a linked\nlist containing four nodes so we keep\ncalling split on it until we have lists\nwith just a single head single node\nlinked lists essentially\nso let's focus on these two down here\nthat we'll call left and right\nwe haven't implemented the logic for\nthis part yet but here we would compare\nthe data values and see which one is\nless than the other\nso we'll assume that left's head is\nlesser than right's head so we'll set\nthis as the next node in the final merge\nlist\nleft is now an empty length list so left\ndot head equals none on the next pass\nthrough the loop left head is none which\nis the situation we just implemented\nhere we can go ahead and now assign\nright head as the next note in the merge\nlink list we know that right is also a\nsingly linked list\nhere's the crucial bit when we move the\npointer forward by calling next node on\nthe right node there is no node and the\nright link the right linked list is also\nempty now which means that both left\nhead and right head are none and either\none of these would cause our loop\ncondition to terminate\nso what we've done here is encoded a\nstopping condition for the loop so we\nneed to document this because it can get\nfuzzy so right above that line of code\ni'll say call next\non right\nto\nset loop condition\nto false\nokay there's another way we can arrive\nat this stopping condition and that's in\nthe opposite direction if we start with\nthe right head being none so here we'll\nsay i'm going to add another comment\nif oops not there there\nif\nthe head node of right\nis none\nwe're past the tail\nthen we'll say\nadd the tail node from left\nto merged linked list\nand then we'll add that condition we'll\nsay else if right head\nis none\nnow remember we can enter these even if\nleft head is none we can still go into\nthis condition we can still enter this\nif statement and execute this logic\nbecause the while loop the loop\ncondition here is an or statement so\neven if left head is false if this\nreturns true because there's a value\nthere there's a node there the loop will\nkeep going\nokay now in this case we want to set the\nhead of the left linked list as the next\nnode on the merge list so this is simply\nthe opposite of what we did over here\nwe'll set current dot next node\nequal to left head\nand then we'll move so after doing that\nwe can move the variable pointing to\nleft head forwards which as we saw\nearlier is past the tail node and then\nresults in the loop terminating so we'll\nsay left hand\nequal\nleft\nhead dot next node and we'll add that\ncomment here as well so we'll say call\nnext on left to set loop condition\nto false\nbecause here right head is none and now\nwe make left head none these two\nconditions we looked at where either the\nleft head or right head\nwere at the tail nodes of our respective\nlists those are conditions that we run\ninto when we've reached the bottom of\nour split where we have single element\nlinked lists or empty linked lists let's\naccount for our final condition where\nwe're evaluating a node that is neither\nthe head nor the tail of the list\nand this condition we need to reach into\nthe nodes and actually compare the data\nvalues to one another before we can\ndecide which node to add first to the\nmerged list\nso here this is an else because we've\narrived at our third condition third and\nfinal\nand here we'll say not at either tail\nnode\nobtain\nno data to perform\ncomparison operations so let's get each\nof those data values out of the\nrespective nodes so that we can compare\nit so we'll say left\ndata equal left head dot data\nand write data\nequal right head righthead.data\nokay what do we do next well we compare\nbut first let's add a comment so we'll\nsay if data\non left\nis less than right\nset current to left node and then\nmove\nactually we'll add this in a second so\nhere we'll say if left data\nis less than write data\nthen current dot next node\nequal left head\nand then\nwe'll add a comment and we'll say move\nleft head to next node\non that list so we'll say left head\nequal left head\ndot next node\njust as our comment says we'll check if\nthe left data is less than the right\ndata if it is since we want a list in\nascending order we'll assign the left\nnode to be the next node in the merged\nlist we'll also move the left head\nforward to traverse down to the next\nnode in that particular list now if left\nis larger than right then we want to do\nthe opposite so we'll go back to spaces\nanother comment\nif data on left is greater than right\nset current\nto\nright node\nokay so else\nhere we assign the right head to be the\nnext node in the merge list so\ncurrent.nextnode\nequal right\nhead\nand then comment\nmove right head to next node\nso right\nhead equal\nright head\ndot next\nnode okay after doing that we move the\nright head pointer to reference the next\nnode in the right list\nand finally at the end of each iteration\nof the while loop so not here but two\nspaces back right make sure we're\nindented at the same level as the while\nso we got to go yep or not the same\nlevel as the wild but the same outer\nscope\nand then there we're going to say\nmove current to next node\nso current equal current dot next node\nokay don't worry if this is confusing as\nalways we'll look at a visualization in\njust a bit so we'll wrap up this\nfunction by discarding that fake head we\nset earlier setting the correct node as\nhead and returning the linked list so\nwe'll add a comment\ndiscard fake head\nand set\nfirst\nmerged node as head so here we'll say\nhead equal\nmerged dot head dot next\nnode and then merged dot head equal head\nand finally return\nmerged\nokay we wrote a lot of code here a lot\nof it was comments but still it's a\nbunch let's take a quick break in the\nnext video we'll test this out evaluate\nour results and determine the runtime of\nour algorithm\nokay first things first let's test out\nour code now we'll keep it simple\nbecause writing a robust verify function\nwould actually take up this entire video\ninstead i'll leave that up to you to try\nas homework\nokay so\nat the very end\nlet's create a new linked list\nlet's add a few notes to this so l add\ni'm going to copy paste this\nso it makes it easier for me\nnot to have to retype a bunch so i'll\nadd 10\nuh then set 2\n44\n15\nand something like 200. okay then we'll\ngo ahead and print l so that we can\ninspect this list\nnext\nlet's create a declare variable here so\nwe'll call this sorted linked list\nand to this we're going to assign the\nresult of calling merge sort on l\nand then we'll print this\nso sorted\nlinked\nlist\nokay since we've taken care of all the\nlogic we know that this gets added in as\nnodes and then\nlet's see what this looks like all right\nso hit save\nand then bring up the console we're\ngoing to type out python\nlinked\nlist underscore merge sort dot pi and\nthen enter okay so we see that linked\nlist we first created remember that what\nwe add first right that eventually\nbecomes a tail or right yeah so 10 is\nthe tail 200 is the last one so 200 is\nthe head because i'm calling add it\nsimply adds each one to the head of the\nlist so here we have 10 to 44 15 and 200\nin the order we added and then the\nsorted linked list sorts it out so it's\n2 10 15 44 and 200. look at that a\nsorted linked list\nokay so let's visualize this from the\ntop\nwe have a linked list containing five\nnodes with integers 10 2 4 15 and 200 as\ndata respectively our merge sort\nfunction calls split on this list the\nsplit function calls size on the list\nand gets back 5 which makes our midpoint\n2.\nusing this midpoint we can split the\nlist using the node at index method\nremember that when doing this we deduct\n1 from the value of mid so we're going\nto split here using an index value of 1.\neffectively this is the same since we're\nstarting with an index value of 0 1\nmeans we split after node 2. we assign\nthe entire list to left half\nthen create a new list and assign that\nto right half\nwe can assign node 3 at index value 2 as\nthe head of the right list and remove\nthe references between node two and node\nthree so far so good right\nokay so now we're back in the merge sort\nfunction after having called split and\nwe have two linked lists\nlet's focus on just the left half\nbecause if you go back and look at our\ncode we're going to call merge sort on\nthe left linked list again\nthis means the next thing we'll do is\nrun through that split process since\nthis is a linked list containing two\nnodes this means that split is going to\nreturn a new left and right list each\nwith one node again we're back in the\nmerge sort function which means that we\ncall merge sort on this left list again\nsince this is a single node linked list\non calling merge sort on it we\nimmediately return before we split since\nwe hit that stopping condition so we go\nto the next line of code which is\ncalling merge sort on the right list as\nwell but again we'll get back\nimmediately because we hit that stopping\ncondition now that we have a left and\nright that we get back from calling\nmerge sort we can call merge on them\ninside the merge function we start by\ncreating a new linked list and attaching\na fake head\nthen we evaluate whether either the left\nor the right head is none\nsince neither condition is true we go to\nthe final step where we evaluate the\ndata in each node\nin this case the data in the right node\nis less than the left node so we assign\nthe right node as the next node in the\nmerge link list and move the right head\npointer forward\nin the merge link list we move our\ncurrent pointer forward to this new node\nwe've added and that completes one\niteration of the loop\non the next iteration righthead now\npoints to none since that was a single\nnode list and we can assign the rest of\nthe left linked list which is\neffectively the single node over to the\nmerge link list here we discard the fake\nhead move the next node up to be the\ncorrect head and return the newly merged\nsorted linked list remember that at this\npoint because right head and left head\npointed to none are while loop\nterminated\nso in this way we recursively split and\nrepeatedly merge sub-lists until we're\nback with one sorted linked list\nthe merge sort algorithm is a powerful\nsorting algorithm but ultimately it\ndoesn't really do anything complicated\nit just breaks the problem down until\nit's really simple to solve\nremember the technique here which we've\ntalked about before is called divide and\nconquer so i like to think of merge sort\nin this way there's a teacher at the\nfront of the room and she has a bunch of\nbooks that she needs to sort into\nalphabetical order instead of doing all\nthat work herself she splits that pile\ninto two and hands it to two students at\nthe front\neach of those students split it into two\nmore and hand it to the four students\nseated behind them as each student does\nthis eventually a bunch of single\nstudents has two books to compare and\nthey can sort it very easily and hand it\nback to the student who gave it to them\nin front of them who repeats the process\nbackwards so ultimately it's really\nsimple work is just efficiently\ndelegated\nnow back to our implementation here\nlet's talk about runtime so far other\nthan the node swapping we had to do it\nseems like most of our implementation is\nthe same right in fact it is including\nthe problems that we ran into in the\nlist version as well so in the first\nimplementation of merge sort we thought\nwe had an algorithm that ran in big o of\nn log n but turns out we didn't why well\nthe python list slicing operation if you\nremember actually takes up some amount\nof time amounting to big o of k\na true implementation of merge sort runs\nin quasi-linear or log linear time that\nis n times log n so we almost got there\nbut we didn't now in our implementation\nof merge sort on a linked list we\nintroduce the same problem so if we go\nback up to\nthe merge or rather the split function\nthis is where it happens now swapping\nnode references that's a constant time\noperation no big deal comparing values\nalso constant time\nthe bottleneck here like list slicing is\nin splitting a late list at the midpoint\nif we go back to our implementation you\ncan see here that we use the node at\nindex method which finds the node we\nwant by traversing the list\nthis means that every split operation\nincurs a big o of k cost where k here is\nthe midpoint of the list effectively n\nby 2 because we have to walk down the\nlist counting up the index until we get\nto that node\ngiven that overall splits take\nlogarithmic time our split function just\nlike the one we wrote earlier\nincurs a cost of\nbig o of\nk log n so here we'll say it takes\nbig o of k times log n\nnow the merge function also like the one\nwe wrote earlier takes linear time so\nthat one is good that one runs in the\nexpected amount of time so here we'll\nsay runs in linear\ntime\nand that would bring our overall run\ntime so up at the merge sort function we\ncan say this runs in\nbig o of k n times log\nn\nit's okay though this is a good start\nand one day when we talk about constant\nfactors and look at ways we can reduce\nthe cost of these operations using\ndifferent strategies we can come back\nand re-evaluate our code to improve our\nimplementation for now as long as you\nunderstand how merge sort works\nconceptually what the run time and space\ncomplexities look like and where the\nbottlenecks are in your code that's\nplenty of stuff\nif you're interested in learning more\nabout how we would solve this problem\ncheck out the notes in the teachers\nvideo in the next video let's wrap this\ncourse up\nand with that let's wrap up this course\nin the prerequisite to this course\nintroduction to algorithms we learned\nabout basic algorithms along with some\nconcepts like recursion and big o that\nset the foundation for learning about\nimplementing and evaluating algorithms\nin this course we learned what a data\nstructure is and how data structures go\nhand in hand with algorithms\nwe started off by exploring a data\nstructure that many of us use in our\nday-to-day programming arrays or lists\nas they are known in python\nwe take a peek under the hood at how\narrays are created and stored and\nexamine some of the common operations\ncarried out on arrays\nthese are operations that we write and\nexecute all the time but here we took a\nstep back and evaluated the run times of\nthese operations and how they affect the\nperformance of our code\nafter that we jumped into an entirely\nnew world where we wrote our own data\nstructure a singly linked list\nadmittedly linked lists aren't used much\nin day-to-day problem solving but it is\na good data structure to start off with\nbecause it is fairly straightforward to\nunderstand and not that much different\nfrom an array\nwe carried out the same exercise as we\ndid on arrays in that we looked at\ncommon data operations but since this\nwas a type we defined on our own we\nimplemented these operations ourselves\nand got to examine with a fine-tooth\ncomb how our code and the structure of\nthe type affected the runtime of these\noperations\nthe next topic we tackled was\nessentially worlds colliding we\nimplemented a sorting algorithm to sort\ntwo different data structures\nhere we got to see how all of the\nconcepts we've learned so far\nalgorithmic thinking time and space\ncomplexity and data structures all come\ntogether to tackle the problem of\nsorting data\nthis kind of exercise is one we're going\nto focus on moving forward as we try to\nsolve more real-world programming\nproblems using different data structures\nand algorithms\nif you've stuck with this content so far\nkeep up the great work this can be a\ncomplex topic but a really interesting\none and if you take your time with it\nyou will get a deeper understanding of\nprogramming and problem solving as\nalways check the notes for more\nresources and happy coding\n[Music]\nyou may have heard that algorithms and\ncomputer science are boring or\nfrustrating they certainly can be hard\nto figure out especially the way some\ntextbooks explain them but once you\nunderstand what's going on algorithms\ncan seem fascinating clever or even\nmagical\nto help further your understanding of\nalgorithms this course is going to look\nat two categories sorting algorithms and\nsearching algorithms you could argue\nthat these are the easiest kinds of\nalgorithms to learn but in learning how\nthese algorithms are designed we'll\ncover useful concepts like recursion and\ndivide and conquer that are used in many\nother sorts of algorithms and can even\nbe used to create brand new ones\nby the way all the code samples i'm\ngoing to show in the videos will be in\npython because it's a popular language\nthat's relatively easy to read but you\ndon't need to know python to benefit\nfrom this course you can see the\nteacher's notes for each video for info\non implementing these algorithms in your\nown favorite language\nour goal with this course is to give you\nan overview of how sorting and searching\nalgorithms work but many algorithms have\ndetails that can be handled in different\nways some of these details may distract\nfrom the big picture so we've put them\nin the teachers notes instead you don't\nneed to worry about these when\ncompleting the course for the first time\nbut if you're going back and referring\nto it later be sure to check the\nteacher's notes for additional info\nsuppose we have a list of names it's a\npretty big list a hundred thousand names\nlong this list could be part of an\naddress book or social media app\nand we need to find the locations of\nindividual names within the list\npossibly to look up additional data\nthat's connected to the name\nlet's assume there's no existing\nfunction in our programming language to\ndo this or that the existing function\ndoesn't suit our purpose in some way\nfor an unsorted list our only option may\nbe to use linear search also known as\nsequential search\nlinear search is covered in more detail\nelsewhere on our site check the\nteacher's notes for a link if you want\nmore details\nyou start at the first element you\ncompare it to the value you're searching\nfor if it's a match you return it if not\nyou go to the next element\nyou compare that to your target if it's\na match you return it if not you go to\nthe next element and so on through the\nwhole list\nthe problem with this is that you have\nto search the entire list every single\ntime we're not doing anything to narrow\ndown the search each time we have to\nsearch all of it\nif you're searching a big list or\nsearching it repeatedly this amount of\ntime can slow your whole lap down to the\npoint that people may not want to use it\nanymore that's why it's much more common\nto use a different algorithm for\nsearching lists binary search\nbinary search is also covered in more\ndetail elsewhere on our site check the\nteacher's notes for a link\nbinary search does narrow the search\ndown for us specifically it lets us get\nrid of half the remaining items we need\nto search through each time\nit does this by requiring that the list\nof values be sorted\nit looks at the value in the middle of\nthe list\nif the value it finds is greater than\nthe target value it ignores all values\nafter the value it's looking at\nif the value it finds is less than the\ntarget value it ignores all values\nbefore the value it's looking at\nthen it takes the set of values that\nremain and looks at the value in the\nmiddle of that list again if the value\nit finds is greater than the target\nvalue it ignores all values after the\nvalue it's looking at if the value it\nfinds is less than the target value it\nignores all values before the value it's\nlooking at\nbut as we mentioned binary search\nrequires the list of values you're\nsearching through to be sorted\nif the lists weren't sorted you would\nhave no idea which half of the values to\nignore because either half could contain\nthe value you're looking for you'd have\nno choice but to use linear search\nso before we can use binary search on a\nlist we need to be able to sort that\nlist we'll look at how to do that next\nour end goal is to sort a list of names\nbut comparing numbers is a little easier\nthan comparing strings so we're going to\nstart by sorting a list of numbers\ni'll show you how to modify our examples\nto sort strings at the end of the course\nto help make clear the importance of\nchoosing a good sorting algorithm we're\ngoing to start with a bad one it's\ncalled bogosort basically bogosort just\nrandomizes the order of the list\nrepeatedly until it's sorted\nhere's a python code file where we're\ngoing to implement bogosort\nit's not important to understand this\ncode here at the top although we'll have\ninfo on it in the teachers notes if you\nreally want it all you need to know is\nthat it takes the name of a file that we\npass on the command line loads it and\nreturns a python list which is just like\nan array in other languages containing\nall the numbers that it read from the\nfile\nlet me have the program print out the\nlist of numbers it loads so you can see\nit we'll call the print method and we'll\npass it the list of numbers\nsave that let's run it real quick\nwith python bogosort.pi\noh whoops and we need to\nprovide it\nthe name of the file here on the command\nline that we're going to load so it's in\nthe numbers directory a slash separates\nthe directory name from the file name\nfive dot text\nand there's our list of numbers that was\nloaded from the file\nokay let me delete that print statement\nand then we'll move on\nbogo sort just randomly rearranges the\nlist of values over and over so the\nfirst thing we're going to need is a\nfunction to detect when the list is\nsorted\nwe'll write an is sorted function that\ntakes a list of values as a parameter\nit'll return true if the list passed in\nis sorted or false if it isn't\nwe'll loop through the numeric index of\neach value in the list from 0 to 1 less\nthan the length of the list like many\nlanguages python list indexes begin at 0\nso a list with a length of 5 has indexes\ngoing from 0 through 4.\nif the list is sorted then every value\nin it will be less than the one that\ncomes after it so we test to see whether\nthe current item is greater than the one\nthat follows it\nif it is it means the whole list is not\nsorted so we can return false\nif we get down here it means the loop\ncompleted without finding any unsorted\nvalues python uses white space to mark\ncode blocks so unindenting the code like\nthis marks the end of the loop\nsince all the values are sorted we can\nreturn true\nnow we need to write the function that\nwill actually do the so-called sorting\nthe bogosort function will also take the\nlist of values it's working with as a\nparameter\nwe'll call our is sorted function to\ntest whether the list is sorted we'll\nkeep looping until is sorted returns\ntrue\npython has a ready-made function that\nrandomizes the order of elements in the\nlist\nsince the list isn't sorted we'll call\nthat function here\nand since this is inside the loop it'll\nbe randomized over and over until our is\nsorted function returns true\nif the loop exits it means is sorted\nreturned true and the list is sorted so\nwe can now return the sorted list\nfinally we need to call our bogosort\nfunction pass it the list we loaded from\nthe file and print the sorted list it\nreturns\nokay let's save this and try running it\nwe do so with python the name of the\nscript bogosort.pi\nand the name of the file we're going to\nrun it on\nnumbers directory5.txt\nit looks like it's sorting our list\nsuccessfully\nbut how efficient is this let's add some\ncode to track the number of times it\nattempts to sort the list\nup here at the top of the bogus sort\nfunction we'll add a variable to track\nthe number of attempts it's made we'll\nname it attempts and we'll set its\ninitial value to zero since we haven't\nmade any attempts yet\nwith each pass through the loop we'll\nprint the current number of attempts\nand then here at the end of the loop\nafter attempting to shuffle the values\nwe'll add one to the count of attempts\nlet's save this and let's try running it\nagain a couple times\nin the console i can just press the up\narrow to bring up the previous command\nand re-run it\nso it looks like this first run to sort\nthis five element list took 363 attempts\nlet's try it again\nthis time it only took 91 attempts\nwe're simply randomizing the list with\neach attempt so each\nrun of the program takes a random number\nof attempts\nnow let's try this same program with a\nlarger number of items\npython bogo sort\nnumbers\ni have a list of eight items set up here\nin this other file\nthis time it takes 11 000 attempts\nonly 487 this time\nand this time thirteen thousand you can\nsee that the trend is increasing\nsteadily\nthe problem with bogosort is that it\ndoesn't make any progress toward a\nsolution with each pass\nit could generate a list where just one\nvalue is out of order but then on the\nnext attempt it could generate a list\nwhere all the elements are out of order\nagain\nstumbling on a solution is literally a\nmatter of luck and for lists with more\nthan a few items it might never happen\nup next we'll look at selection sort\nit's a sorting algorithm that's still\nslow but it's better than bogo's sort\npreviously we showed you bogo sort a\nterrible sorting algorithm that\nbasically randomizes the order of a list\nand then checks to see if it happens to\nbe sorted\nthe problem with bogo's sort is that it\ndoesn't get any closer to a solution\nwith each operation and so with lists\nthat have more than a few items it'll\nprobably never finish sorting them\nnow we're going to look at an algorithm\nnamed selection sort it's still slow but\nat least each pass through the list\nbrings it a little closer to completion\nour implementation of selection sort is\ngoing to use two arrays an unsorted\narray and a sorted one some versions\nmove values around within just one array\nbut we're using two arrays to keep the\ncode simpler the sorted list starts out\nempty but we'll be moving values from\nthe unsorted list to the sorted list one\nat a time\nwith each pass we'll look through each\nof the values in the unsorted array find\nthe smallest one and move that to the\nend of the sorted array\nwe'll start with the first value in the\nunsorted array and say that's the\nminimum or smallest value we've seen so\nfar\nthen we'll look at the next value and\nsee if that's smaller than the current\nminimum if it is we'll mark that as the\nnew minimum\nthen we'll move to the next value and\ncompare that to the minimum again if\nit's smaller that becomes the new\nminimum we continue that way until we\nreach the end of the list\nat that point we know whatever value we\nhave marked as the minimum is the\nsmallest value in the whole list\nnow here's the part that makes selection\nsort better than bogo sort we then move\nthat minimum value from the unsorted\nlist to the end of the sorted list\nthe minimum value isn't part of the\nunsorted list anymore so we don't have\nto waste time looking at it anymore all\nour remaining comparisons will be on the\nremaining values in the unsorted list\nthen we start the process over at this\npoint our list consists of the numbers 8\n5 4 and 7. our first minimum is 8.\nwe start by comparing the minimum to\nfive five is smaller than eight so five\nbecomes the new minimum then we compare\nfive to four and four becomes the new\nminimum four is not smaller than seven\nthough so four remains the minimum four\ngets moved to the end of the sorted\narray becoming its second element\nthe process repeats again eight is the\nfirst minimum but five is smaller so\nthat becomes the minimum seven is larger\nso five stays is the minimum and five is\nwhat gets moved over to the sort of\narray and so on until there are no more\nitems left in the unsorted array and all\nwe have left is the sorted array\nso that's how selection sort works in\ngeneral now let's do an actual\nimplementation of it\nthis code here at the top is the same as\nwe saw in the bogo sword example it just\nloads a python list of numbers from a\nfile\nlet's implement the function that will\ndo our selection sort we're going to\npass in our python list containing all\nthe unsorted numbers we'll create an\nempty list that will hold all our sorted\nvalues\nwe'll loop once for each value in the\nlist\nwe call a function named index submin\nwhich we're going to write in just a\nminute that finds the minimum value in\nthe unsorted list and returns its index\nthen we call the pop method on the list\nand pass it the index of the minimum\nvalue pop will remove that item from the\nlist and return it we then add that\nvalue to the end of the sorted list\ngoing up a level of indentation signals\nto python that we're ending the loop\nafter the loop finishes we return the\nsorted list\nnow we need to write the function that\npicks out the minimum value we pass in\nthe list we're going to search\nwe mark the first value in the list as\nthe minimum it may or may not be the\nactual minimum but it's the smallest\nwe've seen on this pass through the list\nit's also the only value we've seen on\nthis pass through the list so far\nnow we loop through the remaining values\nin the list after the first\nwe test whether the value we're\ncurrently looking at is less than the\npreviously recorded\nminimum if it is then we set the current\nindex as the new index of the minimum\nvalue\nafter we've looped through all the\nvalues we return the index of the\nsmallest value we found\nlastly we need to actually run our\nselection sort method and print the\nsorted list it returns\nlet's save this and now let's try\nrunning it we run the python command and\npass it the name of our script\nselectionsort.pi\nin the numbers directory i've saved\nseveral data files filled with random\nnumbers one on each line five dot text\nhas five lines eight dot text has eight\nlines and to help us really measure the\nspeed of our algorithms ten thousand dot\ntext has ten thousand lines i've even\ncreated a file with a million numbers\nour script takes the path of a file to\nload as an argument so i'll give it the\npath of our file with five numbers\nnumbers slash five dot text\nthe script runs reads the numbers in the\nfile into a list calls our selection\nsort method with that list and then\nprints the sorted list\nlet me add a couple print statements\nwithin the selection sort function so\nyou can watch the sort happening\ndon't worry about figuring out the\npython formatting string that i use it's\njust there to keep the two lists neatly\naligned\ni'll add the first print statement\nbefore the loop runs at all\ni'll have it print out the unsorted list\nand the sorted list\ni'll add an identical print statement\nwithin the loop so we can watch values\nmoving from the unsorted list to the\nsorted list\nlet's save this\nand we'll try running the same command\nagain the output looks like this you can\nsee the unsorted list on the left and\nthe sorted list on the right\ninitially the sorted list is empty on\nthe first pass it selects the lowest\nnumber 1 and moves it to the sorted list\nthen it moves the next lowest number\nover four\nthis repeats until all the numbers have\nbeen moved to the sorted list\ni have another file with eight different\nnumbers in it let's try our program with\nthat\npython selection sort dot pi numbers\n8.text\nyou can see the same process at work\nhere notice that this file had some\nduplicate values too that's okay though\nbecause the index of min function only\nupdates the minimum index if the current\nvalue is less than the previous minimum\nif they're equal it just keeps the first\nminimum value it found and waits to move\nthe duplicate value over until the next\npass through the list\nso now we know that the selection sort\nalgorithm works but the data sets we've\nbeen giving it sort are tiny in the real\nworld algorithms need to work with data\nsets of tens of thousands or even\nmillions of items and do it fast i have\nanother file with ten thousand random\nnumbers in it\nlet's see if selection sort can handle\nthat\nif i run this as it is now though it'll\nprint out a lot of debug info as it\nsorts the list so first i'm going to go\ninto the program and remove the two\nprint statements in the selection sort\nfunction\nnow let's run the program again on the\ndot text file and see how long it takes\npython selection sort dot pi\nnumbers\nten thousand dot text\none one thousand two one thousand three\none four one thousand five one thousand\nsix one thousand seven one thousand\neight one thousand nine one thousand ten\none thousand eleven thousand twelve\nthousand thirteen thousand and it prints\nout all ten thousand of those numbers\nneatly sorted it took a little bit\nthough how long well counting the time\noff vocally isn't very precise and other\nprograms running on the system can skew\nthe amount of time your program takes to\ncomplete\nlet me show you a unix command that's\navailable here in workspaces which can\nhelp you type time followed by a space\nand then the command you want to run\nso this command by itself will print the\ncontents of our 5.txt file cat as in\nconcatenate numbers 5.text\nand this command will do the same thing\nbut it'll also keep track of how long it\ntakes the cat program to complete and\nreport the result time\ncat\nnumbers five dot text\nthe real row in the results is the\nactual amount of time for when the\nprogram started running to when it\ncompleted we can see it finished in a\nfraction of a second but as we said\nother programs running on the system can\ntake cpu resources in which case your\nprogram will seem slower than it is so\nwe generally want to ignore the real\nresult\nthe user result is the amount of time\nthe cpu actually spent running the\nprogram code so this is the total amount\nof time the code inside the cat program\ntook to run\nthe sys result is the amount of time the\ncpu spent running linux kernel calls\nthat your code made the linux kernel is\nresponsible for things like network\ncommunications and reading files so\nloading the 5.txt file is probably\nincluded in this result\nin evaluating code's performance we're\ngenerally going to want to add together\nthe user and sys results but cad is a\nvery simple program let's try running\nthe time command on our code and see if\nwe get a more interesting result\ntime python\nselection sort dot pi\nnumbers\nten thousand dot text\nthis takes much longer to complete\nnearly 12 seconds according to the real\ntime measurement but as we said the real\nresult is often skewed so let's\ndisregard that\nif we add the user and cis runtimes\ntogether we get about 6 seconds\nthe time for the program to complete\nwill vary a little bit each time you run\nit but if it's doing the same operations\nit usually won't change more than a\nfraction of a second if i run our\nselection sort script on the same file\nyou can see it completes in roughly the\nsame time\nnow let's try it on another file with 1\nmillion numbers time python selection\nsort dot pi numbers\n1 million dot text\nhow long does this one take i don't even\nknow while designing this course i tried\nrunning this command and my workspace\nconnection timed out before it completed\nso we'll just say that selection sort\ntakes a very very long time to sort a\nmillion numbers\nif we're going to sort a list that big\nwe're going to need a faster algorithm\nwe'll look into alternative sorting\nalgorithms shortly\nthe next two sorting algorithms we look\nat will rely on recursion which is the\nability of a function to call itself so\nbefore we move on we need to show you\nhow recursion works\nrecursive functions can be very tricky\nto understand imagine a row of dominoes\nstood on end where one domino falling\nover causes the next domino to fall over\nwhich causes the next domino to fall\nover causing a chain reaction it's kind\nof like that\nlet's suppose we need to write a\nfunction that adds together all the\nnumbers in an array or in the case of\npython a list\nnormally we'd probably use a loop for\nthis sort of operation\nthe function takes a list of the numbers\nwe want to add\nthe total starts at zero\nwe loop over every number contained in\nthe list and we add the current number\nto the total\nonce we're done looping we return the\naccumulated total\nif we call this sum function with a list\nof numbers it'll return the total when\nwe run this program it'll print out that\nreturn value 19. let's try it real quick\npython\nrecursion.pi oh whoops\nmustn't forget to save my work here\nand run it and we see the result 19.\nto demonstrate how recursion works let's\nrevise the sum function to use recursion\ninstead note that recursion is not the\nmost efficient way to add a list of\nnumbers together but this is a good\nproblem to use to demonstrate recursion\nbecause it's so simple one thing before\ni show you the recursive version though\nthis example is going to use the python\nslice syntax so i need to take a moment\nto explain that for those not familiar\nwith it\na slice is a way to get a series of\nvalues from a list\nlet's load up the python repel or read\nevaluate print loop so i can demonstrate\nwe'll start by creating a list of\nnumbers to work with numbers equals\na list\nwith 0 1 2 3 and 4\ncontaining those numbers\nlike arrays in most other languages\npython list indexes start at 0 so\nnumbers\n1\nwill actually get the second item from\nthe list\nwith slice notation i can actually get\nseveral items back\nit looks just like accessing an\nindividual index of a list\nbut then i type a colon\nfollowed by the list index that i want\nup to but not including\nso numbers 1 colon 4 would get us the\nsecond up to but not including the fifth\nitems from the list that is it'll get us\nthe second through the fourth items\nnow i know what you're thinking and\nyou're right that up to but not\nincluding rule is a little\ncounterintuitive but you can just forget\nall about it for now because we won't be\nusing a second index with any of our\npython slice operations in this course\nhere's what we will be using when you\nleave the second index off of a python\nslice it gives you the items from the\nfirst index up through the end of the\nlist wherever that is so numbers 1 colon\nwith no index following it will give us\nitems from the second index up through\nthe end of the list\nnumbers 2 colon will give us items from\nthe third index up to the end of the\nlist\nyou can also leave the first index off\nto get everything from the beginning of\nthe list numbers\ncolon 3 will get us everything from the\nbeginning of the list up to but not\nincluding the third index\nit's also worth noting that if you take\na list with only one item and you try to\nget everything from the non-existent\nsecond item onwards the result will be\nan empty list\nso if i create a list with just one item\nin it\nand i try\nto access from the second element\nonwards the second element doesn't exist\nso the result will be an empty list\ndon't worry too much about remembering\npython slice syntax it's not an\nessential part of sorting algorithms or\nrecursion i'm only explaining it to help\nyou read the code you're about to see\nso i'm going to exit the python rebel\nnow that we've covered recursion we can\nconvert our sum function to a recursive\nfunction\nit'll take the list of numbers to add\njust like before\nnow here's the recursive part we'll have\nthe sum function call itself we use\nslice notation to pass the entire list\nof numbers except the first one\nthen we add the first number in the list\nto the result of the recursive function\ncall and return the result\nso if we call sum with four numbers\nfirst it'll call itself with the\nremaining three numbers that call to sum\nwill then call itself with the remaining\ntwo numbers and so on\nbut if we save this and try to run it\npythonrecursion.pi\nwell first we get a syntax error it\nlooks like i accidentally indented\nsomething i shouldn't have so let me go\nfix that real quick\nthere we go that's suggested to python\nthat there was a loop or something there\nwhen there wasn't\nso let's go back to the terminal and try\nrunning this again\nthere we go now we're getting the error\ni was expecting recursion error maximum\nrecursion depth exceeded\nthis happens because some gets into an\ninfinite loop it keeps calling itself\nover and over the reason is that when we\nget down to a list of just one element\nand we take a slice from the\nnon-existent second element to the end\nthe result is an empty list that empty\nlist gets passed to the recursive call\nto sum which passes an empty list in its\nrecursive call to sum and so on until\nthe python interpreter detects too many\nrecursive calls and shuts the program\ndown what we need is to add a base case\nto this recursive function a condition\nwhere the recursion stops this will keep\nit from getting into an infinite loop\nwith the sum function the base case is\nwhen there are no elements left in the\nlist in that case there is nothing left\nto add and the recursion can stop\na base case is the alternative to a\nrecursive case a condition where\nrecursion should occur for the sum\nfunction the recursive case is when\nthere are still elements in the list to\nadd together\nlet's add a base case at the top of the\nfunction\npython treats a list that contains one\nor more values as a true value and it\ntreats a list containing no values as a\nfalse value\nso we'll add an if statement that says\nif there are no numbers in the list we\nshould return a sum of zero that way the\nfunction will exit immediately without\nmaking any further recursive calls to\nitself\nwe'll leave the code for the recursive\ncase unchanged\nif there are still numbers in the list\nthe function will call itself with any\nnumbers after the first then add the\nreturn value to the first number in the\nlist\nlet's save this and try running it again\npython recursion dot pi\noutput the sum of the numbers in the\nlist 19 but it's still not really clear\nhow this worked let's add a couple print\nstatements that will show us what it's\ndoing\nwe'll show the recursive call to sum and\nwhat it's being called with\nwe'll also add a call to print right\nbefore we return showing which of the\ncalls the sum is returning and what it's\nreturning\nlet me save this and resize the console\na bit\nand let's try running it again\npython recursion.pi\nsince the print calls are inside the sum\nfunction the first call to sum 1279\nisn't shown only the recursive calls are\nthis first call to sum ignores the first\nitem in the list 1 and calls itself\nrecursively it passes the remaining\nitems from the list 2 7 and 9.\nthat call to sum again ignores the first\nitem in the list it receives 2 and again\ncalls itself recursively it passes the\nremaining items in the list 7 and 9.\nthat call ignores the 7 and calls itself\nwith a 9\nand the last call shown here ignores the\n9\nand calls itself with an empty list\nat this point none of our recursive\ncalls to sum have returned yet each of\nthem is waiting on the recursive call it\nmade to sum to complete\npython and other programming languages\nuse something called a call stack to\nkeep track of this series of function\ncalls each function call is added to the\nstack along with the place in the code\nthat it needs to return when it\ncompletes\nbut now the empty list triggers the base\ncase causing the recursion to end and\nthe sum function to return zero\nthat zero value is returned to its\ncaller the caller adds the zero to the\nfirst and only value in its list nine\nthe result is nine\nthat nine value gets returned to the\ncaller which adds it to the first value\nin the list it received seven\nthe result is sixteen\nthat sixteen value is returned to the\ncaller which adds it to the first value\nin the list it received two the result\nis 18.\nthat 18 value is returned to the caller\nwhich adds it to the first value in the\nlist it received one the result is 19.\nthat 19 value is returned to the caller\nwhich is not the sum function\nrecursively calling itself but our main\nprogram this is our final result which\ngets printed\nit's the same result we got from the\nloop-based version of our program the\nend\nwe don't want the print statements in\nour final version of the program so let\nme just delete those real quick\nand there you have it a very simple\nrecursive function well the function is\nsimple but as you can see the flow of\ncontrol is very complex don't worry if\nyou didn't understand every detail here\nbecause we won't be using this\nparticular example again\nthere are two fundamental mechanisms you\nneed to remember a recursive function\nneeds a recursive case that causes it to\ncall itself\nand it also needs to eventually reach a\nbase case that causes the recursion to\nstop\nyou've seen bogo sort which doesn't make\nany progress towards sorting a list with\neach pass either it's entirely sorted or\nit isn't\nyou've seen selection sort which moves\none value over to a sorted list with\neach pass so that it has fewer items to\ncompare each time\nnow let's look at an algorithm that\nspeeds up the process further by further\nreducing the number of comparisons it\nmakes it's called quick sort\nhere's some python code where we'll\nimplement quick sort again you can\nignore these lines at the top we're just\nusing them to load a file full of\nnumbers into a list\nthe quick sort algorithm relies on\nrecursion to implement it we'll write a\nrecursive function we'll accept the list\nof numbers to sort as a parameter\nquicksort is recursive because it keeps\ncalling itself with smaller and smaller\nsubsets of the list you're trying to\nsort we're going to need a base case\nwhere the recursion stops so it doesn't\nenter an infinite loop\nlists that are empty don't need to be\nsorted and lists with just one element\ndon't need to be sorted either in both\ncases there's nothing to flip around so\nwe'll make that our base case if there\nare zero or one elements in the list\npassed to the quick sort function we'll\nreturn the unaltered list to the caller\nlastly we need to call our quick sort\nfunction with our list of numbers and\nprint the list it returns\nthat takes care of our base case now we\nneed a recursive case\nwe're going to rely on a technique\nthat's common in algorithm design called\ndivide and conquer basically we're going\nto take our problem and split it into\nsmaller and smaller problems until\nthey're easy to solve\nin this case that means taking our list\nand splitting it into smaller lists\nviewers a suggestion the process i'm\nabout to describe is complex there's\njust no way around it if you're having\ntrouble following along remember the\nvideo playback controls feel free to\nslow the play back down rewind or pause\nthe video as needed after you watch this\nthe first time you may also find it\nhelpful to rewind and make your own\ndiagram of the process as we go\nokay ready here goes\nsuppose we load the numbers from our\n8.txt file into a list how do we divide\nit\nit would probably be smart to have our\nquicksort function divide the list in a\nway that brings it closer to being\nsorted let's pick an item from the list\nwe'll just pick the first item for now\nfour\nwe'll call this value we've picked the\npivot like the center of a seesaw on a\nplayground\nwe'll break the list into two sublists\nthe first sub-list will contain all the\nitems in the original list that are\nsmaller than the pivot the second\nsub-list will contain all the items in\nthe original list that are greater than\nthe pivot\nthe sub list of values less than and\ngreater than the pivot aren't sorted\nbut what if they were you could just\njoin the sub lists and the pivot all\ntogether into one list and the whole\nthing would be sorted\nso how do we sort the sublist we call\nour quick sort function recursively on\nthem this may seem like magic but it's\nnot it's the divide and conquer\nalgorithm design technique at work\nif our quick sort function works on the\nbig list then it will work on the\nsmaller list too\nfor our first sub list we take the first\nitem it's the pivot again\nthat's three\nwe break the sub list into two sub lists\none with everything less than the pivot\nand one with everything greater than the\npivot\nnotice that there's a value equal to the\npivot that gets put into the less than\nsub-list our finished quicksort function\nis actually going to put everything\nthat's less than or equal to the pivot\nin the first sub-list\nbut i don't want to say less than or\nequal to over and over so i'm just\nreferring to it as the less than pivot\nsub-list\nalso notice that there are no values\ngreater than the pivot that's okay when\nwe join the sub-lists back together that\njust means nothing will be in the return\nlist after the pivot\nwe still have one sub list that's more\nthan one element long so we call our\nquick sort function on that too you and\ni can see that it's already sorted but\nthe computer doesn't know that so it'll\ncall it anyway just in case\nit picks the first element 2 as a pivot\nthere are no elements less than the\npivot and only one element greater than\nthe pivot\nthat's it for the recursive case we've\nfinally hit the base case for our quick\nsort function it'll be called on both\nthe empty list of elements less than the\npivot and the one item list of elements\ngreater than the pivot but both of these\nlists will be returned as they are\nbecause there's nothing to sort\nso now at the level of the call stack\nabove this the return sorted lists are\nused in place of the unsorted sub-list\nthat's less than the pivot and the\nunsorted sub-list that's greater than\nthe pivot\nthese are joined together into one\nsorted list remember that any empty\nlists get discarded\nthen at the level of the call stack\nabove that the return sorted lists are\nused in place of the unsorted sub-lists\nthere again they were already sorted but\nthe quick sort method was called on them\nanyway just in case\nthe sub-lists are joined together into\none sorted list at the level of the call\nstack above that the return sorted list\nis used in place of the unsorted\nsub-list that's less than the pivot so\nnow everything that's less than or equal\nto the pivot is sorted\nnow we call quick sort on the unsorted\nsub-list that's greater than the pivot\nand the process repeats for that\nsub-list\nwe pick the first element six is the\npivot we split the sub-list into\nsub-lists of elements that are less than\nand greater than this pivot and we\nrecursively call the quicksort function\nuntil those sub-lists are sorted\neventually a sorted sub-list is returned\nto our first quick sort function call\nwe combine the sub-list that's less than\nor equal to the pivot the pivot itself\nand the sub-list that's greater than the\npivot into a single list and because we\nrecursively sorted the sub lists the\nwhole list is sorted\nso that's how the quick sort function is\ngoing to work in the next video we'll\nshow you the actual code\nquicksort works by picking a pivot value\nthen splitting the full list into two\nsub-lists the first sub-list has all the\nvalues less than or equal to the pivot\nand the second sub-list has all the\nvalues greater than the pivot the quick\nsort function recursively calls itself\nto sort these sub-lists and then to sort\nthe sub-lists of those sub-lists until\nthe full list is sorted\nnow it's time to actually implement this\nin code\nwe already have the base case written\nany list passed in that consists of 0 or\n1 values will be returned as is because\nthere's nothing to sort\nnow we need to create a list that will\nhold all the values less than the pivot\nthat list will be empty at first we do\nthe same for values greater than the\npivot\nnext we need to choose the pivot value\nfor now we just grab the first item from\nthe list\nthen we loop through all the items in\nthe list following the pivot\nwe check to see whether the current\nvalue is less than or equal to the pivot\nif it is we copy it to the sub-list of\nvalues less than the pivot\notherwise the current value must be\ngreater than the pivot\nso we copy it to the other list\nthis last line is where the recursive\nmagic happens we call quick sort\nrecursively on the sub-list that's less\nthan the pivot we do the same for the\nsub-list that's greater than the pivot\nthose two calls will return sorted lists\nso we combine the sort of values less\nthan the pivot the pivot itself and the\nsort of values greater than the pivot\nthat gives us a complete sorted list\nwhich we return\nthis took a lot of prep work are you\nready let's try running it python\nquick sort\ndot pi\nnumbers 8.text\nit outputs our sorted list\ni don't know about you but this whole\nthing still seems a little too magical\nto me let's add a couple print\nstatements to the program so we can see\nwhat it's doing\nfirst we'll add a print statement right\nbefore the first call to the quick sort\nfunction so we can see the unsorted list\nwe'll also add a print right within the\nquick sort function right before the\nrecursive calls again this string\nformatting code is just to keep the info\naligned in columns\nlet's try running this again\nand now you can see our new debug output\neach time quicksort goes to call itself\nrecursively it prints out the pivot as\nwell as the sub list of items less than\nor equal to the pivot if any and the sub\nlist of items greater than the pivot if\nany you can see that first it sorts the\nsub list of items less than the pivot at\nthe top level\nit goes through a couple levels of\nrecursion to do that\nthere are actually additional levels of\nrecursion but they're from calls to\nquick sort with a list of 0 or 1\nelements and those calls return before\nthe print statement is reached\nthen it starts sorting the second sub\nlist from the top level with items\ngreater than the original pivot\nyou can see a couple levels of recursion\nfor that sort as well\nfinally when both sublists are\nrecursively sorted the original call to\nthe quicksort function returns and we\nget the sorted list back\nso we know that it works the next\nquestion is how well does it work let's\ngo back to our file of ten thousand\nnumbers and see if it can sort those\nfirst though i'm going to remove our two\ndebug calls to print so it doesn't\nproduce unreadable output\na quick note if you try running this on\na file with a lot of repeated values\nit's possible you'll get a runtime error\nmaximum recursion depth exceeded\nif you do see the teacher's notes for a\npossible solution\nnow let's try running our quick sort\nprogram against the ten thousand dot\ntext file python\nquick sort dot pi\nnumbers 10 000 dot text\nthere we go and it seems pretty fast but\nhow fast exactly let's run it with the\ntime command to see how long it takes\ntime python\nquick sort dot pi\nnumbers 10 000.text\nremember we need to ignore the real\nresult and add the user and sys results\nit took less than a second of cpu time\nto sort 10 000 numbers with quicksort\nremember that selection sort took about\n13 seconds\nthat's a pretty substantial improvement\nand with a million numbers selection\nsort took so long that it never even\nfinished successfully let's see if\nquicksort performs any better\ntime python quick sort dot pi\nnumbers\n1 million dot text\nnot only did quicksort sort a million\nnumbers successfully it only took about\n11 seconds of cpu time\nquicksort is clearly much much faster\nthan selection sort how much faster\nthat's something we'll discuss in a\nlater video\nwhat we've shown you here is just one\nway to implement quicksort\nalthough the basic algorithm is always\nthe same the details can vary like how\nyou pick the pivot see the teacher's\nnotes for more details\nlet's review another sorting algorithm\nmerge sort so that we can compare it\nwith quick sort merge sort is already\ncovered elsewhere on the site so we\nwon't go into as much detail about it\nbut we'll have more info in the\nteacher's notes if you want it\nboth quicksort and merge sword are\nrecursive the difference between them is\nin the sorting mechanism itself whereas\nquicksort sorts a list into two\nsub-lists that are less than or greater\nthan a pivot value\nmerge sort simply splits the list in\nhalf recursively and then sorts the\nhalves as it merges them back together\nthat's why it's called merge sort\nyou may recognize this code at the top\nby now it just loads a file full of\nnumbers into a list\nlet's define a recursive merge sort\nfunction as usual it'll take the list or\nsub-list that we want it to sort\nour base case is the same as with\nquicksort if the list has zero or one\nvalues there's nothing to sort so we\nreturn it as is\nif we didn't return it means we're in\nthe recursive case so first we need to\nsplit the list in half we need to know\nthe index we should split on so we get\nthe length of the list and divide it by\ntwo so for example if there are eight\nitems in the list we'll want an index of\nfour\nbut what if there were an odd number of\nitems in the list like seven we can't\nhave an index of 3.5 so we'll need to\nround down in that case since we're\nworking in python currently we can take\nadvantage of a special python operator\nthat divides and rounds the result down\nthe floor division operator it consists\nof a double slash\nnow we'll use the python slice syntax to\nget the left half of the list\nwe'll pass that list to a recursive call\nto the merge sort function\nwe'll also use slice syntax to get the\nright half of the list and pass that to\nmerge sort as well\nnow we need to merge the two halves\ntogether and sort them as we do it we'll\ncreate a list to hold the sorted values\nand now we get to the complicated part\nmerging the two halves together and\nsorted them as we do it\nwe'll be moving from left to right\nthrough the left half of the list\ncopying values over to the sorted values\nlist as we go this left index variable\nwill help us keep track of our position\nat the same time we'll also be moving\nfrom left to right through the right\nhalf of the list and copying values over\nso we need a separate write index\nvariable to track that position as well\nwe'll keep looping until we've processed\nall of the values in both halves of the\nlist\nwe're looking to copy over the lowest\nvalues first so first we test whether\nthe current value on the left side is\nless than the value on the right side\nif the left side value is less that's\nwhat we'll copy over to the sorted list\nand then we'll move to the next value in\nthe left half of the list\notherwise the current value from the\nright half must have been lower\nso we'll copy that value to the sorted\nlist instead\nand then we'll move to the next value in\nthe right half of the list\nthat ends the loop at this point one of\nthe two unsorted halves still has a\nvalue remaining and the other is empty\nwe won't waste time checking which is\nwhich we'll just copy the remainder of\nboth lists over to the sorted list the\none with the value left will add that\nvalue and the empty one will add nothing\nall the numbers from both halves should\nnow be copied to the sorted list so we\ncan return it\nfinally we need to kick the whole\nprocess off we'll call the merge sort\nfunction with the list of numbers we\nloaded and print the result\nlet's save this\nand we'll try it out on our file with\neight numbers\npython merge sort dot pi\nnumbers\neight dot text\nand it prints out the sorted list\nbut again this seems pretty magical\nlet's add some print statements to get\nsome insight into what it's doing\nfirst we'll print the unsorted list so\nwe can refer to it we'll add a print\nstatement right before we call the merge\nsort function for the first time\nthen we'll add another print statement\nwithin the merge sort function right\nafter the recursive calls this will show\nus the sorted left half and right half\nthat it's returning again don't worry\nabout the fancy python formatting string\nit just keeps the values neatly aligned\nlet me resize my console\nclear the screen\nand then we'll try running this again\nwhat we're seeing are the values being\nreturned from the recursive merge sort\nfunction calls not the original calls to\nmerge sort so what you see here is after\nwe reach the base case with a list\nthat's only one item in length and the\nrecursive calls start returning\nthe original list gets split into two\nunsorted halves four six three and two\nand nine seven three and five\nthe first half gets split in half again\nfour and six and three and two\nand each of those halves is halved again\ninto single element lists\nthere's nothing to sort in the single\nelement list so they're returned from\nthe merge sort function as is\nthose single element lists get merged\ninto two sub lists and sorted as they do\nso the four and six sub-list looks the\nsame after sorting as it did before\nsorting but the three and the two get\nsorted as they're combined into a\nsub-list the new order is two three\nthe order is shifted again when those\ntwo sub-lists get combined back into a\nsingle list two three four six\nthen we recursively sort the right half\nof the original list\nnine seven three five\nit gets split in half again nine seven\nand three five\nand each of those halves get broken into\nsingle element lists\nthere's nothing to sort there so the\nsingle element lists are returned as is\nthe first two are sorted as they're\nmerged seven nine and so are the second\nthree five\nand then those two sub lists get sorted\nas they're combined into another sub\nlist three five seven nine\nand finally everything is sorted as it's\nmerged back into the full sorted list\ntwo three three four five six seven nine\nthat's how merge sort works on a list of\neight numbers let's see if it works on a\nbigger list\nfirst i'll remove the two print\nstatements so we don't get an\noverwhelming amount of debug output\nthen i'll run it on a list of ten\nthousand items python merge sort dot pi\nnumbers ten thousand dot\ntext\nnot only did it work it was pretty fast\nbut which is faster merge sort or quick\nsort we'll look at that next\ni've removed the call to print that\ndisplays the sorted list at the end of\nour selection sort quick sort and merge\nsort scripts\nthat way it'll still run the sort but\nthe output won't get in the way of our\ncomparing runtimes\nlet's try running each of these scripts\nand see how long it takes\ntime python\nselection sort we'll do that one first\nnumbers\n10 000 dot text\nwe combine the user and sys results and\nthat gives us about six seconds\nnow let's try quick sort time python\nquick sort\ndot pi numbers\nten thousand dot text\nmuch faster less than a second and\nfinally time python\nmerge sort dot pi numbers ten thousand\ndot text\na little longer but far less than a\nsecond so even on a list with just 10\n000 numbers selection sort takes many\ntimes as long as quicksort and merge\nsort\nand remember i ran the selection sort\nscript on a file with a million numbers\nand it took so long that my workspace\ntimed out before it completed\nit looks like selection sort is out of\nthe running as a viable sorting\nalgorithm it may be easy to understand\nand implement but it's just too slow to\nhandle the huge data sets that are out\nin the real world\nnow let's try quicksort and merge sort\non our file with a million numbers and\nsee how they compare there time python\nquicksort dot pi\nnumbers\nmillion\ndot text\nlooks like it took about 11 seconds of\ncpu time\nnow let's try merge sort time python\nmerge sort dot pi\nnumbers\n1 million\ndot text\nthat took about 15 seconds of cpu time\nit looks like quicksort is marginally\nfaster than merge sort on this sample\ndata\nwe had to learn a lot of details for\neach algorithm we've covered in this\ncourse developers who need to implement\ntheir own algorithms often need to\nchoose an algorithm for each and every\nproblem they need to solve and they\noften need to discuss their decisions\nwith other developers can you imagine\nneeding to describe all the algorithms\nin this same level of detail all the\ntime you'd spend all your time in\nmeetings rather than programming\nthat's why big o notation was created as\na way of quickly describing how an\nalgorithm performs as the data set it's\nworking on increases in size\nbig o notation lets you quickly compare\nseveral algorithms to choose the best\none for your problem\nthe algorithms we've discussed in this\ncourse are very well known some job\ninterviewers are going to expect you to\nknow their big o run times so let's look\nat them\nremember that the n in big o notation\nrefers to the number of elements you're\noperating on with selection sort you\nneed to check each item in the list to\nsee if it's the lowest so you can move\nit over to the sorted list so that's in\noperations\nsuppose you're doing selection sort on a\nlist of five items and in this case\nwould be five so that's five operations\nbefore you can move an item to the\nsorted list\nbut with selection sort you have to loop\nover the entire list for each item you\nwant to move there are five items in the\nlist and you have to do five comparisons\nto move each one so it's more like 5\ntimes 5 operations or if we replace 5\nwith n it's n times n or n squared\nbut wait you might say half of that 5 by\n5 grid of operations is missing because\nwe're testing one fewer item in the\nunsorted list with each pass so isn't it\nmore like one half times n times n\nand this is true we're not doing a full\nn squared operations\nbut remember in big o notation as the\nvalue of n gets really big constants\nlike one half become insignificant and\nso we discard them\nthe big o runtime of selection sword is\nwidely recognized as being o n squared\nquicksort requires one operation for\neach element of the list it's sorting\nit needs to select a pivot first and\nthen it needs to sort elements into\nlists that are less than or greater than\nthe pivot\nso that's n operations to put that\nanother way if you have a list of eight\nitems then n is eight so it will take\neight operations to split the list\naround the pivot\nbut of course the list isn't sorted\nafter splitting it around the pivot just\nonce you have to repeat those eight\noperations several times in the best\ncase you'll pick a pivot that's right in\nthe middle of the list so that you're\ndividing the list exactly in half\nthen you keep dividing the list in half\nuntil you have a list with a length of\none\nthe number of times you need to divide n\nin half until you reach one is expressed\nas log n\nso you need to repeat n sorting\noperations log n times that leaves us\nwith the best case run time for quick\nsort of o n log n\nbut that's the best case what about the\nworst case well if you pick the wrong\npivot you won't be dividing the list\nexactly in half if you pick a really bad\npivot the next recursive call to\nquicksort will only reduce the list\nlength by one\nsince our quicksort function simply\npicks the first item to use as a pivot\nwe can make it pick the worst possible\npivot repeatedly simply by giving it a\nlist that's sorted in reverse order\nif we pick the worst possible pivot\nevery time we'll have to split the list\nonce for every item it contains and then\ndo end sorting operations on it\nyou already know another sorting\nalgorithm that only manages to reduce\nthe list by one element with each pass\nselection sort\nselection sort has a runtime of o n\nsquared and in the worst case that's the\nrun time for quicksort as well\nso which do we consider when trying to\ndecide whether to use quicksort the best\ncase or the worst case\nwell as long as your implementation\ndoesn't just pick the first item as a\npivot which we did so we could\ndemonstrate this issue\nit turns out that on average quicksort\nperforms closer to the best case\nmany quicksort implementations\naccomplish this simply by picking a\npivot at random on each recursive loop\nhere we are sorting our reverse sorted\ndata again but this time we pick pivots\nat random which reduces the number of\nrecursive operations needed\nsure random pivots sometimes give you\nthe best case and sometimes you'll\nrandomly get the worst case but it all\naverages out over multiple calls to the\nquick sort function\nnow with merge sort there's no pivot to\npick your list of n items always gets\ndivided in half log n times\nthat means merged sort always has a big\no runtime of o and log in\ncontrast that with quicksort which only\nhas a runtime of o and log n in the best\ncase in the worst case quick sorts\nruntime is o n squared\nand yet out in the real world quicksort\nis more commonly used than merge sort\nnow why is that if quicksort's big o\nruntime can sometimes be worse than\nmerge sorts\nthis is one of those situations where\nbig o notation doesn't tell you the\nwhole story all big o can tell you is\nthe number of times an operation is\nperformed it doesn't describe how long\nthat operation takes\nand the operation mergesor performs\nrepeatedly takes longer than the\noperation quicksort performs repeatedly\nbig-o is a useful tool for quickly\ndescribing how the runtime of an\nalgorithm increases is the data set it's\noperating on gets really really big\nbut you can't always choose between two\nalgorithms based just on their big o\nruntimes sometimes there's additional\ninfo you need to know about an algorithm\nto make a good decision\nnow that we can sort a list of items\nwe're well on our way to being able to\nsearch a list efficiently as well we'll\nlook at how to do that in the next stage\n[Music]\nnow that we've covered sorting\nalgorithms the groundwork has been laid\nto talk about searching algorithms\nif you need to search through an\nunsorted list of items binary search\nisn't an option because you have no idea\nwhich half of the list contains the item\nyou're looking for your only real option\nis to start at the beginning and compare\neach item in the list to your target\nvalue one at a time until you find the\nvalue you're looking for\nthis algorithm is called linear search\nor sequential search because the search\nproceeds in a straight line or sequence\neven though linear search is inefficient\nsearching for just one name will happen\nso fast that we won't be able to tell\nanything useful about the algorithm's\nruntime so let's suppose we had a\nhundred different names and that we\nneeded to know where they appear in a\nlist of unsorted names\nhere's some code that demonstrates\nas usual this code at the top isn't\nrelevant to the search algorithm it's\njust like the code that loaded a list of\nnumbers from a file in the previous\nstage but this code calls a different\nfunction load strings that loads a list\nof strings in\nif you want the load strings python code\nwe'll have it for you in the teacher's\nnotes\nhere's a separate hard-coded list\ncontaining the 100 names we're going to\nsearch for we'll loop through each name\nin this list and pass it to our search\nfunction to get the index within the\nfull list where it appears\nnow let's implement the search function\ncompared to the sorting algorithms this\nis going to be short the index of item\nfunction takes the python list you want\nto search through and a single target\nvalue you want to search for\nnow we need to loop over each item in\nthe list the range function gives us a\nrange of numbers from its first argument\nup to but not including its second\nargument so if our list had a length of\n5 this would loop over the indexes 0\nthrough 4.\nwe test whether the list item at the\ncurrent index matches our target\nif it does then we return the index of\nthe current item this will exit the\nindex of item function without looping\nover the remaining items in the list\nif we reach the end of the loop without\nfinding the target value that means it\nwasn't in the list so instead of\nreturning an index we return the special\npython value none which indicates the\nabsence of a value\nother languages have similar values like\nnil or null but if yours doesn't you\nmight have to return a value that would\notherwise be impossible like an index of\nnegative 1.\nnow let's call our new search function\nwe start by looping over the list of 100\nvalues we're looking for we're using the\nvalues themselves this time not their\nindexes within the list so there's no\nneed to mess with python's range\nfunction here's the actual call to the\nindex of item function we pass it the\nfull list of names that we loaded from\nthe file plus the name we want to search\nfor within that list then we store the\nindex it returns in a variable\nand lastly we print the index we get\nback from the index of item function\nlet's save this and go to our console\nand see if it works\npython linear search dot pi\nnames\nunsorted dot text\nand it'll print out the list of indexes\nfor each name\ni actually set it up so that the last\ntwo items in the list of names we're\ngoing to search for corresponded to the\nfirst and last name within the file\nso if we open up our unsorted.txt file\nwe'll see mary rosenberger is the first\nname and alonso viviano is the last name\nand those are the last two values in our\nlist of names we're searching for\nso it returned an index of zero for that\nsecond to last name and you can see that\nname here on line one of the file\nthe line numbering starts at one and the\npython list indexes start at zero so\nthat makes sense\nand for the last name it returned an\nindex of 109873\nand you can see that name here on line\n109 874 so we can see that it's\nreturning the correct indexes\nbut right now we're just searching for a\nhundred different names in a list of one\nhundred thousand names in the real world\nwe're going to be looking for many more\nnames than that within much bigger lists\nthan that can we do this any faster yes\nbut we'll need to use the binary search\nalgorithm and for that to work we need\nto sort our list of strings we'll do\nthat in the next video\nbefore we can use the binary search\nalgorithm on our list of names we need\nto sort it let's do that now we need to\nload our unsorted list of names from a\nfile sorted and write the sorted names\nback out to a new file\nagain this code at the top just loads a\nfile full of strings into a list\nwe'll use our quick sort method to sort\nthe list of names its code is completely\nunchanged from when you saw it in the\nprevious stage\nwe just call our quick sort function on\nthe list of names loaded from the file\nand save the list to a variable\nthen we loop through each name in the\nsorted list\nand we print that name\nthat's all there is to it let's save\nthis script and try running it\npython\nquicksort strings stop pi\nand we'll pass it the\nnames unsorted.text file\nlet me resize the console window here a\nlittle bit\nthat prints the sorted list of names out\nto the terminal but we need it in a file\nso we'll do what's called a redirect of\nthe program's output we'll run the same\ncommand as before but at the end we'll\nput a greater than sign followed by the\npath to a file that we want the program\noutput written to names\nsorted dot text\nredirecting works not only on linux\nbased systems like workspaces but also\non macs and even on windows machines you\njust need to be careful because if you\nredirect to an existing file its\ncontents will be overwritten without\nasking you\nlet me refresh the list of files in the\nsidebar\nand you'll see that we now have a new\nsorted dot text file in the names\ndirectory\nit's the same number of lines as the\nunsorted dot text file but all the names\nare sorted now\nnow we can load this file of sorted\nnames into a list and we'll be able to\nuse that list with the binary search\nalgorithm we'll see how to do that next\nnow that we have our list of names\nsorted we can use the binary search\nalgorithm on it let's see if we can use\nit to speed up our search for the\nindexes of 100 names\nbinary search keeps narrowing down the\nlist until it has the value it's looking\nfor it's faster than linear search\nbecause it discards half the potential\nmatches each time\nour code here at the top of our binary\nsearch script is unchanged from the\nprevious scripts we just call the load\nstrings function to load our 100 000\nsorted names from a file\nhere we've hard coded the list of 100\nnames we're going to search for again\nit's identical to the list from the\nlinear search script except that i've\nagain changed the last two names to\ncorrespond to the names on the first and\nlast lines of the file we'll be loading\nnow let's write the function that will\nimplement our binary search algorithm\nlike the linear search function before\nit'll take two arguments the first is\nthe list we're going to search through\nand the second is the target value we'll\nbe searching for again the binary search\nfunction will return the index it found\nthe value at or the special value none\nif it wasn't found\nbinary search is faster than a linear\nsearch because it discards half the\nvalues it has to search through each\ntime to do this it needs to keep track\nof a range that it still needs to search\nthrough\nto start that range is going to include\nthe full list\nthe first variable will track the lowest\nindex in the range we're searching to\nstart it's going to be 0 the first index\nin the full list\nlikewise the last variable will track\nthe highest index in the range we're\nsearching to start we'll set it to the\nhighest index in the full list\nif the first and last variables are\nequal then it means the size of the\nsearch range has shrunk to zero and\nthere is no match until that happens\nthough we'll keep looping to continue\nthe search we want to divide the list of\npotential matches in half each time to\ndo that we need to check the value\nthat's in the middle of the range we're\nsearching in\nwe add the indexes in the first and last\nvariables then divide by two to get\ntheir average we might get a fractional\nnumber which can't be used as a list\nindex so we also round down using\npython's double slash floor division\noperator\nall this will give us the index of the\nlist element that's the midpoint of the\nrange we're searching we store that in\nthe midpoint variable\nwhoops looks like my indentation got\nmixed up there let me fix that real\nquick there we go now we test whether\nthe list element at the midpoint matches\nthe target value\nif it does we return the midpoint index\nwithout looping any further our search\nis complete\notherwise if the midpoint element's\nvalue is less than the target value\nthen we know that our target value can't\nbe at the midpoint or any index prior to\nthat so we move the new start of our\nsearch range to just after the old\nmidpoint\notherwise the midpoint element's value\nmust have been greater than the target\nvalue\nwe know that our target value can't be\nat the midpoint or any index after that\nso we move the new end of our search\nrange to just before the old midpoint\nby unindenting here we mark the end of\nthe loop if the loop completes it means\nthe search range shrank to nothing\nwithout our finding a match and that\nmeans there's no matching value in the\nlist so we return the special python\nvalue none to indicate this\nlastly just as we did in our linear\nsearch script we need to search for each\nof the 100 names we loop over each name\nin our hard-coded list\nand we call the binary search function\nwith the sorted list of names we're\ngoing to load from the file and the\ncurrent name we're searching for\nwe store the returned list index in the\nindex variable\nand finally we print that variable\nlet's save this and go to our console\nand try running it\npython\nbinarysearch.pi\nand it's important to give it the name\nof the sorted file if it loads the\nunsorted file the binary search won't\nwork so names\nsorted dot text\nagain it prints out the list of indexes\nfor each name\ni once again set it up so the last two\nitems in the list of names we're going\nto search for corresponded to the first\nand last name in the file\nso it returned an index of zero for the\nsecond to last name\nand you can see that name\nhere's the second to last name aaron\naugustine\nyou can see that name here on line one\nof the file\nand for the last name it returned an\nindex of one zero nine eight seven three\nand you can see that name here on line\none zero nine eight seven four\nlet's check the third to last name for\ngood measure it looks like an index of\n97022 was printed for that name stephen\ndaras\nlet's search for steve and daras within\nthe file\nand here it is on line 97023\nremember that line numbers start on one\ninstead of zero so this actually matches\nup with the printed list index of 97022\nit looks like our binary search script\nis working correctly\nlet's try our linear search and binary\nsearch scripts out with the time command\nand see how they compare i've commented\nout the lines that print the indexes of\nmatches in the two scripts\nthat way they'll still call their\nrespective search functions what the 100\nnames we're searching for but they won't\nactually print the indexes out so we\nwon't have a bunch of output obscuring\nthe results of the time command\nfirst let's try the linear search script\ntime python\nlinear search dot pi\nnames\nand we can just use the unsorted list of\nnames for linear search\nremember we want to ignore the real\nresult and add the user and sys results\ntogether\nit looks like it took about .9 seconds\nfor linear search to find the 100 names\nin the list of one hundred thousand\nnow let's try timing the binary search\nscript time\npython\nbinarysearch.pi\nnames and for this one we need to use\nthe sorted list of names\nlooks like that took around a quarter\nsecond so less than half as long\nbear in mind that part of this time is\nspent loading the file of names into a\nlist the difference between linear\nsearch and binary search will be even\nmore pronounced as you search through\nbigger lists or search for more items\nlet's wrap up the course by looking at\nthe big o runtimes for linear search and\nbinary search these are going to be much\nsimpler to calculate than the sorting\nalgorithms were\nfor linear search you need to do one\ncomparison to the target value for each\nitem in the list again theoretically we\ncould find the target value before\nsearching the whole list but big o\nnotation is only concerned with the\nworst case where we have to search the\nentire list so for a list of eight items\nthat means eight operations\nthe big o runtime for linear search is o\nn where n is the number of items we're\nsearching through\nthis is also known as linear time\nbecause when the number of items and\nnumber of operations are compared on a\ngraph the result is a straight line\nlinear search looks pretty good until\nyou compare it to binary search for\nbinary search the number of items you\nhave to search through and therefore the\nnumber of operations is cut in half with\neach comparison\nremember the number of times you can\ndivide n by two until you reach one is\nexpressed as log n so the run time of\nbinary search in big o notation is o log\nn\neven for very large values of n that is\nvery large lists you have to search\nthrough the number of operations needed\nto search is very small binary search is\na very fast efficient algorithm\nthat's our tour of sorting and searching\nalgorithms be sure to check the\nteacher's notes for opportunities to\nlearn more thanks for watching\n",
  "words": [
    "course",
    "treehouse",
    "free",
    "code",
    "camp",
    "longtime",
    "fans",
    "learning",
    "platform",
    "kind",
    "enough",
    "let",
    "make",
    "course",
    "freely",
    "available",
    "youtube",
    "channel",
    "like",
    "course",
    "treehouse",
    "lot",
    "courses",
    "like",
    "one",
    "link",
    "description",
    "along",
    "time",
    "codes",
    "different",
    "sections",
    "course",
    "music",
    "hi",
    "name",
    "passan",
    "instructor",
    "treehouse",
    "welcome",
    "introduction",
    "algorithms",
    "whether",
    "high",
    "school",
    "college",
    "student",
    "developer",
    "industry",
    "someone",
    "learning",
    "code",
    "undoubtedly",
    "run",
    "term",
    "algorithm",
    "many",
    "people",
    "word",
    "kind",
    "scary",
    "represents",
    "body",
    "knowledge",
    "seems",
    "reach",
    "people",
    "computer",
    "science",
    "degrees",
    "know",
    "algorithms",
    "others",
    "brings",
    "feelings",
    "imposter",
    "syndrome",
    "might",
    "already",
    "know",
    "code",
    "real",
    "developer",
    "know",
    "anything",
    "algorithms",
    "personally",
    "made",
    "frame",
    "certain",
    "jobs",
    "skill",
    "level",
    "interview",
    "contained",
    "algorithm",
    "questions",
    "well",
    "whatever",
    "reasons",
    "course",
    "goal",
    "dispel",
    "feelings",
    "get",
    "comfortable",
    "basics",
    "algorithms",
    "like",
    "subject",
    "like",
    "start",
    "courses",
    "course",
    "course",
    "going",
    "cover",
    "basic",
    "set",
    "knowledge",
    "need",
    "foundation",
    "learning",
    "algorithms",
    "course",
    "less",
    "specific",
    "algorithms",
    "tools",
    "need",
    "evaluate",
    "algorithms",
    "understand",
    "perform",
    "compare",
    "make",
    "statement",
    "utility",
    "algorithm",
    "given",
    "context",
    "worry",
    "none",
    "theoretical",
    "learn",
    "concepts",
    "using",
    "algorithms",
    "course",
    "also",
    "writing",
    "code",
    "expect",
    "programming",
    "experience",
    "intend",
    "continue",
    "topic",
    "definitely",
    "stick",
    "around",
    "even",
    "know",
    "code",
    "might",
    "want",
    "learn",
    "basics",
    "programming",
    "meantime",
    "course",
    "using",
    "python",
    "programming",
    "language",
    "python",
    "reads",
    "lot",
    "like",
    "regular",
    "english",
    "language",
    "likely",
    "encounter",
    "learning",
    "algorithms",
    "days",
    "know",
    "code",
    "know",
    "code",
    "different",
    "language",
    "check",
    "notes",
    "section",
    "video",
    "links",
    "content",
    "might",
    "useful",
    "long",
    "understand",
    "fundamentals",
    "programming",
    "able",
    "follow",
    "along",
    "pretty",
    "well",
    "javascript",
    "developer",
    "student",
    "learning",
    "javascript",
    "example",
    "chances",
    "good",
    "still",
    "able",
    "understand",
    "code",
    "write",
    "later",
    "sure",
    "provide",
    "links",
    "along",
    "way",
    "need",
    "anything",
    "follow",
    "let",
    "start",
    "something",
    "simple",
    "algorithm",
    "algorithm",
    "set",
    "steps",
    "instructions",
    "completing",
    "task",
    "might",
    "sound",
    "like",
    "simplification",
    "really",
    "precisely",
    "algorithm",
    "recipe",
    "algorithm",
    "morning",
    "routine",
    "wake",
    "algorithm",
    "driving",
    "directions",
    "follow",
    "get",
    "destination",
    "also",
    "algorithm",
    "computer",
    "science",
    "term",
    "algorithm",
    "specifically",
    "means",
    "set",
    "steps",
    "program",
    "takes",
    "finish",
    "task",
    "written",
    "code",
    "code",
    "really",
    "generally",
    "speaking",
    "written",
    "algorithm",
    "given",
    "much",
    "code",
    "write",
    "considered",
    "algorithm",
    "people",
    "mean",
    "say",
    "know",
    "algorithms",
    "consider",
    "let",
    "say",
    "teacher",
    "classroom",
    "tell",
    "everyone",
    "assignment",
    "desks",
    "picture",
    "maze",
    "task",
    "come",
    "way",
    "find",
    "quickest",
    "way",
    "maze",
    "everyone",
    "thing",
    "comes",
    "solution",
    "every",
    "single",
    "one",
    "solutions",
    "viable",
    "solution",
    "valid",
    "example",
    "algorithm",
    "steps",
    "one",
    "needs",
    "take",
    "get",
    "maze",
    "classrooms",
    "group",
    "sort",
    "know",
    "people",
    "better",
    "ideas",
    "others",
    "diverse",
    "array",
    "skill",
    "sets",
    "time",
    "class",
    "picks",
    "best",
    "solutions",
    "time",
    "want",
    "solve",
    "maze",
    "go",
    "one",
    "solutions",
    "field",
    "algorithms",
    "many",
    "problems",
    "computer",
    "science",
    "pretty",
    "common",
    "regardless",
    "project",
    "working",
    "different",
    "people",
    "come",
    "different",
    "solutions",
    "common",
    "problems",
    "time",
    "field",
    "computer",
    "science",
    "identified",
    "several",
    "job",
    "well",
    "given",
    "task",
    "talk",
    "algorithms",
    "referring",
    "two",
    "points",
    "primarily",
    "saying",
    "established",
    "body",
    "knowledge",
    "solve",
    "particular",
    "problems",
    "well",
    "important",
    "know",
    "solutions",
    "important",
    "unaware",
    "solution",
    "exists",
    "might",
    "try",
    "come",
    "one",
    "likelihood",
    "solution",
    "wo",
    "good",
    "efficient",
    "whatever",
    "means",
    "compared",
    "thoroughly",
    "reviewed",
    "second",
    "component",
    "well",
    "part",
    "understanding",
    "algorithms",
    "knowing",
    "algorithm",
    "exists",
    "understanding",
    "apply",
    "understanding",
    "apply",
    "algorithm",
    "requires",
    "properly",
    "understanding",
    "problem",
    "hand",
    "arguably",
    "important",
    "part",
    "learning",
    "algorithms",
    "data",
    "structures",
    "progress",
    "content",
    "able",
    "look",
    "problem",
    "break",
    "distinct",
    "steps",
    "set",
    "steps",
    "able",
    "identify",
    "algorithm",
    "data",
    "structure",
    "best",
    "task",
    "hand",
    "concept",
    "called",
    "algorithmic",
    "thinking",
    "something",
    "going",
    "try",
    "cultivate",
    "together",
    "work",
    "content",
    "lastly",
    "learning",
    "algorithms",
    "gives",
    "deeper",
    "understanding",
    "complexity",
    "efficiency",
    "programming",
    "better",
    "sense",
    "code",
    "perform",
    "different",
    "situations",
    "something",
    "always",
    "want",
    "develop",
    "hone",
    "algorithmic",
    "thinking",
    "algorithms",
    "also",
    "come",
    "big",
    "tech",
    "interviews",
    "interviewers",
    "care",
    "much",
    "able",
    "write",
    "specific",
    "algorithm",
    "code",
    "fact",
    "break",
    "seemingly",
    "insurmountable",
    "problem",
    "distinct",
    "components",
    "identify",
    "right",
    "tools",
    "solve",
    "distinct",
    "component",
    "plan",
    "course",
    "though",
    "going",
    "focus",
    "tools",
    "concepts",
    "need",
    "aware",
    "dive",
    "topic",
    "algorithms",
    "ready",
    "let",
    "get",
    "started",
    "hey",
    "video",
    "going",
    "something",
    "unusual",
    "going",
    "play",
    "game",
    "mean",
    "two",
    "friends",
    "brittany",
    "john",
    "game",
    "really",
    "simple",
    "may",
    "played",
    "goes",
    "something",
    "like",
    "going",
    "think",
    "number",
    "1",
    "10",
    "guess",
    "number",
    "easy",
    "right",
    "guess",
    "number",
    "tell",
    "guess",
    "high",
    "low",
    "winner",
    "one",
    "fewest",
    "tries",
    "right",
    "john",
    "let",
    "start",
    "thinking",
    "number",
    "one",
    "ten",
    "answer",
    "three",
    "uh",
    "quick",
    "question",
    "range",
    "include",
    "one",
    "ten",
    "really",
    "good",
    "question",
    "john",
    "right",
    "establish",
    "bounds",
    "problem",
    "solution",
    "works",
    "every",
    "problem",
    "important",
    "part",
    "algorithmic",
    "thinking",
    "clearly",
    "define",
    "problem",
    "set",
    "clarify",
    "values",
    "count",
    "inputs",
    "yeah",
    "1",
    "ten",
    "included",
    "one",
    "low",
    "two",
    "low",
    "three",
    "correct",
    "okay",
    "easy",
    "one",
    "took",
    "john",
    "three",
    "tries",
    "get",
    "answer",
    "let",
    "switch",
    "brittany",
    "play",
    "another",
    "round",
    "using",
    "number",
    "answer",
    "okay",
    "brittany",
    "thinking",
    "number",
    "1",
    "10",
    "inclusive",
    "1",
    "10",
    "range",
    "number",
    "thinking",
    "5",
    "high",
    "2",
    "low",
    "3",
    "correct",
    "right",
    "two",
    "different",
    "ways",
    "playing",
    "game",
    "somehow",
    "even",
    "simple",
    "game",
    "saw",
    "different",
    "approaches",
    "figuring",
    "solution",
    "go",
    "back",
    "algorithmic",
    "thinking",
    "second",
    "means",
    "given",
    "problem",
    "one",
    "best",
    "solution",
    "instead",
    "try",
    "figure",
    "solution",
    "works",
    "better",
    "current",
    "problem",
    "first",
    "pass",
    "game",
    "took",
    "amount",
    "turns",
    "find",
    "answer",
    "obvious",
    "better",
    "approach",
    "mostly",
    "game",
    "easy",
    "let",
    "try",
    "one",
    "time",
    "time",
    "answer",
    "right",
    "john",
    "first",
    "one",
    "low",
    "two",
    "still",
    "low",
    "three",
    "low",
    "four",
    "low",
    "five",
    "still",
    "low",
    "six",
    "low",
    "seven",
    "low",
    "eight",
    "low",
    "nine",
    "low",
    "ten",
    "correct",
    "got",
    "okay",
    "thing",
    "britney",
    "time",
    "five",
    "low",
    "eight",
    "low",
    "nine",
    "still",
    "low",
    "ten",
    "right",
    "start",
    "see",
    "difference",
    "strategies",
    "answer",
    "three",
    "took",
    "number",
    "turns",
    "important",
    "number",
    "larger",
    "much",
    "larger",
    "10",
    "case",
    "start",
    "see",
    "britney",
    "strategy",
    "better",
    "took",
    "four",
    "tries",
    "john",
    "took",
    "played",
    "two",
    "rounds",
    "far",
    "seen",
    "different",
    "set",
    "results",
    "based",
    "number",
    "looking",
    "look",
    "john",
    "way",
    "things",
    "answer",
    "10",
    "round",
    "played",
    "worst",
    "case",
    "scenario",
    "take",
    "maximum",
    "number",
    "turns",
    "10",
    "guess",
    "picked",
    "random",
    "number",
    "like",
    "three",
    "hard",
    "differentiate",
    "strategy",
    "better",
    "performed",
    "exactly",
    "john",
    "worst",
    "case",
    "scenario",
    "clear",
    "winner",
    "terms",
    "strategy",
    "emerges",
    "terms",
    "algorithmic",
    "thinking",
    "starting",
    "get",
    "sense",
    "specific",
    "value",
    "searching",
    "may",
    "matter",
    "much",
    "value",
    "lies",
    "range",
    "given",
    "identifying",
    "helps",
    "us",
    "understand",
    "problem",
    "better",
    "let",
    "range",
    "numbers",
    "one",
    "one",
    "hundred",
    "start",
    "picking",
    "five",
    "answer",
    "trick",
    "okay",
    "time",
    "going",
    "run",
    "exercise",
    "time",
    "one",
    "one",
    "hundred",
    "one",
    "one",
    "hundred",
    "included",
    "one",
    "point",
    "without",
    "even",
    "run",
    "guess",
    "many",
    "tries",
    "john",
    "going",
    "take",
    "since",
    "starts",
    "one",
    "keeps",
    "going",
    "going",
    "take",
    "five",
    "tries",
    "see",
    "five",
    "cool",
    "correct",
    "okay",
    "brittany",
    "turn",
    "50",
    "high",
    "25",
    "still",
    "high",
    "13",
    "high",
    "seven",
    "high",
    "four",
    "low",
    "six",
    "high",
    "five",
    "correct",
    "let",
    "evaluate",
    "john",
    "took",
    "five",
    "tries",
    "brittany",
    "hand",
    "takes",
    "seven",
    "tries",
    "john",
    "wins",
    "round",
    "determining",
    "whose",
    "strategy",
    "preferred",
    "clear",
    "winner",
    "right",
    "tells",
    "us",
    "particularly",
    "useful",
    "look",
    "easy",
    "answers",
    "arrive",
    "number",
    "fairly",
    "quickly",
    "start",
    "range",
    "instead",
    "let",
    "try",
    "one",
    "know",
    "john",
    "going",
    "poorly",
    "let",
    "look",
    "worst",
    "case",
    "scenario",
    "answer",
    "100",
    "see",
    "britney",
    "performs",
    "scenario",
    "okay",
    "john",
    "let",
    "one",
    "time",
    "one",
    "100",
    "one",
    "fast",
    "forward",
    "scene",
    "well",
    "know",
    "happens",
    "john",
    "takes",
    "100",
    "tries",
    "hi",
    "brittany",
    "50",
    "low",
    "75",
    "low",
    "88",
    "low",
    "94",
    "low",
    "97",
    "low",
    "99",
    "low",
    "okay",
    "took",
    "brittney",
    "seven",
    "turns",
    "time",
    "clear",
    "winner",
    "compare",
    "individual",
    "performances",
    "number",
    "set",
    "see",
    "britney",
    "approach",
    "leaves",
    "john",
    "dust",
    "answer",
    "five",
    "right",
    "around",
    "start",
    "range",
    "john",
    "took",
    "five",
    "turns",
    "answer",
    "100",
    "right",
    "end",
    "range",
    "took",
    "100",
    "tries",
    "took",
    "20",
    "times",
    "amount",
    "tries",
    "get",
    "answer",
    "compared",
    "britney",
    "hand",
    "compare",
    "britney",
    "efforts",
    "number",
    "5",
    "took",
    "seven",
    "tries",
    "number",
    "100",
    "took",
    "amount",
    "tries",
    "pretty",
    "impressive",
    "pretend",
    "number",
    "tries",
    "number",
    "seconds",
    "takes",
    "britney",
    "john",
    "run",
    "attempts",
    "good",
    "estimate",
    "fast",
    "solutions",
    "ok",
    "done",
    "couple",
    "times",
    "brittany",
    "john",
    "getting",
    "tired",
    "let",
    "take",
    "break",
    "next",
    "video",
    "talk",
    "point",
    "exercise",
    "last",
    "video",
    "ran",
    "exercise",
    "guess",
    "number",
    "thinking",
    "point",
    "exercise",
    "might",
    "thinking",
    "hey",
    "thought",
    "learn",
    "algorithms",
    "exercise",
    "example",
    "real",
    "life",
    "situation",
    "run",
    "building",
    "websites",
    "apps",
    "writing",
    "code",
    "approaches",
    "taken",
    "john",
    "brittany",
    "find",
    "number",
    "thinking",
    "examples",
    "searching",
    "value",
    "might",
    "weird",
    "think",
    "one",
    "way",
    "search",
    "saw",
    "game",
    "speed",
    "result",
    "obtained",
    "differed",
    "john",
    "brittany",
    "think",
    "problem",
    "perspective",
    "company",
    "like",
    "facebook",
    "time",
    "recording",
    "facebook",
    "billion",
    "active",
    "users",
    "let",
    "say",
    "traveling",
    "different",
    "country",
    "meet",
    "someone",
    "want",
    "add",
    "facebook",
    "go",
    "search",
    "bar",
    "type",
    "person",
    "name",
    "simplify",
    "facebook",
    "app",
    "works",
    "search",
    "across",
    "billion",
    "records",
    "find",
    "person",
    "looking",
    "speed",
    "find",
    "person",
    "really",
    "matters",
    "imagine",
    "kind",
    "experience",
    "would",
    "search",
    "friend",
    "facebook",
    "put",
    "spinning",
    "activity",
    "indicator",
    "said",
    "come",
    "back",
    "couple",
    "hours",
    "think",
    "use",
    "facebook",
    "much",
    "case",
    "company",
    "perspective",
    "working",
    "making",
    "search",
    "fast",
    "possible",
    "using",
    "different",
    "strategies",
    "really",
    "matters",
    "said",
    "two",
    "strategies",
    "britney",
    "john",
    "used",
    "examples",
    "search",
    "specifically",
    "search",
    "algorithms",
    "strategy",
    "john",
    "took",
    "started",
    "beginning",
    "range",
    "counted",
    "one",
    "number",
    "type",
    "search",
    "called",
    "linear",
    "search",
    "also",
    "called",
    "sequential",
    "search",
    "better",
    "description",
    "works",
    "even",
    "simple",
    "search",
    "since",
    "really",
    "quite",
    "simple",
    "makes",
    "approach",
    "algorithm",
    "opposed",
    "looking",
    "something",
    "remember",
    "said",
    "algorithm",
    "set",
    "steps",
    "instructions",
    "complete",
    "task",
    "linear",
    "search",
    "search",
    "algorithm",
    "define",
    "like",
    "start",
    "beginning",
    "list",
    "range",
    "values",
    "compare",
    "current",
    "value",
    "target",
    "current",
    "value",
    "target",
    "value",
    "looking",
    "done",
    "move",
    "sequentially",
    "next",
    "value",
    "list",
    "repeat",
    "step",
    "reach",
    "end",
    "list",
    "target",
    "value",
    "list",
    "definition",
    "nothing",
    "programming",
    "fact",
    "use",
    "real",
    "world",
    "example",
    "could",
    "tell",
    "walk",
    "bookstore",
    "find",
    "particular",
    "book",
    "one",
    "ways",
    "could",
    "using",
    "linear",
    "search",
    "algorithm",
    "could",
    "start",
    "front",
    "bookstore",
    "read",
    "cover",
    "spine",
    "every",
    "book",
    "check",
    "matches",
    "book",
    "looking",
    "go",
    "next",
    "book",
    "repeat",
    "find",
    "run",
    "books",
    "makes",
    "algorithm",
    "specificity",
    "defined",
    "contrast",
    "jumping",
    "problem",
    "solving",
    "go",
    "along",
    "algorithm",
    "follows",
    "certain",
    "set",
    "guidelines",
    "use",
    "steps",
    "solve",
    "problem",
    "time",
    "face",
    "important",
    "first",
    "step",
    "defining",
    "algorithm",
    "algorithm",
    "problem",
    "trying",
    "solve",
    "first",
    "guideline",
    "algorithm",
    "must",
    "clear",
    "problem",
    "statement",
    "pretty",
    "hard",
    "define",
    "instruction",
    "set",
    "clear",
    "idea",
    "problem",
    "trying",
    "solve",
    "defining",
    "problem",
    "need",
    "specify",
    "input",
    "defined",
    "output",
    "looks",
    "like",
    "algorithm",
    "done",
    "job",
    "linear",
    "search",
    "input",
    "generally",
    "described",
    "series",
    "values",
    "output",
    "value",
    "matching",
    "one",
    "looking",
    "right",
    "trying",
    "stay",
    "away",
    "anything",
    "code",
    "related",
    "problem",
    "statement",
    "definition",
    "pretty",
    "generic",
    "get",
    "code",
    "actually",
    "tighten",
    "problem",
    "algorithm",
    "set",
    "steps",
    "solves",
    "problem",
    "given",
    "next",
    "guideline",
    "algorithm",
    "definition",
    "must",
    "contain",
    "specific",
    "set",
    "instructions",
    "particular",
    "order",
    "really",
    "need",
    "clear",
    "order",
    "instructions",
    "executed",
    "taking",
    "simple",
    "definition",
    "linear",
    "search",
    "switched",
    "order",
    "said",
    "move",
    "sequentially",
    "next",
    "value",
    "specifying",
    "first",
    "comparison",
    "step",
    "first",
    "value",
    "target",
    "one",
    "algorithm",
    "would",
    "find",
    "moved",
    "second",
    "value",
    "comparing",
    "might",
    "think",
    "okay",
    "avoidable",
    "mistake",
    "kind",
    "common",
    "sense",
    "thing",
    "computers",
    "know",
    "exactly",
    "tell",
    "specific",
    "order",
    "really",
    "important",
    "third",
    "guideline",
    "step",
    "algorithm",
    "definition",
    "must",
    "complex",
    "one",
    "needs",
    "explicitly",
    "clear",
    "mean",
    "able",
    "break",
    "steps",
    "additional",
    "subtasks",
    "step",
    "needs",
    "distinct",
    "one",
    "ca",
    "define",
    "linear",
    "search",
    "search",
    "find",
    "value",
    "interpreted",
    "many",
    "ways",
    "broken",
    "many",
    "steps",
    "clear",
    "next",
    "one",
    "might",
    "seem",
    "obvious",
    "algorithms",
    "produce",
    "result",
    "would",
    "know",
    "whether",
    "algorithm",
    "works",
    "able",
    "verify",
    "algorithm",
    "works",
    "correctly",
    "need",
    "result",
    "using",
    "search",
    "algorithm",
    "end",
    "result",
    "actually",
    "nothing",
    "indicates",
    "value",
    "found",
    "perfectly",
    "fine",
    "several",
    "ways",
    "represent",
    "nothing",
    "code",
    "long",
    "algorithm",
    "produce",
    "results",
    "understand",
    "behavior",
    "last",
    "guideline",
    "algorithm",
    "actually",
    "complete",
    "take",
    "infinite",
    "amount",
    "time",
    "let",
    "john",
    "loose",
    "world",
    "largest",
    "library",
    "asked",
    "find",
    "novel",
    "way",
    "knowing",
    "whether",
    "succeeded",
    "unless",
    "came",
    "back",
    "us",
    "result",
    "okay",
    "quick",
    "recap",
    "makes",
    "algorithm",
    "algorithm",
    "something",
    "one",
    "needs",
    "clearly",
    "defined",
    "problem",
    "statement",
    "input",
    "output",
    "using",
    "linear",
    "search",
    "input",
    "needs",
    "series",
    "values",
    "actually",
    "use",
    "brittany",
    "strategy",
    "one",
    "additional",
    "precondition",
    "speak",
    "think",
    "strategy",
    "required",
    "numbers",
    "sorted",
    "ascending",
    "order",
    "means",
    "input",
    "john",
    "series",
    "values",
    "solve",
    "problem",
    "input",
    "brittany",
    "algorithm",
    "needs",
    "sorted",
    "series",
    "values",
    "clearly",
    "defined",
    "problem",
    "statement",
    "clearly",
    "defined",
    "input",
    "clearly",
    "defined",
    "output",
    "second",
    "steps",
    "algorithm",
    "need",
    "specific",
    "order",
    "steps",
    "also",
    "need",
    "distinct",
    "able",
    "break",
    "subtasks",
    "next",
    "algorithm",
    "produce",
    "result",
    "finally",
    "algorithm",
    "complete",
    "finite",
    "amount",
    "time",
    "guidelines",
    "help",
    "us",
    "define",
    "algorithm",
    "also",
    "helps",
    "us",
    "verify",
    "algorithm",
    "correct",
    "executing",
    "steps",
    "algorithm",
    "given",
    "input",
    "must",
    "result",
    "output",
    "every",
    "time",
    "game",
    "played",
    "answer",
    "50",
    "every",
    "time",
    "every",
    "single",
    "time",
    "john",
    "must",
    "take",
    "50",
    "turns",
    "find",
    "answer",
    "somehow",
    "takes",
    "50",
    "turns",
    "one",
    "round",
    "30",
    "next",
    "technically",
    "correct",
    "algorithm",
    "consistent",
    "results",
    "set",
    "values",
    "know",
    "algorithm",
    "correct",
    "stress",
    "going",
    "designing",
    "algorithms",
    "start",
    "spend",
    "time",
    "learning",
    "tried",
    "true",
    "algorithms",
    "known",
    "efficiently",
    "solve",
    "problems",
    "reason",
    "talking",
    "makes",
    "good",
    "algorithm",
    "though",
    "set",
    "guidelines",
    "makes",
    "good",
    "algorithmic",
    "thinking",
    "one",
    "important",
    "skills",
    "want",
    "cultivate",
    "encounter",
    "problem",
    "rushing",
    "thinking",
    "solutions",
    "want",
    "work",
    "guidelines",
    "first",
    "break",
    "problem",
    "possible",
    "number",
    "smaller",
    "problems",
    "problem",
    "clearly",
    "defined",
    "terms",
    "input",
    "output",
    "know",
    "generally",
    "define",
    "algorithm",
    "let",
    "talk",
    "means",
    "good",
    "algorithm",
    "important",
    "thing",
    "keep",
    "mind",
    "one",
    "single",
    "way",
    "measure",
    "whether",
    "algorithm",
    "right",
    "solution",
    "context",
    "earlier",
    "touched",
    "two",
    "concepts",
    "correctness",
    "efficiency",
    "let",
    "define",
    "correctness",
    "clearly",
    "evaluate",
    "algorithm",
    "efficiency",
    "need",
    "ensure",
    "correctness",
    "define",
    "algorithms",
    "start",
    "defining",
    "problem",
    "definition",
    "problem",
    "clearly",
    "defined",
    "input",
    "satisfying",
    "preconditions",
    "clearly",
    "defined",
    "output",
    "algorithm",
    "deemed",
    "correct",
    "every",
    "run",
    "algorithm",
    "possible",
    "values",
    "input",
    "data",
    "always",
    "get",
    "output",
    "expect",
    "part",
    "correctness",
    "means",
    "possible",
    "input",
    "algorithm",
    "always",
    "terminate",
    "end",
    "two",
    "true",
    "algorithm",
    "correct",
    "pick",
    "algorithm",
    "textbook",
    "look",
    "correctness",
    "run",
    "bunch",
    "mathematical",
    "theory",
    "traditionally",
    "algorithm",
    "correctness",
    "proved",
    "mathematical",
    "induction",
    "form",
    "reasoning",
    "used",
    "mathematics",
    "verify",
    "statement",
    "correct",
    "approach",
    "involves",
    "writing",
    "called",
    "specification",
    "correctness",
    "proof",
    "wo",
    "going",
    "course",
    "proof",
    "induction",
    "important",
    "part",
    "designing",
    "algorithms",
    "confident",
    "understand",
    "algorithms",
    "terms",
    "use",
    "without",
    "getting",
    "math",
    "pick",
    "textbook",
    "feel",
    "daunted",
    "worry",
    "still",
    "figure",
    "things",
    "without",
    "right",
    "correct",
    "algorithm",
    "start",
    "talk",
    "efficient",
    "algorithm",
    "remember",
    "efficiency",
    "ultimately",
    "matters",
    "help",
    "us",
    "solve",
    "problems",
    "faster",
    "deliver",
    "better",
    "end",
    "user",
    "experience",
    "variety",
    "fields",
    "example",
    "algorithms",
    "used",
    "sequencing",
    "dna",
    "efficient",
    "sequencing",
    "algorithms",
    "allow",
    "us",
    "research",
    "understand",
    "diseases",
    "better",
    "faster",
    "let",
    "get",
    "ahead",
    "start",
    "simple",
    "evaluating",
    "john",
    "linear",
    "search",
    "algorithm",
    "terms",
    "efficiency",
    "first",
    "mean",
    "efficiency",
    "two",
    "measures",
    "efficiency",
    "comes",
    "algorithms",
    "time",
    "space",
    "sounds",
    "really",
    "cool",
    "huh",
    "efficiency",
    "measured",
    "time",
    "something",
    "hear",
    "called",
    "time",
    "complexity",
    "measure",
    "long",
    "takes",
    "algorithm",
    "run",
    "time",
    "complexity",
    "understood",
    "generally",
    "outside",
    "context",
    "code",
    "computers",
    "long",
    "takes",
    "complete",
    "job",
    "universal",
    "measure",
    "efficiency",
    "less",
    "time",
    "take",
    "efficient",
    "second",
    "measure",
    "efficiency",
    "called",
    "space",
    "complexity",
    "pretty",
    "computer",
    "specific",
    "deals",
    "amount",
    "memory",
    "taken",
    "computer",
    "good",
    "algorithms",
    "need",
    "balance",
    "two",
    "measures",
    "useful",
    "example",
    "blazingly",
    "fast",
    "algorithm",
    "might",
    "matter",
    "algorithm",
    "consumes",
    "memory",
    "available",
    "concepts",
    "time",
    "space",
    "complexity",
    "measured",
    "using",
    "metric",
    "technical",
    "sounding",
    "metric",
    "let",
    "build",
    "slowly",
    "start",
    "simple",
    "videos",
    "ago",
    "played",
    "game",
    "brittany",
    "john",
    "tried",
    "guess",
    "number",
    "thinking",
    "effectively",
    "searching",
    "value",
    "figure",
    "efficient",
    "algorithm",
    "algorithm",
    "suited",
    "purposes",
    "consider",
    "number",
    "tries",
    "took",
    "guess",
    "search",
    "value",
    "indicator",
    "time",
    "take",
    "run",
    "exercise",
    "good",
    "indicator",
    "long",
    "algorithm",
    "runs",
    "given",
    "set",
    "values",
    "measurement",
    "called",
    "running",
    "time",
    "algorithm",
    "use",
    "define",
    "time",
    "complexity",
    "game",
    "play",
    "four",
    "rounds",
    "let",
    "recap",
    "focusing",
    "john",
    "performance",
    "round",
    "one",
    "10",
    "values",
    "target",
    "3",
    "john",
    "took",
    "3",
    "turns",
    "round",
    "2",
    "10",
    "values",
    "target",
    "10",
    "john",
    "took",
    "10",
    "turns",
    "round",
    "3",
    "100",
    "values",
    "target",
    "john",
    "took",
    "five",
    "tries",
    "finally",
    "round",
    "four",
    "target",
    "100",
    "given",
    "100",
    "values",
    "john",
    "took",
    "100",
    "tries",
    "paper",
    "hard",
    "gauge",
    "anything",
    "performance",
    "comes",
    "anything",
    "numbers",
    "though",
    "like",
    "put",
    "graph",
    "compare",
    "visually",
    "vertical",
    "let",
    "measure",
    "number",
    "tries",
    "took",
    "john",
    "guess",
    "answer",
    "running",
    "time",
    "algorithm",
    "horizontal",
    "put",
    "turn",
    "number",
    "values",
    "well",
    "target",
    "value",
    "could",
    "plot",
    "target",
    "value",
    "horizontal",
    "axis",
    "leaves",
    "context",
    "meaning",
    "behind",
    "far",
    "impressive",
    "john",
    "took",
    "five",
    "tries",
    "range",
    "went",
    "100",
    "took",
    "three",
    "tries",
    "maximum",
    "10",
    "values",
    "could",
    "plot",
    "maximum",
    "range",
    "values",
    "leaving",
    "half",
    "picture",
    "data",
    "points",
    "however",
    "satisfy",
    "requirements",
    "plot",
    "values",
    "target",
    "number",
    "john",
    "looking",
    "maximum",
    "range",
    "values",
    "data",
    "point",
    "includes",
    "size",
    "data",
    "set",
    "well",
    "effort",
    "additional",
    "benefit",
    "approach",
    "well",
    "three",
    "ways",
    "measure",
    "well",
    "john",
    "general",
    "well",
    "algorithm",
    "first",
    "check",
    "well",
    "john",
    "best",
    "case",
    "good",
    "scenarios",
    "perspective",
    "strategy",
    "range",
    "100",
    "values",
    "answer",
    "low",
    "number",
    "like",
    "three",
    "start",
    "range",
    "good",
    "scenario",
    "guess",
    "fairly",
    "quickly",
    "one",
    "best",
    "case",
    "scenario",
    "could",
    "check",
    "well",
    "average",
    "could",
    "run",
    "game",
    "bunch",
    "times",
    "average",
    "running",
    "time",
    "would",
    "give",
    "us",
    "much",
    "better",
    "picture",
    "john",
    "performance",
    "time",
    "estimates",
    "would",
    "high",
    "value",
    "searching",
    "start",
    "range",
    "far",
    "low",
    "end",
    "range",
    "let",
    "imagine",
    "scenario",
    "facebook",
    "naively",
    "implements",
    "linear",
    "search",
    "finding",
    "friends",
    "looked",
    "latest",
    "census",
    "saw",
    "50",
    "names",
    "start",
    "letters",
    "j",
    "first",
    "40",
    "alphabet",
    "thought",
    "okay",
    "average",
    "linear",
    "search",
    "serves",
    "us",
    "well",
    "rest",
    "whose",
    "names",
    "start",
    "letter",
    "j",
    "alphabet",
    "searching",
    "name",
    "would",
    "take",
    "longer",
    "average",
    "much",
    "longer",
    "someone",
    "whose",
    "name",
    "starts",
    "letter",
    "z",
    "measuring",
    "run",
    "time",
    "algorithm",
    "average",
    "might",
    "seem",
    "like",
    "good",
    "strategy",
    "wo",
    "necessarily",
    "provide",
    "accurate",
    "picture",
    "picking",
    "maximum",
    "range",
    "measuring",
    "algorithm",
    "worst",
    "case",
    "scenario",
    "analyzing",
    "worst",
    "case",
    "scenario",
    "quite",
    "useful",
    "indicates",
    "algorithm",
    "never",
    "perform",
    "worse",
    "expect",
    "room",
    "surprises",
    "back",
    "graph",
    "going",
    "plot",
    "number",
    "tries",
    "proxy",
    "running",
    "time",
    "algorithm",
    "number",
    "values",
    "range",
    "shorten",
    "n",
    "n",
    "also",
    "represents",
    "john",
    "worst",
    "case",
    "scenario",
    "n",
    "10",
    "takes",
    "10",
    "turns",
    "n",
    "100",
    "takes",
    "100",
    "turns",
    "two",
    "values",
    "alone",
    "insufficient",
    "really",
    "get",
    "sort",
    "visual",
    "understanding",
    "moreover",
    "realistic",
    "john",
    "may",
    "take",
    "long",
    "time",
    "work",
    "100",
    "numbers",
    "computer",
    "time",
    "evaluate",
    "performance",
    "linear",
    "search",
    "context",
    "computer",
    "probably",
    "throw",
    "harder",
    "larger",
    "ranges",
    "values",
    "nice",
    "thing",
    "evaluating",
    "worst",
    "case",
    "scenario",
    "actually",
    "work",
    "know",
    "result",
    "given",
    "value",
    "n",
    "using",
    "linear",
    "search",
    "take",
    "n",
    "tries",
    "find",
    "value",
    "worst",
    "case",
    "scenario",
    "let",
    "add",
    "values",
    "build",
    "graph",
    "okay",
    "good",
    "picture",
    "starting",
    "look",
    "like",
    "values",
    "get",
    "really",
    "large",
    "running",
    "time",
    "algorithm",
    "gets",
    "large",
    "well",
    "sort",
    "already",
    "knew",
    "dig",
    "runtime",
    "deeper",
    "let",
    "switch",
    "tracks",
    "evaluate",
    "brittany",
    "work",
    "something",
    "compare",
    "become",
    "easier",
    "build",
    "mental",
    "model",
    "around",
    "time",
    "complexity",
    "algorithm",
    "john",
    "used",
    "linear",
    "search",
    "seemed",
    "familiar",
    "us",
    "could",
    "understand",
    "us",
    "search",
    "things",
    "real",
    "life",
    "anyway",
    "brittany",
    "approach",
    "hand",
    "got",
    "results",
    "quickly",
    "bit",
    "harder",
    "understand",
    "let",
    "break",
    "like",
    "john",
    "approach",
    "britney",
    "started",
    "series",
    "values",
    "list",
    "numbers",
    "input",
    "john",
    "started",
    "beginning",
    "list",
    "searched",
    "sequentially",
    "brittany",
    "strategy",
    "always",
    "start",
    "middle",
    "range",
    "asks",
    "comparison",
    "question",
    "number",
    "middle",
    "range",
    "equal",
    "answer",
    "looking",
    "greater",
    "less",
    "answer",
    "greater",
    "eliminate",
    "values",
    "less",
    "one",
    "currently",
    "evaluating",
    "lesser",
    "answer",
    "eliminate",
    "values",
    "greater",
    "one",
    "currently",
    "evaluating",
    "range",
    "values",
    "left",
    "repeats",
    "process",
    "arrives",
    "answer",
    "let",
    "visualize",
    "looking",
    "round",
    "three",
    "round",
    "three",
    "number",
    "values",
    "range",
    "100",
    "answer",
    "bar",
    "represents",
    "range",
    "values",
    "one",
    "left",
    "100",
    "right",
    "pointer",
    "represents",
    "value",
    "britney",
    "chooses",
    "evaluate",
    "starts",
    "middle",
    "asks",
    "equal",
    "answer",
    "say",
    "high",
    "tells",
    "value",
    "evaluating",
    "greater",
    "target",
    "value",
    "means",
    "point",
    "searching",
    "values",
    "right",
    "50",
    "values",
    "greater",
    "50",
    "range",
    "discard",
    "values",
    "altogether",
    "consider",
    "values",
    "1",
    "50",
    "beauty",
    "strategy",
    "reason",
    "britney",
    "able",
    "find",
    "answer",
    "turns",
    "every",
    "value",
    "evaluates",
    "discard",
    "half",
    "current",
    "range",
    "second",
    "turn",
    "picks",
    "value",
    "middle",
    "current",
    "range",
    "asks",
    "question",
    "say",
    "value",
    "high",
    "tells",
    "discard",
    "everything",
    "greater",
    "25",
    "range",
    "values",
    "drops",
    "1",
    "evaluates",
    "number",
    "middle",
    "roughly",
    "13",
    "tell",
    "still",
    "high",
    "discards",
    "values",
    "greater",
    "moves",
    "value",
    "7",
    "still",
    "high",
    "moves",
    "4",
    "low",
    "discard",
    "everything",
    "less",
    "4",
    "leaves",
    "numbers",
    "4",
    "picked",
    "6",
    "high",
    "leaves",
    "one",
    "value",
    "seems",
    "like",
    "lot",
    "work",
    "able",
    "get",
    "rid",
    "half",
    "values",
    "turn",
    "makes",
    "algorithm",
    "much",
    "efficient",
    "one",
    "subtlety",
    "using",
    "binary",
    "search",
    "might",
    "caught",
    "search",
    "method",
    "work",
    "mentioned",
    "values",
    "need",
    "sorted",
    "linear",
    "search",
    "matter",
    "values",
    "sorted",
    "since",
    "linear",
    "search",
    "algorithm",
    "progresses",
    "sequentially",
    "checking",
    "every",
    "element",
    "list",
    "target",
    "value",
    "exists",
    "list",
    "fouled",
    "let",
    "say",
    "range",
    "values",
    "100",
    "unsorted",
    "britney",
    "would",
    "start",
    "middle",
    "something",
    "like",
    "14",
    "ask",
    "value",
    "low",
    "high",
    "say",
    "high",
    "discards",
    "everything",
    "less",
    "example",
    "starts",
    "fall",
    "apart",
    "well",
    "britney",
    "knows",
    "numbers",
    "less",
    "14",
    "greater",
    "one",
    "need",
    "actual",
    "range",
    "values",
    "solve",
    "computer",
    "however",
    "need",
    "remember",
    "search",
    "algorithms",
    "run",
    "lists",
    "containing",
    "sorts",
    "data",
    "always",
    "range",
    "values",
    "containing",
    "numbers",
    "real",
    "use",
    "case",
    "binary",
    "search",
    "going",
    "implement",
    "bit",
    "algorithm",
    "would",
    "return",
    "target",
    "value",
    "already",
    "know",
    "search",
    "algorithm",
    "providing",
    "something",
    "search",
    "instead",
    "returns",
    "position",
    "list",
    "target",
    "occupies",
    "without",
    "list",
    "sorted",
    "binary",
    "search",
    "algorithm",
    "would",
    "discard",
    "values",
    "left",
    "14",
    "could",
    "include",
    "position",
    "target",
    "value",
    "eventually",
    "get",
    "result",
    "back",
    "saying",
    "target",
    "value",
    "exist",
    "list",
    "inaccurate",
    "earlier",
    "defining",
    "linear",
    "simple",
    "search",
    "said",
    "input",
    "list",
    "values",
    "output",
    "target",
    "value",
    "specifically",
    "position",
    "target",
    "value",
    "list",
    "binary",
    "search",
    "also",
    "precondition",
    "input",
    "list",
    "must",
    "sorted",
    "let",
    "formally",
    "define",
    "binary",
    "search",
    "first",
    "input",
    "sorted",
    "list",
    "values",
    "output",
    "position",
    "list",
    "target",
    "value",
    "searching",
    "sort",
    "values",
    "indicate",
    "target",
    "exist",
    "list",
    "remember",
    "guidelines",
    "defining",
    "algorithm",
    "let",
    "put",
    "really",
    "quick",
    "steps",
    "algorithm",
    "need",
    "specific",
    "order",
    "steps",
    "also",
    "need",
    "distinct",
    "algorithms",
    "produce",
    "result",
    "finally",
    "algorithm",
    "complete",
    "finite",
    "amount",
    "time",
    "let",
    "use",
    "define",
    "algorithm",
    "step",
    "one",
    "determine",
    "middle",
    "position",
    "sorted",
    "list",
    "step",
    "two",
    "compare",
    "element",
    "middle",
    "position",
    "target",
    "element",
    "step",
    "three",
    "elements",
    "match",
    "return",
    "middle",
    "position",
    "end",
    "match",
    "step",
    "4",
    "check",
    "whether",
    "element",
    "middle",
    "position",
    "smaller",
    "target",
    "element",
    "go",
    "back",
    "step",
    "2",
    "new",
    "list",
    "goes",
    "middle",
    "position",
    "current",
    "list",
    "end",
    "current",
    "list",
    "step",
    "five",
    "element",
    "middle",
    "position",
    "greater",
    "target",
    "element",
    "go",
    "back",
    "step",
    "two",
    "new",
    "list",
    "goes",
    "start",
    "current",
    "list",
    "middle",
    "position",
    "current",
    "list",
    "repeat",
    "process",
    "target",
    "element",
    "found",
    "sub",
    "list",
    "contains",
    "one",
    "element",
    "single",
    "element",
    "sublist",
    "match",
    "target",
    "element",
    "end",
    "algorithm",
    "indicating",
    "element",
    "exist",
    "list",
    "okay",
    "magic",
    "behind",
    "britney",
    "managed",
    "solve",
    "round",
    "much",
    "faster",
    "next",
    "video",
    "let",
    "talk",
    "efficiency",
    "binary",
    "search",
    "music",
    "vague",
    "understanding",
    "britney",
    "approach",
    "better",
    "cases",
    "like",
    "linear",
    "search",
    "helps",
    "visualize",
    "much",
    "like",
    "linear",
    "search",
    "determining",
    "efficiency",
    "algorithm",
    "remember",
    "still",
    "looking",
    "efficiency",
    "terms",
    "time",
    "time",
    "complexity",
    "called",
    "always",
    "want",
    "evaluate",
    "algorithm",
    "performs",
    "worst",
    "case",
    "scenario",
    "might",
    "thinking",
    "well",
    "seem",
    "fair",
    "given",
    "series",
    "data",
    "target",
    "value",
    "searching",
    "somewhere",
    "near",
    "front",
    "list",
    "linear",
    "search",
    "may",
    "perform",
    "well",
    "slightly",
    "better",
    "binary",
    "search",
    "totally",
    "true",
    "remember",
    "crucial",
    "part",
    "learning",
    "algorithms",
    "understanding",
    "works",
    "better",
    "given",
    "context",
    "measuring",
    "efficiency",
    "though",
    "always",
    "use",
    "worst",
    "case",
    "scenarios",
    "benchmark",
    "remember",
    "never",
    "perform",
    "worse",
    "worst",
    "case",
    "let",
    "plot",
    "values",
    "graph",
    "started",
    "earlier",
    "number",
    "tris",
    "runtime",
    "algorithm",
    "axis",
    "maximum",
    "number",
    "values",
    "series",
    "n",
    "horizontal",
    "axis",
    "represent",
    "worst",
    "case",
    "scenario",
    "two",
    "data",
    "points",
    "n",
    "equals",
    "10",
    "britney",
    "took",
    "four",
    "tries",
    "using",
    "binary",
    "search",
    "n",
    "equals",
    "100",
    "took",
    "seven",
    "tries",
    "even",
    "side",
    "side",
    "data",
    "points",
    "sort",
    "meaningless",
    "remember",
    "quite",
    "difference",
    "run",
    "time",
    "linear",
    "search",
    "binary",
    "search",
    "n",
    "value",
    "100",
    "computer",
    "matter",
    "check",
    "algorithm",
    "performs",
    "levels",
    "n",
    "might",
    "actually",
    "slow",
    "computer",
    "n",
    "grows",
    "larger",
    "larger",
    "algorithms",
    "compare",
    "one",
    "another",
    "let",
    "add",
    "graph",
    "okay",
    "picture",
    "starts",
    "emerge",
    "n",
    "gets",
    "really",
    "large",
    "performance",
    "two",
    "algorithms",
    "differs",
    "significantly",
    "difference",
    "kind",
    "staggering",
    "actually",
    "even",
    "simple",
    "game",
    "saw",
    "binary",
    "search",
    "better",
    "much",
    "complete",
    "idea",
    "much",
    "better",
    "example",
    "n",
    "1000",
    "runtime",
    "linear",
    "search",
    "measured",
    "number",
    "operations",
    "turns",
    "also",
    "binary",
    "search",
    "takes",
    "10",
    "operations",
    "let",
    "look",
    "happens",
    "increase",
    "n",
    "factor",
    "10",
    "10",
    "000",
    "linear",
    "search",
    "takes",
    "10",
    "000",
    "operations",
    "binary",
    "search",
    "takes",
    "14",
    "operations",
    "increased",
    "factor",
    "10",
    "binary",
    "search",
    "needs",
    "four",
    "operations",
    "find",
    "value",
    "increase",
    "factor",
    "10",
    "n",
    "value",
    "100",
    "000",
    "binary",
    "search",
    "takes",
    "17",
    "operations",
    "blazing",
    "fast",
    "done",
    "plotted",
    "graph",
    "algorithm",
    "performs",
    "input",
    "set",
    "working",
    "increases",
    "words",
    "plotted",
    "growth",
    "rate",
    "algorithm",
    "also",
    "known",
    "order",
    "growth",
    "different",
    "algorithms",
    "grow",
    "different",
    "rates",
    "evaluating",
    "growth",
    "rates",
    "get",
    "much",
    "better",
    "picture",
    "performance",
    "know",
    "algorithm",
    "hold",
    "n",
    "grows",
    "larger",
    "important",
    "fact",
    "standard",
    "way",
    "evaluating",
    "algorithm",
    "brings",
    "us",
    "concept",
    "called",
    "big",
    "might",
    "heard",
    "word",
    "thrown",
    "found",
    "confusing",
    "worry",
    "already",
    "built",
    "definition",
    "past",
    "videos",
    "need",
    "bring",
    "together",
    "let",
    "start",
    "common",
    "statement",
    "see",
    "studies",
    "algorithms",
    "big",
    "theoretical",
    "definition",
    "complexity",
    "algorithm",
    "function",
    "size",
    "wow",
    "mouthful",
    "sounds",
    "really",
    "intimidating",
    "really",
    "let",
    "break",
    "big",
    "notation",
    "used",
    "describe",
    "complexity",
    "mean",
    "notation",
    "simplifies",
    "everything",
    "talked",
    "single",
    "variable",
    "example",
    "complexity",
    "written",
    "terms",
    "big",
    "looks",
    "like",
    "see",
    "starts",
    "uppercase",
    "letter",
    "call",
    "big",
    "literally",
    "big",
    "comes",
    "order",
    "magnitude",
    "complexity",
    "get",
    "big",
    "complexity",
    "refers",
    "exercise",
    "carrying",
    "measuring",
    "efficiency",
    "takes",
    "brittany",
    "4",
    "tries",
    "n",
    "10",
    "long",
    "algorithm",
    "take",
    "n",
    "10",
    "million",
    "use",
    "big",
    "variable",
    "used",
    "get",
    "distills",
    "information",
    "reading",
    "variable",
    "get",
    "big",
    "picture",
    "view",
    "without",
    "run",
    "data",
    "points",
    "graphs",
    "like",
    "important",
    "remember",
    "complexity",
    "relative",
    "evaluate",
    "complexity",
    "binary",
    "search",
    "algorithm",
    "relative",
    "search",
    "algorithms",
    "algorithms",
    "bigo",
    "useful",
    "notation",
    "understanding",
    "time",
    "space",
    "complexity",
    "comparing",
    "amongst",
    "algorithms",
    "solve",
    "problem",
    "last",
    "bit",
    "definition",
    "big",
    "function",
    "size",
    "means",
    "big",
    "measures",
    "complexity",
    "input",
    "size",
    "grows",
    "important",
    "understand",
    "algorithm",
    "performs",
    "single",
    "data",
    "set",
    "possible",
    "data",
    "sets",
    "also",
    "see",
    "big",
    "referred",
    "upper",
    "bound",
    "algorithm",
    "means",
    "big",
    "measures",
    "algorithm",
    "performs",
    "worst",
    "case",
    "scenario",
    "big",
    "nothing",
    "special",
    "notation",
    "condenses",
    "data",
    "points",
    "graphs",
    "built",
    "one",
    "variable",
    "okay",
    "variables",
    "look",
    "like",
    "john",
    "strategy",
    "linear",
    "search",
    "say",
    "time",
    "complexity",
    "big",
    "n",
    "big",
    "n",
    "inside",
    "parentheses",
    "britney",
    "strategy",
    "binary",
    "search",
    "say",
    "time",
    "complexity",
    "big",
    "log",
    "n",
    "big",
    "something",
    "called",
    "log",
    "n",
    "inside",
    "parentheses",
    "worry",
    "understand",
    "go",
    "detail",
    "later",
    "course",
    "special",
    "meaning",
    "helps",
    "work",
    "get",
    "big",
    "picture",
    "view",
    "next",
    "videos",
    "let",
    "examine",
    "called",
    "common",
    "complexities",
    "common",
    "values",
    "big",
    "run",
    "internalize",
    "discussions",
    "complexity",
    "made",
    "one",
    "assumption",
    "algorithm",
    "whole",
    "single",
    "measure",
    "complexity",
    "true",
    "get",
    "arrive",
    "measures",
    "entire",
    "algorithm",
    "end",
    "exercise",
    "step",
    "algorithm",
    "space",
    "time",
    "complexity",
    "linear",
    "search",
    "example",
    "multiple",
    "steps",
    "algorithm",
    "goes",
    "like",
    "start",
    "beginning",
    "list",
    "range",
    "values",
    "compare",
    "current",
    "value",
    "target",
    "current",
    "value",
    "target",
    "value",
    "looking",
    "done",
    "move",
    "sequentially",
    "next",
    "value",
    "list",
    "repeat",
    "step",
    "two",
    "reach",
    "end",
    "list",
    "target",
    "value",
    "list",
    "let",
    "go",
    "back",
    "step",
    "two",
    "second",
    "comparing",
    "current",
    "value",
    "target",
    "size",
    "data",
    "set",
    "matter",
    "step",
    "step",
    "two",
    "already",
    "position",
    "list",
    "reading",
    "value",
    "make",
    "comparison",
    "reading",
    "value",
    "single",
    "operation",
    "plot",
    "graph",
    "runtime",
    "per",
    "operations",
    "n",
    "looks",
    "like",
    "straight",
    "line",
    "takes",
    "constant",
    "time",
    "regardless",
    "size",
    "n",
    "since",
    "takes",
    "amount",
    "time",
    "given",
    "case",
    "say",
    "run",
    "time",
    "constant",
    "time",
    "change",
    "big",
    "notation",
    "represent",
    "big",
    "1",
    "inside",
    "parentheses",
    "first",
    "started",
    "learning",
    "really",
    "confused",
    "read",
    "even",
    "head",
    "say",
    "big",
    "one",
    "see",
    "written",
    "going",
    "read",
    "constant",
    "time",
    "reading",
    "value",
    "list",
    "constant",
    "time",
    "operation",
    "ideal",
    "case",
    "comes",
    "run",
    "times",
    "input",
    "size",
    "matter",
    "know",
    "regardless",
    "size",
    "n",
    "algorithm",
    "runtime",
    "remain",
    "next",
    "step",
    "complexity",
    "speak",
    "situation",
    "encountered",
    "binary",
    "search",
    "algorithm",
    "traditionally",
    "explaining",
    "time",
    "complexity",
    "binary",
    "search",
    "involves",
    "math",
    "going",
    "try",
    "without",
    "played",
    "game",
    "using",
    "binary",
    "search",
    "notice",
    "every",
    "turn",
    "able",
    "discard",
    "half",
    "data",
    "another",
    "pattern",
    "emerges",
    "explore",
    "let",
    "say",
    "n",
    "equals",
    "long",
    "take",
    "find",
    "item",
    "10th",
    "position",
    "list",
    "write",
    "go",
    "10",
    "5",
    "8",
    "9",
    "takes",
    "us",
    "four",
    "tries",
    "cut",
    "list",
    "one",
    "element",
    "find",
    "value",
    "looking",
    "let",
    "double",
    "value",
    "n",
    "20",
    "see",
    "long",
    "takes",
    "us",
    "find",
    "item",
    "20th",
    "position",
    "start",
    "20",
    "pick",
    "10",
    "go",
    "15",
    "17",
    "19",
    "finally",
    "takes",
    "us",
    "five",
    "tries",
    "okay",
    "let",
    "double",
    "n",
    "40",
    "try",
    "find",
    "item",
    "40th",
    "position",
    "start",
    "40",
    "first",
    "midpoint",
    "going",
    "pick",
    "20",
    "go",
    "30",
    "35",
    "37",
    "39",
    "notice",
    "every",
    "time",
    "double",
    "value",
    "n",
    "number",
    "operations",
    "takes",
    "reduce",
    "list",
    "single",
    "element",
    "increases",
    "mathematical",
    "relationship",
    "pattern",
    "called",
    "logarithm",
    "n",
    "really",
    "know",
    "logarithms",
    "truly",
    "know",
    "like",
    "underlying",
    "explainers",
    "give",
    "quick",
    "one",
    "taken",
    "algebra",
    "classes",
    "may",
    "learned",
    "exponents",
    "quick",
    "refresher",
    "2",
    "times",
    "1",
    "equals",
    "written",
    "2",
    "raised",
    "first",
    "power",
    "base",
    "case",
    "two",
    "times",
    "one",
    "two",
    "two",
    "times",
    "two",
    "four",
    "written",
    "two",
    "raised",
    "second",
    "power",
    "multiplying",
    "two",
    "twice",
    "first",
    "multiply",
    "two",
    "times",
    "one",
    "result",
    "times",
    "2",
    "2",
    "times",
    "2",
    "times",
    "2",
    "8",
    "write",
    "2",
    "raised",
    "3rd",
    "power",
    "multiplying",
    "2",
    "3",
    "times",
    "2",
    "raised",
    "2",
    "2",
    "raised",
    "3",
    "2",
    "3",
    "called",
    "exponents",
    "define",
    "number",
    "grows",
    "2",
    "raised",
    "3",
    "start",
    "base",
    "value",
    "multiply",
    "3",
    "times",
    "inverse",
    "exponent",
    "called",
    "logarithm",
    "say",
    "log",
    "base",
    "2",
    "8",
    "equals",
    "3",
    "basically",
    "saying",
    "opposite",
    "exponent",
    "instead",
    "saying",
    "many",
    "times",
    "multiply",
    "value",
    "asking",
    "many",
    "times",
    "divide",
    "8",
    "two",
    "get",
    "value",
    "one",
    "takes",
    "three",
    "operations",
    "result",
    "log",
    "base",
    "two",
    "sixteen",
    "evaluates",
    "four",
    "matter",
    "notice",
    "sort",
    "binary",
    "search",
    "works",
    "log",
    "base",
    "2",
    "16",
    "n",
    "16",
    "many",
    "triads",
    "take",
    "get",
    "last",
    "element",
    "well",
    "start",
    "middle",
    "8",
    "low",
    "move",
    "12",
    "move",
    "14",
    "15",
    "16",
    "5",
    "tries",
    "log",
    "base",
    "2",
    "16",
    "plus",
    "general",
    "given",
    "value",
    "n",
    "number",
    "tries",
    "takes",
    "find",
    "worst",
    "case",
    "scenario",
    "log",
    "n",
    "plus",
    "one",
    "pattern",
    "overall",
    "logarithmic",
    "pattern",
    "say",
    "runtime",
    "algorithms",
    "logarithmic",
    "plot",
    "data",
    "points",
    "graph",
    "logarithmic",
    "runtime",
    "looks",
    "like",
    "big",
    "notation",
    "represent",
    "logarithmic",
    "runtime",
    "big",
    "log",
    "n",
    "written",
    "big",
    "log",
    "n",
    "inside",
    "parentheses",
    "even",
    "sometimes",
    "l",
    "n",
    "n",
    "inside",
    "parentheses",
    "see",
    "read",
    "logarithmic",
    "time",
    "see",
    "graph",
    "n",
    "grows",
    "really",
    "large",
    "number",
    "operations",
    "grows",
    "slowly",
    "eventually",
    "flattens",
    "since",
    "line",
    "line",
    "linear",
    "runtime",
    "look",
    "second",
    "might",
    "often",
    "hear",
    "algorithms",
    "logarithmic",
    "runtimes",
    "called",
    "sublinear",
    "logarithmic",
    "runtimes",
    "preferred",
    "linear",
    "efficient",
    "practice",
    "linear",
    "search",
    "set",
    "advantages",
    "take",
    "look",
    "next",
    "video",
    "next",
    "let",
    "look",
    "situation",
    "encountered",
    "linear",
    "search",
    "algorithm",
    "saw",
    "worst",
    "case",
    "scenario",
    "whatever",
    "value",
    "n",
    "john",
    "took",
    "exactly",
    "many",
    "tries",
    "find",
    "answer",
    "linear",
    "search",
    "number",
    "operations",
    "determine",
    "result",
    "worst",
    "case",
    "scenario",
    "n",
    "say",
    "algorithm",
    "runs",
    "linear",
    "time",
    "represent",
    "big",
    "n",
    "read",
    "big",
    "n",
    "like",
    "said",
    "say",
    "linear",
    "time",
    "common",
    "put",
    "graph",
    "constant",
    "time",
    "logarithmic",
    "time",
    "get",
    "line",
    "looks",
    "like",
    "algorithm",
    "sequentially",
    "reads",
    "input",
    "linear",
    "time",
    "remember",
    "anytime",
    "know",
    "problem",
    "involves",
    "reading",
    "every",
    "item",
    "list",
    "means",
    "linear",
    "run",
    "time",
    "saw",
    "game",
    "played",
    "brittany",
    "strategy",
    "using",
    "binary",
    "search",
    "clearly",
    "better",
    "see",
    "graph",
    "option",
    "would",
    "use",
    "linear",
    "search",
    "runs",
    "linear",
    "time",
    "remember",
    "binary",
    "search",
    "precondition",
    "input",
    "set",
    "sorted",
    "wo",
    "looking",
    "sorting",
    "algorithms",
    "course",
    "learn",
    "algorithms",
    "find",
    "sorting",
    "algorithms",
    "varying",
    "complexities",
    "like",
    "search",
    "additional",
    "work",
    "prior",
    "using",
    "binary",
    "search",
    "reason",
    "practice",
    "linear",
    "search",
    "ends",
    "performant",
    "certain",
    "value",
    "n",
    "combination",
    "sorting",
    "first",
    "searching",
    "using",
    "binary",
    "search",
    "adds",
    "next",
    "common",
    "complexity",
    "hear",
    "algorithm",
    "runs",
    "quadratic",
    "time",
    "word",
    "quadratic",
    "sounds",
    "familiar",
    "might",
    "heard",
    "math",
    "class",
    "quadratic",
    "word",
    "means",
    "operation",
    "raised",
    "second",
    "power",
    "something",
    "squared",
    "let",
    "say",
    "friends",
    "playing",
    "tower",
    "defense",
    "game",
    "start",
    "going",
    "draw",
    "map",
    "terrain",
    "map",
    "going",
    "grid",
    "pick",
    "random",
    "number",
    "determine",
    "large",
    "grid",
    "let",
    "set",
    "n",
    "size",
    "grid",
    "four",
    "next",
    "need",
    "come",
    "list",
    "coordinates",
    "place",
    "towers",
    "enemies",
    "stuff",
    "map",
    "would",
    "start",
    "horizontally",
    "coordinate",
    "points",
    "go",
    "1",
    "1",
    "1",
    "2",
    "1",
    "3",
    "1",
    "go",
    "one",
    "level",
    "vertically",
    "points",
    "2",
    "1",
    "2",
    "2",
    "2",
    "3",
    "2",
    "go",
    "one",
    "points",
    "3",
    "1",
    "3",
    "2",
    "3",
    "3",
    "3",
    "4",
    "last",
    "row",
    "points",
    "4",
    "1",
    "4",
    "2",
    "4",
    "3",
    "4",
    "notice",
    "pattern",
    "row",
    "take",
    "value",
    "create",
    "point",
    "adding",
    "every",
    "column",
    "value",
    "range",
    "values",
    "go",
    "1",
    "value",
    "n",
    "generally",
    "think",
    "way",
    "range",
    "values",
    "1",
    "n",
    "value",
    "range",
    "create",
    "point",
    "combining",
    "value",
    "range",
    "values",
    "1",
    "n",
    "way",
    "value",
    "range",
    "1",
    "n",
    "create",
    "n",
    "number",
    "values",
    "end",
    "16",
    "points",
    "also",
    "n",
    "times",
    "n",
    "n",
    "squared",
    "algorithm",
    "quadratic",
    "runtime",
    "given",
    "value",
    "n",
    "carry",
    "n",
    "squared",
    "number",
    "operations",
    "picked",
    "relatively",
    "easy",
    "speak",
    "example",
    "english",
    "least",
    "often",
    "denote",
    "map",
    "sizes",
    "height",
    "times",
    "width",
    "would",
    "call",
    "4",
    "4",
    "grid",
    "another",
    "way",
    "saying",
    "4",
    "squared",
    "n",
    "squared",
    "big",
    "notation",
    "would",
    "write",
    "big",
    "n",
    "squared",
    "say",
    "algorithm",
    "quadratic",
    "runtime",
    "many",
    "search",
    "algorithms",
    "worst",
    "case",
    "quadratic",
    "runtime",
    "learn",
    "soon",
    "addition",
    "quadratic",
    "runtimes",
    "may",
    "also",
    "run",
    "cubic",
    "runtimes",
    "encounter",
    "different",
    "algorithms",
    "algorithm",
    "given",
    "value",
    "n",
    "algorithm",
    "executes",
    "n",
    "raised",
    "third",
    "power",
    "number",
    "operations",
    "common",
    "quadratic",
    "algorithms",
    "though",
    "wo",
    "look",
    "examples",
    "think",
    "worth",
    "mentioning",
    "thrown",
    "graph",
    "quadratic",
    "cubic",
    "runtimes",
    "look",
    "like",
    "starting",
    "look",
    "pretty",
    "expensive",
    "computationally",
    "say",
    "see",
    "small",
    "changes",
    "n",
    "pretty",
    "significant",
    "change",
    "number",
    "operations",
    "need",
    "carry",
    "next",
    "worst",
    "case",
    "runtime",
    "going",
    "look",
    "one",
    "called",
    "sort",
    "easier",
    "understand",
    "lack",
    "better",
    "word",
    "starting",
    "big",
    "notation",
    "runtimes",
    "written",
    "big",
    "n",
    "times",
    "log",
    "n",
    "learned",
    "log",
    "n",
    "right",
    "logarithmic",
    "runtime",
    "whereas",
    "n",
    "grew",
    "number",
    "operations",
    "increased",
    "small",
    "factor",
    "runtime",
    "saying",
    "every",
    "value",
    "n",
    "going",
    "execute",
    "log",
    "n",
    "number",
    "operations",
    "hence",
    "run",
    "time",
    "n",
    "times",
    "log",
    "n",
    "saw",
    "earlier",
    "quadratic",
    "runtime",
    "value",
    "n",
    "conducted",
    "n",
    "operations",
    "sort",
    "go",
    "range",
    "values",
    "n",
    "executing",
    "login",
    "operations",
    "comparison",
    "runtimes",
    "algorithm",
    "runtime",
    "lies",
    "somewhere",
    "linear",
    "runtime",
    "quadratic",
    "runtime",
    "would",
    "expect",
    "see",
    "kind",
    "runtime",
    "practical",
    "use",
    "well",
    "sorting",
    "algorithms",
    "one",
    "place",
    "definitely",
    "see",
    "merge",
    "sort",
    "example",
    "sorting",
    "algorithm",
    "worst",
    "case",
    "runtime",
    "big",
    "n",
    "log",
    "n",
    "let",
    "take",
    "look",
    "quick",
    "example",
    "let",
    "say",
    "start",
    "list",
    "numbers",
    "looks",
    "like",
    "need",
    "sort",
    "merge",
    "sort",
    "starts",
    "splitting",
    "list",
    "two",
    "lists",
    "middle",
    "takes",
    "sub",
    "list",
    "splits",
    "half",
    "middle",
    "keeps",
    "end",
    "list",
    "single",
    "number",
    "single",
    "numbers",
    "one",
    "sort",
    "operation",
    "merge",
    "back",
    "opposite",
    "direction",
    "first",
    "part",
    "merge",
    "sort",
    "cuts",
    "lists",
    "half",
    "numbers",
    "similar",
    "binary",
    "search",
    "comparison",
    "operation",
    "cuts",
    "range",
    "half",
    "values",
    "know",
    "worst",
    "case",
    "runtime",
    "binary",
    "search",
    "log",
    "n",
    "splitting",
    "operations",
    "runtime",
    "big",
    "log",
    "n",
    "logarithmic",
    "splitting",
    "half",
    "thing",
    "need",
    "merge",
    "sort",
    "also",
    "need",
    "carry",
    "comparison",
    "operations",
    "sort",
    "values",
    "look",
    "step",
    "algorithm",
    "carry",
    "n",
    "number",
    "comparison",
    "operations",
    "brings",
    "worst",
    "case",
    "runtime",
    "algorithm",
    "n",
    "times",
    "log",
    "n",
    "also",
    "known",
    "quasi",
    "linear",
    "worry",
    "understand",
    "merge",
    "sort",
    "works",
    "point",
    "demonstration",
    "covering",
    "merge",
    "sorts",
    "soon",
    "future",
    "course",
    "run",
    "times",
    "looked",
    "far",
    "called",
    "polynomial",
    "runtimes",
    "algorithm",
    "considered",
    "polynomial",
    "runtime",
    "given",
    "value",
    "n",
    "worst",
    "case",
    "runtime",
    "form",
    "n",
    "raised",
    "k",
    "power",
    "k",
    "means",
    "value",
    "could",
    "n",
    "squared",
    "k",
    "equals",
    "2",
    "quadratic",
    "runtime",
    "n",
    "cubed",
    "cubic",
    "runtime",
    "form",
    "n",
    "raised",
    "power",
    "anything",
    "bounded",
    "mean",
    "hypothetical",
    "line",
    "graph",
    "n",
    "raised",
    "k",
    "power",
    "anything",
    "falls",
    "graph",
    "considered",
    "polynomial",
    "runtime",
    "algorithms",
    "upper",
    "bound",
    "runtime",
    "big",
    "value",
    "polynomial",
    "considered",
    "efficient",
    "algorithms",
    "likely",
    "used",
    "practice",
    "next",
    "class",
    "runtimes",
    "going",
    "look",
    "runtimes",
    "consider",
    "efficient",
    "called",
    "exponential",
    "runtimes",
    "runtimes",
    "n",
    "increases",
    "slightly",
    "number",
    "operations",
    "increases",
    "exponentially",
    "see",
    "second",
    "algorithms",
    "far",
    "expensive",
    "used",
    "exponential",
    "runtime",
    "algorithm",
    "big",
    "value",
    "number",
    "raised",
    "nth",
    "power",
    "imagine",
    "wanted",
    "break",
    "locker",
    "padlock",
    "let",
    "assume",
    "forgot",
    "code",
    "lock",
    "takes",
    "two",
    "digit",
    "code",
    "digit",
    "code",
    "ranges",
    "zero",
    "nine",
    "start",
    "setting",
    "dials",
    "zero",
    "first",
    "dial",
    "remaining",
    "zero",
    "change",
    "second",
    "dial",
    "one",
    "try",
    "open",
    "work",
    "set",
    "two",
    "try",
    "would",
    "keep",
    "still",
    "succeeded",
    "second",
    "dial",
    "set",
    "9",
    "go",
    "back",
    "first",
    "dial",
    "set",
    "1",
    "start",
    "second",
    "dial",
    "range",
    "values",
    "go",
    "0",
    "0",
    "9",
    "9",
    "100",
    "values",
    "generalized",
    "10",
    "second",
    "power",
    "since",
    "10",
    "values",
    "dial",
    "raised",
    "two",
    "dials",
    "searching",
    "individual",
    "value",
    "stumble",
    "right",
    "one",
    "strategy",
    "called",
    "brute",
    "force",
    "brute",
    "force",
    "algorithms",
    "exponential",
    "run",
    "times",
    "two",
    "dials",
    "n",
    "2",
    "dial",
    "10",
    "values",
    "generalize",
    "algorithm",
    "10",
    "raised",
    "n",
    "n",
    "represents",
    "number",
    "dials",
    "reason",
    "algorithm",
    "inefficient",
    "one",
    "dial",
    "lock",
    "number",
    "operations",
    "increases",
    "significantly",
    "three",
    "dials",
    "number",
    "combinations",
    "worst",
    "case",
    "scenario",
    "correct",
    "code",
    "last",
    "digit",
    "range",
    "10",
    "raised",
    "3",
    "1",
    "000",
    "values",
    "additional",
    "wheel",
    "becomes",
    "10",
    "raised",
    "4",
    "10",
    "000",
    "values",
    "n",
    "increases",
    "number",
    "operations",
    "increases",
    "exponentially",
    "point",
    "unsolvable",
    "realistic",
    "amount",
    "time",
    "might",
    "think",
    "well",
    "computer",
    "crack",
    "four",
    "digit",
    "numerical",
    "lock",
    "true",
    "n",
    "sufficiently",
    "small",
    "principle",
    "use",
    "passwords",
    "typical",
    "password",
    "field",
    "implemented",
    "well",
    "users",
    "allowed",
    "use",
    "letters",
    "english",
    "alphabet",
    "26",
    "characters",
    "numbers",
    "0",
    "9",
    "set",
    "special",
    "characters",
    "around",
    "33",
    "typically",
    "means",
    "character",
    "password",
    "one",
    "69",
    "values",
    "means",
    "one",
    "character",
    "password",
    "takes",
    "69",
    "nth",
    "power",
    "1",
    "equals",
    "69",
    "operations",
    "worst",
    "case",
    "scenario",
    "figure",
    "password",
    "increasing",
    "n",
    "2",
    "increases",
    "number",
    "operations",
    "needed",
    "guess",
    "password",
    "69",
    "squared",
    "4761",
    "operations",
    "usually",
    "secure",
    "website",
    "really",
    "limit",
    "general",
    "passwords",
    "limited",
    "around",
    "20",
    "characters",
    "length",
    "character",
    "possible",
    "69",
    "values",
    "20",
    "characters",
    "number",
    "operations",
    "needed",
    "guess",
    "password",
    "worst",
    "case",
    "scenario",
    "69",
    "raised",
    "20th",
    "power",
    "approximately",
    "6",
    "followed",
    "36",
    "zeros",
    "number",
    "operations",
    "intel",
    "cpu",
    "five",
    "cores",
    "carry",
    "roughly",
    "65",
    "000",
    "million",
    "instructions",
    "per",
    "second",
    "funny",
    "number",
    "know",
    "crack",
    "passcode",
    "simplistic",
    "model",
    "would",
    "take",
    "intel",
    "cpu",
    "race",
    "20th",
    "power",
    "years",
    "brute",
    "force",
    "password",
    "algorithm",
    "would",
    "eventually",
    "produce",
    "result",
    "inefficient",
    "pointless",
    "one",
    "reasons",
    "people",
    "recommend",
    "longer",
    "passwords",
    "since",
    "brute",
    "forcing",
    "exponential",
    "worst",
    "case",
    "character",
    "add",
    "increases",
    "number",
    "combinations",
    "exponent",
    "next",
    "class",
    "exponential",
    "algorithms",
    "best",
    "highlighted",
    "popular",
    "problem",
    "known",
    "traveling",
    "salesman",
    "problem",
    "statement",
    "goes",
    "like",
    "given",
    "list",
    "cities",
    "distance",
    "pair",
    "cities",
    "shortest",
    "possible",
    "route",
    "visits",
    "city",
    "returns",
    "origin",
    "city",
    "seems",
    "like",
    "simple",
    "question",
    "let",
    "start",
    "simple",
    "case",
    "three",
    "cities",
    "b",
    "c",
    "figure",
    "shortest",
    "route",
    "need",
    "come",
    "possible",
    "routes",
    "three",
    "cities",
    "six",
    "routes",
    "theory",
    "least",
    "routes",
    "discarded",
    "abc",
    "c",
    "b",
    "opposite",
    "direction",
    "know",
    "sometimes",
    "going",
    "c",
    "b",
    "may",
    "go",
    "different",
    "route",
    "c",
    "b",
    "stick",
    "six",
    "routes",
    "could",
    "determine",
    "shortest",
    "big",
    "deal",
    "increase",
    "four",
    "cities",
    "jump",
    "24",
    "combinations",
    "mathematical",
    "relationship",
    "defines",
    "called",
    "factorial",
    "written",
    "n",
    "followed",
    "exclamation",
    "point",
    "factorials",
    "basically",
    "n",
    "times",
    "n",
    "minus",
    "one",
    "repeated",
    "reach",
    "number",
    "one",
    "example",
    "factorial",
    "three",
    "three",
    "times",
    "two",
    "times",
    "one",
    "six",
    "number",
    "combinations",
    "came",
    "three",
    "cities",
    "factorial",
    "four",
    "four",
    "times",
    "three",
    "times",
    "two",
    "times",
    "one",
    "24",
    "number",
    "combinations",
    "arrived",
    "four",
    "cities",
    "solving",
    "traveling",
    "salesman",
    "problem",
    "efficient",
    "algorithm",
    "factorial",
    "runtime",
    "combinatorial",
    "runtime",
    "also",
    "called",
    "low",
    "values",
    "n",
    "algorithms",
    "factorial",
    "runtime",
    "may",
    "used",
    "n",
    "value",
    "say",
    "200",
    "would",
    "take",
    "longer",
    "humans",
    "alive",
    "solve",
    "problem",
    "sake",
    "completeness",
    "let",
    "plot",
    "combinatorial",
    "runtime",
    "graph",
    "compare",
    "algorithm",
    "one",
    "solves",
    "traveling",
    "salesman",
    "problem",
    "worst",
    "case",
    "run",
    "time",
    "big",
    "n",
    "factorial",
    "studying",
    "exponential",
    "runtimes",
    "like",
    "useful",
    "two",
    "reasons",
    "first",
    "studying",
    "make",
    "algorithms",
    "efficient",
    "develop",
    "strategies",
    "useful",
    "across",
    "board",
    "potentially",
    "used",
    "make",
    "existing",
    "algorithms",
    "even",
    "efficient",
    "second",
    "important",
    "aware",
    "problems",
    "take",
    "long",
    "time",
    "solve",
    "knowing",
    "right",
    "bat",
    "problem",
    "somewhat",
    "unsolvable",
    "realistic",
    "time",
    "means",
    "focus",
    "efforts",
    "aspects",
    "problem",
    "beginners",
    "though",
    "going",
    "steer",
    "clear",
    "focus",
    "efforts",
    "algorithms",
    "polynomial",
    "runtimes",
    "since",
    "much",
    "likely",
    "work",
    "learn",
    "algorithms",
    "know",
    "common",
    "complexities",
    "next",
    "video",
    "let",
    "talk",
    "determine",
    "complexity",
    "algorithm",
    "nuances",
    "last",
    "videos",
    "took",
    "look",
    "common",
    "complexities",
    "would",
    "encounter",
    "studying",
    "algorithms",
    "question",
    "remains",
    "determine",
    "worst",
    "case",
    "complexity",
    "algorithm",
    "earlier",
    "mentioned",
    "even",
    "though",
    "say",
    "algorithm",
    "particular",
    "upper",
    "bound",
    "worst",
    "case",
    "runtime",
    "step",
    "given",
    "algorithm",
    "different",
    "run",
    "times",
    "let",
    "bring",
    "steps",
    "binary",
    "search",
    "assuming",
    "list",
    "sorted",
    "first",
    "step",
    "determine",
    "middle",
    "position",
    "list",
    "general",
    "going",
    "constant",
    "time",
    "operation",
    "many",
    "programming",
    "languages",
    "hold",
    "information",
    "size",
    "list",
    "actually",
    "need",
    "walk",
    "list",
    "determine",
    "size",
    "information",
    "size",
    "list",
    "would",
    "need",
    "walk",
    "counting",
    "item",
    "one",
    "one",
    "reached",
    "end",
    "list",
    "linear",
    "time",
    "operation",
    "realistically",
    "big",
    "1",
    "constant",
    "time",
    "step",
    "2",
    "compare",
    "element",
    "middle",
    "position",
    "target",
    "element",
    "assume",
    "modern",
    "programming",
    "languages",
    "also",
    "constant",
    "time",
    "operation",
    "documentation",
    "language",
    "tells",
    "us",
    "step",
    "3",
    "success",
    "case",
    "algorithm",
    "ends",
    "best",
    "case",
    "far",
    "incurred",
    "two",
    "constant",
    "time",
    "operations",
    "would",
    "say",
    "best",
    "case",
    "run",
    "time",
    "binary",
    "search",
    "constant",
    "time",
    "actually",
    "true",
    "remember",
    "best",
    "case",
    "useful",
    "metric",
    "step",
    "4",
    "match",
    "splitting",
    "list",
    "assuming",
    "worst",
    "case",
    "scenario",
    "algorithm",
    "would",
    "keep",
    "splitting",
    "single",
    "element",
    "list",
    "reached",
    "value",
    "searching",
    "run",
    "time",
    "step",
    "logarithmic",
    "since",
    "discard",
    "half",
    "values",
    "time",
    "algorithm",
    "couple",
    "steps",
    "constant",
    "time",
    "one",
    "step",
    "logarithmic",
    "overall",
    "evaluating",
    "run",
    "time",
    "algorithm",
    "say",
    "algorithm",
    "upper",
    "bound",
    "runtime",
    "least",
    "efficient",
    "step",
    "algorithm",
    "think",
    "way",
    "let",
    "say",
    "participating",
    "triathlon",
    "race",
    "swimming",
    "running",
    "cycling",
    "component",
    "could",
    "phenomenal",
    "swimmer",
    "really",
    "good",
    "cyclist",
    "pretty",
    "terrible",
    "runner",
    "matter",
    "fast",
    "swimming",
    "cycling",
    "overall",
    "race",
    "time",
    "going",
    "impacted",
    "running",
    "race",
    "time",
    "part",
    "takes",
    "longest",
    "take",
    "hour",
    "30",
    "finish",
    "running",
    "component",
    "55",
    "minutes",
    "swim",
    "38",
    "minutes",
    "bike",
    "wo",
    "matter",
    "fine",
    "tune",
    "swimming",
    "technique",
    "finish",
    "48",
    "minutes",
    "cycle",
    "time",
    "35",
    "still",
    "bounded",
    "top",
    "running",
    "time",
    "close",
    "almost",
    "double",
    "bike",
    "time",
    "similarly",
    "binary",
    "search",
    "algorithm",
    "matter",
    "fast",
    "make",
    "steps",
    "already",
    "fast",
    "worst",
    "case",
    "scenario",
    "splitting",
    "list",
    "single",
    "element",
    "list",
    "impact",
    "overall",
    "running",
    "time",
    "algorithm",
    "say",
    "time",
    "complexity",
    "run",
    "time",
    "algorithm",
    "worst",
    "case",
    "big",
    "log",
    "n",
    "logarithmic",
    "alluded",
    "though",
    "algorithm",
    "may",
    "hit",
    "best",
    "case",
    "runtime",
    "two",
    "best",
    "worst",
    "case",
    "average",
    "run",
    "time",
    "well",
    "important",
    "understand",
    "algorithms",
    "always",
    "hit",
    "worst",
    "case",
    "getting",
    "bit",
    "complex",
    "us",
    "safely",
    "ignore",
    "average",
    "case",
    "performances",
    "focus",
    "worst",
    "case",
    "future",
    "decide",
    "stick",
    "around",
    "circle",
    "back",
    "talk",
    "know",
    "algorithms",
    "complexities",
    "big",
    "let",
    "take",
    "break",
    "write",
    "code",
    "next",
    "video",
    "music",
    "far",
    "spent",
    "lot",
    "time",
    "theory",
    "things",
    "important",
    "things",
    "know",
    "get",
    "much",
    "better",
    "understanding",
    "algorithms",
    "work",
    "start",
    "writing",
    "code",
    "mentioned",
    "earlier",
    "going",
    "writing",
    "python",
    "code",
    "subsequent",
    "algorithm",
    "courses",
    "programming",
    "experience",
    "another",
    "language",
    "check",
    "notes",
    "section",
    "video",
    "implementation",
    "language",
    "experience",
    "try",
    "best",
    "explain",
    "go",
    "along",
    "video",
    "watching",
    "right",
    "see",
    "launch",
    "workspaces",
    "button",
    "going",
    "use",
    "treehouse",
    "coding",
    "environment",
    "call",
    "workspaces",
    "write",
    "code",
    "familiar",
    "using",
    "python",
    "local",
    "environment",
    "feel",
    "free",
    "keep",
    "workspaces",
    "coding",
    "environment",
    "take",
    "care",
    "setup",
    "installation",
    "focus",
    "writing",
    "evaluating",
    "code",
    "workspaces",
    "quite",
    "straightforward",
    "use",
    "left",
    "file",
    "navigator",
    "pane",
    "currently",
    "empty",
    "since",
    "created",
    "new",
    "file",
    "top",
    "editor",
    "write",
    "code",
    "terminal",
    "command",
    "line",
    "prompt",
    "execute",
    "scripts",
    "write",
    "let",
    "add",
    "new",
    "file",
    "top",
    "editor",
    "area",
    "going",
    "go",
    "file",
    "new",
    "file",
    "name",
    "linear",
    "underscore",
    "search",
    "dot",
    "pi",
    "going",
    "define",
    "linear",
    "search",
    "algorithm",
    "standalone",
    "function",
    "start",
    "keyword",
    "def",
    "defines",
    "function",
    "block",
    "code",
    "give",
    "name",
    "linear",
    "underscore",
    "search",
    "function",
    "accept",
    "two",
    "arguments",
    "first",
    "list",
    "searching",
    "target",
    "value",
    "looking",
    "arguments",
    "enclosed",
    "set",
    "parentheses",
    "space",
    "name",
    "function",
    "arguments",
    "colon",
    "might",
    "bit",
    "confusion",
    "since",
    "already",
    "target",
    "value",
    "searching",
    "unlike",
    "game",
    "played",
    "beginning",
    "john",
    "job",
    "find",
    "value",
    "true",
    "implementation",
    "linear",
    "search",
    "looking",
    "position",
    "list",
    "value",
    "exists",
    "target",
    "list",
    "return",
    "position",
    "since",
    "list",
    "position",
    "going",
    "denoted",
    "index",
    "value",
    "target",
    "found",
    "going",
    "return",
    "none",
    "choice",
    "return",
    "failure",
    "case",
    "may",
    "different",
    "implementations",
    "linear",
    "search",
    "return",
    "since",
    "typically",
    "index",
    "value",
    "also",
    "raise",
    "exception",
    "python",
    "speak",
    "indicating",
    "error",
    "occurred",
    "think",
    "us",
    "straightforward",
    "value",
    "return",
    "none",
    "let",
    "add",
    "comment",
    "clarify",
    "hit",
    "enter",
    "go",
    "next",
    "line",
    "going",
    "add",
    "three",
    "single",
    "quotes",
    "next",
    "line",
    "say",
    "returns",
    "position",
    "index",
    "position",
    "target",
    "found",
    "else",
    "returns",
    "none",
    "next",
    "line",
    "close",
    "three",
    "quotes",
    "called",
    "doc",
    "string",
    "python",
    "convention",
    "documenting",
    "code",
    "linear",
    "search",
    "algorithm",
    "sequential",
    "algorithm",
    "compares",
    "item",
    "list",
    "target",
    "found",
    "iterate",
    "loop",
    "walk",
    "list",
    "sequentially",
    "going",
    "use",
    "loop",
    "typically",
    "iterating",
    "list",
    "python",
    "would",
    "use",
    "loop",
    "like",
    "say",
    "item",
    "list",
    "assigns",
    "value",
    "index",
    "position",
    "local",
    "variable",
    "item",
    "want",
    "though",
    "since",
    "primarily",
    "care",
    "index",
    "position",
    "instead",
    "going",
    "use",
    "range",
    "function",
    "python",
    "create",
    "range",
    "values",
    "start",
    "0",
    "end",
    "number",
    "items",
    "list",
    "say",
    "4",
    "stands",
    "index",
    "range",
    "starting",
    "0",
    "going",
    "way",
    "length",
    "list",
    "get",
    "number",
    "items",
    "list",
    "using",
    "len",
    "function",
    "going",
    "back",
    "talk",
    "complexity",
    "individual",
    "steps",
    "algorithm",
    "run",
    "times",
    "line",
    "code",
    "would",
    "careful",
    "python",
    "keeps",
    "track",
    "length",
    "list",
    "function",
    "call",
    "len",
    "list",
    "constant",
    "time",
    "operation",
    "naive",
    "implementation",
    "let",
    "say",
    "wrote",
    "implementation",
    "list",
    "iterate",
    "list",
    "every",
    "time",
    "call",
    "length",
    "function",
    "already",
    "incurred",
    "linear",
    "cost",
    "okay",
    "range",
    "values",
    "represent",
    "index",
    "positions",
    "list",
    "going",
    "iterate",
    "using",
    "loop",
    "assign",
    "index",
    "value",
    "local",
    "variable",
    "using",
    "index",
    "value",
    "obtain",
    "item",
    "position",
    "using",
    "subscript",
    "notation",
    "list",
    "also",
    "constant",
    "time",
    "operation",
    "language",
    "says",
    "list",
    "value",
    "get",
    "using",
    "subscript",
    "notation",
    "say",
    "list",
    "value",
    "check",
    "matches",
    "target",
    "value",
    "equals",
    "target",
    "well",
    "return",
    "index",
    "value",
    "want",
    "position",
    "hit",
    "return",
    "statement",
    "going",
    "terminate",
    "function",
    "entire",
    "loop",
    "executed",
    "hit",
    "return",
    "statement",
    "target",
    "exist",
    "list",
    "bottom",
    "say",
    "return",
    "none",
    "even",
    "though",
    "individual",
    "operations",
    "algorithm",
    "run",
    "constant",
    "time",
    "worst",
    "case",
    "scenario",
    "loop",
    "go",
    "entire",
    "range",
    "values",
    "read",
    "every",
    "single",
    "element",
    "list",
    "therefore",
    "giving",
    "algorithm",
    "big",
    "value",
    "n",
    "running",
    "linear",
    "time",
    "written",
    "code",
    "definitely",
    "written",
    "code",
    "like",
    "number",
    "times",
    "bet",
    "know",
    "along",
    "implementing",
    "essentially",
    "algorithm",
    "hope",
    "goes",
    "show",
    "algorithms",
    "pretty",
    "approachable",
    "topic",
    "like",
    "everything",
    "else",
    "get",
    "advanced",
    "long",
    "take",
    "things",
    "slow",
    "reason",
    "impossible",
    "remember",
    "block",
    "code",
    "counts",
    "algorithm",
    "proper",
    "implementation",
    "linear",
    "search",
    "block",
    "code",
    "must",
    "return",
    "value",
    "must",
    "complete",
    "execution",
    "finite",
    "amount",
    "time",
    "must",
    "output",
    "result",
    "every",
    "time",
    "given",
    "input",
    "set",
    "let",
    "verify",
    "small",
    "test",
    "let",
    "write",
    "function",
    "called",
    "verify",
    "accepts",
    "index",
    "value",
    "value",
    "none",
    "prints",
    "index",
    "position",
    "none",
    "informs",
    "us",
    "target",
    "found",
    "list",
    "def",
    "verify",
    "going",
    "take",
    "index",
    "value",
    "say",
    "index",
    "none",
    "print",
    "target",
    "found",
    "index",
    "oops",
    "colon",
    "index",
    "else",
    "needs",
    "go",
    "back",
    "go",
    "else",
    "say",
    "target",
    "found",
    "list",
    "okay",
    "using",
    "function",
    "let",
    "define",
    "range",
    "numbers",
    "list",
    "numbers",
    "go",
    "1",
    "let",
    "say",
    "written",
    "python",
    "code",
    "know",
    "use",
    "list",
    "comprehension",
    "make",
    "easier",
    "keep",
    "things",
    "simple",
    "use",
    "linear",
    "search",
    "function",
    "search",
    "position",
    "target",
    "value",
    "list",
    "say",
    "result",
    "equal",
    "linear",
    "underscore",
    "search",
    "going",
    "pass",
    "numbers",
    "list",
    "one",
    "searching",
    "want",
    "look",
    "position",
    "value",
    "12",
    "exists",
    "verify",
    "result",
    "algorithm",
    "works",
    "correctly",
    "verify",
    "function",
    "inform",
    "us",
    "target",
    "exist",
    "make",
    "sure",
    "save",
    "file",
    "going",
    "file",
    "save",
    "hitting",
    "command",
    "terminal",
    "going",
    "type",
    "python",
    "linear",
    "search",
    "hit",
    "tab",
    "auto",
    "complete",
    "linear",
    "search",
    "dot",
    "pi",
    "see",
    "correct",
    "target",
    "found",
    "list",
    "output",
    "script",
    "expect",
    "second",
    "test",
    "let",
    "search",
    "value",
    "6",
    "list",
    "copy",
    "command",
    "c",
    "copy",
    "paste",
    "change",
    "12",
    "6",
    "come",
    "back",
    "terminal",
    "hit",
    "arrow",
    "execute",
    "command",
    "hit",
    "enter",
    "notice",
    "forgot",
    "hit",
    "save",
    "account",
    "new",
    "change",
    "try",
    "see",
    "works",
    "correctly",
    "index",
    "number",
    "five",
    "run",
    "program",
    "end",
    "make",
    "sure",
    "everything",
    "works",
    "expected",
    "algorithm",
    "returned",
    "result",
    "case",
    "executed",
    "finite",
    "time",
    "results",
    "ones",
    "expect",
    "next",
    "video",
    "let",
    "tackle",
    "binary",
    "search",
    "last",
    "video",
    "left",
    "implementation",
    "linear",
    "search",
    "let",
    "binary",
    "search",
    "get",
    "understanding",
    "represented",
    "code",
    "new",
    "file",
    "back",
    "file",
    "new",
    "file",
    "name",
    "one",
    "binary",
    "search",
    "dot",
    "py",
    "like",
    "going",
    "start",
    "function",
    "named",
    "binary",
    "search",
    "say",
    "def",
    "binary",
    "underscore",
    "search",
    "takes",
    "list",
    "target",
    "remember",
    "binary",
    "search",
    "works",
    "breaking",
    "array",
    "list",
    "smaller",
    "sets",
    "find",
    "value",
    "looking",
    "need",
    "way",
    "keep",
    "track",
    "position",
    "list",
    "working",
    "let",
    "create",
    "two",
    "variables",
    "first",
    "last",
    "point",
    "beginning",
    "end",
    "array",
    "first",
    "equal",
    "zero",
    "new",
    "programming",
    "list",
    "positions",
    "represented",
    "index",
    "values",
    "start",
    "zero",
    "instead",
    "one",
    "setting",
    "first",
    "zero",
    "point",
    "first",
    "element",
    "list",
    "last",
    "going",
    "point",
    "last",
    "element",
    "list",
    "say",
    "last",
    "equal",
    "len",
    "list",
    "minus",
    "one",
    "may",
    "confusing",
    "quick",
    "sidebar",
    "explain",
    "going",
    "let",
    "say",
    "list",
    "containing",
    "5",
    "elements",
    "called",
    "len",
    "list",
    "get",
    "5",
    "back",
    "5",
    "elements",
    "remember",
    "position",
    "numbers",
    "start",
    "0",
    "last",
    "value",
    "position",
    "5",
    "nearly",
    "programming",
    "languages",
    "getting",
    "position",
    "last",
    "element",
    "list",
    "obtained",
    "determining",
    "length",
    "list",
    "deducting",
    "1",
    "okay",
    "know",
    "first",
    "last",
    "positions",
    "start",
    "algorithm",
    "next",
    "line",
    "code",
    "going",
    "create",
    "loop",
    "loop",
    "takes",
    "condition",
    "keeps",
    "executing",
    "code",
    "inside",
    "loop",
    "condition",
    "evaluates",
    "false",
    "condition",
    "going",
    "say",
    "keep",
    "executing",
    "loop",
    "value",
    "first",
    "less",
    "equal",
    "value",
    "last",
    "first",
    "less",
    "equal",
    "last",
    "well",
    "ask",
    "condition",
    "well",
    "let",
    "work",
    "implementation",
    "visualization",
    "help",
    "inside",
    "loop",
    "going",
    "calculate",
    "midpoint",
    "list",
    "since",
    "first",
    "step",
    "binary",
    "search",
    "midpoint",
    "equal",
    "say",
    "first",
    "plus",
    "last",
    "use",
    "floor",
    "division",
    "double",
    "slash",
    "divided",
    "two",
    "two",
    "forward",
    "slashes",
    "python",
    "calls",
    "floor",
    "division",
    "operator",
    "rounds",
    "nearest",
    "whole",
    "number",
    "eight",
    "element",
    "array",
    "first",
    "zero",
    "last",
    "7",
    "divided",
    "0",
    "plus",
    "7",
    "7",
    "2",
    "would",
    "get",
    "valid",
    "index",
    "position",
    "round",
    "3",
    "using",
    "floor",
    "division",
    "operator",
    "okay",
    "midpoint",
    "next",
    "step",
    "binary",
    "search",
    "evaluate",
    "whether",
    "value",
    "midpoint",
    "target",
    "looking",
    "say",
    "list",
    "value",
    "midpoint",
    "equals",
    "target",
    "well",
    "go",
    "ahead",
    "return",
    "midpoint",
    "say",
    "return",
    "midpoint",
    "return",
    "statement",
    "terminates",
    "algorithm",
    "done",
    "best",
    "case",
    "scenario",
    "next",
    "say",
    "else",
    "list",
    "midpoint",
    "value",
    "midpoint",
    "less",
    "target",
    "value",
    "less",
    "value",
    "midpoint",
    "less",
    "target",
    "care",
    "values",
    "lower",
    "midpoint",
    "redefine",
    "first",
    "point",
    "value",
    "midpoint",
    "say",
    "midpoint",
    "plus",
    "value",
    "midpoint",
    "greater",
    "target",
    "discard",
    "values",
    "midpoint",
    "redefine",
    "last",
    "point",
    "value",
    "prior",
    "midpoint",
    "say",
    "else",
    "last",
    "equal",
    "midpoint",
    "minus",
    "let",
    "visualize",
    "going",
    "start",
    "list",
    "nine",
    "integers",
    "make",
    "easier",
    "understand",
    "let",
    "specify",
    "integers",
    "value",
    "index",
    "position",
    "range",
    "values",
    "0",
    "target",
    "worst",
    "case",
    "scenario",
    "looking",
    "position",
    "value",
    "start",
    "algorithm",
    "sets",
    "first",
    "point",
    "index",
    "0",
    "last",
    "point",
    "length",
    "list",
    "minus",
    "1",
    "next",
    "hit",
    "loop",
    "logic",
    "loop",
    "going",
    "executed",
    "long",
    "value",
    "first",
    "greater",
    "value",
    "last",
    "defined",
    "going",
    "keep",
    "executing",
    "contents",
    "loop",
    "long",
    "first",
    "less",
    "equal",
    "last",
    "first",
    "pass",
    "true",
    "enter",
    "body",
    "loop",
    "midpoint",
    "first",
    "plus",
    "last",
    "divided",
    "two",
    "rounded",
    "get",
    "nice",
    "even",
    "four",
    "value",
    "position",
    "four",
    "equal",
    "target",
    "move",
    "first",
    "else",
    "four",
    "less",
    "eight",
    "redefine",
    "first",
    "point",
    "midpoint",
    "plus",
    "one",
    "five",
    "first",
    "still",
    "less",
    "last",
    "run",
    "body",
    "loop",
    "midpoint",
    "six",
    "six",
    "less",
    "eight",
    "move",
    "first",
    "point",
    "seven",
    "seven",
    "still",
    "less",
    "equal",
    "eight",
    "go",
    "another",
    "iteration",
    "loop",
    "midpoint",
    "seven",
    "oddly",
    "enough",
    "seven",
    "still",
    "less",
    "target",
    "move",
    "first",
    "point",
    "eight",
    "first",
    "equal",
    "last",
    "condition",
    "says",
    "keep",
    "loop",
    "going",
    "long",
    "first",
    "less",
    "equal",
    "last",
    "final",
    "time",
    "loop",
    "midpoint",
    "8",
    "makes",
    "value",
    "midpoint",
    "equal",
    "target",
    "finally",
    "exit",
    "algorithm",
    "return",
    "position",
    "target",
    "executed",
    "code",
    "never",
    "hit",
    "case",
    "midpoint",
    "equal",
    "target",
    "well",
    "would",
    "mean",
    "list",
    "contain",
    "target",
    "value",
    "loop",
    "bottom",
    "return",
    "none",
    "several",
    "operations",
    "make",
    "binary",
    "search",
    "algorithm",
    "let",
    "look",
    "runtime",
    "step",
    "start",
    "assigning",
    "values",
    "first",
    "last",
    "value",
    "assigned",
    "last",
    "involves",
    "call",
    "len",
    "function",
    "get",
    "size",
    "list",
    "already",
    "know",
    "constant",
    "time",
    "operation",
    "python",
    "operations",
    "run",
    "constant",
    "time",
    "inside",
    "loop",
    "another",
    "value",
    "assignment",
    "simple",
    "division",
    "operation",
    "runtime",
    "constant",
    "next",
    "line",
    "code",
    "reading",
    "value",
    "list",
    "comparing",
    "midpoint",
    "target",
    "constant",
    "time",
    "operations",
    "remainder",
    "code",
    "series",
    "comparisons",
    "value",
    "assignments",
    "know",
    "constant",
    "time",
    "operations",
    "well",
    "series",
    "constant",
    "time",
    "operations",
    "algorithm",
    "worst",
    "case",
    "logarithmic",
    "runtime",
    "hard",
    "evaluate",
    "looking",
    "code",
    "loop",
    "causes",
    "run",
    "time",
    "grow",
    "even",
    "though",
    "comparison",
    "operation",
    "redefining",
    "first",
    "last",
    "rather",
    "last",
    "two",
    "steps",
    "asking",
    "algorithm",
    "run",
    "many",
    "times",
    "needs",
    "first",
    "equal",
    "greater",
    "last",
    "time",
    "loop",
    "size",
    "data",
    "set",
    "size",
    "list",
    "grows",
    "smaller",
    "certain",
    "factor",
    "approaches",
    "single",
    "element",
    "results",
    "logarithmic",
    "runtime",
    "okay",
    "like",
    "linear",
    "search",
    "let",
    "test",
    "algorithm",
    "works",
    "go",
    "back",
    "linear",
    "going",
    "copy",
    "paste",
    "command",
    "c",
    "copy",
    "mac",
    "go",
    "back",
    "binary",
    "search",
    "bottom",
    "oops",
    "going",
    "paste",
    "verify",
    "function",
    "okay",
    "also",
    "go",
    "back",
    "grab",
    "numbers",
    "know",
    "let",
    "go",
    "ahead",
    "copy",
    "things",
    "numbers",
    "two",
    "verify",
    "cases",
    "paste",
    "well",
    "thing",
    "need",
    "change",
    "instead",
    "calling",
    "linear",
    "search",
    "going",
    "call",
    "binary",
    "search",
    "okay",
    "hit",
    "command",
    "save",
    "file",
    "going",
    "drag",
    "console",
    "run",
    "python",
    "binary",
    "search",
    "dot",
    "hit",
    "enter",
    "see",
    "like",
    "like",
    "get",
    "results",
    "back",
    "note",
    "extremely",
    "important",
    "distinction",
    "needs",
    "made",
    "numbers",
    "list",
    "defined",
    "test",
    "cases",
    "right",
    "sorted",
    "basic",
    "logic",
    "binary",
    "search",
    "relies",
    "fact",
    "target",
    "greater",
    "midpoint",
    "potential",
    "values",
    "lie",
    "left",
    "vice",
    "versa",
    "since",
    "values",
    "sorted",
    "ascending",
    "order",
    "values",
    "unsorted",
    "implementation",
    "binary",
    "search",
    "may",
    "return",
    "none",
    "even",
    "value",
    "exists",
    "list",
    "like",
    "written",
    "code",
    "implement",
    "two",
    "search",
    "algorithms",
    "fun",
    "hopefully",
    "course",
    "shown",
    "topic",
    "afraid",
    "algorithms",
    "like",
    "topic",
    "code",
    "broken",
    "understood",
    "piece",
    "piece",
    "working",
    "implementation",
    "binary",
    "search",
    "actually",
    "one",
    "way",
    "write",
    "next",
    "video",
    "let",
    "write",
    "second",
    "version",
    "going",
    "create",
    "new",
    "file",
    "always",
    "file",
    "new",
    "file",
    "name",
    "recursive",
    "underscore",
    "binary",
    "underscore",
    "search",
    "dot",
    "p",
    "okay",
    "going",
    "add",
    "new",
    "implementation",
    "get",
    "rid",
    "first",
    "implementation",
    "wrote",
    "let",
    "call",
    "new",
    "function",
    "recursive",
    "binary",
    "search",
    "unlike",
    "previous",
    "implementation",
    "version",
    "going",
    "behave",
    "slightly",
    "differently",
    "wo",
    "return",
    "index",
    "value",
    "target",
    "element",
    "exists",
    "instead",
    "return",
    "true",
    "value",
    "exists",
    "false",
    "recursive",
    "underscore",
    "binary",
    "underscore",
    "search",
    "like",
    "going",
    "take",
    "list",
    "accepts",
    "list",
    "target",
    "look",
    "list",
    "start",
    "body",
    "function",
    "considering",
    "happens",
    "empty",
    "list",
    "passed",
    "case",
    "would",
    "return",
    "false",
    "would",
    "say",
    "length",
    "list",
    "one",
    "way",
    "figure",
    "empty",
    "equal",
    "zero",
    "return",
    "false",
    "might",
    "thinking",
    "previous",
    "version",
    "binary",
    "search",
    "care",
    "list",
    "empty",
    "well",
    "actually",
    "roundabout",
    "sort",
    "way",
    "previous",
    "version",
    "binary",
    "search",
    "function",
    "loop",
    "loop",
    "condition",
    "true",
    "first",
    "less",
    "equal",
    "last",
    "long",
    "less",
    "equal",
    "last",
    "continue",
    "loop",
    "empty",
    "list",
    "first",
    "greater",
    "last",
    "loop",
    "would",
    "never",
    "execute",
    "return",
    "none",
    "bottom",
    "logic",
    "implementing",
    "slightly",
    "different",
    "way",
    "list",
    "empty",
    "implement",
    "else",
    "clause",
    "calculate",
    "midpoint",
    "dividing",
    "length",
    "list",
    "2",
    "rounding",
    "use",
    "first",
    "last",
    "say",
    "length",
    "list",
    "using",
    "floor",
    "division",
    "operator",
    "divide",
    "value",
    "midpoint",
    "check",
    "saying",
    "list",
    "using",
    "subscript",
    "notation",
    "say",
    "midpoint",
    "index",
    "value",
    "midpoint",
    "target",
    "go",
    "ahead",
    "return",
    "true",
    "far",
    "less",
    "except",
    "value",
    "returning",
    "let",
    "actually",
    "get",
    "rid",
    "okay",
    "right",
    "case",
    "let",
    "implement",
    "else",
    "clause",
    "two",
    "situations",
    "first",
    "value",
    "midpoint",
    "less",
    "target",
    "value",
    "midpoint",
    "less",
    "target",
    "going",
    "something",
    "new",
    "going",
    "call",
    "function",
    "recursive",
    "binary",
    "search",
    "function",
    "process",
    "defining",
    "going",
    "call",
    "going",
    "give",
    "portion",
    "list",
    "want",
    "focus",
    "previous",
    "version",
    "binary",
    "search",
    "moved",
    "first",
    "value",
    "point",
    "value",
    "midpoint",
    "going",
    "create",
    "new",
    "list",
    "using",
    "called",
    "slice",
    "operation",
    "create",
    "sub",
    "list",
    "starts",
    "midpoint",
    "plus",
    "1",
    "goes",
    "way",
    "end",
    "going",
    "specify",
    "target",
    "search",
    "target",
    "function",
    "call",
    "done",
    "return",
    "value",
    "say",
    "return",
    "return",
    "important",
    "call",
    "function",
    "recursive",
    "binary",
    "search",
    "function",
    "takes",
    "list",
    "going",
    "use",
    "subscript",
    "notation",
    "perform",
    "slice",
    "operation",
    "using",
    "two",
    "indexes",
    "start",
    "end",
    "say",
    "new",
    "list",
    "passing",
    "needs",
    "start",
    "midpoint",
    "plus",
    "one",
    "go",
    "way",
    "end",
    "python",
    "syntactic",
    "sugar",
    "speak",
    "specify",
    "end",
    "index",
    "python",
    "knows",
    "go",
    "way",
    "end",
    "right",
    "new",
    "list",
    "working",
    "need",
    "target",
    "pass",
    "confused",
    "bear",
    "like",
    "visualize",
    "end",
    "okay",
    "another",
    "else",
    "case",
    "scenario",
    "value",
    "midpoint",
    "greater",
    "target",
    "means",
    "care",
    "values",
    "list",
    "start",
    "going",
    "midpoint",
    "case",
    "well",
    "going",
    "call",
    "binary",
    "search",
    "function",
    "specify",
    "new",
    "list",
    "work",
    "time",
    "list",
    "going",
    "start",
    "beginning",
    "go",
    "way",
    "midpoint",
    "looks",
    "say",
    "return",
    "recursive",
    "binary",
    "search",
    "going",
    "pass",
    "list",
    "put",
    "colon",
    "without",
    "start",
    "index",
    "python",
    "knows",
    "start",
    "beginning",
    "going",
    "go",
    "way",
    "midpoint",
    "target",
    "new",
    "binary",
    "search",
    "function",
    "let",
    "see",
    "works",
    "actually",
    "yes",
    "make",
    "space",
    "define",
    "verify",
    "function",
    "going",
    "copy",
    "paste",
    "previous",
    "one",
    "returning",
    "none",
    "integer",
    "verify",
    "result",
    "pass",
    "say",
    "print",
    "target",
    "found",
    "going",
    "say",
    "true",
    "false",
    "whether",
    "found",
    "okay",
    "like",
    "need",
    "numbers",
    "list",
    "something",
    "one",
    "two",
    "three",
    "four",
    "way",
    "eight",
    "okay",
    "let",
    "test",
    "call",
    "recursive",
    "binary",
    "search",
    "function",
    "pass",
    "numbers",
    "list",
    "target",
    "going",
    "verify",
    "verify",
    "result",
    "make",
    "sure",
    "works",
    "call",
    "time",
    "making",
    "sure",
    "give",
    "target",
    "actually",
    "list",
    "say",
    "6",
    "verify",
    "make",
    "sure",
    "hit",
    "command",
    "save",
    "console",
    "going",
    "type",
    "python",
    "recursive",
    "run",
    "see",
    "verified",
    "search",
    "works",
    "ca",
    "verify",
    "index",
    "position",
    "target",
    "value",
    "modification",
    "algorithm",
    "works",
    "guarantee",
    "running",
    "across",
    "valid",
    "inputs",
    "search",
    "works",
    "intended",
    "write",
    "different",
    "search",
    "algorithm",
    "different",
    "binary",
    "search",
    "algorithm",
    "difference",
    "two",
    "implementations",
    "anyway",
    "difference",
    "lies",
    "last",
    "four",
    "lines",
    "code",
    "see",
    "something",
    "unusual",
    "get",
    "small",
    "word",
    "advice",
    "confusing",
    "topic",
    "people",
    "get",
    "confused",
    "time",
    "worry",
    "make",
    "less",
    "programmer",
    "fact",
    "trouble",
    "often",
    "always",
    "look",
    "including",
    "made",
    "video",
    "version",
    "binary",
    "search",
    "recursive",
    "binary",
    "search",
    "recursive",
    "function",
    "one",
    "calls",
    "hard",
    "people",
    "grasp",
    "sometimes",
    "easy",
    "analogies",
    "make",
    "sense",
    "think",
    "sort",
    "way",
    "let",
    "say",
    "book",
    "contains",
    "answers",
    "multiplication",
    "problems",
    "working",
    "problem",
    "look",
    "answer",
    "book",
    "answer",
    "problem",
    "says",
    "add",
    "10",
    "answer",
    "problem",
    "52",
    "okay",
    "look",
    "problem",
    "52",
    "says",
    "add",
    "12",
    "answer",
    "problem",
    "85",
    "well",
    "go",
    "look",
    "answer",
    "problem",
    "85",
    "finally",
    "instead",
    "redirecting",
    "somewhere",
    "else",
    "answer",
    "says",
    "take",
    "10",
    "go",
    "back",
    "problem",
    "52",
    "remember",
    "answer",
    "problem",
    "52",
    "add",
    "12",
    "answer",
    "problem",
    "85",
    "take",
    "10",
    "answer",
    "problem",
    "85",
    "add",
    "10",
    "12",
    "get",
    "go",
    "back",
    "original",
    "problem",
    "said",
    "add",
    "10",
    "answer",
    "problem",
    "52",
    "add",
    "10",
    "22",
    "get",
    "32",
    "end",
    "final",
    "answer",
    "weird",
    "way",
    "example",
    "recursion",
    "solution",
    "first",
    "lookup",
    "book",
    "value",
    "obtained",
    "another",
    "lookup",
    "book",
    "followed",
    "yet",
    "another",
    "lookup",
    "book",
    "book",
    "told",
    "check",
    "book",
    "arrived",
    "base",
    "value",
    "function",
    "works",
    "similar",
    "manner",
    "let",
    "visualize",
    "example",
    "list",
    "like",
    "nine",
    "element",
    "list",
    "values",
    "zero",
    "eight",
    "target",
    "searching",
    "value",
    "eight",
    "check",
    "list",
    "empty",
    "calling",
    "len",
    "list",
    "empty",
    "go",
    "else",
    "clause",
    "next",
    "calculate",
    "midpoint",
    "9",
    "divided",
    "2",
    "rounded",
    "4",
    "first",
    "midpoint",
    "value",
    "perform",
    "first",
    "check",
    "value",
    "midpoint",
    "equal",
    "target",
    "true",
    "go",
    "else",
    "clause",
    "perform",
    "another",
    "check",
    "value",
    "midpoint",
    "less",
    "target",
    "case",
    "true",
    "earlier",
    "evaluated",
    "condition",
    "simply",
    "change",
    "value",
    "first",
    "going",
    "call",
    "recursive",
    "binary",
    "search",
    "function",
    "give",
    "new",
    "list",
    "work",
    "list",
    "starts",
    "midpoint",
    "plus",
    "1",
    "index",
    "position",
    "5",
    "way",
    "end",
    "notice",
    "call",
    "recursive",
    "binary",
    "search",
    "inside",
    "recursive",
    "binary",
    "search",
    "includes",
    "return",
    "statement",
    "important",
    "come",
    "back",
    "second",
    "back",
    "top",
    "new",
    "call",
    "recursive",
    "binary",
    "search",
    "effectively",
    "new",
    "list",
    "although",
    "technically",
    "sub",
    "list",
    "first",
    "one",
    "list",
    "contains",
    "numbers",
    "6",
    "7",
    "starting",
    "first",
    "check",
    "list",
    "empty",
    "move",
    "else",
    "midpoint",
    "case",
    "length",
    "list",
    "3",
    "divided",
    "2",
    "rounded",
    "value",
    "midpoint",
    "equal",
    "target",
    "well",
    "value",
    "position",
    "7",
    "else",
    "perform",
    "first",
    "check",
    "value",
    "midpoint",
    "less",
    "target",
    "indeed",
    "call",
    "recursive",
    "binary",
    "search",
    "provided",
    "new",
    "list",
    "list",
    "starts",
    "midpoint",
    "plus",
    "1",
    "goes",
    "end",
    "case",
    "single",
    "element",
    "list",
    "since",
    "new",
    "call",
    "recursive",
    "binary",
    "search",
    "start",
    "back",
    "top",
    "list",
    "empty",
    "midpoint",
    "zero",
    "value",
    "midpoint",
    "target",
    "return",
    "true",
    "remember",
    "minute",
    "ago",
    "pointed",
    "call",
    "recursive",
    "binary",
    "search",
    "inside",
    "function",
    "preceded",
    "return",
    "statement",
    "plays",
    "pretty",
    "important",
    "role",
    "back",
    "visualization",
    "start",
    "top",
    "recall",
    "binary",
    "search",
    "new",
    "list",
    "got",
    "return",
    "statement",
    "saying",
    "hey",
    "run",
    "binary",
    "search",
    "whatever",
    "value",
    "get",
    "back",
    "return",
    "function",
    "called",
    "second",
    "level",
    "call",
    "binary",
    "search",
    "along",
    "another",
    "return",
    "statement",
    "like",
    "first",
    "call",
    "instructing",
    "function",
    "return",
    "value",
    "back",
    "code",
    "called",
    "level",
    "find",
    "target",
    "function",
    "returns",
    "true",
    "back",
    "caller",
    "since",
    "inner",
    "function",
    "also",
    "called",
    "function",
    "instructions",
    "return",
    "keeps",
    "returning",
    "true",
    "value",
    "back",
    "reach",
    "first",
    "function",
    "called",
    "going",
    "back",
    "book",
    "answers",
    "recursive",
    "binary",
    "search",
    "instructs",
    "keep",
    "working",
    "problem",
    "concrete",
    "answer",
    "works",
    "way",
    "backwards",
    "giving",
    "answer",
    "every",
    "function",
    "called",
    "original",
    "caller",
    "answer",
    "like",
    "said",
    "beginning",
    "pretty",
    "complicated",
    "concerned",
    "click",
    "honestly",
    "one",
    "thing",
    "going",
    "walk",
    "away",
    "knowing",
    "fully",
    "understand",
    "recursion",
    "first",
    "try",
    "really",
    "lying",
    "say",
    "pretty",
    "hard",
    "time",
    "recursion",
    "move",
    "want",
    "point",
    "one",
    "thing",
    "even",
    "though",
    "implementation",
    "recursion",
    "harder",
    "understand",
    "easier",
    "case",
    "understand",
    "arrive",
    "logarithmic",
    "run",
    "time",
    "since",
    "keep",
    "calling",
    "function",
    "smaller",
    "lists",
    "let",
    "take",
    "break",
    "next",
    "video",
    "let",
    "talk",
    "bit",
    "recursion",
    "matters",
    "music",
    "last",
    "video",
    "wrote",
    "version",
    "binary",
    "search",
    "uses",
    "concept",
    "called",
    "recursion",
    "recursion",
    "might",
    "new",
    "concept",
    "let",
    "formalize",
    "use",
    "recursive",
    "function",
    "one",
    "calls",
    "example",
    "recursive",
    "binary",
    "search",
    "function",
    "called",
    "inside",
    "body",
    "function",
    "writing",
    "recursive",
    "function",
    "always",
    "need",
    "stopping",
    "condition",
    "typically",
    "start",
    "body",
    "recursive",
    "function",
    "stopping",
    "condition",
    "common",
    "call",
    "stopping",
    "condition",
    "base",
    "case",
    "recursive",
    "binary",
    "search",
    "function",
    "two",
    "stopping",
    "conditions",
    "first",
    "function",
    "return",
    "empty",
    "list",
    "passed",
    "seems",
    "weird",
    "evaluate",
    "empty",
    "list",
    "would",
    "expect",
    "run",
    "search",
    "empty",
    "list",
    "look",
    "function",
    "works",
    "recursive",
    "binary",
    "search",
    "keeps",
    "calling",
    "call",
    "size",
    "list",
    "cut",
    "half",
    "searched",
    "target",
    "exist",
    "list",
    "function",
    "would",
    "keep",
    "halving",
    "got",
    "empty",
    "list",
    "consider",
    "three",
    "element",
    "list",
    "numbers",
    "one",
    "two",
    "three",
    "searching",
    "target",
    "four",
    "first",
    "pass",
    "midpoint",
    "2",
    "function",
    "would",
    "call",
    "list",
    "next",
    "pass",
    "midpoint",
    "0",
    "target",
    "still",
    "greater",
    "function",
    "would",
    "call",
    "time",
    "passing",
    "empty",
    "list",
    "index",
    "0",
    "plus",
    "1",
    "single",
    "element",
    "list",
    "exist",
    "empty",
    "list",
    "means",
    "searching",
    "list",
    "value",
    "found",
    "define",
    "empty",
    "list",
    "stopping",
    "condition",
    "base",
    "case",
    "returns",
    "false",
    "empty",
    "list",
    "entirely",
    "different",
    "set",
    "instructions",
    "want",
    "execute",
    "first",
    "obtain",
    "midpoint",
    "list",
    "midpoint",
    "introduce",
    "next",
    "base",
    "case",
    "stopping",
    "condition",
    "value",
    "midpoint",
    "target",
    "return",
    "true",
    "two",
    "stopping",
    "conditions",
    "covered",
    "possible",
    "paths",
    "logic",
    "search",
    "algorithm",
    "either",
    "find",
    "value",
    "base",
    "cases",
    "rest",
    "implementation",
    "recursive",
    "function",
    "call",
    "function",
    "smaller",
    "hit",
    "one",
    "base",
    "cases",
    "going",
    "back",
    "visualization",
    "second",
    "see",
    "recursive",
    "binary",
    "search",
    "calls",
    "first",
    "time",
    "calls",
    "initial",
    "list",
    "started",
    "function",
    "calls",
    "times",
    "stopping",
    "condition",
    "reached",
    "number",
    "times",
    "recursive",
    "function",
    "calls",
    "called",
    "recursive",
    "depth",
    "reason",
    "bring",
    "start",
    "learning",
    "algorithms",
    "decide",
    "want",
    "go",
    "research",
    "may",
    "start",
    "see",
    "lot",
    "algorithms",
    "implemented",
    "using",
    "recursion",
    "way",
    "implemented",
    "binary",
    "search",
    "first",
    "time",
    "called",
    "iterative",
    "solution",
    "see",
    "word",
    "iterative",
    "generally",
    "means",
    "solution",
    "implemented",
    "using",
    "loop",
    "structure",
    "kind",
    "recursive",
    "solution",
    "hand",
    "one",
    "involves",
    "set",
    "stopping",
    "conditions",
    "function",
    "calls",
    "computer",
    "scientists",
    "computer",
    "science",
    "textbooks",
    "particularly",
    "back",
    "day",
    "favor",
    "written",
    "called",
    "functional",
    "languages",
    "functional",
    "languages",
    "try",
    "avoid",
    "changing",
    "data",
    "given",
    "function",
    "first",
    "version",
    "binary",
    "search",
    "created",
    "first",
    "last",
    "variables",
    "using",
    "list",
    "modified",
    "first",
    "last",
    "needed",
    "arrive",
    "solution",
    "functional",
    "languages",
    "like",
    "modification",
    "variables",
    "prefer",
    "solution",
    "using",
    "recursion",
    "language",
    "like",
    "python",
    "using",
    "opposite",
    "like",
    "recursion",
    "fact",
    "python",
    "maximum",
    "recursion",
    "depth",
    "function",
    "halt",
    "execution",
    "python",
    "prefers",
    "iterative",
    "solution",
    "mentioned",
    "two",
    "reasons",
    "decide",
    "want",
    "learn",
    "implement",
    "algorithm",
    "language",
    "choice",
    "python",
    "might",
    "see",
    "recursive",
    "solution",
    "best",
    "implementation",
    "particular",
    "language",
    "ios",
    "developer",
    "example",
    "work",
    "language",
    "called",
    "swift",
    "swift",
    "different",
    "python",
    "care",
    "recursion",
    "depth",
    "neat",
    "tricks",
    "even",
    "matter",
    "many",
    "times",
    "function",
    "calls",
    "want",
    "see",
    "swift",
    "code",
    "need",
    "know",
    "recursion",
    "works",
    "well",
    "idea",
    "second",
    "reason",
    "bring",
    "actually",
    "way",
    "important",
    "find",
    "next",
    "video",
    "beginning",
    "series",
    "mentioned",
    "two",
    "ways",
    "measuring",
    "efficiency",
    "algorithm",
    "first",
    "time",
    "complexity",
    "run",
    "time",
    "algorithm",
    "grows",
    "n",
    "grows",
    "larger",
    "second",
    "space",
    "complexity",
    "took",
    "pretty",
    "long",
    "route",
    "build",
    "example",
    "good",
    "place",
    "discuss",
    "space",
    "complexity",
    "space",
    "complexity",
    "measure",
    "much",
    "working",
    "storage",
    "extra",
    "storage",
    "needed",
    "particular",
    "algorithm",
    "grows",
    "think",
    "much",
    "days",
    "every",
    "single",
    "thing",
    "computer",
    "takes",
    "space",
    "memory",
    "early",
    "days",
    "computing",
    "considering",
    "memory",
    "usage",
    "paramount",
    "importance",
    "memory",
    "limited",
    "really",
    "expensive",
    "days",
    "spoiled",
    "devices",
    "rich",
    "memory",
    "okay",
    "write",
    "everyday",
    "code",
    "us",
    "dealing",
    "enormously",
    "large",
    "data",
    "sets",
    "write",
    "algorithms",
    "however",
    "need",
    "think",
    "want",
    "design",
    "algorithms",
    "perform",
    "efficiently",
    "size",
    "data",
    "set",
    "n",
    "grows",
    "really",
    "large",
    "like",
    "time",
    "complexity",
    "space",
    "complexity",
    "measured",
    "worst",
    "case",
    "scenario",
    "using",
    "notation",
    "since",
    "familiar",
    "different",
    "kinds",
    "complexities",
    "let",
    "dive",
    "right",
    "example",
    "iterative",
    "implementation",
    "binary",
    "search",
    "first",
    "one",
    "wrote",
    "uses",
    "loop",
    "let",
    "look",
    "happens",
    "memory",
    "usage",
    "n",
    "gets",
    "large",
    "let",
    "bring",
    "function",
    "let",
    "say",
    "start",
    "list",
    "10",
    "elements",
    "inspecting",
    "code",
    "see",
    "solution",
    "relies",
    "heavily",
    "two",
    "variables",
    "first",
    "last",
    "first",
    "points",
    "start",
    "list",
    "last",
    "end",
    "eliminate",
    "set",
    "values",
    "actually",
    "create",
    "sub",
    "list",
    "instead",
    "redefine",
    "first",
    "last",
    "see",
    "point",
    "different",
    "section",
    "list",
    "since",
    "algorithm",
    "considers",
    "values",
    "first",
    "last",
    "determining",
    "midpoint",
    "redefining",
    "first",
    "last",
    "algorithm",
    "proceeds",
    "find",
    "solution",
    "using",
    "original",
    "list",
    "means",
    "value",
    "n",
    "space",
    "complexity",
    "iterative",
    "version",
    "binary",
    "search",
    "constant",
    "iterative",
    "version",
    "binary",
    "search",
    "takes",
    "constant",
    "space",
    "remember",
    "would",
    "write",
    "big",
    "one",
    "might",
    "seem",
    "confusing",
    "n",
    "grows",
    "need",
    "storage",
    "account",
    "larger",
    "list",
    "size",
    "true",
    "storage",
    "space",
    "complexity",
    "cares",
    "measuring",
    "care",
    "additional",
    "storage",
    "needed",
    "algorithm",
    "runs",
    "tries",
    "find",
    "solution",
    "assume",
    "something",
    "simple",
    "say",
    "given",
    "size",
    "list",
    "represented",
    "value",
    "n",
    "takes",
    "n",
    "amount",
    "space",
    "store",
    "whatever",
    "means",
    "iterative",
    "version",
    "binary",
    "search",
    "regardless",
    "large",
    "list",
    "start",
    "middle",
    "end",
    "algorithm",
    "process",
    "amount",
    "storage",
    "required",
    "get",
    "larger",
    "n",
    "consider",
    "run",
    "constant",
    "space",
    "entirely",
    "different",
    "story",
    "recursive",
    "version",
    "however",
    "recursive",
    "version",
    "binary",
    "search",
    "make",
    "use",
    "variables",
    "keep",
    "track",
    "portion",
    "list",
    "working",
    "instead",
    "create",
    "new",
    "lists",
    "every",
    "time",
    "subset",
    "values",
    "every",
    "recursive",
    "function",
    "call",
    "let",
    "assume",
    "list",
    "size",
    "n",
    "worst",
    "case",
    "scenario",
    "target",
    "element",
    "last",
    "list",
    "calling",
    "recursive",
    "implementation",
    "binary",
    "search",
    "list",
    "target",
    "would",
    "lead",
    "scenario",
    "like",
    "function",
    "would",
    "call",
    "create",
    "new",
    "list",
    "goes",
    "midpoint",
    "end",
    "list",
    "since",
    "discarding",
    "half",
    "values",
    "size",
    "sub",
    "list",
    "n",
    "function",
    "keep",
    "calling",
    "creating",
    "new",
    "sub",
    "list",
    "half",
    "size",
    "current",
    "one",
    "arrives",
    "single",
    "element",
    "list",
    "stopping",
    "condition",
    "pattern",
    "see",
    "size",
    "sublist",
    "reduced",
    "factor",
    "execution",
    "algorithmic",
    "logic",
    "well",
    "seen",
    "pattern",
    "remember",
    "exactly",
    "binary",
    "search",
    "works",
    "discards",
    "half",
    "values",
    "every",
    "time",
    "finds",
    "solution",
    "know",
    "pattern",
    "running",
    "time",
    "binary",
    "search",
    "logarithmic",
    "fact",
    "space",
    "complexity",
    "recursive",
    "version",
    "binary",
    "search",
    "start",
    "memory",
    "allocation",
    "size",
    "n",
    "matches",
    "list",
    "function",
    "call",
    "recursive",
    "binary",
    "search",
    "need",
    "allocate",
    "additional",
    "memory",
    "size",
    "n",
    "2",
    "n",
    "4",
    "sub",
    "list",
    "either",
    "empty",
    "contains",
    "single",
    "value",
    "say",
    "recursive",
    "version",
    "binary",
    "search",
    "algorithm",
    "runs",
    "logarithmic",
    "time",
    "big",
    "log",
    "n",
    "important",
    "caveat",
    "totally",
    "depends",
    "language",
    "remember",
    "said",
    "programming",
    "language",
    "like",
    "swift",
    "tricks",
    "recursion",
    "depth",
    "matter",
    "concept",
    "applies",
    "care",
    "read",
    "concept",
    "called",
    "tail",
    "optimization",
    "called",
    "tail",
    "optimization",
    "think",
    "function",
    "head",
    "tail",
    "recursive",
    "function",
    "call",
    "last",
    "line",
    "code",
    "function",
    "case",
    "call",
    "tail",
    "recursion",
    "since",
    "last",
    "part",
    "function",
    "calls",
    "trick",
    "swift",
    "reduce",
    "amount",
    "space",
    "therefore",
    "computing",
    "overhead",
    "keep",
    "track",
    "recursive",
    "calls",
    "called",
    "tail",
    "call",
    "optimization",
    "tail",
    "call",
    "elimination",
    "one",
    "things",
    "see",
    "thrown",
    "around",
    "loss",
    "algorithm",
    "discussions",
    "may",
    "always",
    "relevant",
    "relevant",
    "us",
    "well",
    "python",
    "implement",
    "tail",
    "call",
    "optimization",
    "recursive",
    "version",
    "binary",
    "search",
    "takes",
    "logarithmic",
    "space",
    "choose",
    "two",
    "implementations",
    "given",
    "time",
    "complexity",
    "run",
    "time",
    "versions",
    "iterative",
    "recursive",
    "version",
    "definitely",
    "go",
    "iterative",
    "implementation",
    "python",
    "since",
    "runs",
    "constant",
    "space",
    "okay",
    "lot",
    "established",
    "two",
    "important",
    "ways",
    "distinguish",
    "algorithms",
    "handle",
    "task",
    "determine",
    "one",
    "use",
    "arrived",
    "think",
    "good",
    "spot",
    "take",
    "long",
    "break",
    "let",
    "new",
    "concepts",
    "sink",
    "go",
    "next",
    "course",
    "let",
    "take",
    "minutes",
    "recap",
    "everything",
    "learned",
    "far",
    "implement",
    "two",
    "algorithms",
    "course",
    "actual",
    "code",
    "much",
    "learned",
    "conceptual",
    "serve",
    "building",
    "blocks",
    "everything",
    "going",
    "learn",
    "future",
    "let",
    "list",
    "first",
    "thing",
    "learned",
    "arguably",
    "important",
    "algorithmic",
    "thinking",
    "algorithmic",
    "thinking",
    "approach",
    "problem",
    "solving",
    "involves",
    "breaking",
    "problem",
    "clearly",
    "defined",
    "input",
    "output",
    "along",
    "distinct",
    "set",
    "steps",
    "solves",
    "problem",
    "going",
    "input",
    "output",
    "algorithmic",
    "thinking",
    "something",
    "develop",
    "overnight",
    "taking",
    "one",
    "course",
    "worry",
    "thinking",
    "still",
    "truly",
    "know",
    "apply",
    "learned",
    "algorithmic",
    "thinking",
    "sinks",
    "go",
    "several",
    "examples",
    "similar",
    "fashion",
    "today",
    "also",
    "helps",
    "apply",
    "concepts",
    "context",
    "real",
    "example",
    "another",
    "thing",
    "strive",
    "moving",
    "forward",
    "regardless",
    "important",
    "keep",
    "mind",
    "main",
    "goal",
    "learn",
    "implement",
    "specific",
    "data",
    "structure",
    "algorithm",
    "top",
    "head",
    "honest",
    "look",
    "couple",
    "code",
    "snippets",
    "algorithms",
    "writing",
    "course",
    "going",
    "know",
    "binary",
    "search",
    "exists",
    "apply",
    "problem",
    "need",
    "faster",
    "search",
    "algorithm",
    "unlike",
    "courses",
    "immediately",
    "apply",
    "learned",
    "build",
    "something",
    "cool",
    "learning",
    "algorithms",
    "data",
    "structures",
    "pay",
    "long",
    "run",
    "second",
    "thing",
    "learned",
    "define",
    "implement",
    "algorithms",
    "gone",
    "guidelines",
    "several",
    "times",
    "wo",
    "bore",
    "end",
    "remind",
    "often",
    "confused",
    "effectively",
    "break",
    "problem",
    "code",
    "something",
    "manageable",
    "following",
    "algorithm",
    "guidelines",
    "good",
    "place",
    "start",
    "next",
    "learned",
    "big",
    "measuring",
    "time",
    "complexity",
    "algorithms",
    "mildly",
    "complicated",
    "topic",
    "abstracted",
    "math",
    "away",
    "hazy",
    "topic",
    "seems",
    "get",
    "wrong",
    "math",
    "pretty",
    "important",
    "designing",
    "analyzing",
    "algorithms",
    "goal",
    "understand",
    "evaluate",
    "algorithms",
    "learned",
    "common",
    "run",
    "times",
    "like",
    "constant",
    "linear",
    "logarithmic",
    "quadratic",
    "runtimes",
    "fairly",
    "new",
    "concepts",
    "time",
    "immediately",
    "able",
    "distinguish",
    "runtime",
    "algorithm",
    "based",
    "code",
    "write",
    "understanding",
    "sits",
    "efficiency",
    "scale",
    "also",
    "due",
    "time",
    "internalize",
    "runtimes",
    "popular",
    "algorithms",
    "like",
    "fact",
    "binary",
    "search",
    "runs",
    "logarithmic",
    "time",
    "constant",
    "space",
    "able",
    "recommend",
    "alternative",
    "algorithms",
    "given",
    "problem",
    "time",
    "number",
    "tools",
    "tool",
    "belt",
    "increase",
    "next",
    "learned",
    "two",
    "important",
    "search",
    "algorithms",
    "situations",
    "select",
    "one",
    "also",
    "implemented",
    "algorithms",
    "code",
    "got",
    "chance",
    "see",
    "work",
    "python",
    "familiar",
    "different",
    "language",
    "gotten",
    "chance",
    "check",
    "code",
    "snippets",
    "provided",
    "try",
    "hand",
    "implementing",
    "really",
    "good",
    "exercise",
    "go",
    "finally",
    "learned",
    "important",
    "concept",
    "way",
    "writing",
    "algorithmic",
    "code",
    "recursion",
    "recursion",
    "tricky",
    "thing",
    "depending",
    "language",
    "write",
    "code",
    "may",
    "run",
    "others",
    "also",
    "good",
    "aware",
    "saw",
    "implementation",
    "binary",
    "search",
    "whether",
    "recursion",
    "used",
    "affected",
    "amount",
    "space",
    "used",
    "worry",
    "fully",
    "understand",
    "write",
    "recursive",
    "functions",
    "truly",
    "know",
    "either",
    "good",
    "part",
    "always",
    "look",
    "things",
    "understand",
    "people",
    "anytime",
    "encounter",
    "recursion",
    "courses",
    "moving",
    "forward",
    "get",
    "full",
    "explanation",
    "function",
    "brings",
    "us",
    "end",
    "course",
    "stress",
    "goal",
    "course",
    "get",
    "prepared",
    "learning",
    "specific",
    "algorithms",
    "introducing",
    "tools",
    "concepts",
    "need",
    "moving",
    "forward",
    "sitting",
    "thinking",
    "still",
    "know",
    "write",
    "many",
    "algorithms",
    "use",
    "algorithmic",
    "thinking",
    "okay",
    "get",
    "stick",
    "always",
    "fun",
    "happy",
    "coding",
    "music",
    "hi",
    "name",
    "passant",
    "instructor",
    "treehouse",
    "welcome",
    "introduction",
    "data",
    "structures",
    "course",
    "course",
    "going",
    "answer",
    "one",
    "fundamental",
    "question",
    "need",
    "data",
    "structures",
    "programming",
    "language",
    "provides",
    "answer",
    "question",
    "housekeeping",
    "course",
    "going",
    "rely",
    "concepts",
    "learned",
    "introduction",
    "algorithms",
    "course",
    "namely",
    "notation",
    "space",
    "time",
    "complexity",
    "recursion",
    "unfamiliar",
    "concepts",
    "need",
    "refresher",
    "check",
    "prerequisites",
    "courses",
    "listed",
    "addition",
    "course",
    "assume",
    "programming",
    "experience",
    "going",
    "use",
    "data",
    "structures",
    "come",
    "built",
    "nearly",
    "programming",
    "languages",
    "point",
    "reference",
    "explain",
    "basics",
    "structures",
    "work",
    "wo",
    "going",
    "use",
    "practice",
    "looking",
    "learn",
    "program",
    "digging",
    "content",
    "check",
    "notes",
    "section",
    "video",
    "helpful",
    "links",
    "good",
    "go",
    "awesome",
    "let",
    "start",
    "overview",
    "course",
    "first",
    "thing",
    "going",
    "explore",
    "data",
    "structure",
    "somewhat",
    "already",
    "familiar",
    "arrays",
    "written",
    "code",
    "high",
    "chance",
    "used",
    "array",
    "course",
    "going",
    "spend",
    "time",
    "understanding",
    "arrays",
    "work",
    "common",
    "operations",
    "array",
    "run",
    "times",
    "associated",
    "operations",
    "done",
    "going",
    "build",
    "data",
    "type",
    "called",
    "linked",
    "list",
    "going",
    "learn",
    "one",
    "way",
    "store",
    "data",
    "fact",
    "way",
    "one",
    "way",
    "also",
    "going",
    "explore",
    "motivates",
    "us",
    "build",
    "specific",
    "kinds",
    "structures",
    "look",
    "pros",
    "cons",
    "structures",
    "exploring",
    "four",
    "common",
    "operations",
    "accessing",
    "value",
    "searching",
    "value",
    "inserting",
    "value",
    "deleting",
    "value",
    "actually",
    "going",
    "circle",
    "back",
    "algorithms",
    "implement",
    "new",
    "one",
    "sorting",
    "algorithm",
    "introductions",
    "algorithms",
    "course",
    "implemented",
    "binary",
    "search",
    "algorithm",
    "precondition",
    "binary",
    "search",
    "list",
    "needed",
    "sorted",
    "going",
    "try",
    "hand",
    "sorting",
    "list",
    "open",
    "door",
    "entirely",
    "new",
    "category",
    "algorithms",
    "going",
    "implement",
    "sorting",
    "algorithm",
    "two",
    "different",
    "data",
    "structures",
    "explore",
    "implementation",
    "one",
    "algorithm",
    "differ",
    "based",
    "data",
    "structure",
    "used",
    "also",
    "look",
    "choice",
    "data",
    "structure",
    "potentially",
    "influences",
    "run",
    "time",
    "algorithm",
    "learning",
    "sorting",
    "also",
    "going",
    "encounter",
    "another",
    "general",
    "concept",
    "algorithmic",
    "thinking",
    "called",
    "divide",
    "conquer",
    "along",
    "recursion",
    "dividing",
    "conquer",
    "fundamental",
    "tool",
    "use",
    "solve",
    "complex",
    "problems",
    "due",
    "time",
    "next",
    "video",
    "let",
    "talk",
    "arrays",
    "common",
    "data",
    "structure",
    "built",
    "nearly",
    "every",
    "programming",
    "language",
    "array",
    "arrays",
    "fundamental",
    "data",
    "structure",
    "used",
    "represent",
    "collection",
    "values",
    "much",
    "arrays",
    "also",
    "used",
    "building",
    "blocks",
    "create",
    "even",
    "custom",
    "data",
    "types",
    "structures",
    "fact",
    "programming",
    "languages",
    "text",
    "represented",
    "using",
    "string",
    "type",
    "hood",
    "strings",
    "bunch",
    "characters",
    "stored",
    "particular",
    "order",
    "array",
    "go",
    "dig",
    "arrays",
    "exactly",
    "data",
    "structure",
    "data",
    "structure",
    "way",
    "storing",
    "data",
    "programming",
    "collection",
    "values",
    "format",
    "stored",
    "relationship",
    "values",
    "collection",
    "well",
    "operations",
    "applied",
    "data",
    "stored",
    "structure",
    "array",
    "one",
    "many",
    "data",
    "structures",
    "general",
    "array",
    "data",
    "structure",
    "stores",
    "collection",
    "values",
    "value",
    "referenced",
    "using",
    "index",
    "key",
    "common",
    "analogy",
    "thinking",
    "arrays",
    "set",
    "train",
    "cars",
    "car",
    "number",
    "cars",
    "ordered",
    "sequentially",
    "inside",
    "car",
    "array",
    "train",
    "analogy",
    "stores",
    "data",
    "general",
    "representation",
    "array",
    "differ",
    "slightly",
    "one",
    "language",
    "another",
    "part",
    "fundamentals",
    "remain",
    "language",
    "like",
    "swift",
    "java",
    "arrays",
    "homogeneous",
    "containers",
    "means",
    "contain",
    "values",
    "type",
    "use",
    "array",
    "store",
    "integers",
    "java",
    "store",
    "integers",
    "languages",
    "arrays",
    "heterogeneous",
    "structures",
    "store",
    "kind",
    "value",
    "python",
    "example",
    "mix",
    "numbers",
    "text",
    "issues",
    "regardless",
    "nuance",
    "fundamental",
    "concept",
    "array",
    "index",
    "index",
    "value",
    "used",
    "every",
    "operation",
    "array",
    "accessing",
    "values",
    "inserting",
    "updating",
    "deleting",
    "python",
    "language",
    "going",
    "using",
    "course",
    "tiny",
    "bit",
    "confusing",
    "type",
    "generally",
    "refer",
    "array",
    "languages",
    "best",
    "represented",
    "list",
    "type",
    "python",
    "python",
    "type",
    "called",
    "array",
    "well",
    "something",
    "different",
    "going",
    "use",
    "python",
    "calls",
    "list",
    "use",
    "list",
    "course",
    "talking",
    "concepts",
    "apply",
    "arrays",
    "well",
    "languages",
    "definitely",
    "skip",
    "one",
    "thing",
    "computer",
    "science",
    "list",
    "actually",
    "different",
    "data",
    "structure",
    "array",
    "fact",
    "going",
    "build",
    "list",
    "later",
    "course",
    "generally",
    "though",
    "structure",
    "called",
    "linked",
    "list",
    "opposed",
    "list",
    "hopefully",
    "terminology",
    "confusing",
    "properly",
    "understand",
    "arrays",
    "work",
    "let",
    "take",
    "peek",
    "arrays",
    "stored",
    "hood",
    "array",
    "contiguous",
    "data",
    "structure",
    "means",
    "array",
    "stored",
    "blocks",
    "memory",
    "right",
    "beside",
    "gaps",
    "advantage",
    "retrieving",
    "values",
    "easy",
    "data",
    "structure",
    "going",
    "build",
    "one",
    "soon",
    "structure",
    "stores",
    "value",
    "well",
    "reference",
    "next",
    "value",
    "retrieve",
    "next",
    "value",
    "language",
    "follow",
    "reference",
    "also",
    "called",
    "pointer",
    "next",
    "block",
    "memory",
    "adds",
    "overhead",
    "see",
    "increases",
    "runtime",
    "common",
    "operations",
    "second",
    "ago",
    "mentioned",
    "depending",
    "language",
    "arrays",
    "either",
    "homogeneous",
    "containing",
    "type",
    "value",
    "heterogeneous",
    "kind",
    "value",
    "mixed",
    "choice",
    "also",
    "affects",
    "memory",
    "layout",
    "array",
    "example",
    "language",
    "like",
    "c",
    "swift",
    "java",
    "arrays",
    "homogeneous",
    "array",
    "created",
    "since",
    "kind",
    "value",
    "known",
    "language",
    "compiler",
    "think",
    "compiler",
    "brains",
    "behind",
    "language",
    "choose",
    "contiguous",
    "block",
    "memory",
    "fits",
    "array",
    "size",
    "values",
    "created",
    "values",
    "integers",
    "assuming",
    "integer",
    "took",
    "space",
    "represented",
    "one",
    "blocks",
    "five",
    "item",
    "array",
    "compiler",
    "allocate",
    "five",
    "blocks",
    "equally",
    "sized",
    "memory",
    "python",
    "however",
    "case",
    "put",
    "value",
    "python",
    "list",
    "restriction",
    "way",
    "works",
    "combination",
    "contiguous",
    "memory",
    "pointers",
    "references",
    "mentioned",
    "earlier",
    "create",
    "list",
    "python",
    "information",
    "go",
    "array",
    "makes",
    "hard",
    "allocate",
    "contiguous",
    "memory",
    "size",
    "several",
    "advantages",
    "contiguous",
    "memory",
    "since",
    "values",
    "stored",
    "beside",
    "accessing",
    "values",
    "happens",
    "almost",
    "constant",
    "time",
    "characteristic",
    "want",
    "preserve",
    "way",
    "python",
    "gets",
    "around",
    "allocating",
    "contiguous",
    "memory",
    "storing",
    "init",
    "value",
    "want",
    "store",
    "reference",
    "pointer",
    "value",
    "stored",
    "somewhere",
    "else",
    "memory",
    "allocate",
    "equally",
    "sized",
    "contiguous",
    "memory",
    "since",
    "regardless",
    "value",
    "size",
    "size",
    "pointer",
    "value",
    "always",
    "going",
    "equal",
    "incurs",
    "additional",
    "cost",
    "value",
    "accessed",
    "need",
    "follow",
    "pointer",
    "block",
    "memory",
    "value",
    "actually",
    "stored",
    "python",
    "ways",
    "dealing",
    "costs",
    "outside",
    "scope",
    "course",
    "know",
    "array",
    "stores",
    "values",
    "let",
    "look",
    "common",
    "operations",
    "execute",
    "array",
    "regardless",
    "kind",
    "data",
    "structure",
    "work",
    "data",
    "structures",
    "expected",
    "carry",
    "four",
    "kinds",
    "operations",
    "minimum",
    "need",
    "able",
    "access",
    "read",
    "values",
    "stored",
    "structure",
    "need",
    "able",
    "search",
    "arbitrary",
    "value",
    "also",
    "need",
    "able",
    "insert",
    "value",
    "point",
    "structure",
    "finally",
    "need",
    "able",
    "delete",
    "structures",
    "let",
    "look",
    "operations",
    "implemented",
    "array",
    "structure",
    "detail",
    "starting",
    "access",
    "elements",
    "array",
    "identified",
    "using",
    "value",
    "known",
    "index",
    "use",
    "index",
    "access",
    "read",
    "value",
    "programming",
    "languages",
    "follow",
    "numbering",
    "system",
    "comes",
    "arrays",
    "means",
    "first",
    "index",
    "value",
    "equal",
    "zero",
    "one",
    "generally",
    "speaking",
    "array",
    "declared",
    "base",
    "amount",
    "contiguous",
    "memory",
    "allocated",
    "array",
    "storage",
    "computers",
    "refer",
    "memory",
    "use",
    "address",
    "instead",
    "keeping",
    "reference",
    "memory",
    "allocated",
    "array",
    "array",
    "store",
    "address",
    "first",
    "location",
    "memory",
    "contiguous",
    "using",
    "base",
    "address",
    "array",
    "calculate",
    "address",
    "value",
    "using",
    "index",
    "position",
    "value",
    "offset",
    "want",
    "specific",
    "think",
    "way",
    "let",
    "say",
    "want",
    "create",
    "array",
    "integers",
    "integer",
    "takes",
    "certain",
    "amount",
    "space",
    "memory",
    "call",
    "let",
    "also",
    "assume",
    "know",
    "many",
    "elements",
    "going",
    "create",
    "size",
    "array",
    "number",
    "elements",
    "call",
    "n",
    "total",
    "amount",
    "space",
    "need",
    "allocate",
    "n",
    "times",
    "space",
    "per",
    "item",
    "array",
    "keeps",
    "track",
    "location",
    "memory",
    "first",
    "value",
    "held",
    "let",
    "label",
    "m0",
    "information",
    "needs",
    "find",
    "element",
    "list",
    "accessing",
    "value",
    "array",
    "use",
    "index",
    "get",
    "first",
    "element",
    "list",
    "use",
    "zeroth",
    "index",
    "get",
    "second",
    "use",
    "index",
    "value",
    "1",
    "given",
    "array",
    "knows",
    "much",
    "storage",
    "needed",
    "element",
    "get",
    "address",
    "element",
    "starting",
    "address",
    "first",
    "element",
    "adding",
    "index",
    "value",
    "times",
    "amount",
    "storage",
    "per",
    "element",
    "example",
    "access",
    "second",
    "value",
    "start",
    "m0",
    "add",
    "times",
    "index",
    "value",
    "1",
    "giving",
    "us",
    "m1",
    "location",
    "memory",
    "second",
    "address",
    "simplified",
    "model",
    "less",
    "works",
    "possible",
    "know",
    "array",
    "memory",
    "contiguous",
    "gaps",
    "let",
    "switch",
    "code",
    "mentioned",
    "earlier",
    "going",
    "using",
    "python",
    "course",
    "know",
    "code",
    "interested",
    "content",
    "know",
    "language",
    "python",
    "check",
    "notes",
    "section",
    "video",
    "information",
    "code",
    "python",
    "concepts",
    "universal",
    "importantly",
    "simple",
    "enough",
    "issue",
    "following",
    "along",
    "favorite",
    "programming",
    "language",
    "get",
    "started",
    "click",
    "launch",
    "workspaces",
    "button",
    "video",
    "page",
    "watching",
    "right",
    "spin",
    "instance",
    "treehouse",
    "workspace",
    "coding",
    "environment",
    "right",
    "workspace",
    "empty",
    "expected",
    "let",
    "add",
    "new",
    "file",
    "going",
    "go",
    "file",
    "new",
    "file",
    "call",
    "arrays",
    "dot",
    "py",
    "pi",
    "creating",
    "list",
    "python",
    "quite",
    "simple",
    "call",
    "new",
    "underscore",
    "list",
    "use",
    "set",
    "square",
    "brackets",
    "around",
    "set",
    "values",
    "create",
    "list",
    "one",
    "comma",
    "separate",
    "space",
    "two",
    "space",
    "three",
    "allocates",
    "base",
    "amount",
    "memory",
    "array",
    "use",
    "say",
    "array",
    "know",
    "python",
    "mean",
    "list",
    "since",
    "python",
    "values",
    "stored",
    "memory",
    "instead",
    "values",
    "1",
    "2",
    "3",
    "stored",
    "elsewhere",
    "memory",
    "array",
    "stores",
    "references",
    "objects",
    "access",
    "value",
    "use",
    "subscript",
    "along",
    "index",
    "value",
    "get",
    "first",
    "value",
    "use",
    "index",
    "0",
    "assign",
    "another",
    "variable",
    "would",
    "say",
    "result",
    "equal",
    "new",
    "list",
    "write",
    "new",
    "lists",
    "since",
    "array",
    "accessing",
    "value",
    "subscript",
    "notation",
    "square",
    "bracket",
    "index",
    "value",
    "saw",
    "since",
    "array",
    "reference",
    "base",
    "location",
    "memory",
    "position",
    "element",
    "determined",
    "pretty",
    "easily",
    "iterate",
    "entire",
    "list",
    "need",
    "simple",
    "calculation",
    "offset",
    "base",
    "memory",
    "since",
    "guaranteed",
    "memory",
    "contiguous",
    "reason",
    "access",
    "constant",
    "time",
    "operation",
    "array",
    "python",
    "list",
    "also",
    "array",
    "crashes",
    "try",
    "access",
    "value",
    "using",
    "index",
    "bounds",
    "array",
    "stores",
    "used",
    "array",
    "undoubtedly",
    "run",
    "error",
    "crash",
    "try",
    "access",
    "value",
    "using",
    "index",
    "larger",
    "number",
    "elements",
    "array",
    "since",
    "array",
    "calculates",
    "memory",
    "address",
    "fly",
    "access",
    "value",
    "bounds",
    "index",
    "called",
    "memory",
    "address",
    "returned",
    "one",
    "part",
    "array",
    "structure",
    "therefore",
    "read",
    "array",
    "python",
    "represented",
    "index",
    "error",
    "make",
    "happen",
    "using",
    "index",
    "know",
    "array",
    "wo",
    "contain",
    "writing",
    "code",
    "inside",
    "text",
    "editor",
    "obviously",
    "run",
    "code",
    "let",
    "drag",
    "console",
    "area",
    "going",
    "write",
    "python",
    "bring",
    "python",
    "interpreter",
    "thing",
    "say",
    "new",
    "list",
    "equal",
    "one",
    "comma",
    "two",
    "comma",
    "three",
    "interpreter",
    "actually",
    "going",
    "evaluate",
    "code",
    "right",
    "new",
    "list",
    "type",
    "new",
    "list",
    "gets",
    "printed",
    "console",
    "okay",
    "also",
    "new",
    "list",
    "square",
    "bracket",
    "0",
    "see",
    "get",
    "value",
    "1",
    "value",
    "stored",
    "zeroth",
    "index",
    "highlight",
    "index",
    "error",
    "new",
    "list",
    "inside",
    "square",
    "brackets",
    "provide",
    "index",
    "know",
    "array",
    "contain",
    "say",
    "index",
    "10",
    "hit",
    "enter",
    "see",
    "say",
    "index",
    "error",
    "list",
    "index",
    "range",
    "basics",
    "create",
    "read",
    "values",
    "array",
    "next",
    "video",
    "let",
    "take",
    "look",
    "searching",
    "last",
    "video",
    "learned",
    "happens",
    "hood",
    "create",
    "array",
    "read",
    "value",
    "using",
    "index",
    "video",
    "going",
    "look",
    "remaining",
    "data",
    "structure",
    "operations",
    "work",
    "arrays",
    "took",
    "introduction",
    "algorithms",
    "course",
    "spent",
    "time",
    "learning",
    "two",
    "search",
    "algorithms",
    "linear",
    "search",
    "binary",
    "search",
    "arrays",
    "really",
    "fast",
    "accessing",
    "values",
    "pretty",
    "bad",
    "searching",
    "taking",
    "array",
    "best",
    "use",
    "linear",
    "search",
    "worst",
    "case",
    "linear",
    "runtime",
    "linear",
    "search",
    "works",
    "accessing",
    "reading",
    "value",
    "list",
    "element",
    "concern",
    "found",
    "element",
    "looking",
    "end",
    "list",
    "every",
    "single",
    "element",
    "list",
    "accessed",
    "compared",
    "even",
    "though",
    "accessing",
    "comparing",
    "constant",
    "time",
    "operations",
    "every",
    "element",
    "results",
    "overall",
    "linear",
    "time",
    "let",
    "look",
    "search",
    "works",
    "code",
    "python",
    "search",
    "item",
    "array",
    "one",
    "two",
    "ways",
    "use",
    "operator",
    "check",
    "whether",
    "list",
    "contains",
    "item",
    "say",
    "one",
    "new",
    "underscore",
    "list",
    "print",
    "true",
    "operator",
    "actually",
    "calls",
    "contains",
    "method",
    "defined",
    "list",
    "type",
    "runs",
    "linear",
    "search",
    "operation",
    "addition",
    "also",
    "use",
    "loop",
    "iterate",
    "list",
    "manually",
    "perform",
    "comparison",
    "operation",
    "say",
    "n",
    "new",
    "list",
    "n",
    "equals",
    "one",
    "print",
    "true",
    "break",
    "loop",
    "less",
    "implementation",
    "linear",
    "search",
    "array",
    "sorted",
    "however",
    "could",
    "use",
    "binary",
    "search",
    "sort",
    "operations",
    "incur",
    "cost",
    "languages",
    "usually",
    "stay",
    "away",
    "sorting",
    "list",
    "running",
    "binary",
    "search",
    "since",
    "smaller",
    "arrays",
    "linear",
    "search",
    "may",
    "faster",
    "remember",
    "since",
    "editor",
    "text",
    "file",
    "none",
    "lines",
    "code",
    "evaluated",
    "try",
    "copy",
    "come",
    "say",
    "python",
    "hit",
    "enter",
    "starts",
    "paste",
    "list",
    "try",
    "one",
    "new",
    "list",
    "print",
    "true",
    "go",
    "prints",
    "true",
    "already",
    "learned",
    "linear",
    "binary",
    "search",
    "previous",
    "course",
    "nothing",
    "new",
    "going",
    "interesting",
    "look",
    "opinion",
    "inserting",
    "deleting",
    "values",
    "array",
    "let",
    "start",
    "inserting",
    "general",
    "array",
    "implementations",
    "support",
    "three",
    "types",
    "insert",
    "operations",
    "first",
    "true",
    "insert",
    "using",
    "index",
    "value",
    "insert",
    "element",
    "anywhere",
    "list",
    "operation",
    "linear",
    "runtime",
    "imagine",
    "wanted",
    "insert",
    "item",
    "start",
    "list",
    "insert",
    "first",
    "position",
    "happens",
    "item",
    "currently",
    "spot",
    "well",
    "move",
    "next",
    "spot",
    "index",
    "value",
    "one",
    "happens",
    "second",
    "item",
    "index",
    "position",
    "one",
    "one",
    "moves",
    "next",
    "spot",
    "index",
    "position",
    "two",
    "keeps",
    "happening",
    "elements",
    "shifted",
    "forward",
    "one",
    "index",
    "position",
    "worst",
    "case",
    "scenario",
    "inserting",
    "zeroth",
    "position",
    "array",
    "every",
    "single",
    "item",
    "array",
    "shifted",
    "forward",
    "know",
    "operation",
    "involves",
    "iterating",
    "every",
    "single",
    "value",
    "means",
    "linear",
    "runtime",
    "second",
    "way",
    "insert",
    "item",
    "array",
    "appending",
    "appending",
    "although",
    "technically",
    "insert",
    "operation",
    "inserts",
    "item",
    "existing",
    "array",
    "incur",
    "runtime",
    "cost",
    "appends",
    "simply",
    "add",
    "item",
    "end",
    "list",
    "simplify",
    "say",
    "constant",
    "time",
    "constant",
    "time",
    "operation",
    "depends",
    "language",
    "implementation",
    "array",
    "highlight",
    "matters",
    "let",
    "consider",
    "lists",
    "python",
    "work",
    "python",
    "create",
    "list",
    "list",
    "know",
    "anything",
    "size",
    "list",
    "many",
    "elements",
    "going",
    "store",
    "creating",
    "new",
    "empty",
    "list",
    "like",
    "numbers",
    "equal",
    "two",
    "empty",
    "brackets",
    "creates",
    "list",
    "allocates",
    "space",
    "size",
    "n",
    "plus",
    "one",
    "since",
    "n",
    "zero",
    "elements",
    "array",
    "list",
    "space",
    "allocated",
    "one",
    "element",
    "list",
    "start",
    "space",
    "allocated",
    "list",
    "space",
    "used",
    "list",
    "think",
    "happens",
    "ask",
    "python",
    "length",
    "list",
    "say",
    "len",
    "numbers",
    "correctly",
    "get",
    "0",
    "back",
    "means",
    "list",
    "use",
    "memory",
    "allocation",
    "indicator",
    "size",
    "mentioned",
    "allocated",
    "space",
    "one",
    "element",
    "list",
    "returns",
    "zero",
    "determines",
    "ways",
    "okay",
    "numbers",
    "list",
    "currently",
    "space",
    "one",
    "element",
    "let",
    "use",
    "append",
    "method",
    "defined",
    "type",
    "insert",
    "number",
    "end",
    "list",
    "say",
    "numbers",
    "dot",
    "append",
    "pass",
    "memory",
    "allocation",
    "size",
    "list",
    "since",
    "list",
    "contains",
    "one",
    "element",
    "something",
    "like",
    "needs",
    "dot",
    "add",
    "another",
    "value",
    "since",
    "list",
    "allocation",
    "one",
    "item",
    "point",
    "add",
    "new",
    "element",
    "list",
    "needs",
    "increase",
    "memory",
    "allocation",
    "thereby",
    "size",
    "list",
    "calling",
    "list",
    "resize",
    "operation",
    "list",
    "resizing",
    "quite",
    "interesting",
    "shows",
    "ingenuity",
    "solving",
    "problems",
    "like",
    "python",
    "resize",
    "list",
    "accommodate",
    "element",
    "want",
    "add",
    "instead",
    "case",
    "would",
    "allocate",
    "four",
    "blocks",
    "memory",
    "increase",
    "size",
    "total",
    "four",
    "contiguous",
    "blocks",
    "memory",
    "resize",
    "list",
    "every",
    "single",
    "time",
    "add",
    "element",
    "specific",
    "points",
    "growth",
    "pattern",
    "list",
    "type",
    "python",
    "0",
    "4",
    "8",
    "16",
    "25",
    "35",
    "46",
    "means",
    "list",
    "size",
    "approaches",
    "specific",
    "values",
    "resize",
    "called",
    "look",
    "size",
    "list",
    "four",
    "means",
    "appending",
    "four",
    "values",
    "size",
    "eight",
    "append",
    "operations",
    "increase",
    "amount",
    "space",
    "taken",
    "specific",
    "points",
    "however",
    "resizing",
    "triggered",
    "space",
    "required",
    "increases",
    "memory",
    "allocation",
    "increases",
    "might",
    "signify",
    "append",
    "method",
    "space",
    "complexity",
    "turns",
    "operations",
    "increase",
    "space",
    "others",
    "average",
    "append",
    "operations",
    "take",
    "constant",
    "space",
    "say",
    "amortized",
    "constant",
    "space",
    "complexity",
    "also",
    "happens",
    "insert",
    "operations",
    "four",
    "element",
    "array",
    "would",
    "four",
    "elements",
    "memory",
    "allocation",
    "four",
    "insert",
    "operation",
    "point",
    "matter",
    "happens",
    "list",
    "point",
    "would",
    "trigger",
    "resize",
    "inserting",
    "still",
    "expensive",
    "though",
    "resize",
    "every",
    "element",
    "needs",
    "shifted",
    "one",
    "last",
    "insert",
    "operation",
    "supported",
    "languages",
    "ability",
    "add",
    "one",
    "list",
    "another",
    "python",
    "called",
    "extend",
    "looks",
    "like",
    "say",
    "numbers",
    "let",
    "actually",
    "clear",
    "console",
    "oh",
    "actually",
    "let",
    "exit",
    "python",
    "clear",
    "back",
    "top",
    "start",
    "say",
    "numbers",
    "set",
    "empty",
    "list",
    "say",
    "numbers",
    "dot",
    "extend",
    "argument",
    "going",
    "pass",
    "new",
    "list",
    "entirely",
    "say",
    "4",
    "comma",
    "5",
    "comma",
    "6",
    "hit",
    "enter",
    "print",
    "numbers",
    "see",
    "contains",
    "values",
    "4",
    "5",
    "extend",
    "takes",
    "another",
    "list",
    "add",
    "extend",
    "effectively",
    "makes",
    "series",
    "append",
    "calls",
    "elements",
    "new",
    "list",
    "appended",
    "original",
    "list",
    "operation",
    "run",
    "time",
    "big",
    "k",
    "k",
    "represents",
    "number",
    "elements",
    "list",
    "adding",
    "existing",
    "list",
    "last",
    "type",
    "operation",
    "need",
    "consider",
    "delete",
    "operations",
    "deletes",
    "similar",
    "inserts",
    "delete",
    "operation",
    "occurs",
    "list",
    "needs",
    "maintain",
    "correct",
    "index",
    "values",
    "insert",
    "shifts",
    "every",
    "element",
    "right",
    "delete",
    "operation",
    "shifts",
    "every",
    "element",
    "left",
    "like",
    "insert",
    "well",
    "delete",
    "first",
    "element",
    "list",
    "every",
    "single",
    "element",
    "list",
    "needs",
    "shifted",
    "left",
    "delete",
    "operations",
    "upper",
    "bound",
    "big",
    "n",
    "also",
    "known",
    "linear",
    "runtime",
    "seen",
    "common",
    "operations",
    "work",
    "data",
    "structure",
    "quite",
    "familiar",
    "let",
    "switch",
    "tracks",
    "build",
    "data",
    "structure",
    "music",
    "next",
    "videos",
    "going",
    "build",
    "data",
    "structure",
    "may",
    "worked",
    "linked",
    "list",
    "get",
    "linked",
    "list",
    "let",
    "talk",
    "build",
    "data",
    "structures",
    "instead",
    "using",
    "ones",
    "come",
    "built",
    "languages",
    "data",
    "structure",
    "solves",
    "particular",
    "problem",
    "went",
    "basics",
    "array",
    "data",
    "structure",
    "looked",
    "cost",
    "common",
    "operations",
    "carry",
    "arrays",
    "found",
    "arrays",
    "particularly",
    "good",
    "accessing",
    "reading",
    "values",
    "happens",
    "constant",
    "time",
    "arrays",
    "pretty",
    "bad",
    "inserting",
    "deleting",
    "run",
    "linear",
    "time",
    "linked",
    "lists",
    "hand",
    "somewhat",
    "better",
    "although",
    "caveats",
    "trying",
    "solve",
    "problem",
    "involves",
    "far",
    "inserts",
    "deletes",
    "accessing",
    "linked",
    "list",
    "better",
    "tool",
    "array",
    "linked",
    "list",
    "linked",
    "list",
    "linear",
    "data",
    "structure",
    "element",
    "list",
    "contained",
    "separate",
    "object",
    "called",
    "node",
    "node",
    "models",
    "two",
    "pieces",
    "information",
    "individual",
    "item",
    "data",
    "want",
    "store",
    "reference",
    "next",
    "node",
    "list",
    "first",
    "node",
    "linked",
    "list",
    "called",
    "head",
    "list",
    "last",
    "node",
    "called",
    "tail",
    "head",
    "tail",
    "nodes",
    "special",
    "list",
    "maintains",
    "reference",
    "head",
    "although",
    "implementations",
    "keeps",
    "reference",
    "tail",
    "well",
    "aspect",
    "linked",
    "lists",
    "important",
    "see",
    "operations",
    "list",
    "need",
    "implemented",
    "quite",
    "differently",
    "compared",
    "array",
    "opposite",
    "head",
    "tail",
    "denotes",
    "end",
    "list",
    "every",
    "node",
    "tail",
    "points",
    "next",
    "node",
    "list",
    "tail",
    "point",
    "anything",
    "basically",
    "know",
    "end",
    "list",
    "nodes",
    "called",
    "objects",
    "definition",
    "node",
    "includes",
    "link",
    "another",
    "node",
    "means",
    "definition",
    "node",
    "includes",
    "node",
    "linked",
    "lists",
    "often",
    "come",
    "two",
    "forms",
    "singly",
    "linked",
    "list",
    "node",
    "stores",
    "reference",
    "next",
    "node",
    "list",
    "doubly",
    "linked",
    "list",
    "node",
    "stores",
    "reference",
    "node",
    "array",
    "train",
    "bunch",
    "cars",
    "order",
    "linked",
    "list",
    "like",
    "treasure",
    "hunt",
    "start",
    "hunt",
    "piece",
    "paper",
    "location",
    "first",
    "treasure",
    "go",
    "location",
    "find",
    "item",
    "along",
    "location",
    "next",
    "item",
    "treasure",
    "finally",
    "find",
    "item",
    "also",
    "include",
    "location",
    "know",
    "hunt",
    "ended",
    "high",
    "level",
    "view",
    "linked",
    "list",
    "let",
    "jump",
    "code",
    "build",
    "one",
    "together",
    "focus",
    "building",
    "singly",
    "linked",
    "list",
    "course",
    "advantages",
    "doubly",
    "linked",
    "list",
    "want",
    "get",
    "ahead",
    "let",
    "start",
    "creating",
    "new",
    "file",
    "going",
    "put",
    "code",
    "linked",
    "list",
    "call",
    "linked",
    "underscore",
    "list",
    "dot",
    "pi",
    "first",
    "going",
    "create",
    "class",
    "represent",
    "node",
    "say",
    "class",
    "node",
    "node",
    "simple",
    "object",
    "wo",
    "model",
    "much",
    "first",
    "add",
    "data",
    "variable",
    "instance",
    "variable",
    "called",
    "data",
    "assign",
    "value",
    "none",
    "initially",
    "add",
    "one",
    "call",
    "next",
    "node",
    "assign",
    "none",
    "well",
    "created",
    "two",
    "instance",
    "variables",
    "data",
    "hold",
    "data",
    "storing",
    "next",
    "node",
    "point",
    "next",
    "node",
    "list",
    "need",
    "add",
    "constructor",
    "make",
    "class",
    "easy",
    "create",
    "add",
    "init",
    "method",
    "takes",
    "self",
    "data",
    "start",
    "going",
    "assign",
    "data",
    "instance",
    "variable",
    "created",
    "need",
    "model",
    "node",
    "anything",
    "else",
    "though",
    "let",
    "document",
    "right",
    "class",
    "definition",
    "let",
    "create",
    "docs",
    "string",
    "three",
    "quotes",
    "next",
    "line",
    "say",
    "object",
    "storing",
    "single",
    "node",
    "linked",
    "list",
    "next",
    "line",
    "say",
    "models",
    "two",
    "attributes",
    "data",
    "link",
    "next",
    "node",
    "list",
    "close",
    "doc",
    "string",
    "three",
    "quotation",
    "marks",
    "okay",
    "using",
    "node",
    "class",
    "fairly",
    "straightforward",
    "create",
    "new",
    "instance",
    "node",
    "data",
    "store",
    "way",
    "going",
    "going",
    "bring",
    "console",
    "going",
    "type",
    "like",
    "typing",
    "python",
    "followed",
    "name",
    "script",
    "wrote",
    "linked",
    "list",
    "linked",
    "underscore",
    "going",
    "pass",
    "argument",
    "python",
    "command",
    "going",
    "say",
    "dash",
    "python",
    "name",
    "script",
    "linked",
    "underscore",
    "list",
    "dot",
    "pi",
    "going",
    "run",
    "python",
    "repl",
    "read",
    "evaluate",
    "print",
    "loop",
    "console",
    "going",
    "load",
    "contents",
    "file",
    "use",
    "hit",
    "enter",
    "new",
    "instance",
    "going",
    "use",
    "node",
    "say",
    "n1",
    "equal",
    "node",
    "since",
    "defined",
    "constructor",
    "pass",
    "data",
    "say",
    "10",
    "try",
    "inspect",
    "object",
    "representation",
    "returned",
    "useful",
    "make",
    "things",
    "really",
    "hard",
    "debug",
    "code",
    "grows",
    "example",
    "type",
    "n1",
    "see",
    "valid",
    "instance",
    "helpful",
    "way",
    "printed",
    "customize",
    "adding",
    "representation",
    "object",
    "using",
    "wrapper",
    "function",
    "terminal",
    "still",
    "type",
    "exit",
    "like",
    "hit",
    "enter",
    "exit",
    "console",
    "let",
    "add",
    "room",
    "okay",
    "say",
    "def",
    "double",
    "underscore",
    "wrapper",
    "another",
    "set",
    "double",
    "underscores",
    "function",
    "takes",
    "argument",
    "self",
    "provide",
    "string",
    "representation",
    "want",
    "printed",
    "console",
    "inspect",
    "object",
    "inside",
    "inside",
    "console",
    "say",
    "return",
    "string",
    "representation",
    "inside",
    "quotes",
    "say",
    "node",
    "represents",
    "node",
    "instance",
    "data",
    "contains",
    "say",
    "percent",
    "python",
    "way",
    "substituting",
    "something",
    "string",
    "string",
    "interpolation",
    "outside",
    "string",
    "say",
    "percent",
    "saying",
    "want",
    "replace",
    "percent",
    "okay",
    "let",
    "hit",
    "save",
    "move",
    "let",
    "verify",
    "works",
    "going",
    "come",
    "type",
    "clear",
    "get",
    "rid",
    "everything",
    "hit",
    "arrow",
    "couple",
    "times",
    "get",
    "command",
    "right",
    "hit",
    "enter",
    "know",
    "every",
    "time",
    "run",
    "start",
    "know",
    "scratch",
    "n1",
    "created",
    "earlier",
    "anymore",
    "let",
    "go",
    "ahead",
    "create",
    "n1",
    "equal",
    "node",
    "10",
    "type",
    "n1",
    "hit",
    "enter",
    "much",
    "better",
    "representation",
    "see",
    "node",
    "contains",
    "data",
    "also",
    "create",
    "another",
    "one",
    "n2",
    "equal",
    "node",
    "contains",
    "data",
    "20",
    "say",
    "equal",
    "n2",
    "n1",
    "points",
    "n2",
    "say",
    "see",
    "points",
    "node",
    "node",
    "containing",
    "nodes",
    "building",
    "blocks",
    "list",
    "node",
    "object",
    "use",
    "create",
    "singly",
    "linked",
    "list",
    "going",
    "exit",
    "go",
    "back",
    "text",
    "editor",
    "create",
    "new",
    "class",
    "class",
    "linked",
    "list",
    "linked",
    "list",
    "class",
    "going",
    "define",
    "head",
    "attribute",
    "models",
    "node",
    "list",
    "going",
    "reference",
    "say",
    "head",
    "assign",
    "none",
    "initially",
    "like",
    "earlier",
    "let",
    "create",
    "constructor",
    "double",
    "underscore",
    "init",
    "double",
    "underscore",
    "takes",
    "self",
    "inside",
    "like",
    "say",
    "self",
    "dot",
    "head",
    "equal",
    "none",
    "actually",
    "get",
    "rid",
    "use",
    "constructor",
    "okay",
    "head",
    "attribute",
    "models",
    "node",
    "list",
    "reference",
    "since",
    "every",
    "node",
    "points",
    "next",
    "node",
    "find",
    "particular",
    "node",
    "go",
    "one",
    "node",
    "next",
    "process",
    "called",
    "list",
    "traversal",
    "class",
    "constructor",
    "set",
    "default",
    "value",
    "head",
    "none",
    "new",
    "lists",
    "created",
    "always",
    "empty",
    "notice",
    "explicitly",
    "declare",
    "head",
    "attribute",
    "top",
    "class",
    "definition",
    "worry",
    "oversight",
    "initializer",
    "means",
    "still",
    "created",
    "okay",
    "modeling",
    "linked",
    "list",
    "add",
    "methods",
    "make",
    "easier",
    "use",
    "data",
    "structure",
    "first",
    "really",
    "simple",
    "docstring",
    "provide",
    "information",
    "create",
    "docstring",
    "three",
    "quotation",
    "marks",
    "say",
    "singly",
    "linked",
    "list",
    "close",
    "common",
    "operation",
    "carried",
    "data",
    "structures",
    "checking",
    "whether",
    "contains",
    "data",
    "whether",
    "empty",
    "moment",
    "check",
    "list",
    "empty",
    "would",
    "need",
    "query",
    "instance",
    "variables",
    "head",
    "every",
    "time",
    "ideally",
    "would",
    "like",
    "expose",
    "inner",
    "workings",
    "data",
    "structure",
    "code",
    "uses",
    "instead",
    "let",
    "make",
    "operation",
    "explicit",
    "defining",
    "method",
    "say",
    "def",
    "empty",
    "method",
    "takes",
    "self",
    "argument",
    "say",
    "return",
    "double",
    "equal",
    "none",
    "checking",
    "see",
    "head",
    "none",
    "condition",
    "evaluates",
    "true",
    "indicates",
    "list",
    "empty",
    "end",
    "video",
    "let",
    "add",
    "one",
    "convenience",
    "method",
    "calculate",
    "size",
    "list",
    "name",
    "convenience",
    "method",
    "indicates",
    "method",
    "providing",
    "additional",
    "functionality",
    "data",
    "structure",
    "ca",
    "handle",
    "right",
    "instead",
    "making",
    "existing",
    "functionality",
    "easier",
    "use",
    "could",
    "calculate",
    "size",
    "linked",
    "list",
    "traversing",
    "every",
    "time",
    "using",
    "loop",
    "hit",
    "tail",
    "node",
    "every",
    "time",
    "hassle",
    "okay",
    "call",
    "method",
    "size",
    "always",
    "takes",
    "self",
    "unlike",
    "calling",
    "len",
    "python",
    "list",
    "confused",
    "linked",
    "list",
    "constant",
    "time",
    "operation",
    "size",
    "operation",
    "going",
    "run",
    "linear",
    "time",
    "way",
    "count",
    "many",
    "items",
    "visit",
    "node",
    "call",
    "next",
    "hit",
    "tail",
    "node",
    "start",
    "getting",
    "reference",
    "head",
    "say",
    "current",
    "equal",
    "let",
    "also",
    "define",
    "local",
    "variable",
    "named",
    "count",
    "initial",
    "value",
    "0",
    "increment",
    "every",
    "time",
    "visit",
    "node",
    "hit",
    "tail",
    "count",
    "reflect",
    "size",
    "list",
    "next",
    "define",
    "loop",
    "keep",
    "going",
    "nodes",
    "say",
    "current",
    "current",
    "writing",
    "current",
    "equal",
    "none",
    "succinct",
    "go",
    "former",
    "ladder",
    "precise",
    "go",
    "inside",
    "loop",
    "increment",
    "count",
    "value",
    "count",
    "plus",
    "equal",
    "one",
    "plus",
    "equal",
    "encountered",
    "writing",
    "count",
    "equal",
    "count",
    "plus",
    "one",
    "count",
    "zero",
    "initially",
    "zero",
    "plus",
    "one",
    "one",
    "assign",
    "back",
    "count",
    "okay",
    "count",
    "plus",
    "equal",
    "one",
    "next",
    "going",
    "assign",
    "next",
    "node",
    "list",
    "current",
    "current",
    "equal",
    "current",
    "dot",
    "next",
    "node",
    "way",
    "get",
    "tail",
    "call",
    "next",
    "node",
    "current",
    "equal",
    "none",
    "loop",
    "terminates",
    "end",
    "return",
    "count",
    "see",
    "need",
    "visit",
    "every",
    "node",
    "determine",
    "size",
    "meaning",
    "algorithm",
    "runs",
    "linear",
    "time",
    "let",
    "document",
    "docs",
    "string",
    "add",
    "size",
    "say",
    "returns",
    "number",
    "nodes",
    "list",
    "takes",
    "linear",
    "time",
    "let",
    "take",
    "break",
    "create",
    "lists",
    "check",
    "empty",
    "check",
    "size",
    "next",
    "video",
    "let",
    "start",
    "implementing",
    "common",
    "operations",
    "moment",
    "create",
    "empty",
    "list",
    "nothing",
    "else",
    "let",
    "define",
    "method",
    "add",
    "data",
    "list",
    "technically",
    "speaking",
    "three",
    "ways",
    "add",
    "data",
    "list",
    "add",
    "nodes",
    "head",
    "list",
    "means",
    "recent",
    "node",
    "created",
    "head",
    "first",
    "node",
    "created",
    "tail",
    "could",
    "flip",
    "around",
    "recent",
    "nodes",
    "tail",
    "list",
    "first",
    "node",
    "added",
    "head",
    "mentioned",
    "one",
    "advantages",
    "linked",
    "lists",
    "arrays",
    "inserting",
    "data",
    "list",
    "much",
    "efficient",
    "array",
    "true",
    "inserting",
    "head",
    "tail",
    "technically",
    "speaking",
    "insert",
    "often",
    "see",
    "method",
    "called",
    "add",
    "prepend",
    "data",
    "added",
    "head",
    "append",
    "added",
    "tail",
    "true",
    "insert",
    "insert",
    "data",
    "point",
    "list",
    "third",
    "way",
    "adding",
    "data",
    "going",
    "circle",
    "back",
    "wanted",
    "insert",
    "tail",
    "list",
    "needs",
    "reference",
    "tail",
    "node",
    "otherwise",
    "would",
    "start",
    "head",
    "walk",
    "length",
    "list",
    "traverse",
    "find",
    "tail",
    "since",
    "list",
    "keeps",
    "reference",
    "head",
    "going",
    "add",
    "new",
    "items",
    "head",
    "list",
    "add",
    "new",
    "method",
    "forgot",
    "show",
    "last",
    "video",
    "actually",
    "use",
    "code",
    "added",
    "check",
    "every",
    "time",
    "know",
    "add",
    "new",
    "code",
    "works",
    "correctly",
    "like",
    "gon",
    "na",
    "bring",
    "console",
    "gon",
    "na",
    "say",
    "python",
    "dash",
    "linked",
    "underscore",
    "list",
    "dot",
    "pi",
    "load",
    "load",
    "contents",
    "file",
    "start",
    "creating",
    "linked",
    "list",
    "l",
    "equal",
    "linked",
    "list",
    "use",
    "node",
    "n1",
    "equal",
    "node",
    "value",
    "10",
    "assign",
    "n1",
    "nodes",
    "linked",
    "lists",
    "head",
    "attribute",
    "l1",
    "dot",
    "head",
    "equal",
    "n1",
    "see",
    "size",
    "works",
    "correctly",
    "call",
    "l1",
    "dot",
    "size",
    "since",
    "method",
    "need",
    "set",
    "parentheses",
    "end",
    "enter",
    "see",
    "get",
    "back",
    "one",
    "correctly",
    "okay",
    "works",
    "let",
    "add",
    "new",
    "method",
    "going",
    "call",
    "add",
    "add",
    "going",
    "accept",
    "data",
    "add",
    "list",
    "inside",
    "node",
    "say",
    "def",
    "add",
    "every",
    "python",
    "method",
    "takes",
    "self",
    "argument",
    "want",
    "add",
    "data",
    "node",
    "going",
    "say",
    "data",
    "second",
    "argument",
    "inside",
    "method",
    "first",
    "create",
    "new",
    "node",
    "hold",
    "data",
    "new",
    "underscore",
    "node",
    "equal",
    "node",
    "data",
    "set",
    "new",
    "node",
    "head",
    "list",
    "need",
    "point",
    "new",
    "node",
    "next",
    "property",
    "whatever",
    "node",
    "currently",
    "head",
    "way",
    "set",
    "new",
    "node",
    "head",
    "list",
    "lose",
    "reference",
    "old",
    "head",
    "new",
    "underscore",
    "node",
    "dot",
    "next",
    "node",
    "equal",
    "node",
    "head",
    "correctly",
    "sets",
    "next",
    "node",
    "none",
    "set",
    "new",
    "node",
    "head",
    "node",
    "say",
    "equal",
    "new",
    "underscore",
    "node",
    "insert",
    "operation",
    "simply",
    "reassignment",
    "head",
    "next",
    "node",
    "properties",
    "constant",
    "time",
    "operation",
    "let",
    "add",
    "docs",
    "string",
    "first",
    "method",
    "adds",
    "new",
    "node",
    "containing",
    "data",
    "head",
    "list",
    "operation",
    "takes",
    "constant",
    "time",
    "best",
    "case",
    "scenario",
    "okay",
    "let",
    "test",
    "going",
    "bring",
    "console",
    "back",
    "exit",
    "current",
    "reply",
    "load",
    "contents",
    "file",
    "need",
    "create",
    "node",
    "like",
    "earlier",
    "say",
    "l",
    "equal",
    "linked",
    "list",
    "one",
    "okay",
    "let",
    "see",
    "works",
    "call",
    "size",
    "worked",
    "linked",
    "list",
    "size",
    "one",
    "go",
    "also",
    "three",
    "l",
    "dot",
    "size",
    "three",
    "go",
    "type",
    "l",
    "hit",
    "print",
    "get",
    "repel",
    "nothing",
    "useful",
    "like",
    "implement",
    "wrapper",
    "function",
    "linked",
    "list",
    "going",
    "copy",
    "paste",
    "walk",
    "okay",
    "implementation",
    "wrapper",
    "looks",
    "like",
    "linked",
    "list",
    "object",
    "grab",
    "code",
    "notes",
    "section",
    "video",
    "okay",
    "top",
    "see",
    "docs",
    "string",
    "says",
    "returns",
    "string",
    "representation",
    "list",
    "like",
    "everything",
    "need",
    "linked",
    "list",
    "need",
    "traverse",
    "going",
    "take",
    "linear",
    "time",
    "start",
    "creating",
    "empty",
    "list",
    "need",
    "distinguish",
    "python",
    "list",
    "linked",
    "list",
    "create",
    "empty",
    "list",
    "called",
    "nodes",
    "two",
    "nodes",
    "going",
    "add",
    "strings",
    "description",
    "provide",
    "description",
    "node",
    "going",
    "use",
    "description",
    "implemented",
    "node",
    "class",
    "going",
    "customize",
    "bit",
    "next",
    "start",
    "assigning",
    "current",
    "sort",
    "pointer",
    "head",
    "node",
    "long",
    "current",
    "equal",
    "none",
    "means",
    "tail",
    "going",
    "implement",
    "logic",
    "first",
    "scenario",
    "node",
    "assigned",
    "current",
    "head",
    "going",
    "append",
    "string",
    "nodes",
    "list",
    "string",
    "simply",
    "going",
    "say",
    "hey",
    "head",
    "node",
    "contains",
    "data",
    "extract",
    "using",
    "next",
    "scenario",
    "node",
    "assigned",
    "current",
    "next",
    "node",
    "none",
    "meaning",
    "tail",
    "node",
    "assign",
    "different",
    "kind",
    "string",
    "earlier",
    "except",
    "saying",
    "tail",
    "finally",
    "scenario",
    "means",
    "head",
    "tail",
    "simply",
    "print",
    "node",
    "value",
    "inside",
    "extract",
    "using",
    "every",
    "iteration",
    "loop",
    "move",
    "current",
    "forward",
    "calling",
    "reassigning",
    "end",
    "done",
    "join",
    "strings",
    "inside",
    "nodes",
    "list",
    "together",
    "using",
    "python",
    "join",
    "method",
    "say",
    "every",
    "join",
    "join",
    "two",
    "strings",
    "together",
    "make",
    "one",
    "string",
    "need",
    "put",
    "set",
    "characters",
    "right",
    "let",
    "see",
    "looks",
    "like",
    "going",
    "come",
    "exit",
    "console",
    "clear",
    "load",
    "contents",
    "file",
    "let",
    "try",
    "say",
    "l",
    "equal",
    "linked",
    "list",
    "right",
    "l",
    "dot",
    "add",
    "one",
    "l",
    "dot",
    "add",
    "two",
    "l",
    "dot",
    "add",
    "three",
    "seems",
    "enough",
    "type",
    "l",
    "hit",
    "enter",
    "get",
    "nice",
    "string",
    "representation",
    "list",
    "see",
    "add",
    "every",
    "new",
    "node",
    "head",
    "added",
    "one",
    "first",
    "one",
    "ends",
    "tail",
    "keeps",
    "getting",
    "pushed",
    "two",
    "finally",
    "three",
    "three",
    "head",
    "far",
    "implemented",
    "single",
    "method",
    "functions",
    "much",
    "like",
    "append",
    "method",
    "python",
    "list",
    "array",
    "except",
    "adds",
    "start",
    "linked",
    "list",
    "like",
    "append",
    "happens",
    "constant",
    "time",
    "next",
    "video",
    "let",
    "add",
    "ability",
    "search",
    "list",
    "search",
    "operation",
    "going",
    "define",
    "method",
    "takes",
    "value",
    "search",
    "returns",
    "either",
    "node",
    "containing",
    "value",
    "value",
    "found",
    "none",
    "right",
    "actually",
    "know",
    "make",
    "sure",
    "wrapper",
    "last",
    "function",
    "last",
    "method",
    "class",
    "add",
    "say",
    "def",
    "search",
    "self",
    "key",
    "last",
    "video",
    "implemented",
    "wrapper",
    "method",
    "provide",
    "string",
    "representation",
    "list",
    "going",
    "use",
    "similar",
    "logic",
    "implement",
    "search",
    "function",
    "start",
    "setting",
    "local",
    "variable",
    "current",
    "point",
    "head",
    "list",
    "value",
    "assigned",
    "current",
    "valid",
    "node",
    "none",
    "check",
    "data",
    "node",
    "matches",
    "key",
    "searching",
    "current",
    "say",
    "key",
    "return",
    "current",
    "match",
    "go",
    "ahead",
    "return",
    "like",
    "done",
    "assign",
    "next",
    "node",
    "list",
    "current",
    "check",
    "say",
    "else",
    "current",
    "equal",
    "current",
    "dot",
    "next",
    "node",
    "hit",
    "tail",
    "node",
    "found",
    "key",
    "current",
    "gets",
    "set",
    "none",
    "loop",
    "exits",
    "point",
    "know",
    "list",
    "contain",
    "key",
    "return",
    "none",
    "okay",
    "completes",
    "body",
    "method",
    "let",
    "add",
    "docs",
    "string",
    "document",
    "top",
    "say",
    "search",
    "first",
    "node",
    "containing",
    "data",
    "matches",
    "key",
    "important",
    "linked",
    "list",
    "contains",
    "one",
    "node",
    "value",
    "matter",
    "going",
    "return",
    "first",
    "one",
    "implementation",
    "also",
    "say",
    "returns",
    "node",
    "none",
    "found",
    "worst",
    "case",
    "scenario",
    "need",
    "check",
    "every",
    "single",
    "node",
    "list",
    "find",
    "key",
    "fail",
    "result",
    "operation",
    "runs",
    "linear",
    "time",
    "say",
    "takes",
    "n",
    "linear",
    "time",
    "far",
    "seen",
    "anything",
    "indicates",
    "data",
    "structure",
    "advantage",
    "array",
    "python",
    "list",
    "knew",
    "mentioned",
    "strength",
    "linked",
    "lists",
    "comes",
    "inserts",
    "deletes",
    "specific",
    "positions",
    "check",
    "next",
    "video",
    "always",
    "end",
    "one",
    "let",
    "make",
    "sure",
    "everything",
    "works",
    "load",
    "contents",
    "file",
    "l",
    "equal",
    "linked",
    "list",
    "say",
    "10",
    "l",
    "dot",
    "add",
    "20",
    "2",
    "matter",
    "l",
    "dot",
    "add",
    "45",
    "one",
    "metal",
    "dot",
    "add",
    "say",
    "need",
    "give",
    "value",
    "say",
    "45",
    "returns",
    "node",
    "none",
    "say",
    "n",
    "equal",
    "hit",
    "enter",
    "works",
    "n",
    "node",
    "okay",
    "weirdly",
    "n",
    "work",
    "least",
    "says",
    "node",
    "means",
    "made",
    "mistake",
    "typing",
    "code",
    "looking",
    "immediately",
    "fairly",
    "obvious",
    "return",
    "none",
    "needs",
    "outside",
    "loop",
    "okay",
    "going",
    "hit",
    "save",
    "make",
    "sure",
    "indentation",
    "means",
    "outside",
    "loop",
    "run",
    "okay",
    "l",
    "linked",
    "list",
    "10",
    "l",
    "dot",
    "add",
    "2",
    "45",
    "last",
    "one",
    "believe",
    "15",
    "able",
    "say",
    "remember",
    "assigning",
    "node",
    "variable",
    "45",
    "go",
    "get",
    "node",
    "back",
    "hit",
    "l",
    "see",
    "representation",
    "list",
    "okay",
    "next",
    "video",
    "inserts",
    "deletes",
    "specific",
    "positions",
    "insert",
    "operations",
    "linked",
    "lists",
    "quite",
    "interesting",
    "unlike",
    "arrays",
    "insert",
    "element",
    "array",
    "elements",
    "particular",
    "index",
    "need",
    "shifted",
    "linked",
    "list",
    "need",
    "change",
    "references",
    "next",
    "nodes",
    "good",
    "go",
    "since",
    "node",
    "points",
    "next",
    "one",
    "swapping",
    "references",
    "insert",
    "node",
    "point",
    "list",
    "constant",
    "time",
    "much",
    "like",
    "binary",
    "search",
    "though",
    "catch",
    "find",
    "node",
    "position",
    "want",
    "insert",
    "need",
    "traverse",
    "list",
    "get",
    "point",
    "implemented",
    "search",
    "algorithm",
    "linked",
    "list",
    "type",
    "know",
    "runs",
    "linear",
    "time",
    "actually",
    "inserting",
    "fast",
    "finding",
    "position",
    "list",
    "want",
    "insert",
    "mentioned",
    "caveats",
    "inserting",
    "anyway",
    "let",
    "see",
    "looks",
    "like",
    "code",
    "define",
    "method",
    "named",
    "insert",
    "takes",
    "data",
    "insert",
    "along",
    "index",
    "position",
    "search",
    "right",
    "say",
    "def",
    "insert",
    "takes",
    "data",
    "insert",
    "position",
    "insert",
    "may",
    "thinking",
    "wait",
    "minute",
    "linked",
    "lists",
    "index",
    "positions",
    "right",
    "correct",
    "mimic",
    "behavior",
    "counting",
    "number",
    "times",
    "access",
    "next",
    "node",
    "index",
    "value",
    "passed",
    "argument",
    "0",
    "means",
    "want",
    "insert",
    "new",
    "node",
    "head",
    "list",
    "effectively",
    "behavior",
    "calling",
    "add",
    "means",
    "logic",
    "need",
    "repeat",
    "call",
    "add",
    "method",
    "wrote",
    "earlier",
    "say",
    "index",
    "index",
    "equals",
    "0",
    "index",
    "0",
    "self",
    "dot",
    "add",
    "data",
    "index",
    "greater",
    "0",
    "need",
    "traverse",
    "list",
    "find",
    "current",
    "node",
    "index",
    "index",
    "greater",
    "zero",
    "need",
    "create",
    "new",
    "node",
    "containing",
    "data",
    "want",
    "insert",
    "say",
    "new",
    "equal",
    "node",
    "data",
    "going",
    "assign",
    "index",
    "argument",
    "passed",
    "function",
    "local",
    "variable",
    "named",
    "position",
    "head",
    "list",
    "variable",
    "named",
    "current",
    "position",
    "equal",
    "index",
    "current",
    "equal",
    "every",
    "time",
    "call",
    "meaning",
    "moving",
    "next",
    "node",
    "list",
    "decrease",
    "value",
    "position",
    "position",
    "zero",
    "arrived",
    "node",
    "currently",
    "position",
    "want",
    "insert",
    "reality",
    "though",
    "want",
    "decrease",
    "way",
    "zero",
    "imagine",
    "list",
    "five",
    "nodes",
    "want",
    "insert",
    "node",
    "position",
    "insert",
    "node",
    "position",
    "3",
    "need",
    "modify",
    "nodes",
    "positions",
    "2",
    "node",
    "2",
    "next",
    "node",
    "attribute",
    "going",
    "point",
    "new",
    "node",
    "new",
    "node",
    "next",
    "node",
    "attribute",
    "point",
    "node",
    "way",
    "insert",
    "constant",
    "time",
    "operation",
    "need",
    "shift",
    "every",
    "single",
    "element",
    "modify",
    "next",
    "node",
    "references",
    "doubly",
    "linked",
    "list",
    "use",
    "node",
    "3",
    "carry",
    "operations",
    "node",
    "3",
    "doubly",
    "linked",
    "list",
    "would",
    "reference",
    "node",
    "2",
    "use",
    "reference",
    "modify",
    "unnecessary",
    "links",
    "singly",
    "linked",
    "list",
    "though",
    "kept",
    "decreasing",
    "position",
    "0",
    "arrive",
    "node",
    "set",
    "new",
    "node",
    "next",
    "node",
    "property",
    "point",
    "node",
    "3",
    "way",
    "getting",
    "reference",
    "node",
    "2",
    "also",
    "need",
    "reason",
    "easier",
    "decrease",
    "position",
    "1",
    "equals",
    "1",
    "stop",
    "node",
    "say",
    "position",
    "greater",
    "one",
    "position",
    "greater",
    "one",
    "keep",
    "calling",
    "next",
    "node",
    "reassigning",
    "current",
    "node",
    "current",
    "equal",
    "node",
    "time",
    "decrement",
    "position",
    "position",
    "equal",
    "position",
    "minus",
    "one",
    "also",
    "succinctly",
    "write",
    "minus",
    "equal",
    "one",
    "way",
    "position",
    "equals",
    "one",
    "loop",
    "exits",
    "current",
    "refer",
    "node",
    "position",
    "insert",
    "point",
    "outside",
    "loop",
    "say",
    "previous",
    "equal",
    "current",
    "next",
    "equal",
    "current",
    "dot",
    "next",
    "node",
    "make",
    "things",
    "clear",
    "done",
    "name",
    "node",
    "new",
    "one",
    "previous",
    "node",
    "new",
    "one",
    "next",
    "left",
    "insert",
    "new",
    "node",
    "previous",
    "next",
    "say",
    "previous",
    "dot",
    "next",
    "node",
    "equal",
    "new",
    "new",
    "dot",
    "next",
    "node",
    "equal",
    "next",
    "seems",
    "like",
    "issue",
    "variable",
    "naming",
    "probably",
    "conflicting",
    "globally",
    "named",
    "next",
    "variable",
    "actually",
    "go",
    "ahead",
    "call",
    "next",
    "node",
    "previous",
    "node",
    "mess",
    "things",
    "previous",
    "node",
    "dot",
    "next",
    "node",
    "obviously",
    "attribute",
    "node",
    "local",
    "variable",
    "let",
    "document",
    "method",
    "top",
    "add",
    "docs",
    "string",
    "say",
    "inserts",
    "new",
    "node",
    "containing",
    "data",
    "index",
    "position",
    "insertion",
    "takes",
    "constant",
    "time",
    "finding",
    "node",
    "insertion",
    "point",
    "takes",
    "linear",
    "time",
    "let",
    "add",
    "next",
    "line",
    "go",
    "say",
    "therefore",
    "takes",
    "overall",
    "linear",
    "time",
    "even",
    "though",
    "easily",
    "insert",
    "new",
    "node",
    "without",
    "shift",
    "rest",
    "ultimately",
    "adding",
    "either",
    "head",
    "tail",
    "reference",
    "much",
    "efficient",
    "one",
    "operation",
    "add",
    "linked",
    "list",
    "make",
    "robust",
    "data",
    "structure",
    "much",
    "like",
    "inserts",
    "removing",
    "node",
    "actually",
    "quite",
    "fast",
    "occurs",
    "constant",
    "time",
    "actually",
    "get",
    "node",
    "want",
    "remove",
    "modify",
    "next",
    "connections",
    "need",
    "traverse",
    "entire",
    "list",
    "worst",
    "case",
    "worst",
    "case",
    "takes",
    "linear",
    "time",
    "let",
    "add",
    "operation",
    "data",
    "structure",
    "two",
    "ways",
    "define",
    "remove",
    "method",
    "one",
    "provide",
    "key",
    "remove",
    "argument",
    "one",
    "provide",
    "index",
    "former",
    "key",
    "refers",
    "data",
    "node",
    "stores",
    "order",
    "remove",
    "node",
    "would",
    "first",
    "need",
    "search",
    "data",
    "matches",
    "key",
    "going",
    "implement",
    "first",
    "method",
    "call",
    "remove",
    "leave",
    "get",
    "practice",
    "implement",
    "remove",
    "index",
    "method",
    "complete",
    "data",
    "structure",
    "add",
    "insert",
    "method",
    "right",
    "remove",
    "going",
    "accept",
    "key",
    "need",
    "search",
    "remove",
    "node",
    "earlier",
    "defined",
    "search",
    "method",
    "found",
    "node",
    "containing",
    "data",
    "matches",
    "key",
    "ca",
    "use",
    "method",
    "implementation",
    "remove",
    "remove",
    "node",
    "much",
    "like",
    "insert",
    "operation",
    "need",
    "modify",
    "next",
    "node",
    "references",
    "node",
    "match",
    "needs",
    "point",
    "node",
    "match",
    "use",
    "search",
    "method",
    "defined",
    "earlier",
    "get",
    "node",
    "want",
    "remove",
    "return",
    "value",
    "singly",
    "linked",
    "list",
    "ca",
    "obtain",
    "reference",
    "previous",
    "node",
    "like",
    "said",
    "earlier",
    "doubly",
    "linked",
    "list",
    "could",
    "use",
    "search",
    "method",
    "since",
    "would",
    "reference",
    "previous",
    "node",
    "start",
    "setting",
    "local",
    "variable",
    "named",
    "current",
    "point",
    "head",
    "let",
    "also",
    "define",
    "variable",
    "named",
    "previous",
    "set",
    "none",
    "keep",
    "track",
    "previous",
    "node",
    "traverse",
    "list",
    "finally",
    "let",
    "declare",
    "variable",
    "named",
    "found",
    "set",
    "false",
    "found",
    "going",
    "serve",
    "stopping",
    "condition",
    "loop",
    "define",
    "use",
    "loop",
    "keep",
    "traversing",
    "linked",
    "list",
    "long",
    "found",
    "false",
    "meaning",
    "found",
    "key",
    "looking",
    "found",
    "set",
    "found",
    "true",
    "loop",
    "terminates",
    "let",
    "set",
    "loop",
    "say",
    "current",
    "found",
    "defining",
    "loop",
    "contains",
    "two",
    "conditions",
    "first",
    "tell",
    "loop",
    "keep",
    "iterating",
    "long",
    "current",
    "equal",
    "none",
    "current",
    "equals",
    "none",
    "means",
    "gone",
    "past",
    "tail",
    "node",
    "key",
    "exist",
    "second",
    "condition",
    "asks",
    "loop",
    "keep",
    "evaluating",
    "long",
    "found",
    "equals",
    "true",
    "might",
    "tricky",
    "involves",
    "negation",
    "right",
    "found",
    "set",
    "false",
    "found",
    "false",
    "equals",
    "true",
    "operator",
    "flips",
    "value",
    "find",
    "key",
    "set",
    "found",
    "true",
    "true",
    "found",
    "equal",
    "false",
    "loop",
    "stop",
    "end",
    "loop",
    "means",
    "conditions",
    "current",
    "valid",
    "node",
    "found",
    "equalling",
    "true",
    "true",
    "either",
    "one",
    "evaluates",
    "false",
    "loop",
    "terminate",
    "inside",
    "loop",
    "three",
    "situations",
    "run",
    "first",
    "key",
    "matches",
    "current",
    "node",
    "data",
    "current",
    "still",
    "head",
    "list",
    "special",
    "case",
    "head",
    "previous",
    "node",
    "node",
    "referenced",
    "list",
    "let",
    "handle",
    "case",
    "say",
    "double",
    "equals",
    "key",
    "current",
    "write",
    "current",
    "equal",
    "current",
    "hit",
    "case",
    "indicate",
    "found",
    "key",
    "setting",
    "found",
    "true",
    "means",
    "next",
    "pass",
    "going",
    "evaluate",
    "false",
    "true",
    "false",
    "loop",
    "terminates",
    "want",
    "remove",
    "current",
    "node",
    "since",
    "head",
    "node",
    "need",
    "point",
    "head",
    "second",
    "node",
    "list",
    "get",
    "referencing",
    "next",
    "node",
    "attribute",
    "current",
    "equal",
    "nothing",
    "pointing",
    "first",
    "node",
    "automatically",
    "removed",
    "next",
    "scenario",
    "key",
    "matches",
    "data",
    "node",
    "node",
    "head",
    "say",
    "else",
    "current",
    "dot",
    "data",
    "equal",
    "key",
    "current",
    "node",
    "contains",
    "key",
    "looking",
    "need",
    "remove",
    "remove",
    "current",
    "node",
    "need",
    "go",
    "previous",
    "node",
    "modify",
    "next",
    "node",
    "reference",
    "point",
    "node",
    "current",
    "first",
    "set",
    "found",
    "true",
    "switch",
    "references",
    "equal",
    "far",
    "written",
    "code",
    "keep",
    "track",
    "previous",
    "node",
    "else",
    "case",
    "hit",
    "else",
    "case",
    "means",
    "current",
    "node",
    "evaluating",
    "contain",
    "data",
    "matches",
    "key",
    "case",
    "make",
    "previous",
    "point",
    "current",
    "node",
    "set",
    "current",
    "next",
    "node",
    "previous",
    "equal",
    "current",
    "current",
    "equal",
    "implementation",
    "remove",
    "anything",
    "moment",
    "node",
    "removing",
    "common",
    "remove",
    "operations",
    "return",
    "value",
    "removed",
    "bottom",
    "outside",
    "loop",
    "let",
    "return",
    "current",
    "minimal",
    "implementation",
    "linked",
    "list",
    "first",
    "custom",
    "data",
    "structure",
    "cool",
    "quite",
    "bit",
    "improve",
    "data",
    "structure",
    "particularly",
    "making",
    "easy",
    "use",
    "good",
    "place",
    "stop",
    "move",
    "next",
    "topic",
    "let",
    "document",
    "method",
    "top",
    "another",
    "docs",
    "string",
    "say",
    "removes",
    "node",
    "containing",
    "data",
    "matches",
    "key",
    "also",
    "returns",
    "node",
    "none",
    "key",
    "exist",
    "finally",
    "takes",
    "linear",
    "time",
    "worst",
    "case",
    "scenario",
    "need",
    "search",
    "entire",
    "list",
    "like",
    "get",
    "additional",
    "practice",
    "implementing",
    "functionality",
    "linked",
    "lists",
    "two",
    "methods",
    "work",
    "remove",
    "index",
    "node",
    "index",
    "allow",
    "easily",
    "delete",
    "read",
    "values",
    "list",
    "given",
    "index",
    "linked",
    "list",
    "let",
    "talk",
    "use",
    "honest",
    "answer",
    "lot",
    "places",
    "linked",
    "lists",
    "really",
    "useful",
    "structures",
    "build",
    "learning",
    "purposes",
    "relatively",
    "simple",
    "good",
    "place",
    "start",
    "introduce",
    "kinds",
    "operations",
    "need",
    "implement",
    "various",
    "data",
    "structures",
    "quite",
    "rare",
    "however",
    "need",
    "implement",
    "linked",
    "list",
    "typically",
    "much",
    "better",
    "mean",
    "much",
    "efficient",
    "data",
    "structures",
    "use",
    "addition",
    "many",
    "languages",
    "like",
    "java",
    "example",
    "provide",
    "implementation",
    "linked",
    "list",
    "already",
    "custom",
    "data",
    "structure",
    "let",
    "something",
    "let",
    "combine",
    "knowledge",
    "look",
    "sorting",
    "algorithm",
    "implemented",
    "across",
    "two",
    "different",
    "data",
    "structures",
    "music",
    "seen",
    "two",
    "different",
    "data",
    "structures",
    "let",
    "circle",
    "back",
    "apply",
    "know",
    "algorithms",
    "new",
    "concepts",
    "one",
    "first",
    "algorithms",
    "learned",
    "binary",
    "search",
    "learned",
    "binary",
    "search",
    "one",
    "precondition",
    "data",
    "collection",
    "needs",
    "sorted",
    "next",
    "videos",
    "let",
    "implement",
    "merge",
    "sort",
    "algorithm",
    "one",
    "many",
    "sorting",
    "algorithms",
    "arrays",
    "python",
    "lists",
    "singly",
    "linked",
    "list",
    "created",
    "way",
    "learn",
    "new",
    "sorting",
    "algorithm",
    "real",
    "world",
    "use",
    "cases",
    "see",
    "single",
    "algorithm",
    "implemented",
    "different",
    "data",
    "structures",
    "get",
    "code",
    "let",
    "take",
    "look",
    "merge",
    "sort",
    "works",
    "conceptually",
    "use",
    "array",
    "work",
    "start",
    "unsorted",
    "array",
    "integers",
    "goal",
    "end",
    "array",
    "sorted",
    "ascending",
    "order",
    "merge",
    "sort",
    "works",
    "like",
    "binary",
    "sort",
    "splitting",
    "problem",
    "sub",
    "problems",
    "takes",
    "process",
    "one",
    "step",
    "first",
    "pass",
    "going",
    "split",
    "array",
    "two",
    "smaller",
    "arrays",
    "binary",
    "search",
    "one",
    "subarrays",
    "would",
    "discarded",
    "happens",
    "second",
    "pass",
    "going",
    "split",
    "subarrays",
    "smaller",
    "evenly",
    "sized",
    "arrays",
    "going",
    "keep",
    "single",
    "element",
    "arrays",
    "merge",
    "sort",
    "algorithm",
    "works",
    "backwards",
    "repeatedly",
    "merging",
    "single",
    "element",
    "arrays",
    "sorting",
    "time",
    "since",
    "start",
    "bottom",
    "merging",
    "single",
    "element",
    "arrays",
    "need",
    "make",
    "single",
    "comparison",
    "sort",
    "resulting",
    "merge",
    "array",
    "starting",
    "smaller",
    "arrays",
    "sorted",
    "grow",
    "merge",
    "sort",
    "execute",
    "fewer",
    "sort",
    "operations",
    "sorted",
    "entire",
    "array",
    "solving",
    "problem",
    "like",
    "recursively",
    "breaking",
    "problem",
    "subparts",
    "easily",
    "solved",
    "algorithmic",
    "strategy",
    "known",
    "divide",
    "conquer",
    "instead",
    "talking",
    "abstract",
    "let",
    "dive",
    "code",
    "way",
    "analyze",
    "runtime",
    "implement",
    "first",
    "implementation",
    "merge",
    "sort",
    "going",
    "use",
    "array",
    "python",
    "list",
    "implementation",
    "wo",
    "different",
    "conceptually",
    "linked",
    "list",
    "write",
    "code",
    "list",
    "traversal",
    "nodes",
    "arranged",
    "concepts",
    "squared",
    "away",
    "come",
    "back",
    "let",
    "add",
    "new",
    "file",
    "call",
    "merge",
    "underscore",
    "sort",
    "dot",
    "pi",
    "file",
    "let",
    "create",
    "new",
    "function",
    "named",
    "merge",
    "sort",
    "takes",
    "list",
    "remember",
    "say",
    "list",
    "unless",
    "specify",
    "linked",
    "list",
    "mean",
    "python",
    "list",
    "equivalent",
    "array",
    "say",
    "def",
    "merge",
    "underscore",
    "sort",
    "takes",
    "list",
    "introduction",
    "algorithms",
    "course",
    "started",
    "study",
    "algorithm",
    "defining",
    "specific",
    "steps",
    "comprise",
    "algorithm",
    "let",
    "write",
    "docstring",
    "steps",
    "algorithm",
    "refer",
    "right",
    "code",
    "algorithm",
    "going",
    "sort",
    "given",
    "list",
    "ascending",
    "order",
    "start",
    "putting",
    "simple",
    "definition",
    "sorts",
    "list",
    "ascending",
    "order",
    "many",
    "variations",
    "merge",
    "sort",
    "one",
    "going",
    "implement",
    "create",
    "return",
    "new",
    "sorted",
    "list",
    "implementations",
    "sort",
    "list",
    "pass",
    "less",
    "typical",
    "operation",
    "known",
    "sort",
    "place",
    "think",
    "returning",
    "new",
    "list",
    "makes",
    "easier",
    "understand",
    "code",
    "choices",
    "implications",
    "though",
    "talk",
    "write",
    "code",
    "next",
    "bit",
    "docs",
    "string",
    "let",
    "write",
    "output",
    "algorithm",
    "returns",
    "new",
    "sorted",
    "list",
    "merge",
    "sort",
    "three",
    "main",
    "steps",
    "first",
    "divide",
    "step",
    "find",
    "midpoint",
    "list",
    "say",
    "divide",
    "find",
    "mid",
    "point",
    "list",
    "divide",
    "second",
    "step",
    "conquer",
    "step",
    "sort",
    "created",
    "divide",
    "step",
    "say",
    "recursively",
    "sort",
    "created",
    "previous",
    "step",
    "finally",
    "combine",
    "combined",
    "step",
    "merge",
    "recursively",
    "sorted",
    "back",
    "single",
    "list",
    "merge",
    "sorted",
    "created",
    "previous",
    "step",
    "learned",
    "algorithms",
    "learned",
    "recursive",
    "function",
    "basic",
    "pattern",
    "first",
    "start",
    "base",
    "case",
    "includes",
    "stopping",
    "condition",
    "logic",
    "breaks",
    "problem",
    "recursively",
    "calls",
    "stopping",
    "condition",
    "end",
    "goal",
    "sorted",
    "array",
    "come",
    "stopping",
    "condition",
    "base",
    "case",
    "need",
    "come",
    "simplest",
    "condition",
    "satisfies",
    "end",
    "result",
    "two",
    "possible",
    "values",
    "fit",
    "single",
    "element",
    "list",
    "empty",
    "list",
    "situations",
    "work",
    "give",
    "merge",
    "sort",
    "function",
    "empty",
    "list",
    "list",
    "one",
    "element",
    "technically",
    "already",
    "sorted",
    "call",
    "naively",
    "sorting",
    "let",
    "add",
    "stopping",
    "condition",
    "say",
    "len",
    "list",
    "length",
    "list",
    "less",
    "equal",
    "one",
    "return",
    "list",
    "okay",
    "stopping",
    "condition",
    "stopping",
    "condition",
    "proceed",
    "list",
    "steps",
    "first",
    "need",
    "divide",
    "list",
    "sub",
    "lists",
    "make",
    "functions",
    "easier",
    "understand",
    "going",
    "put",
    "logic",
    "couple",
    "different",
    "functions",
    "instead",
    "one",
    "large",
    "one",
    "say",
    "left",
    "half",
    "comma",
    "right",
    "half",
    "equal",
    "split",
    "list",
    "calling",
    "split",
    "function",
    "splits",
    "list",
    "pass",
    "returns",
    "two",
    "lists",
    "split",
    "midpoint",
    "returning",
    "two",
    "lists",
    "capture",
    "two",
    "variables",
    "know",
    "split",
    "function",
    "something",
    "comes",
    "built",
    "python",
    "global",
    "function",
    "write",
    "next",
    "conquer",
    "step",
    "sort",
    "return",
    "new",
    "sorted",
    "say",
    "left",
    "equal",
    "merge",
    "sort",
    "left",
    "half",
    "right",
    "equal",
    "merge",
    "sort",
    "right",
    "half",
    "recursive",
    "portion",
    "function",
    "calling",
    "merge",
    "sort",
    "divided",
    "sub",
    "list",
    "divide",
    "list",
    "two",
    "call",
    "merge",
    "sort",
    "splits",
    "sublist",
    "two",
    "next",
    "pass",
    "merge",
    "sort",
    "going",
    "called",
    "reach",
    "stopping",
    "condition",
    "single",
    "element",
    "lists",
    "empty",
    "lists",
    "subdivided",
    "divide",
    "end",
    "left",
    "right",
    "half",
    "start",
    "merging",
    "backwards",
    "say",
    "return",
    "merge",
    "left",
    "right",
    "brings",
    "us",
    "combined",
    "step",
    "two",
    "sorted",
    "combined",
    "return",
    "obviously",
    "none",
    "functions",
    "merge",
    "merge",
    "sort",
    "well",
    "merge",
    "sort",
    "written",
    "merge",
    "split",
    "written",
    "going",
    "run",
    "raise",
    "error",
    "next",
    "video",
    "let",
    "implement",
    "split",
    "operation",
    "first",
    "bit",
    "logic",
    "going",
    "write",
    "divide",
    "step",
    "algorithm",
    "step",
    "fairly",
    "straightforward",
    "requires",
    "lines",
    "code",
    "essential",
    "get",
    "sorting",
    "process",
    "going",
    "right",
    "saw",
    "earlier",
    "going",
    "call",
    "function",
    "divide",
    "step",
    "split",
    "say",
    "def",
    "split",
    "split",
    "going",
    "take",
    "argument",
    "list",
    "split",
    "let",
    "document",
    "function",
    "works",
    "say",
    "divide",
    "unsorted",
    "list",
    "midpoint",
    "sub",
    "lists",
    "always",
    "good",
    "say",
    "returning",
    "well",
    "say",
    "returns",
    "left",
    "right",
    "right",
    "first",
    "step",
    "determine",
    "midpoint",
    "list",
    "array",
    "going",
    "use",
    "floor",
    "division",
    "operator",
    "floor",
    "division",
    "carries",
    "division",
    "operation",
    "get",
    "value",
    "like",
    "back",
    "gets",
    "rounded",
    "two",
    "define",
    "midpoint",
    "length",
    "list",
    "divided",
    "two",
    "rounded",
    "lan",
    "list",
    "using",
    "two",
    "forward",
    "slashes",
    "floor",
    "division",
    "operator",
    "put",
    "number",
    "two",
    "okay",
    "midpoint",
    "use",
    "slicing",
    "notation",
    "python",
    "extract",
    "portions",
    "list",
    "want",
    "return",
    "instance",
    "define",
    "left",
    "left",
    "goes",
    "way",
    "start",
    "list",
    "way",
    "midpoint",
    "without",
    "including",
    "midpoint",
    "using",
    "slicing",
    "syntax",
    "like",
    "using",
    "know",
    "subscript",
    "notation",
    "access",
    "value",
    "list",
    "instead",
    "give",
    "two",
    "index",
    "values",
    "start",
    "stop",
    "include",
    "start",
    "value",
    "done",
    "python",
    "interprets",
    "starting",
    "zeroth",
    "index",
    "start",
    "list",
    "similarly",
    "define",
    "right",
    "music",
    "values",
    "right",
    "midpoint",
    "starting",
    "midpoint",
    "going",
    "way",
    "end",
    "list",
    "couple",
    "things",
    "note",
    "said",
    "earlier",
    "include",
    "starting",
    "index",
    "interprets",
    "start",
    "beginning",
    "list",
    "index",
    "give",
    "stopping",
    "condition",
    "value",
    "included",
    "slice",
    "starting",
    "beginning",
    "list",
    "go",
    "way",
    "midpoint",
    "including",
    "midpoint",
    "right",
    "starts",
    "midpoint",
    "includes",
    "value",
    "goes",
    "way",
    "end",
    "list",
    "two",
    "return",
    "return",
    "left",
    "right",
    "notice",
    "returning",
    "two",
    "values",
    "merge",
    "sort",
    "function",
    "call",
    "split",
    "function",
    "declaring",
    "two",
    "variables",
    "left",
    "half",
    "right",
    "half",
    "assign",
    "assign",
    "two",
    "sub",
    "lists",
    "okay",
    "split",
    "function",
    "next",
    "video",
    "let",
    "implement",
    "crucial",
    "portion",
    "merge",
    "sort",
    "logic",
    "run",
    "split",
    "function",
    "recursively",
    "array",
    "end",
    "several",
    "single",
    "member",
    "empty",
    "arrays",
    "point",
    "need",
    "merge",
    "back",
    "sort",
    "process",
    "merge",
    "function",
    "merge",
    "function",
    "going",
    "take",
    "two",
    "arrays",
    "lists",
    "arguments",
    "match",
    "naming",
    "conventions",
    "used",
    "split",
    "function",
    "call",
    "left",
    "right",
    "well",
    "say",
    "def",
    "merge",
    "takes",
    "left",
    "right",
    "list",
    "like",
    "let",
    "add",
    "documentation",
    "function",
    "function",
    "merges",
    "lists",
    "arrays",
    "sorting",
    "process",
    "returns",
    "new",
    "merged",
    "list",
    "since",
    "function",
    "going",
    "return",
    "new",
    "list",
    "let",
    "start",
    "creating",
    "one",
    "process",
    "merging",
    "need",
    "sort",
    "values",
    "lists",
    "sort",
    "need",
    "compare",
    "values",
    "array",
    "list",
    "next",
    "let",
    "create",
    "two",
    "local",
    "variables",
    "keep",
    "track",
    "index",
    "values",
    "using",
    "list",
    "convention",
    "j",
    "stick",
    "equals",
    "0",
    "j",
    "equals",
    "inspect",
    "value",
    "either",
    "list",
    "use",
    "variables",
    "keep",
    "track",
    "indexes",
    "values",
    "use",
    "keep",
    "track",
    "indexes",
    "left",
    "list",
    "j",
    "indexes",
    "right",
    "list",
    "merging",
    "want",
    "keep",
    "sorting",
    "values",
    "worked",
    "lists",
    "loop",
    "let",
    "set",
    "two",
    "conditions",
    "operator",
    "say",
    "let",
    "stay",
    "less",
    "less",
    "length",
    "left",
    "list",
    "j",
    "less",
    "length",
    "right",
    "list",
    "keep",
    "executing",
    "loop",
    "ensuring",
    "long",
    "less",
    "length",
    "left",
    "list",
    "important",
    "j",
    "less",
    "length",
    "right",
    "list",
    "going",
    "keep",
    "executing",
    "code",
    "j",
    "set",
    "zero",
    "initially",
    "means",
    "first",
    "comparison",
    "operation",
    "first",
    "element",
    "list",
    "respectively",
    "say",
    "left",
    "zero",
    "going",
    "get",
    "first",
    "value",
    "left",
    "list",
    "less",
    "right",
    "j",
    "j",
    "zero",
    "going",
    "get",
    "first",
    "value",
    "right",
    "list",
    "value",
    "index",
    "left",
    "list",
    "less",
    "value",
    "index",
    "j",
    "right",
    "list",
    "well",
    "means",
    "value",
    "compared",
    "left",
    "less",
    "value",
    "right",
    "placed",
    "position",
    "0",
    "new",
    "array",
    "l",
    "created",
    "earlier",
    "say",
    "l",
    "dot",
    "append",
    "left",
    "since",
    "read",
    "done",
    "something",
    "value",
    "position",
    "let",
    "increment",
    "value",
    "move",
    "forward",
    "evaluate",
    "next",
    "item",
    "left",
    "list",
    "plus",
    "one",
    "say",
    "plus",
    "equal",
    "one",
    "okay",
    "next",
    "else",
    "statement",
    "say",
    "value",
    "index",
    "write",
    "actual",
    "logic",
    "implied",
    "saying",
    "left",
    "value",
    "left",
    "less",
    "value",
    "right",
    "else",
    "clause",
    "value",
    "equal",
    "greater",
    "written",
    "condition",
    "implied",
    "saying",
    "value",
    "left",
    "less",
    "value",
    "right",
    "else",
    "clause",
    "going",
    "mean",
    "value",
    "left",
    "either",
    "greater",
    "equal",
    "value",
    "right",
    "hit",
    "else",
    "clause",
    "value",
    "index",
    "left",
    "list",
    "greater",
    "place",
    "value",
    "index",
    "j",
    "right",
    "list",
    "start",
    "new",
    "one",
    "list",
    "l",
    "similarly",
    "increment",
    "j",
    "say",
    "l",
    "dot",
    "append",
    "right",
    "j",
    "j",
    "equal",
    "j",
    "plus",
    "one",
    "necessarily",
    "mean",
    "one",
    "step",
    "completely",
    "sorted",
    "array",
    "remember",
    "start",
    "single",
    "element",
    "arrays",
    "combine",
    "merge",
    "step",
    "eventually",
    "sort",
    "values",
    "one",
    "time",
    "time",
    "entire",
    "process",
    "done",
    "values",
    "correctly",
    "sorted",
    "need",
    "merge",
    "step",
    "however",
    "two",
    "situations",
    "run",
    "one",
    "left",
    "array",
    "larger",
    "right",
    "vice",
    "versa",
    "occur",
    "array",
    "containing",
    "odd",
    "number",
    "elements",
    "needs",
    "split",
    "split",
    "three",
    "element",
    "array",
    "list",
    "well",
    "left",
    "two",
    "elements",
    "right",
    "one",
    "way",
    "around",
    "either",
    "case",
    "loop",
    "uses",
    "condition",
    "variables",
    "used",
    "store",
    "indexes",
    "need",
    "less",
    "length",
    "lists",
    "left",
    "list",
    "shorter",
    "right",
    "first",
    "condition",
    "returns",
    "false",
    "entire",
    "loop",
    "returns",
    "false",
    "condition",
    "means",
    "event",
    "loop",
    "terminates",
    "values",
    "right",
    "list",
    "moved",
    "new",
    "combined",
    "list",
    "account",
    "let",
    "add",
    "two",
    "loops",
    "first",
    "loop",
    "going",
    "account",
    "situation",
    "right",
    "list",
    "shorter",
    "left",
    "previous",
    "loop",
    "terminated",
    "reached",
    "end",
    "right",
    "list",
    "first",
    "case",
    "going",
    "simply",
    "add",
    "remaining",
    "elements",
    "left",
    "new",
    "list",
    "going",
    "compare",
    "elements",
    "going",
    "assume",
    "within",
    "list",
    "elements",
    "already",
    "sorted",
    "less",
    "length",
    "left",
    "logic",
    "l",
    "dot",
    "append",
    "left",
    "plus",
    "equal",
    "one",
    "loop",
    "going",
    "similar",
    "condition",
    "keep",
    "loop",
    "going",
    "last",
    "index",
    "inside",
    "body",
    "incrementing",
    "index",
    "every",
    "iteration",
    "loop",
    "final",
    "loop",
    "accounts",
    "opposite",
    "scenario",
    "left",
    "shorter",
    "right",
    "difference",
    "going",
    "use",
    "variable",
    "j",
    "along",
    "right",
    "list",
    "say",
    "j",
    "less",
    "length",
    "right",
    "l",
    "dot",
    "append",
    "right",
    "j",
    "j",
    "plus",
    "equal",
    "one",
    "okay",
    "let",
    "stop",
    "next",
    "video",
    "let",
    "test",
    "merge",
    "sort",
    "make",
    "sure",
    "code",
    "running",
    "correctly",
    "everything",
    "written",
    "well",
    "wrap",
    "stage",
    "documenting",
    "code",
    "evaluating",
    "run",
    "time",
    "algorithm",
    "last",
    "video",
    "completed",
    "implementation",
    "merge",
    "sort",
    "algorithm",
    "test",
    "way",
    "let",
    "define",
    "new",
    "list",
    "bottom",
    "contains",
    "several",
    "numbers",
    "put",
    "whatever",
    "want",
    "make",
    "sure",
    "numbers",
    "order",
    "call",
    "mine",
    "list",
    "say",
    "54",
    "26",
    "62",
    "matter",
    "93",
    "17",
    "77",
    "31",
    "add",
    "enough",
    "make",
    "sorted",
    "okay",
    "next",
    "going",
    "call",
    "merge",
    "sort",
    "algorithm",
    "pass",
    "list",
    "let",
    "assign",
    "variables",
    "say",
    "l",
    "equal",
    "merge",
    "underscore",
    "sort",
    "list",
    "works",
    "correctly",
    "able",
    "print",
    "list",
    "see",
    "looks",
    "like",
    "going",
    "hit",
    "save",
    "console",
    "tap",
    "python",
    "merge",
    "sort",
    "dot",
    "pi",
    "hit",
    "enter",
    "actually",
    "noticed",
    "made",
    "error",
    "last",
    "video",
    "hit",
    "enter",
    "anyway",
    "see",
    "error",
    "pop",
    "okay",
    "forgot",
    "pretty",
    "crucial",
    "part",
    "algorithm",
    "merge",
    "function",
    "forgot",
    "return",
    "list",
    "containing",
    "sorted",
    "numbers",
    "carrying",
    "logic",
    "bottom",
    "say",
    "return",
    "l",
    "right",
    "save",
    "clear",
    "try",
    "one",
    "time",
    "go",
    "see",
    "sorted",
    "list",
    "printed",
    "write",
    "robust",
    "function",
    "test",
    "bigger",
    "arrays",
    "visually",
    "evaluating",
    "printed",
    "list",
    "wo",
    "always",
    "feasible",
    "bring",
    "back",
    "let",
    "get",
    "rid",
    "call",
    "function",
    "verify",
    "sorted",
    "take",
    "list",
    "first",
    "going",
    "check",
    "inside",
    "body",
    "function",
    "check",
    "length",
    "list",
    "list",
    "single",
    "element",
    "list",
    "empty",
    "list",
    "need",
    "unnecessary",
    "work",
    "remember",
    "naively",
    "sorted",
    "say",
    "n",
    "equals",
    "0",
    "n",
    "equals",
    "1",
    "return",
    "true",
    "verified",
    "sorted",
    "conclude",
    "function",
    "going",
    "write",
    "one",
    "line",
    "code",
    "actually",
    "quite",
    "bit",
    "work",
    "first",
    "say",
    "return",
    "list",
    "zero",
    "take",
    "first",
    "element",
    "list",
    "compare",
    "see",
    "less",
    "second",
    "element",
    "list",
    "okay",
    "first",
    "check",
    "first",
    "element",
    "list",
    "less",
    "second",
    "element",
    "list",
    "returns",
    "either",
    "true",
    "false",
    "return",
    "directly",
    "sufficient",
    "could",
    "trick",
    "verify",
    "function",
    "sorting",
    "first",
    "two",
    "elements",
    "list",
    "return",
    "statement",
    "going",
    "use",
    "operator",
    "add",
    "one",
    "condition",
    "condition",
    "going",
    "make",
    "recursive",
    "function",
    "call",
    "back",
    "verify",
    "sorted",
    "argument",
    "going",
    "pass",
    "list",
    "going",
    "second",
    "element",
    "way",
    "end",
    "let",
    "visualize",
    "would",
    "work",
    "use",
    "five",
    "element",
    "list",
    "example",
    "call",
    "verify",
    "sorted",
    "pass",
    "entire",
    "list",
    "list",
    "one",
    "zero",
    "elements",
    "long",
    "skip",
    "first",
    "statement",
    "one",
    "line",
    "code",
    "left",
    "function",
    "first",
    "check",
    "element",
    "index",
    "0",
    "less",
    "element",
    "index",
    "false",
    "function",
    "returns",
    "immediately",
    "false",
    "value",
    "operator",
    "requires",
    "conditions",
    "true",
    "entire",
    "line",
    "code",
    "return",
    "true",
    "since",
    "first",
    "condition",
    "evaluates",
    "false",
    "need",
    "bother",
    "evaluating",
    "second",
    "second",
    "condition",
    "recursive",
    "call",
    "containing",
    "elements",
    "original",
    "list",
    "starting",
    "position",
    "1",
    "going",
    "end",
    "second",
    "call",
    "skip",
    "first",
    "statement",
    "proceed",
    "check",
    "whether",
    "value",
    "element",
    "0",
    "less",
    "value",
    "element",
    "remember",
    "list",
    "original",
    "starting",
    "element",
    "second",
    "element",
    "original",
    "list",
    "comparing",
    "elements",
    "position",
    "0",
    "1",
    "sub",
    "list",
    "effectively",
    "comparing",
    "elements",
    "position",
    "1",
    "2",
    "original",
    "list",
    "recursive",
    "call",
    "create",
    "new",
    "sub",
    "lists",
    "start",
    "index",
    "position",
    "1",
    "able",
    "check",
    "entire",
    "list",
    "without",
    "specify",
    "checks",
    "first",
    "two",
    "elements",
    "since",
    "recursive",
    "function",
    "means",
    "need",
    "stopping",
    "condition",
    "already",
    "first",
    "condition",
    "keep",
    "making",
    "sub",
    "lists",
    "reach",
    "single",
    "element",
    "list",
    "element",
    "already",
    "sorted",
    "definition",
    "return",
    "true",
    "since",
    "recursive",
    "function",
    "call",
    "part",
    "condition",
    "means",
    "every",
    "single",
    "recursive",
    "call",
    "return",
    "true",
    "way",
    "back",
    "beginning",
    "top",
    "level",
    "function",
    "return",
    "true",
    "function",
    "say",
    "yes",
    "sorted",
    "could",
    "easily",
    "done",
    "using",
    "iterative",
    "solution",
    "loop",
    "way",
    "get",
    "another",
    "example",
    "recursion",
    "work",
    "understand",
    "let",
    "use",
    "function",
    "bottom",
    "say",
    "print",
    "verify",
    "sorted",
    "first",
    "pass",
    "list",
    "oops",
    "got",
    "rid",
    "okay",
    "let",
    "write",
    "list",
    "equal",
    "think",
    "original",
    "numbers",
    "somewhere",
    "say",
    "54",
    "26",
    "93",
    "okay",
    "assigned",
    "l",
    "result",
    "calling",
    "merge",
    "sort",
    "list",
    "okay",
    "going",
    "use",
    "verify",
    "sorted",
    "function",
    "check",
    "first",
    "list",
    "sorted",
    "return",
    "false",
    "check",
    "call",
    "pass",
    "l",
    "return",
    "true",
    "okay",
    "bottom",
    "console",
    "call",
    "python",
    "merge",
    "sort",
    "dot",
    "pi",
    "go",
    "returned",
    "false",
    "list",
    "meaning",
    "sorted",
    "l",
    "sorted",
    "cool",
    "merge",
    "sort",
    "function",
    "works",
    "next",
    "video",
    "let",
    "talk",
    "cost",
    "algorithm",
    "go",
    "back",
    "top",
    "level",
    "merge",
    "sort",
    "function",
    "run",
    "time",
    "function",
    "look",
    "like",
    "space",
    "complexity",
    "memory",
    "usage",
    "grow",
    "algorithm",
    "runs",
    "answer",
    "questions",
    "let",
    "look",
    "individual",
    "steps",
    "starting",
    "split",
    "function",
    "split",
    "function",
    "finding",
    "midpoint",
    "list",
    "splitting",
    "list",
    "midpoint",
    "seems",
    "like",
    "constant",
    "time",
    "operation",
    "remember",
    "split",
    "function",
    "called",
    "called",
    "many",
    "times",
    "need",
    "go",
    "initial",
    "list",
    "single",
    "element",
    "list",
    "pattern",
    "seen",
    "couple",
    "times",
    "know",
    "overall",
    "runs",
    "logarithmic",
    "time",
    "let",
    "add",
    "comment",
    "say",
    "takes",
    "overall",
    "big",
    "log",
    "n",
    "time",
    "caveat",
    "come",
    "back",
    "next",
    "merge",
    "step",
    "merge",
    "step",
    "broken",
    "original",
    "list",
    "single",
    "element",
    "lists",
    "need",
    "make",
    "comparison",
    "operations",
    "merge",
    "back",
    "reverse",
    "order",
    "list",
    "size",
    "n",
    "always",
    "need",
    "make",
    "n",
    "number",
    "merge",
    "operations",
    "get",
    "back",
    "single",
    "element",
    "lists",
    "merge",
    "list",
    "makes",
    "overall",
    "runtime",
    "big",
    "n",
    "times",
    "log",
    "n",
    "n",
    "number",
    "merge",
    "steps",
    "multiplied",
    "log",
    "n",
    "number",
    "splits",
    "original",
    "list",
    "merge",
    "step",
    "let",
    "add",
    "comment",
    "say",
    "runs",
    "overall",
    "oops",
    "go",
    "runs",
    "overall",
    "linear",
    "time",
    "right",
    "takes",
    "n",
    "number",
    "steps",
    "number",
    "merge",
    "steps",
    "two",
    "linear",
    "logarithmic",
    "multiply",
    "say",
    "merge",
    "sort",
    "function",
    "top",
    "level",
    "function",
    "conclude",
    "runtime",
    "overall",
    "sorting",
    "process",
    "big",
    "n",
    "times",
    "log",
    "n",
    "caveat",
    "mentioned",
    "earlier",
    "go",
    "back",
    "split",
    "function",
    "right",
    "go",
    "let",
    "take",
    "look",
    "way",
    "actually",
    "splitting",
    "list",
    "using",
    "python",
    "list",
    "slicing",
    "operation",
    "passing",
    "two",
    "indexes",
    "split",
    "occurs",
    "go",
    "poke",
    "around",
    "python",
    "documentation",
    "done",
    "says",
    "slicing",
    "operation",
    "constant",
    "time",
    "operation",
    "fact",
    "runtime",
    "big",
    "k",
    "k",
    "represents",
    "slice",
    "size",
    "means",
    "reality",
    "implementation",
    "split",
    "implementation",
    "split",
    "run",
    "logarithmic",
    "time",
    "k",
    "times",
    "logarithmic",
    "time",
    "slice",
    "operation",
    "split",
    "means",
    "implementation",
    "much",
    "expensive",
    "overall",
    "makes",
    "overall",
    "top",
    "level",
    "merge",
    "sort",
    "function",
    "n",
    "times",
    "log",
    "n",
    "k",
    "n",
    "times",
    "log",
    "n",
    "much",
    "expensive",
    "let",
    "get",
    "rid",
    "fix",
    "would",
    "need",
    "remove",
    "slicing",
    "operation",
    "using",
    "technique",
    "learned",
    "previous",
    "course",
    "introduction",
    "algorithms",
    "course",
    "looked",
    "two",
    "versions",
    "binary",
    "search",
    "python",
    "recursive",
    "iterative",
    "version",
    "recursive",
    "one",
    "use",
    "list",
    "slicing",
    "every",
    "recursion",
    "call",
    "achieve",
    "end",
    "result",
    "using",
    "iterative",
    "approach",
    "without",
    "using",
    "list",
    "slicing",
    "declared",
    "two",
    "variables",
    "keep",
    "track",
    "starting",
    "ending",
    "positions",
    "list",
    "could",
    "rewrite",
    "merge",
    "sort",
    "leave",
    "exercise",
    "want",
    "hints",
    "want",
    "direction",
    "included",
    "link",
    "notes",
    "implementation",
    "time",
    "complexity",
    "know",
    "moving",
    "python",
    "overall",
    "run",
    "time",
    "listed",
    "actual",
    "run",
    "time",
    "merge",
    "sort",
    "algorithm",
    "looks",
    "like",
    "merge",
    "step",
    "runs",
    "linear",
    "time",
    "split",
    "step",
    "takes",
    "logarithmic",
    "time",
    "overall",
    "n",
    "times",
    "log",
    "n",
    "merge",
    "sort",
    "actually",
    "works",
    "okay",
    "space",
    "complexity",
    "merge",
    "sort",
    "algorithm",
    "takes",
    "linear",
    "space",
    "weird",
    "think",
    "first",
    "always",
    "visualization",
    "helps",
    "start",
    "top",
    "full",
    "list",
    "carry",
    "split",
    "method",
    "single",
    "element",
    "lists",
    "new",
    "lists",
    "take",
    "certain",
    "amount",
    "space",
    "second",
    "level",
    "two",
    "lists",
    "take",
    "n",
    "two",
    "amount",
    "space",
    "makes",
    "seem",
    "sum",
    "space",
    "additional",
    "space",
    "needed",
    "merge",
    "sort",
    "actually",
    "case",
    "reality",
    "two",
    "factors",
    "make",
    "difference",
    "first",
    "every",
    "single",
    "one",
    "sub",
    "lists",
    "created",
    "simultaneously",
    "step",
    "two",
    "create",
    "two",
    "n",
    "two",
    "size",
    "sub",
    "lists",
    "move",
    "next",
    "step",
    "however",
    "hold",
    "n",
    "two",
    "sub",
    "lists",
    "create",
    "four",
    "n",
    "four",
    "size",
    "sub",
    "lists",
    "next",
    "split",
    "instead",
    "four",
    "n",
    "four",
    "size",
    "sub",
    "lists",
    "created",
    "n",
    "two",
    "ones",
    "deleted",
    "memory",
    "reason",
    "hold",
    "longer",
    "second",
    "point",
    "code",
    "execute",
    "every",
    "path",
    "simultaneously",
    "think",
    "way",
    "pass",
    "list",
    "top",
    "level",
    "merge",
    "sort",
    "function",
    "implementation",
    "calls",
    "split",
    "returns",
    "left",
    "half",
    "right",
    "half",
    "next",
    "line",
    "code",
    "calls",
    "merge",
    "sort",
    "left",
    "half",
    "runs",
    "function",
    "merge",
    "sort",
    "function",
    "new",
    "list",
    "second",
    "run",
    "function",
    "split",
    "called",
    "get",
    "second",
    "left",
    "right",
    "half",
    "like",
    "call",
    "merge",
    "sort",
    "left",
    "half",
    "well",
    "means",
    "code",
    "walks",
    "left",
    "path",
    "way",
    "initial",
    "left",
    "half",
    "sorted",
    "merged",
    "back",
    "one",
    "array",
    "going",
    "walk",
    "way",
    "right",
    "path",
    "sort",
    "back",
    "first",
    "split",
    "two",
    "n",
    "two",
    "sized",
    "sublists",
    "essentially",
    "run",
    "paths",
    "code",
    "algorithm",
    "need",
    "additional",
    "space",
    "every",
    "fact",
    "last",
    "step",
    "matters",
    "last",
    "step",
    "two",
    "merged",
    "back",
    "new",
    "sorted",
    "list",
    "returned",
    "sorted",
    "list",
    "equal",
    "number",
    "items",
    "original",
    "unsorted",
    "list",
    "since",
    "new",
    "list",
    "means",
    "additional",
    "space",
    "algorithm",
    "require",
    "given",
    "time",
    "n",
    "yes",
    "different",
    "points",
    "algorithm",
    "require",
    "log",
    "n",
    "amount",
    "space",
    "log",
    "n",
    "smaller",
    "n",
    "consider",
    "space",
    "complexity",
    "merge",
    "sort",
    "linear",
    "overall",
    "factor",
    "okay",
    "lot",
    "let",
    "stop",
    "worry",
    "got",
    "questions",
    "merge",
    "sort",
    "done",
    "yet",
    "next",
    "videos",
    "let",
    "wrap",
    "course",
    "implementing",
    "merge",
    "sort",
    "linked",
    "list",
    "music",
    "last",
    "videos",
    "implemented",
    "merge",
    "sort",
    "algorithm",
    "array",
    "list",
    "type",
    "python",
    "merge",
    "sort",
    "probably",
    "complicated",
    "algorithm",
    "written",
    "far",
    "learned",
    "important",
    "concept",
    "divide",
    "conquer",
    "also",
    "concluded",
    "last",
    "video",
    "figuring",
    "run",
    "time",
    "merge",
    "sort",
    "based",
    "implementation",
    "next",
    "videos",
    "going",
    "implement",
    "merge",
    "sort",
    "time",
    "linked",
    "list",
    "type",
    "going",
    "get",
    "chance",
    "see",
    "implementation",
    "differs",
    "based",
    "data",
    "structure",
    "still",
    "keeping",
    "fundamentals",
    "algorithm",
    "also",
    "see",
    "run",
    "time",
    "may",
    "affected",
    "kinds",
    "operations",
    "need",
    "implement",
    "let",
    "create",
    "new",
    "file",
    "put",
    "second",
    "implementation",
    "merge",
    "sort",
    "file",
    "new",
    "file",
    "going",
    "rather",
    "long",
    "name",
    "call",
    "linked",
    "list",
    "merge",
    "sort",
    "underscores",
    "everywhere",
    "dot",
    "pi",
    "going",
    "need",
    "linked",
    "list",
    "class",
    "created",
    "earlier",
    "start",
    "top",
    "importing",
    "linked",
    "list",
    "class",
    "file",
    "way",
    "say",
    "linked",
    "list",
    "import",
    "linked",
    "list",
    "right",
    "imports",
    "class",
    "uh",
    "let",
    "test",
    "works",
    "really",
    "quick",
    "something",
    "like",
    "l",
    "equal",
    "linked",
    "list",
    "ten",
    "one",
    "matter",
    "print",
    "l",
    "okay",
    "hit",
    "save",
    "say",
    "python",
    "linked",
    "list",
    "merge",
    "sword",
    "dot",
    "pi",
    "okay",
    "works",
    "get",
    "code",
    "reuse",
    "code",
    "written",
    "files",
    "current",
    "file",
    "get",
    "rid",
    "okay",
    "like",
    "first",
    "implementation",
    "merge",
    "sort",
    "going",
    "split",
    "code",
    "across",
    "three",
    "functions",
    "main",
    "function",
    "merge",
    "sort",
    "split",
    "function",
    "merge",
    "function",
    "look",
    "merge",
    "sort",
    "implementation",
    "python",
    "regular",
    "list",
    "array",
    "linked",
    "list",
    "would",
    "find",
    "much",
    "concise",
    "versions",
    "kind",
    "hard",
    "explain",
    "splitting",
    "three",
    "sort",
    "help",
    "know",
    "easier",
    "understand",
    "call",
    "merge",
    "sort",
    "top",
    "level",
    "time",
    "going",
    "take",
    "linked",
    "list",
    "let",
    "add",
    "dog",
    "string",
    "document",
    "function",
    "say",
    "function",
    "sorts",
    "linked",
    "list",
    "ascending",
    "order",
    "like",
    "add",
    "steps",
    "say",
    "first",
    "recursively",
    "divide",
    "linked",
    "list",
    "sub",
    "lists",
    "containing",
    "single",
    "node",
    "repeatedly",
    "merge",
    "produce",
    "sorted",
    "one",
    "remains",
    "finally",
    "function",
    "returns",
    "sorted",
    "linked",
    "list",
    "implementation",
    "top",
    "level",
    "merge",
    "function",
    "nearly",
    "identical",
    "array",
    "list",
    "version",
    "wrote",
    "earlier",
    "first",
    "provide",
    "stopping",
    "condition",
    "two",
    "size",
    "list",
    "one",
    "empty",
    "list",
    "return",
    "linked",
    "list",
    "since",
    "naively",
    "sorted",
    "linked",
    "list",
    "dot",
    "size",
    "remember",
    "function",
    "run",
    "equal",
    "one",
    "return",
    "linked",
    "list",
    "else",
    "linked",
    "list",
    "dot",
    "head",
    "none",
    "meaning",
    "empty",
    "list",
    "return",
    "linked",
    "list",
    "well",
    "okay",
    "next",
    "let",
    "split",
    "linked",
    "list",
    "left",
    "right",
    "half",
    "conceptually",
    "different",
    "practice",
    "need",
    "actually",
    "traverse",
    "list",
    "implement",
    "helper",
    "method",
    "make",
    "easier",
    "say",
    "left",
    "half",
    "comma",
    "right",
    "half",
    "equal",
    "split",
    "linked",
    "list",
    "two",
    "sub",
    "lists",
    "like",
    "call",
    "merge",
    "sort",
    "top",
    "level",
    "function",
    "left",
    "equal",
    "merge",
    "sort",
    "left",
    "half",
    "right",
    "equal",
    "merge",
    "sort",
    "right",
    "half",
    "finally",
    "merge",
    "two",
    "return",
    "merge",
    "left",
    "right",
    "okay",
    "nothing",
    "new",
    "next",
    "video",
    "let",
    "implement",
    "split",
    "logic",
    "next",
    "step",
    "merge",
    "sort",
    "algorithm",
    "divide",
    "step",
    "rather",
    "implementation",
    "split",
    "function",
    "call",
    "split",
    "like",
    "going",
    "take",
    "linked",
    "list",
    "documenting",
    "things",
    "good",
    "far",
    "let",
    "add",
    "docstring",
    "divide",
    "unsorted",
    "list",
    "midpoint",
    "course",
    "say",
    "mean",
    "lists",
    "long",
    "word",
    "say",
    "things",
    "start",
    "deviate",
    "previous",
    "version",
    "list",
    "type",
    "could",
    "rely",
    "fact",
    "finding",
    "midpoint",
    "using",
    "index",
    "list",
    "slicing",
    "split",
    "two",
    "lists",
    "would",
    "work",
    "even",
    "empty",
    "list",
    "passed",
    "since",
    "automatic",
    "behavior",
    "like",
    "need",
    "account",
    "using",
    "linked",
    "list",
    "first",
    "condition",
    "linked",
    "list",
    "none",
    "empty",
    "head",
    "equal",
    "none",
    "say",
    "linked",
    "list",
    "equal",
    "none",
    "write",
    "matter",
    "linked",
    "list",
    "dot",
    "head",
    "none",
    "well",
    "linked",
    "list",
    "none",
    "example",
    "call",
    "split",
    "linked",
    "list",
    "containing",
    "single",
    "node",
    "split",
    "list",
    "would",
    "mean",
    "left",
    "would",
    "contain",
    "single",
    "node",
    "right",
    "would",
    "none",
    "either",
    "case",
    "going",
    "assign",
    "entire",
    "list",
    "left",
    "half",
    "assign",
    "none",
    "right",
    "say",
    "left",
    "half",
    "equal",
    "linked",
    "list",
    "right",
    "half",
    "equal",
    "none",
    "could",
    "also",
    "assign",
    "single",
    "element",
    "list",
    "none",
    "left",
    "create",
    "new",
    "empty",
    "linked",
    "list",
    "assigned",
    "right",
    "half",
    "unnecessary",
    "work",
    "done",
    "return",
    "left",
    "half",
    "right",
    "half",
    "first",
    "condition",
    "let",
    "add",
    "else",
    "clause",
    "account",
    "linked",
    "lists",
    "first",
    "calculate",
    "size",
    "list",
    "easy",
    "done",
    "work",
    "already",
    "call",
    "size",
    "method",
    "defined",
    "say",
    "size",
    "equal",
    "linked",
    "underscore",
    "list",
    "dot",
    "size",
    "using",
    "size",
    "determine",
    "midpoint",
    "mid",
    "equal",
    "size",
    "use",
    "floor",
    "division",
    "operator",
    "divide",
    "two",
    "midpoint",
    "need",
    "get",
    "node",
    "midpoint",
    "make",
    "sure",
    "hit",
    "command",
    "save",
    "going",
    "navigate",
    "back",
    "going",
    "add",
    "convenience",
    "method",
    "bottom",
    "right",
    "wrapper",
    "function",
    "right",
    "convenience",
    "method",
    "going",
    "return",
    "node",
    "given",
    "index",
    "call",
    "node",
    "index",
    "going",
    "take",
    "index",
    "value",
    "way",
    "instead",
    "traverse",
    "list",
    "inside",
    "split",
    "function",
    "simply",
    "call",
    "node",
    "index",
    "pass",
    "midpoint",
    "index",
    "calculated",
    "give",
    "us",
    "node",
    "right",
    "perform",
    "split",
    "okay",
    "method",
    "accepts",
    "argument",
    "index",
    "want",
    "get",
    "node",
    "index",
    "zero",
    "return",
    "head",
    "list",
    "index",
    "double",
    "equals",
    "zero",
    "return",
    "rest",
    "implementation",
    "involves",
    "traversing",
    "linked",
    "list",
    "counting",
    "index",
    "visit",
    "node",
    "rest",
    "implementation",
    "involves",
    "traversing",
    "linked",
    "list",
    "counting",
    "index",
    "visit",
    "node",
    "add",
    "else",
    "clause",
    "start",
    "head",
    "say",
    "current",
    "equal",
    "let",
    "also",
    "declare",
    "variable",
    "called",
    "position",
    "indicate",
    "list",
    "use",
    "loop",
    "walk",
    "list",
    "condition",
    "long",
    "position",
    "less",
    "index",
    "value",
    "say",
    "position",
    "less",
    "index",
    "inside",
    "loop",
    "assign",
    "next",
    "node",
    "current",
    "increment",
    "value",
    "position",
    "one",
    "current",
    "equal",
    "current",
    "dot",
    "next",
    "node",
    "position",
    "plus",
    "equal",
    "one",
    "position",
    "value",
    "equals",
    "index",
    "value",
    "current",
    "refers",
    "node",
    "looking",
    "return",
    "say",
    "return",
    "current",
    "let",
    "get",
    "rid",
    "empty",
    "space",
    "go",
    "back",
    "linked",
    "list",
    "merge",
    "sort",
    "dot",
    "pi",
    "use",
    "method",
    "get",
    "node",
    "calculated",
    "midpoint",
    "get",
    "node",
    "midpoint",
    "list",
    "say",
    "mid",
    "node",
    "equal",
    "linked",
    "list",
    "dot",
    "node",
    "index",
    "going",
    "something",
    "slightly",
    "confusing",
    "going",
    "mid",
    "minus",
    "remember",
    "subtracting",
    "1",
    "used",
    "size",
    "calculate",
    "midpoint",
    "like",
    "len",
    "function",
    "size",
    "always",
    "return",
    "value",
    "greater",
    "maximum",
    "index",
    "value",
    "think",
    "linked",
    "list",
    "two",
    "nodes",
    "size",
    "would",
    "return",
    "two",
    "midpoint",
    "though",
    "way",
    "calculating",
    "index",
    "always",
    "start",
    "zero",
    "means",
    "size",
    "going",
    "one",
    "greater",
    "going",
    "deduct",
    "one",
    "get",
    "value",
    "want",
    "using",
    "floor",
    "division",
    "operator",
    "going",
    "round",
    "even",
    "big",
    "deal",
    "node",
    "midpoint",
    "midnote",
    "actually",
    "split",
    "list",
    "first",
    "going",
    "assign",
    "entire",
    "linked",
    "list",
    "variable",
    "named",
    "left",
    "half",
    "left",
    "half",
    "equal",
    "linked",
    "list",
    "seems",
    "counterintuitive",
    "make",
    "sense",
    "second",
    "right",
    "half",
    "going",
    "assign",
    "new",
    "instance",
    "linked",
    "list",
    "right",
    "half",
    "equal",
    "linked",
    "list",
    "newly",
    "created",
    "list",
    "empty",
    "fix",
    "assigning",
    "node",
    "comes",
    "midpoint",
    "midpoint",
    "original",
    "linked",
    "list",
    "assign",
    "node",
    "comes",
    "midpoint",
    "node",
    "head",
    "newly",
    "created",
    "right",
    "linked",
    "list",
    "say",
    "right",
    "half",
    "dot",
    "head",
    "equal",
    "mid",
    "node",
    "dot",
    "node",
    "assign",
    "none",
    "next",
    "node",
    "property",
    "mid",
    "node",
    "effectively",
    "sever",
    "connection",
    "make",
    "mid",
    "node",
    "tail",
    "node",
    "left",
    "linked",
    "list",
    "say",
    "mid",
    "node",
    "dot",
    "next",
    "node",
    "equal",
    "none",
    "confusing",
    "quick",
    "visualization",
    "happened",
    "start",
    "single",
    "linked",
    "list",
    "find",
    "midpoint",
    "node",
    "comes",
    "node",
    "midpoint",
    "assigned",
    "head",
    "newly",
    "created",
    "linked",
    "list",
    "connection",
    "midpoint",
    "node",
    "one",
    "removed",
    "two",
    "distinct",
    "linked",
    "lists",
    "split",
    "midpoint",
    "return",
    "two",
    "sub",
    "lists",
    "return",
    "left",
    "half",
    "right",
    "half",
    "next",
    "video",
    "let",
    "tackle",
    "merge",
    "function",
    "last",
    "video",
    "defined",
    "implementation",
    "version",
    "split",
    "function",
    "works",
    "linked",
    "lists",
    "contained",
    "tiny",
    "bit",
    "code",
    "array",
    "list",
    "version",
    "expected",
    "merge",
    "function",
    "different",
    "like",
    "split",
    "function",
    "carry",
    "comparison",
    "operation",
    "also",
    "need",
    "swap",
    "references",
    "corresponding",
    "nodes",
    "right",
    "let",
    "add",
    "merge",
    "function",
    "bottom",
    "split",
    "functions",
    "call",
    "merge",
    "going",
    "take",
    "left",
    "right",
    "get",
    "complicated",
    "going",
    "document",
    "function",
    "extensively",
    "always",
    "going",
    "start",
    "doc",
    "string",
    "say",
    "function",
    "merges",
    "two",
    "linked",
    "lists",
    "sorting",
    "data",
    "nodes",
    "returns",
    "new",
    "merged",
    "list",
    "remember",
    "merge",
    "step",
    "going",
    "compare",
    "values",
    "across",
    "two",
    "linked",
    "lists",
    "return",
    "new",
    "linked",
    "list",
    "nodes",
    "data",
    "sorted",
    "first",
    "need",
    "create",
    "new",
    "linked",
    "list",
    "let",
    "add",
    "comment",
    "say",
    "create",
    "new",
    "linked",
    "list",
    "contains",
    "nodes",
    "let",
    "add",
    "new",
    "line",
    "merging",
    "left",
    "right",
    "okay",
    "create",
    "list",
    "merged",
    "equal",
    "new",
    "linked",
    "list",
    "list",
    "going",
    "something",
    "unusual",
    "going",
    "add",
    "fake",
    "head",
    "adding",
    "sorted",
    "nodes",
    "reduce",
    "amount",
    "code",
    "write",
    "worrying",
    "whether",
    "head",
    "list",
    "done",
    "assign",
    "first",
    "sorted",
    "node",
    "head",
    "discard",
    "fake",
    "head",
    "might",
    "make",
    "sense",
    "first",
    "worry",
    "whether",
    "new",
    "linked",
    "list",
    "already",
    "contains",
    "head",
    "makes",
    "code",
    "simpler",
    "add",
    "another",
    "comment",
    "fake",
    "hand",
    "discarded",
    "later",
    "say",
    "merged",
    "dot",
    "add",
    "zero",
    "like",
    "far",
    "declare",
    "variable",
    "named",
    "current",
    "point",
    "head",
    "list",
    "set",
    "current",
    "head",
    "linked",
    "list",
    "current",
    "equal",
    "merged",
    "dot",
    "head",
    "next",
    "get",
    "reference",
    "head",
    "linked",
    "lists",
    "left",
    "right",
    "say",
    "obtain",
    "head",
    "nodes",
    "left",
    "right",
    "linked",
    "lists",
    "call",
    "left",
    "head",
    "equal",
    "left",
    "dot",
    "head",
    "right",
    "hand",
    "equal",
    "right",
    "dot",
    "head",
    "okay",
    "setup",
    "way",
    "let",
    "start",
    "iterating",
    "lists",
    "another",
    "comment",
    "iterate",
    "left",
    "right",
    "long",
    "say",
    "reach",
    "tail",
    "node",
    "either",
    "saying",
    "left",
    "head",
    "right",
    "head",
    "pattern",
    "following",
    "along",
    "going",
    "iterate",
    "hit",
    "tail",
    "nodes",
    "lists",
    "move",
    "pointer",
    "forward",
    "every",
    "time",
    "traverse",
    "list",
    "every",
    "iteration",
    "remember",
    "logic",
    "behind",
    "earlier",
    "version",
    "hit",
    "tail",
    "note",
    "one",
    "list",
    "nodes",
    "left",
    "linked",
    "list",
    "need",
    "carry",
    "comparison",
    "operation",
    "anymore",
    "simply",
    "add",
    "nodes",
    "merged",
    "list",
    "first",
    "scenario",
    "consider",
    "head",
    "left",
    "linked",
    "list",
    "none",
    "means",
    "already",
    "past",
    "tail",
    "left",
    "add",
    "nodes",
    "right",
    "linked",
    "list",
    "final",
    "merge",
    "list",
    "say",
    "head",
    "node",
    "left",
    "none",
    "past",
    "tail",
    "add",
    "node",
    "right",
    "right",
    "merged",
    "linked",
    "list",
    "say",
    "left",
    "head",
    "none",
    "current",
    "dot",
    "next",
    "node",
    "remember",
    "current",
    "points",
    "head",
    "merge",
    "list",
    "going",
    "return",
    "setting",
    "next",
    "node",
    "reference",
    "head",
    "node",
    "right",
    "link",
    "list",
    "say",
    "right",
    "head",
    "move",
    "right",
    "head",
    "forward",
    "next",
    "node",
    "let",
    "say",
    "right",
    "head",
    "equal",
    "right",
    "hand",
    "dot",
    "next",
    "node",
    "terminates",
    "loop",
    "next",
    "iteration",
    "let",
    "look",
    "visualization",
    "understand",
    "let",
    "say",
    "start",
    "linked",
    "list",
    "containing",
    "four",
    "nodes",
    "keep",
    "calling",
    "split",
    "lists",
    "single",
    "head",
    "single",
    "node",
    "linked",
    "lists",
    "essentially",
    "let",
    "focus",
    "two",
    "call",
    "left",
    "right",
    "implemented",
    "logic",
    "part",
    "yet",
    "would",
    "compare",
    "data",
    "values",
    "see",
    "one",
    "less",
    "assume",
    "left",
    "head",
    "lesser",
    "right",
    "head",
    "set",
    "next",
    "node",
    "final",
    "merge",
    "list",
    "left",
    "empty",
    "length",
    "list",
    "left",
    "dot",
    "head",
    "equals",
    "none",
    "next",
    "pass",
    "loop",
    "left",
    "head",
    "none",
    "situation",
    "implemented",
    "go",
    "ahead",
    "assign",
    "right",
    "head",
    "next",
    "note",
    "merge",
    "link",
    "list",
    "know",
    "right",
    "also",
    "singly",
    "linked",
    "list",
    "crucial",
    "bit",
    "move",
    "pointer",
    "forward",
    "calling",
    "next",
    "node",
    "right",
    "node",
    "node",
    "right",
    "link",
    "right",
    "linked",
    "list",
    "also",
    "empty",
    "means",
    "left",
    "head",
    "right",
    "head",
    "none",
    "either",
    "one",
    "would",
    "cause",
    "loop",
    "condition",
    "terminate",
    "done",
    "encoded",
    "stopping",
    "condition",
    "loop",
    "need",
    "document",
    "get",
    "fuzzy",
    "right",
    "line",
    "code",
    "say",
    "call",
    "next",
    "right",
    "set",
    "loop",
    "condition",
    "false",
    "okay",
    "another",
    "way",
    "arrive",
    "stopping",
    "condition",
    "opposite",
    "direction",
    "start",
    "right",
    "head",
    "none",
    "say",
    "going",
    "add",
    "another",
    "comment",
    "oops",
    "head",
    "node",
    "right",
    "none",
    "past",
    "tail",
    "say",
    "add",
    "tail",
    "node",
    "left",
    "merged",
    "linked",
    "list",
    "add",
    "condition",
    "say",
    "else",
    "right",
    "head",
    "none",
    "remember",
    "enter",
    "even",
    "left",
    "head",
    "none",
    "still",
    "go",
    "condition",
    "still",
    "enter",
    "statement",
    "execute",
    "logic",
    "loop",
    "loop",
    "condition",
    "statement",
    "even",
    "left",
    "head",
    "false",
    "returns",
    "true",
    "value",
    "node",
    "loop",
    "keep",
    "going",
    "okay",
    "case",
    "want",
    "set",
    "head",
    "left",
    "linked",
    "list",
    "next",
    "node",
    "merge",
    "list",
    "simply",
    "opposite",
    "set",
    "current",
    "dot",
    "next",
    "node",
    "equal",
    "left",
    "head",
    "move",
    "move",
    "variable",
    "pointing",
    "left",
    "head",
    "forwards",
    "saw",
    "earlier",
    "past",
    "tail",
    "node",
    "results",
    "loop",
    "terminating",
    "say",
    "left",
    "hand",
    "equal",
    "left",
    "head",
    "dot",
    "next",
    "node",
    "add",
    "comment",
    "well",
    "say",
    "call",
    "next",
    "left",
    "set",
    "loop",
    "condition",
    "false",
    "right",
    "head",
    "none",
    "make",
    "left",
    "head",
    "none",
    "two",
    "conditions",
    "looked",
    "either",
    "left",
    "head",
    "right",
    "head",
    "tail",
    "nodes",
    "respective",
    "lists",
    "conditions",
    "run",
    "reached",
    "bottom",
    "split",
    "single",
    "element",
    "linked",
    "lists",
    "empty",
    "linked",
    "lists",
    "let",
    "account",
    "final",
    "condition",
    "evaluating",
    "node",
    "neither",
    "head",
    "tail",
    "list",
    "condition",
    "need",
    "reach",
    "nodes",
    "actually",
    "compare",
    "data",
    "values",
    "one",
    "another",
    "decide",
    "node",
    "add",
    "first",
    "merged",
    "list",
    "else",
    "arrived",
    "third",
    "condition",
    "third",
    "final",
    "say",
    "either",
    "tail",
    "node",
    "obtain",
    "data",
    "perform",
    "comparison",
    "operations",
    "let",
    "get",
    "data",
    "values",
    "respective",
    "nodes",
    "compare",
    "say",
    "left",
    "data",
    "equal",
    "left",
    "head",
    "dot",
    "data",
    "write",
    "data",
    "equal",
    "right",
    "head",
    "okay",
    "next",
    "well",
    "compare",
    "first",
    "let",
    "add",
    "comment",
    "say",
    "data",
    "left",
    "less",
    "right",
    "set",
    "current",
    "left",
    "node",
    "move",
    "actually",
    "add",
    "second",
    "say",
    "left",
    "data",
    "less",
    "write",
    "data",
    "current",
    "dot",
    "next",
    "node",
    "equal",
    "left",
    "head",
    "add",
    "comment",
    "say",
    "move",
    "left",
    "head",
    "next",
    "node",
    "list",
    "say",
    "left",
    "head",
    "equal",
    "left",
    "head",
    "dot",
    "next",
    "node",
    "comment",
    "says",
    "check",
    "left",
    "data",
    "less",
    "right",
    "data",
    "since",
    "want",
    "list",
    "ascending",
    "order",
    "assign",
    "left",
    "node",
    "next",
    "node",
    "merged",
    "list",
    "also",
    "move",
    "left",
    "head",
    "forward",
    "traverse",
    "next",
    "node",
    "particular",
    "list",
    "left",
    "larger",
    "right",
    "want",
    "opposite",
    "go",
    "back",
    "spaces",
    "another",
    "comment",
    "data",
    "left",
    "greater",
    "right",
    "set",
    "current",
    "right",
    "node",
    "okay",
    "else",
    "assign",
    "right",
    "head",
    "next",
    "node",
    "merge",
    "list",
    "equal",
    "right",
    "head",
    "comment",
    "move",
    "right",
    "head",
    "next",
    "node",
    "right",
    "head",
    "equal",
    "right",
    "head",
    "dot",
    "next",
    "node",
    "okay",
    "move",
    "right",
    "head",
    "pointer",
    "reference",
    "next",
    "node",
    "right",
    "list",
    "finally",
    "end",
    "iteration",
    "loop",
    "two",
    "spaces",
    "back",
    "right",
    "make",
    "sure",
    "indented",
    "level",
    "got",
    "go",
    "yep",
    "level",
    "wild",
    "outer",
    "scope",
    "going",
    "say",
    "move",
    "current",
    "next",
    "node",
    "current",
    "equal",
    "current",
    "dot",
    "next",
    "node",
    "okay",
    "worry",
    "confusing",
    "always",
    "look",
    "visualization",
    "bit",
    "wrap",
    "function",
    "discarding",
    "fake",
    "head",
    "set",
    "earlier",
    "setting",
    "correct",
    "node",
    "head",
    "returning",
    "linked",
    "list",
    "add",
    "comment",
    "discard",
    "fake",
    "head",
    "set",
    "first",
    "merged",
    "node",
    "head",
    "say",
    "head",
    "equal",
    "merged",
    "dot",
    "head",
    "dot",
    "next",
    "node",
    "merged",
    "dot",
    "head",
    "equal",
    "head",
    "finally",
    "return",
    "merged",
    "okay",
    "wrote",
    "lot",
    "code",
    "lot",
    "comments",
    "still",
    "bunch",
    "let",
    "take",
    "quick",
    "break",
    "next",
    "video",
    "test",
    "evaluate",
    "results",
    "determine",
    "runtime",
    "algorithm",
    "okay",
    "first",
    "things",
    "first",
    "let",
    "test",
    "code",
    "keep",
    "simple",
    "writing",
    "robust",
    "verify",
    "function",
    "would",
    "actually",
    "take",
    "entire",
    "video",
    "instead",
    "leave",
    "try",
    "homework",
    "okay",
    "end",
    "let",
    "create",
    "new",
    "linked",
    "list",
    "let",
    "add",
    "notes",
    "l",
    "add",
    "going",
    "copy",
    "paste",
    "makes",
    "easier",
    "retype",
    "bunch",
    "add",
    "10",
    "uh",
    "set",
    "2",
    "44",
    "15",
    "something",
    "like",
    "okay",
    "go",
    "ahead",
    "print",
    "l",
    "inspect",
    "list",
    "next",
    "let",
    "create",
    "declare",
    "variable",
    "call",
    "sorted",
    "linked",
    "list",
    "going",
    "assign",
    "result",
    "calling",
    "merge",
    "sort",
    "l",
    "print",
    "sorted",
    "linked",
    "list",
    "okay",
    "since",
    "taken",
    "care",
    "logic",
    "know",
    "gets",
    "added",
    "nodes",
    "let",
    "see",
    "looks",
    "like",
    "right",
    "hit",
    "save",
    "bring",
    "console",
    "going",
    "type",
    "python",
    "linked",
    "list",
    "underscore",
    "merge",
    "sort",
    "dot",
    "pi",
    "enter",
    "okay",
    "see",
    "linked",
    "list",
    "first",
    "created",
    "remember",
    "add",
    "first",
    "right",
    "eventually",
    "becomes",
    "tail",
    "right",
    "yeah",
    "10",
    "tail",
    "200",
    "last",
    "one",
    "200",
    "head",
    "calling",
    "add",
    "simply",
    "adds",
    "one",
    "head",
    "list",
    "10",
    "44",
    "15",
    "200",
    "order",
    "added",
    "sorted",
    "linked",
    "list",
    "sorts",
    "2",
    "10",
    "15",
    "44",
    "look",
    "sorted",
    "linked",
    "list",
    "okay",
    "let",
    "visualize",
    "top",
    "linked",
    "list",
    "containing",
    "five",
    "nodes",
    "integers",
    "10",
    "2",
    "4",
    "15",
    "200",
    "data",
    "respectively",
    "merge",
    "sort",
    "function",
    "calls",
    "split",
    "list",
    "split",
    "function",
    "calls",
    "size",
    "list",
    "gets",
    "back",
    "5",
    "makes",
    "midpoint",
    "using",
    "midpoint",
    "split",
    "list",
    "using",
    "node",
    "index",
    "method",
    "remember",
    "deduct",
    "1",
    "value",
    "mid",
    "going",
    "split",
    "using",
    "index",
    "value",
    "effectively",
    "since",
    "starting",
    "index",
    "value",
    "0",
    "1",
    "means",
    "split",
    "node",
    "assign",
    "entire",
    "list",
    "left",
    "half",
    "create",
    "new",
    "list",
    "assign",
    "right",
    "half",
    "assign",
    "node",
    "3",
    "index",
    "value",
    "2",
    "head",
    "right",
    "list",
    "remove",
    "references",
    "node",
    "two",
    "node",
    "three",
    "far",
    "good",
    "right",
    "okay",
    "back",
    "merge",
    "sort",
    "function",
    "called",
    "split",
    "two",
    "linked",
    "lists",
    "let",
    "focus",
    "left",
    "half",
    "go",
    "back",
    "look",
    "code",
    "going",
    "call",
    "merge",
    "sort",
    "left",
    "linked",
    "list",
    "means",
    "next",
    "thing",
    "run",
    "split",
    "process",
    "since",
    "linked",
    "list",
    "containing",
    "two",
    "nodes",
    "means",
    "split",
    "going",
    "return",
    "new",
    "left",
    "right",
    "list",
    "one",
    "node",
    "back",
    "merge",
    "sort",
    "function",
    "means",
    "call",
    "merge",
    "sort",
    "left",
    "list",
    "since",
    "single",
    "node",
    "linked",
    "list",
    "calling",
    "merge",
    "sort",
    "immediately",
    "return",
    "split",
    "since",
    "hit",
    "stopping",
    "condition",
    "go",
    "next",
    "line",
    "code",
    "calling",
    "merge",
    "sort",
    "right",
    "list",
    "well",
    "get",
    "back",
    "immediately",
    "hit",
    "stopping",
    "condition",
    "left",
    "right",
    "get",
    "back",
    "calling",
    "merge",
    "sort",
    "call",
    "merge",
    "inside",
    "merge",
    "function",
    "start",
    "creating",
    "new",
    "linked",
    "list",
    "attaching",
    "fake",
    "head",
    "evaluate",
    "whether",
    "either",
    "left",
    "right",
    "head",
    "none",
    "since",
    "neither",
    "condition",
    "true",
    "go",
    "final",
    "step",
    "evaluate",
    "data",
    "node",
    "case",
    "data",
    "right",
    "node",
    "less",
    "left",
    "node",
    "assign",
    "right",
    "node",
    "next",
    "node",
    "merge",
    "link",
    "list",
    "move",
    "right",
    "head",
    "pointer",
    "forward",
    "merge",
    "link",
    "list",
    "move",
    "current",
    "pointer",
    "forward",
    "new",
    "node",
    "added",
    "completes",
    "one",
    "iteration",
    "loop",
    "next",
    "iteration",
    "righthead",
    "points",
    "none",
    "since",
    "single",
    "node",
    "list",
    "assign",
    "rest",
    "left",
    "linked",
    "list",
    "effectively",
    "single",
    "node",
    "merge",
    "link",
    "list",
    "discard",
    "fake",
    "head",
    "move",
    "next",
    "node",
    "correct",
    "head",
    "return",
    "newly",
    "merged",
    "sorted",
    "linked",
    "list",
    "remember",
    "point",
    "right",
    "head",
    "left",
    "head",
    "pointed",
    "none",
    "loop",
    "terminated",
    "way",
    "recursively",
    "split",
    "repeatedly",
    "merge",
    "back",
    "one",
    "sorted",
    "linked",
    "list",
    "merge",
    "sort",
    "algorithm",
    "powerful",
    "sorting",
    "algorithm",
    "ultimately",
    "really",
    "anything",
    "complicated",
    "breaks",
    "problem",
    "really",
    "simple",
    "solve",
    "remember",
    "technique",
    "talked",
    "called",
    "divide",
    "conquer",
    "like",
    "think",
    "merge",
    "sort",
    "way",
    "teacher",
    "front",
    "room",
    "bunch",
    "books",
    "needs",
    "sort",
    "alphabetical",
    "order",
    "instead",
    "work",
    "splits",
    "pile",
    "two",
    "hands",
    "two",
    "students",
    "front",
    "students",
    "split",
    "two",
    "hand",
    "four",
    "students",
    "seated",
    "behind",
    "student",
    "eventually",
    "bunch",
    "single",
    "students",
    "two",
    "books",
    "compare",
    "sort",
    "easily",
    "hand",
    "back",
    "student",
    "gave",
    "front",
    "repeats",
    "process",
    "backwards",
    "ultimately",
    "really",
    "simple",
    "work",
    "efficiently",
    "delegated",
    "back",
    "implementation",
    "let",
    "talk",
    "runtime",
    "far",
    "node",
    "swapping",
    "seems",
    "like",
    "implementation",
    "right",
    "fact",
    "including",
    "problems",
    "ran",
    "list",
    "version",
    "well",
    "first",
    "implementation",
    "merge",
    "sort",
    "thought",
    "algorithm",
    "ran",
    "big",
    "n",
    "log",
    "n",
    "turns",
    "well",
    "python",
    "list",
    "slicing",
    "operation",
    "remember",
    "actually",
    "takes",
    "amount",
    "time",
    "amounting",
    "big",
    "k",
    "true",
    "implementation",
    "merge",
    "sort",
    "runs",
    "log",
    "linear",
    "time",
    "n",
    "times",
    "log",
    "n",
    "almost",
    "got",
    "implementation",
    "merge",
    "sort",
    "linked",
    "list",
    "introduce",
    "problem",
    "go",
    "back",
    "merge",
    "rather",
    "split",
    "function",
    "happens",
    "swapping",
    "node",
    "references",
    "constant",
    "time",
    "operation",
    "big",
    "deal",
    "comparing",
    "values",
    "also",
    "constant",
    "time",
    "bottleneck",
    "like",
    "list",
    "slicing",
    "splitting",
    "late",
    "list",
    "midpoint",
    "go",
    "back",
    "implementation",
    "see",
    "use",
    "node",
    "index",
    "method",
    "finds",
    "node",
    "want",
    "traversing",
    "list",
    "means",
    "every",
    "split",
    "operation",
    "incurs",
    "big",
    "k",
    "cost",
    "k",
    "midpoint",
    "list",
    "effectively",
    "n",
    "2",
    "walk",
    "list",
    "counting",
    "index",
    "get",
    "node",
    "given",
    "overall",
    "splits",
    "take",
    "logarithmic",
    "time",
    "split",
    "function",
    "like",
    "one",
    "wrote",
    "earlier",
    "incurs",
    "cost",
    "big",
    "k",
    "log",
    "n",
    "say",
    "takes",
    "big",
    "k",
    "times",
    "log",
    "n",
    "merge",
    "function",
    "also",
    "like",
    "one",
    "wrote",
    "earlier",
    "takes",
    "linear",
    "time",
    "one",
    "good",
    "one",
    "runs",
    "expected",
    "amount",
    "time",
    "say",
    "runs",
    "linear",
    "time",
    "would",
    "bring",
    "overall",
    "run",
    "time",
    "merge",
    "sort",
    "function",
    "say",
    "runs",
    "big",
    "k",
    "n",
    "times",
    "log",
    "n",
    "okay",
    "though",
    "good",
    "start",
    "one",
    "day",
    "talk",
    "constant",
    "factors",
    "look",
    "ways",
    "reduce",
    "cost",
    "operations",
    "using",
    "different",
    "strategies",
    "come",
    "back",
    "code",
    "improve",
    "implementation",
    "long",
    "understand",
    "merge",
    "sort",
    "works",
    "conceptually",
    "run",
    "time",
    "space",
    "complexities",
    "look",
    "like",
    "bottlenecks",
    "code",
    "plenty",
    "stuff",
    "interested",
    "learning",
    "would",
    "solve",
    "problem",
    "check",
    "notes",
    "teachers",
    "video",
    "next",
    "video",
    "let",
    "wrap",
    "course",
    "let",
    "wrap",
    "course",
    "prerequisite",
    "course",
    "introduction",
    "algorithms",
    "learned",
    "basic",
    "algorithms",
    "along",
    "concepts",
    "like",
    "recursion",
    "big",
    "set",
    "foundation",
    "learning",
    "implementing",
    "evaluating",
    "algorithms",
    "course",
    "learned",
    "data",
    "structure",
    "data",
    "structures",
    "go",
    "hand",
    "hand",
    "algorithms",
    "started",
    "exploring",
    "data",
    "structure",
    "many",
    "us",
    "use",
    "programming",
    "arrays",
    "lists",
    "known",
    "python",
    "take",
    "peek",
    "hood",
    "arrays",
    "created",
    "stored",
    "examine",
    "common",
    "operations",
    "carried",
    "arrays",
    "operations",
    "write",
    "execute",
    "time",
    "took",
    "step",
    "back",
    "evaluated",
    "run",
    "times",
    "operations",
    "affect",
    "performance",
    "code",
    "jumped",
    "entirely",
    "new",
    "world",
    "wrote",
    "data",
    "structure",
    "singly",
    "linked",
    "list",
    "admittedly",
    "linked",
    "lists",
    "used",
    "much",
    "problem",
    "solving",
    "good",
    "data",
    "structure",
    "start",
    "fairly",
    "straightforward",
    "understand",
    "much",
    "different",
    "array",
    "carried",
    "exercise",
    "arrays",
    "looked",
    "common",
    "data",
    "operations",
    "since",
    "type",
    "defined",
    "implemented",
    "operations",
    "got",
    "examine",
    "comb",
    "code",
    "structure",
    "type",
    "affected",
    "runtime",
    "operations",
    "next",
    "topic",
    "tackled",
    "essentially",
    "worlds",
    "colliding",
    "implemented",
    "sorting",
    "algorithm",
    "sort",
    "two",
    "different",
    "data",
    "structures",
    "got",
    "see",
    "concepts",
    "learned",
    "far",
    "algorithmic",
    "thinking",
    "time",
    "space",
    "complexity",
    "data",
    "structures",
    "come",
    "together",
    "tackle",
    "problem",
    "sorting",
    "data",
    "kind",
    "exercise",
    "one",
    "going",
    "focus",
    "moving",
    "forward",
    "try",
    "solve",
    "programming",
    "problems",
    "using",
    "different",
    "data",
    "structures",
    "algorithms",
    "stuck",
    "content",
    "far",
    "keep",
    "great",
    "work",
    "complex",
    "topic",
    "really",
    "interesting",
    "one",
    "take",
    "time",
    "get",
    "deeper",
    "understanding",
    "programming",
    "problem",
    "solving",
    "always",
    "check",
    "notes",
    "resources",
    "happy",
    "coding",
    "music",
    "may",
    "heard",
    "algorithms",
    "computer",
    "science",
    "boring",
    "frustrating",
    "certainly",
    "hard",
    "figure",
    "especially",
    "way",
    "textbooks",
    "explain",
    "understand",
    "going",
    "algorithms",
    "seem",
    "fascinating",
    "clever",
    "even",
    "magical",
    "help",
    "understanding",
    "algorithms",
    "course",
    "going",
    "look",
    "two",
    "categories",
    "sorting",
    "algorithms",
    "searching",
    "algorithms",
    "could",
    "argue",
    "easiest",
    "kinds",
    "algorithms",
    "learn",
    "learning",
    "algorithms",
    "designed",
    "cover",
    "useful",
    "concepts",
    "like",
    "recursion",
    "divide",
    "conquer",
    "used",
    "many",
    "sorts",
    "algorithms",
    "even",
    "used",
    "create",
    "brand",
    "new",
    "ones",
    "way",
    "code",
    "samples",
    "going",
    "show",
    "videos",
    "python",
    "popular",
    "language",
    "relatively",
    "easy",
    "read",
    "need",
    "know",
    "python",
    "benefit",
    "course",
    "see",
    "teacher",
    "notes",
    "video",
    "info",
    "implementing",
    "algorithms",
    "favorite",
    "language",
    "goal",
    "course",
    "give",
    "overview",
    "sorting",
    "searching",
    "algorithms",
    "work",
    "many",
    "algorithms",
    "details",
    "handled",
    "different",
    "ways",
    "details",
    "may",
    "distract",
    "big",
    "picture",
    "put",
    "teachers",
    "notes",
    "instead",
    "need",
    "worry",
    "completing",
    "course",
    "first",
    "time",
    "going",
    "back",
    "referring",
    "later",
    "sure",
    "check",
    "teacher",
    "notes",
    "additional",
    "info",
    "suppose",
    "list",
    "names",
    "pretty",
    "big",
    "list",
    "hundred",
    "thousand",
    "names",
    "long",
    "list",
    "could",
    "part",
    "address",
    "book",
    "social",
    "media",
    "app",
    "need",
    "find",
    "locations",
    "individual",
    "names",
    "within",
    "list",
    "possibly",
    "look",
    "additional",
    "data",
    "connected",
    "name",
    "let",
    "assume",
    "existing",
    "function",
    "programming",
    "language",
    "existing",
    "function",
    "suit",
    "purpose",
    "way",
    "unsorted",
    "list",
    "option",
    "may",
    "use",
    "linear",
    "search",
    "also",
    "known",
    "sequential",
    "search",
    "linear",
    "search",
    "covered",
    "detail",
    "elsewhere",
    "site",
    "check",
    "teacher",
    "notes",
    "link",
    "want",
    "details",
    "start",
    "first",
    "element",
    "compare",
    "value",
    "searching",
    "match",
    "return",
    "go",
    "next",
    "element",
    "compare",
    "target",
    "match",
    "return",
    "go",
    "next",
    "element",
    "whole",
    "list",
    "problem",
    "search",
    "entire",
    "list",
    "every",
    "single",
    "time",
    "anything",
    "narrow",
    "search",
    "time",
    "search",
    "searching",
    "big",
    "list",
    "searching",
    "repeatedly",
    "amount",
    "time",
    "slow",
    "whole",
    "lap",
    "point",
    "people",
    "may",
    "want",
    "use",
    "anymore",
    "much",
    "common",
    "use",
    "different",
    "algorithm",
    "searching",
    "lists",
    "binary",
    "search",
    "binary",
    "search",
    "also",
    "covered",
    "detail",
    "elsewhere",
    "site",
    "check",
    "teacher",
    "notes",
    "link",
    "binary",
    "search",
    "narrow",
    "search",
    "us",
    "specifically",
    "lets",
    "us",
    "get",
    "rid",
    "half",
    "remaining",
    "items",
    "need",
    "search",
    "time",
    "requiring",
    "list",
    "values",
    "sorted",
    "looks",
    "value",
    "middle",
    "list",
    "value",
    "finds",
    "greater",
    "target",
    "value",
    "ignores",
    "values",
    "value",
    "looking",
    "value",
    "finds",
    "less",
    "target",
    "value",
    "ignores",
    "values",
    "value",
    "looking",
    "takes",
    "set",
    "values",
    "remain",
    "looks",
    "value",
    "middle",
    "list",
    "value",
    "finds",
    "greater",
    "target",
    "value",
    "ignores",
    "values",
    "value",
    "looking",
    "value",
    "finds",
    "less",
    "target",
    "value",
    "ignores",
    "values",
    "value",
    "looking",
    "mentioned",
    "binary",
    "search",
    "requires",
    "list",
    "values",
    "searching",
    "sorted",
    "lists",
    "sorted",
    "would",
    "idea",
    "half",
    "values",
    "ignore",
    "either",
    "half",
    "could",
    "contain",
    "value",
    "looking",
    "choice",
    "use",
    "linear",
    "search",
    "use",
    "binary",
    "search",
    "list",
    "need",
    "able",
    "sort",
    "list",
    "look",
    "next",
    "end",
    "goal",
    "sort",
    "list",
    "names",
    "comparing",
    "numbers",
    "little",
    "easier",
    "comparing",
    "strings",
    "going",
    "start",
    "sorting",
    "list",
    "numbers",
    "show",
    "modify",
    "examples",
    "sort",
    "strings",
    "end",
    "course",
    "help",
    "make",
    "clear",
    "importance",
    "choosing",
    "good",
    "sorting",
    "algorithm",
    "going",
    "start",
    "bad",
    "one",
    "called",
    "bogosort",
    "basically",
    "bogosort",
    "randomizes",
    "order",
    "list",
    "repeatedly",
    "sorted",
    "python",
    "code",
    "file",
    "going",
    "implement",
    "bogosort",
    "important",
    "understand",
    "code",
    "top",
    "although",
    "info",
    "teachers",
    "notes",
    "really",
    "want",
    "need",
    "know",
    "takes",
    "name",
    "file",
    "pass",
    "command",
    "line",
    "loads",
    "returns",
    "python",
    "list",
    "like",
    "array",
    "languages",
    "containing",
    "numbers",
    "read",
    "file",
    "let",
    "program",
    "print",
    "list",
    "numbers",
    "loads",
    "see",
    "call",
    "print",
    "method",
    "pass",
    "list",
    "numbers",
    "save",
    "let",
    "run",
    "real",
    "quick",
    "python",
    "oh",
    "whoops",
    "need",
    "provide",
    "name",
    "file",
    "command",
    "line",
    "going",
    "load",
    "numbers",
    "directory",
    "slash",
    "separates",
    "directory",
    "name",
    "file",
    "name",
    "five",
    "dot",
    "text",
    "list",
    "numbers",
    "loaded",
    "file",
    "okay",
    "let",
    "delete",
    "print",
    "statement",
    "move",
    "bogo",
    "sort",
    "randomly",
    "rearranges",
    "list",
    "values",
    "first",
    "thing",
    "going",
    "need",
    "function",
    "detect",
    "list",
    "sorted",
    "write",
    "sorted",
    "function",
    "takes",
    "list",
    "values",
    "parameter",
    "return",
    "true",
    "list",
    "passed",
    "sorted",
    "false",
    "loop",
    "numeric",
    "index",
    "value",
    "list",
    "0",
    "1",
    "less",
    "length",
    "list",
    "like",
    "many",
    "languages",
    "python",
    "list",
    "indexes",
    "begin",
    "0",
    "list",
    "length",
    "5",
    "indexes",
    "going",
    "0",
    "list",
    "sorted",
    "every",
    "value",
    "less",
    "one",
    "comes",
    "test",
    "see",
    "whether",
    "current",
    "item",
    "greater",
    "one",
    "follows",
    "means",
    "whole",
    "list",
    "sorted",
    "return",
    "false",
    "get",
    "means",
    "loop",
    "completed",
    "without",
    "finding",
    "unsorted",
    "values",
    "python",
    "uses",
    "white",
    "space",
    "mark",
    "code",
    "blocks",
    "unindenting",
    "code",
    "like",
    "marks",
    "end",
    "loop",
    "since",
    "values",
    "sorted",
    "return",
    "true",
    "need",
    "write",
    "function",
    "actually",
    "sorting",
    "bogosort",
    "function",
    "also",
    "take",
    "list",
    "values",
    "working",
    "parameter",
    "call",
    "sorted",
    "function",
    "test",
    "whether",
    "list",
    "sorted",
    "keep",
    "looping",
    "sorted",
    "returns",
    "true",
    "python",
    "function",
    "randomizes",
    "order",
    "elements",
    "list",
    "since",
    "list",
    "sorted",
    "call",
    "function",
    "since",
    "inside",
    "loop",
    "randomized",
    "sorted",
    "function",
    "returns",
    "true",
    "loop",
    "exits",
    "means",
    "sorted",
    "returned",
    "true",
    "list",
    "sorted",
    "return",
    "sorted",
    "list",
    "finally",
    "need",
    "call",
    "bogosort",
    "function",
    "pass",
    "list",
    "loaded",
    "file",
    "print",
    "sorted",
    "list",
    "returns",
    "okay",
    "let",
    "save",
    "try",
    "running",
    "python",
    "name",
    "script",
    "name",
    "file",
    "going",
    "run",
    "numbers",
    "looks",
    "like",
    "sorting",
    "list",
    "successfully",
    "efficient",
    "let",
    "add",
    "code",
    "track",
    "number",
    "times",
    "attempts",
    "sort",
    "list",
    "top",
    "bogus",
    "sort",
    "function",
    "add",
    "variable",
    "track",
    "number",
    "attempts",
    "made",
    "name",
    "attempts",
    "set",
    "initial",
    "value",
    "zero",
    "since",
    "made",
    "attempts",
    "yet",
    "pass",
    "loop",
    "print",
    "current",
    "number",
    "attempts",
    "end",
    "loop",
    "attempting",
    "shuffle",
    "values",
    "add",
    "one",
    "count",
    "attempts",
    "let",
    "save",
    "let",
    "try",
    "running",
    "couple",
    "times",
    "console",
    "press",
    "arrow",
    "bring",
    "previous",
    "command",
    "looks",
    "like",
    "first",
    "run",
    "sort",
    "five",
    "element",
    "list",
    "took",
    "363",
    "attempts",
    "let",
    "try",
    "time",
    "took",
    "91",
    "attempts",
    "simply",
    "randomizing",
    "list",
    "attempt",
    "run",
    "program",
    "takes",
    "random",
    "number",
    "attempts",
    "let",
    "try",
    "program",
    "larger",
    "number",
    "items",
    "python",
    "bogo",
    "sort",
    "numbers",
    "list",
    "eight",
    "items",
    "set",
    "file",
    "time",
    "takes",
    "11",
    "000",
    "attempts",
    "487",
    "time",
    "time",
    "thirteen",
    "thousand",
    "see",
    "trend",
    "increasing",
    "steadily",
    "problem",
    "bogosort",
    "make",
    "progress",
    "toward",
    "solution",
    "pass",
    "could",
    "generate",
    "list",
    "one",
    "value",
    "order",
    "next",
    "attempt",
    "could",
    "generate",
    "list",
    "elements",
    "order",
    "stumbling",
    "solution",
    "literally",
    "matter",
    "luck",
    "lists",
    "items",
    "might",
    "never",
    "happen",
    "next",
    "look",
    "selection",
    "sort",
    "sorting",
    "algorithm",
    "still",
    "slow",
    "better",
    "bogo",
    "sort",
    "previously",
    "showed",
    "bogo",
    "sort",
    "terrible",
    "sorting",
    "algorithm",
    "basically",
    "randomizes",
    "order",
    "list",
    "checks",
    "see",
    "happens",
    "sorted",
    "problem",
    "bogo",
    "sort",
    "get",
    "closer",
    "solution",
    "operation",
    "lists",
    "items",
    "probably",
    "never",
    "finish",
    "sorting",
    "going",
    "look",
    "algorithm",
    "named",
    "selection",
    "sort",
    "still",
    "slow",
    "least",
    "pass",
    "list",
    "brings",
    "little",
    "closer",
    "completion",
    "implementation",
    "selection",
    "sort",
    "going",
    "use",
    "two",
    "arrays",
    "unsorted",
    "array",
    "sorted",
    "one",
    "versions",
    "move",
    "values",
    "around",
    "within",
    "one",
    "array",
    "using",
    "two",
    "arrays",
    "keep",
    "code",
    "simpler",
    "sorted",
    "list",
    "starts",
    "empty",
    "moving",
    "values",
    "unsorted",
    "list",
    "sorted",
    "list",
    "one",
    "time",
    "pass",
    "look",
    "values",
    "unsorted",
    "array",
    "find",
    "smallest",
    "one",
    "move",
    "end",
    "sorted",
    "array",
    "start",
    "first",
    "value",
    "unsorted",
    "array",
    "say",
    "minimum",
    "smallest",
    "value",
    "seen",
    "far",
    "look",
    "next",
    "value",
    "see",
    "smaller",
    "current",
    "minimum",
    "mark",
    "new",
    "minimum",
    "move",
    "next",
    "value",
    "compare",
    "minimum",
    "smaller",
    "becomes",
    "new",
    "minimum",
    "continue",
    "way",
    "reach",
    "end",
    "list",
    "point",
    "know",
    "whatever",
    "value",
    "marked",
    "minimum",
    "smallest",
    "value",
    "whole",
    "list",
    "part",
    "makes",
    "selection",
    "sort",
    "better",
    "bogo",
    "sort",
    "move",
    "minimum",
    "value",
    "unsorted",
    "list",
    "end",
    "sorted",
    "list",
    "minimum",
    "value",
    "part",
    "unsorted",
    "list",
    "anymore",
    "waste",
    "time",
    "looking",
    "anymore",
    "remaining",
    "comparisons",
    "remaining",
    "values",
    "unsorted",
    "list",
    "start",
    "process",
    "point",
    "list",
    "consists",
    "numbers",
    "8",
    "5",
    "4",
    "first",
    "minimum",
    "start",
    "comparing",
    "minimum",
    "five",
    "five",
    "smaller",
    "eight",
    "five",
    "becomes",
    "new",
    "minimum",
    "compare",
    "five",
    "four",
    "four",
    "becomes",
    "new",
    "minimum",
    "four",
    "smaller",
    "seven",
    "though",
    "four",
    "remains",
    "minimum",
    "four",
    "gets",
    "moved",
    "end",
    "sorted",
    "array",
    "becoming",
    "second",
    "element",
    "process",
    "repeats",
    "eight",
    "first",
    "minimum",
    "five",
    "smaller",
    "becomes",
    "minimum",
    "seven",
    "larger",
    "five",
    "stays",
    "minimum",
    "five",
    "gets",
    "moved",
    "sort",
    "array",
    "items",
    "left",
    "unsorted",
    "array",
    "left",
    "sorted",
    "array",
    "selection",
    "sort",
    "works",
    "general",
    "let",
    "actual",
    "implementation",
    "code",
    "top",
    "saw",
    "bogo",
    "sword",
    "example",
    "loads",
    "python",
    "list",
    "numbers",
    "file",
    "let",
    "implement",
    "function",
    "selection",
    "sort",
    "going",
    "pass",
    "python",
    "list",
    "containing",
    "unsorted",
    "numbers",
    "create",
    "empty",
    "list",
    "hold",
    "sorted",
    "values",
    "loop",
    "value",
    "list",
    "call",
    "function",
    "named",
    "index",
    "submin",
    "going",
    "write",
    "minute",
    "finds",
    "minimum",
    "value",
    "unsorted",
    "list",
    "returns",
    "index",
    "call",
    "pop",
    "method",
    "list",
    "pass",
    "index",
    "minimum",
    "value",
    "pop",
    "remove",
    "item",
    "list",
    "return",
    "add",
    "value",
    "end",
    "sorted",
    "list",
    "going",
    "level",
    "indentation",
    "signals",
    "python",
    "ending",
    "loop",
    "loop",
    "finishes",
    "return",
    "sorted",
    "list",
    "need",
    "write",
    "function",
    "picks",
    "minimum",
    "value",
    "pass",
    "list",
    "going",
    "search",
    "mark",
    "first",
    "value",
    "list",
    "minimum",
    "may",
    "may",
    "actual",
    "minimum",
    "smallest",
    "seen",
    "pass",
    "list",
    "also",
    "value",
    "seen",
    "pass",
    "list",
    "far",
    "loop",
    "remaining",
    "values",
    "list",
    "first",
    "test",
    "whether",
    "value",
    "currently",
    "looking",
    "less",
    "previously",
    "recorded",
    "minimum",
    "set",
    "current",
    "index",
    "new",
    "index",
    "minimum",
    "value",
    "looped",
    "values",
    "return",
    "index",
    "smallest",
    "value",
    "found",
    "lastly",
    "need",
    "actually",
    "run",
    "selection",
    "sort",
    "method",
    "print",
    "sorted",
    "list",
    "returns",
    "let",
    "save",
    "let",
    "try",
    "running",
    "run",
    "python",
    "command",
    "pass",
    "name",
    "script",
    "numbers",
    "directory",
    "saved",
    "several",
    "data",
    "files",
    "filled",
    "random",
    "numbers",
    "one",
    "line",
    "five",
    "dot",
    "text",
    "five",
    "lines",
    "eight",
    "dot",
    "text",
    "eight",
    "lines",
    "help",
    "us",
    "really",
    "measure",
    "speed",
    "algorithms",
    "ten",
    "thousand",
    "dot",
    "text",
    "ten",
    "thousand",
    "lines",
    "even",
    "created",
    "file",
    "million",
    "numbers",
    "script",
    "takes",
    "path",
    "file",
    "load",
    "argument",
    "give",
    "path",
    "file",
    "five",
    "numbers",
    "numbers",
    "slash",
    "five",
    "dot",
    "text",
    "script",
    "runs",
    "reads",
    "numbers",
    "file",
    "list",
    "calls",
    "selection",
    "sort",
    "method",
    "list",
    "prints",
    "sorted",
    "list",
    "let",
    "add",
    "couple",
    "print",
    "statements",
    "within",
    "selection",
    "sort",
    "function",
    "watch",
    "sort",
    "happening",
    "worry",
    "figuring",
    "python",
    "formatting",
    "string",
    "use",
    "keep",
    "two",
    "lists",
    "neatly",
    "aligned",
    "add",
    "first",
    "print",
    "statement",
    "loop",
    "runs",
    "print",
    "unsorted",
    "list",
    "sorted",
    "list",
    "add",
    "identical",
    "print",
    "statement",
    "within",
    "loop",
    "watch",
    "values",
    "moving",
    "unsorted",
    "list",
    "sorted",
    "list",
    "let",
    "save",
    "try",
    "running",
    "command",
    "output",
    "looks",
    "like",
    "see",
    "unsorted",
    "list",
    "left",
    "sorted",
    "list",
    "right",
    "initially",
    "sorted",
    "list",
    "empty",
    "first",
    "pass",
    "selects",
    "lowest",
    "number",
    "1",
    "moves",
    "sorted",
    "list",
    "moves",
    "next",
    "lowest",
    "number",
    "four",
    "repeats",
    "numbers",
    "moved",
    "sorted",
    "list",
    "another",
    "file",
    "eight",
    "different",
    "numbers",
    "let",
    "try",
    "program",
    "python",
    "selection",
    "sort",
    "dot",
    "pi",
    "numbers",
    "see",
    "process",
    "work",
    "notice",
    "file",
    "duplicate",
    "values",
    "okay",
    "though",
    "index",
    "min",
    "function",
    "updates",
    "minimum",
    "index",
    "current",
    "value",
    "less",
    "previous",
    "minimum",
    "equal",
    "keeps",
    "first",
    "minimum",
    "value",
    "found",
    "waits",
    "move",
    "duplicate",
    "value",
    "next",
    "pass",
    "list",
    "know",
    "selection",
    "sort",
    "algorithm",
    "works",
    "data",
    "sets",
    "giving",
    "sort",
    "tiny",
    "real",
    "world",
    "algorithms",
    "need",
    "work",
    "data",
    "sets",
    "tens",
    "thousands",
    "even",
    "millions",
    "items",
    "fast",
    "another",
    "file",
    "ten",
    "thousand",
    "random",
    "numbers",
    "let",
    "see",
    "selection",
    "sort",
    "handle",
    "run",
    "though",
    "print",
    "lot",
    "debug",
    "info",
    "sorts",
    "list",
    "first",
    "going",
    "go",
    "program",
    "remove",
    "two",
    "print",
    "statements",
    "selection",
    "sort",
    "function",
    "let",
    "run",
    "program",
    "dot",
    "text",
    "file",
    "see",
    "long",
    "takes",
    "python",
    "selection",
    "sort",
    "dot",
    "pi",
    "numbers",
    "ten",
    "thousand",
    "dot",
    "text",
    "one",
    "one",
    "thousand",
    "two",
    "one",
    "thousand",
    "three",
    "one",
    "four",
    "one",
    "thousand",
    "five",
    "one",
    "thousand",
    "six",
    "one",
    "thousand",
    "seven",
    "one",
    "thousand",
    "eight",
    "one",
    "thousand",
    "nine",
    "one",
    "thousand",
    "ten",
    "one",
    "thousand",
    "eleven",
    "thousand",
    "twelve",
    "thousand",
    "thirteen",
    "thousand",
    "prints",
    "ten",
    "thousand",
    "numbers",
    "neatly",
    "sorted",
    "took",
    "little",
    "bit",
    "though",
    "long",
    "well",
    "counting",
    "time",
    "vocally",
    "precise",
    "programs",
    "running",
    "system",
    "skew",
    "amount",
    "time",
    "program",
    "takes",
    "complete",
    "let",
    "show",
    "unix",
    "command",
    "available",
    "workspaces",
    "help",
    "type",
    "time",
    "followed",
    "space",
    "command",
    "want",
    "run",
    "command",
    "print",
    "contents",
    "file",
    "cat",
    "concatenate",
    "numbers",
    "command",
    "thing",
    "also",
    "keep",
    "track",
    "long",
    "takes",
    "cat",
    "program",
    "complete",
    "report",
    "result",
    "time",
    "cat",
    "numbers",
    "five",
    "dot",
    "text",
    "real",
    "row",
    "results",
    "actual",
    "amount",
    "time",
    "program",
    "started",
    "running",
    "completed",
    "see",
    "finished",
    "fraction",
    "second",
    "said",
    "programs",
    "running",
    "system",
    "take",
    "cpu",
    "resources",
    "case",
    "program",
    "seem",
    "slower",
    "generally",
    "want",
    "ignore",
    "real",
    "result",
    "user",
    "result",
    "amount",
    "time",
    "cpu",
    "actually",
    "spent",
    "running",
    "program",
    "code",
    "total",
    "amount",
    "time",
    "code",
    "inside",
    "cat",
    "program",
    "took",
    "run",
    "sys",
    "result",
    "amount",
    "time",
    "cpu",
    "spent",
    "running",
    "linux",
    "kernel",
    "calls",
    "code",
    "made",
    "linux",
    "kernel",
    "responsible",
    "things",
    "like",
    "network",
    "communications",
    "reading",
    "files",
    "loading",
    "file",
    "probably",
    "included",
    "result",
    "evaluating",
    "code",
    "performance",
    "generally",
    "going",
    "want",
    "add",
    "together",
    "user",
    "sys",
    "results",
    "cad",
    "simple",
    "program",
    "let",
    "try",
    "running",
    "time",
    "command",
    "code",
    "see",
    "get",
    "interesting",
    "result",
    "time",
    "python",
    "selection",
    "sort",
    "dot",
    "pi",
    "numbers",
    "ten",
    "thousand",
    "dot",
    "text",
    "takes",
    "much",
    "longer",
    "complete",
    "nearly",
    "12",
    "seconds",
    "according",
    "real",
    "time",
    "measurement",
    "said",
    "real",
    "result",
    "often",
    "skewed",
    "let",
    "disregard",
    "add",
    "user",
    "cis",
    "runtimes",
    "together",
    "get",
    "6",
    "seconds",
    "time",
    "program",
    "complete",
    "vary",
    "little",
    "bit",
    "time",
    "run",
    "operations",
    "usually",
    "wo",
    "change",
    "fraction",
    "second",
    "run",
    "selection",
    "sort",
    "script",
    "file",
    "see",
    "completes",
    "roughly",
    "time",
    "let",
    "try",
    "another",
    "file",
    "1",
    "million",
    "numbers",
    "time",
    "python",
    "selection",
    "sort",
    "dot",
    "pi",
    "numbers",
    "1",
    "million",
    "dot",
    "text",
    "long",
    "one",
    "take",
    "even",
    "know",
    "designing",
    "course",
    "tried",
    "running",
    "command",
    "workspace",
    "connection",
    "timed",
    "completed",
    "say",
    "selection",
    "sort",
    "takes",
    "long",
    "time",
    "sort",
    "million",
    "numbers",
    "going",
    "sort",
    "list",
    "big",
    "going",
    "need",
    "faster",
    "algorithm",
    "look",
    "alternative",
    "sorting",
    "algorithms",
    "shortly",
    "next",
    "two",
    "sorting",
    "algorithms",
    "look",
    "rely",
    "recursion",
    "ability",
    "function",
    "call",
    "move",
    "need",
    "show",
    "recursion",
    "works",
    "recursive",
    "functions",
    "tricky",
    "understand",
    "imagine",
    "row",
    "dominoes",
    "stood",
    "end",
    "one",
    "domino",
    "falling",
    "causes",
    "next",
    "domino",
    "fall",
    "causes",
    "next",
    "domino",
    "fall",
    "causing",
    "chain",
    "reaction",
    "kind",
    "like",
    "let",
    "suppose",
    "need",
    "write",
    "function",
    "adds",
    "together",
    "numbers",
    "array",
    "case",
    "python",
    "list",
    "normally",
    "probably",
    "use",
    "loop",
    "sort",
    "operation",
    "function",
    "takes",
    "list",
    "numbers",
    "want",
    "add",
    "total",
    "starts",
    "zero",
    "loop",
    "every",
    "number",
    "contained",
    "list",
    "add",
    "current",
    "number",
    "total",
    "done",
    "looping",
    "return",
    "accumulated",
    "total",
    "call",
    "sum",
    "function",
    "list",
    "numbers",
    "return",
    "total",
    "run",
    "program",
    "print",
    "return",
    "value",
    "let",
    "try",
    "real",
    "quick",
    "python",
    "oh",
    "whoops",
    "must",
    "forget",
    "save",
    "work",
    "run",
    "see",
    "result",
    "demonstrate",
    "recursion",
    "works",
    "let",
    "revise",
    "sum",
    "function",
    "use",
    "recursion",
    "instead",
    "note",
    "recursion",
    "efficient",
    "way",
    "add",
    "list",
    "numbers",
    "together",
    "good",
    "problem",
    "use",
    "demonstrate",
    "recursion",
    "simple",
    "one",
    "thing",
    "show",
    "recursive",
    "version",
    "though",
    "example",
    "going",
    "use",
    "python",
    "slice",
    "syntax",
    "need",
    "take",
    "moment",
    "explain",
    "familiar",
    "slice",
    "way",
    "get",
    "series",
    "values",
    "list",
    "let",
    "load",
    "python",
    "repel",
    "read",
    "evaluate",
    "print",
    "loop",
    "demonstrate",
    "start",
    "creating",
    "list",
    "numbers",
    "work",
    "numbers",
    "equals",
    "list",
    "0",
    "1",
    "2",
    "3",
    "4",
    "containing",
    "numbers",
    "like",
    "arrays",
    "languages",
    "python",
    "list",
    "indexes",
    "start",
    "0",
    "numbers",
    "1",
    "actually",
    "get",
    "second",
    "item",
    "list",
    "slice",
    "notation",
    "actually",
    "get",
    "several",
    "items",
    "back",
    "looks",
    "like",
    "accessing",
    "individual",
    "index",
    "list",
    "type",
    "colon",
    "followed",
    "list",
    "index",
    "want",
    "including",
    "numbers",
    "1",
    "colon",
    "4",
    "would",
    "get",
    "us",
    "second",
    "including",
    "fifth",
    "items",
    "list",
    "get",
    "us",
    "second",
    "fourth",
    "items",
    "know",
    "thinking",
    "right",
    "including",
    "rule",
    "little",
    "counterintuitive",
    "forget",
    "wo",
    "using",
    "second",
    "index",
    "python",
    "slice",
    "operations",
    "course",
    "using",
    "leave",
    "second",
    "index",
    "python",
    "slice",
    "gives",
    "items",
    "first",
    "index",
    "end",
    "list",
    "wherever",
    "numbers",
    "1",
    "colon",
    "index",
    "following",
    "give",
    "us",
    "items",
    "second",
    "index",
    "end",
    "list",
    "numbers",
    "2",
    "colon",
    "give",
    "us",
    "items",
    "third",
    "index",
    "end",
    "list",
    "also",
    "leave",
    "first",
    "index",
    "get",
    "everything",
    "beginning",
    "list",
    "numbers",
    "colon",
    "3",
    "get",
    "us",
    "everything",
    "beginning",
    "list",
    "including",
    "third",
    "index",
    "also",
    "worth",
    "noting",
    "take",
    "list",
    "one",
    "item",
    "try",
    "get",
    "everything",
    "second",
    "item",
    "onwards",
    "result",
    "empty",
    "list",
    "create",
    "list",
    "one",
    "item",
    "try",
    "access",
    "second",
    "element",
    "onwards",
    "second",
    "element",
    "exist",
    "result",
    "empty",
    "list",
    "worry",
    "much",
    "remembering",
    "python",
    "slice",
    "syntax",
    "essential",
    "part",
    "sorting",
    "algorithms",
    "recursion",
    "explaining",
    "help",
    "read",
    "code",
    "see",
    "going",
    "exit",
    "python",
    "rebel",
    "covered",
    "recursion",
    "convert",
    "sum",
    "function",
    "recursive",
    "function",
    "take",
    "list",
    "numbers",
    "add",
    "like",
    "recursive",
    "part",
    "sum",
    "function",
    "call",
    "use",
    "slice",
    "notation",
    "pass",
    "entire",
    "list",
    "numbers",
    "except",
    "first",
    "one",
    "add",
    "first",
    "number",
    "list",
    "result",
    "recursive",
    "function",
    "call",
    "return",
    "result",
    "call",
    "sum",
    "four",
    "numbers",
    "first",
    "call",
    "remaining",
    "three",
    "numbers",
    "call",
    "sum",
    "call",
    "remaining",
    "two",
    "numbers",
    "save",
    "try",
    "run",
    "well",
    "first",
    "get",
    "syntax",
    "error",
    "looks",
    "like",
    "accidentally",
    "indented",
    "something",
    "let",
    "go",
    "fix",
    "real",
    "quick",
    "go",
    "suggested",
    "python",
    "loop",
    "something",
    "let",
    "go",
    "back",
    "terminal",
    "try",
    "running",
    "go",
    "getting",
    "error",
    "expecting",
    "recursion",
    "error",
    "maximum",
    "recursion",
    "depth",
    "exceeded",
    "happens",
    "gets",
    "infinite",
    "loop",
    "keeps",
    "calling",
    "reason",
    "get",
    "list",
    "one",
    "element",
    "take",
    "slice",
    "second",
    "element",
    "end",
    "result",
    "empty",
    "list",
    "empty",
    "list",
    "gets",
    "passed",
    "recursive",
    "call",
    "sum",
    "passes",
    "empty",
    "list",
    "recursive",
    "call",
    "sum",
    "python",
    "interpreter",
    "detects",
    "many",
    "recursive",
    "calls",
    "shuts",
    "program",
    "need",
    "add",
    "base",
    "case",
    "recursive",
    "function",
    "condition",
    "recursion",
    "stops",
    "keep",
    "getting",
    "infinite",
    "loop",
    "sum",
    "function",
    "base",
    "case",
    "elements",
    "left",
    "list",
    "case",
    "nothing",
    "left",
    "add",
    "recursion",
    "stop",
    "base",
    "case",
    "alternative",
    "recursive",
    "case",
    "condition",
    "recursion",
    "occur",
    "sum",
    "function",
    "recursive",
    "case",
    "still",
    "elements",
    "list",
    "add",
    "together",
    "let",
    "add",
    "base",
    "case",
    "top",
    "function",
    "python",
    "treats",
    "list",
    "contains",
    "one",
    "values",
    "true",
    "value",
    "treats",
    "list",
    "containing",
    "values",
    "false",
    "value",
    "add",
    "statement",
    "says",
    "numbers",
    "list",
    "return",
    "sum",
    "zero",
    "way",
    "function",
    "exit",
    "immediately",
    "without",
    "making",
    "recursive",
    "calls",
    "leave",
    "code",
    "recursive",
    "case",
    "unchanged",
    "still",
    "numbers",
    "list",
    "function",
    "call",
    "numbers",
    "first",
    "add",
    "return",
    "value",
    "first",
    "number",
    "list",
    "let",
    "save",
    "try",
    "running",
    "python",
    "recursion",
    "dot",
    "pi",
    "output",
    "sum",
    "numbers",
    "list",
    "19",
    "still",
    "really",
    "clear",
    "worked",
    "let",
    "add",
    "couple",
    "print",
    "statements",
    "show",
    "us",
    "show",
    "recursive",
    "call",
    "sum",
    "called",
    "also",
    "add",
    "call",
    "print",
    "right",
    "return",
    "showing",
    "calls",
    "sum",
    "returning",
    "returning",
    "let",
    "save",
    "resize",
    "console",
    "bit",
    "let",
    "try",
    "running",
    "python",
    "since",
    "print",
    "calls",
    "inside",
    "sum",
    "function",
    "first",
    "call",
    "sum",
    "1279",
    "shown",
    "recursive",
    "calls",
    "first",
    "call",
    "sum",
    "ignores",
    "first",
    "item",
    "list",
    "1",
    "calls",
    "recursively",
    "passes",
    "remaining",
    "items",
    "list",
    "2",
    "7",
    "call",
    "sum",
    "ignores",
    "first",
    "item",
    "list",
    "receives",
    "2",
    "calls",
    "recursively",
    "passes",
    "remaining",
    "items",
    "list",
    "7",
    "call",
    "ignores",
    "7",
    "calls",
    "9",
    "last",
    "call",
    "shown",
    "ignores",
    "9",
    "calls",
    "empty",
    "list",
    "point",
    "none",
    "recursive",
    "calls",
    "sum",
    "returned",
    "yet",
    "waiting",
    "recursive",
    "call",
    "made",
    "sum",
    "complete",
    "python",
    "programming",
    "languages",
    "use",
    "something",
    "called",
    "call",
    "stack",
    "keep",
    "track",
    "series",
    "function",
    "calls",
    "function",
    "call",
    "added",
    "stack",
    "along",
    "place",
    "code",
    "needs",
    "return",
    "completes",
    "empty",
    "list",
    "triggers",
    "base",
    "case",
    "causing",
    "recursion",
    "end",
    "sum",
    "function",
    "return",
    "zero",
    "zero",
    "value",
    "returned",
    "caller",
    "caller",
    "adds",
    "zero",
    "first",
    "value",
    "list",
    "nine",
    "result",
    "nine",
    "nine",
    "value",
    "gets",
    "returned",
    "caller",
    "adds",
    "first",
    "value",
    "list",
    "received",
    "seven",
    "result",
    "sixteen",
    "sixteen",
    "value",
    "returned",
    "caller",
    "adds",
    "first",
    "value",
    "list",
    "received",
    "two",
    "result",
    "18",
    "value",
    "returned",
    "caller",
    "adds",
    "first",
    "value",
    "list",
    "received",
    "one",
    "result",
    "19",
    "value",
    "returned",
    "caller",
    "sum",
    "function",
    "recursively",
    "calling",
    "main",
    "program",
    "final",
    "result",
    "gets",
    "printed",
    "result",
    "got",
    "version",
    "program",
    "end",
    "want",
    "print",
    "statements",
    "final",
    "version",
    "program",
    "let",
    "delete",
    "real",
    "quick",
    "simple",
    "recursive",
    "function",
    "well",
    "function",
    "simple",
    "see",
    "flow",
    "control",
    "complex",
    "worry",
    "understand",
    "every",
    "detail",
    "wo",
    "using",
    "particular",
    "example",
    "two",
    "fundamental",
    "mechanisms",
    "need",
    "remember",
    "recursive",
    "function",
    "needs",
    "recursive",
    "case",
    "causes",
    "call",
    "also",
    "needs",
    "eventually",
    "reach",
    "base",
    "case",
    "causes",
    "recursion",
    "stop",
    "seen",
    "bogo",
    "sort",
    "make",
    "progress",
    "towards",
    "sorting",
    "list",
    "pass",
    "either",
    "entirely",
    "sorted",
    "seen",
    "selection",
    "sort",
    "moves",
    "one",
    "value",
    "sorted",
    "list",
    "pass",
    "fewer",
    "items",
    "compare",
    "time",
    "let",
    "look",
    "algorithm",
    "speeds",
    "process",
    "reducing",
    "number",
    "comparisons",
    "makes",
    "called",
    "quick",
    "sort",
    "python",
    "code",
    "implement",
    "quick",
    "sort",
    "ignore",
    "lines",
    "top",
    "using",
    "load",
    "file",
    "full",
    "numbers",
    "list",
    "quick",
    "sort",
    "algorithm",
    "relies",
    "recursion",
    "implement",
    "write",
    "recursive",
    "function",
    "accept",
    "list",
    "numbers",
    "sort",
    "parameter",
    "quicksort",
    "recursive",
    "keeps",
    "calling",
    "smaller",
    "smaller",
    "subsets",
    "list",
    "trying",
    "sort",
    "going",
    "need",
    "base",
    "case",
    "recursion",
    "stops",
    "enter",
    "infinite",
    "loop",
    "lists",
    "empty",
    "need",
    "sorted",
    "lists",
    "one",
    "element",
    "need",
    "sorted",
    "either",
    "cases",
    "nothing",
    "flip",
    "around",
    "make",
    "base",
    "case",
    "zero",
    "one",
    "elements",
    "list",
    "passed",
    "quick",
    "sort",
    "function",
    "return",
    "unaltered",
    "list",
    "caller",
    "lastly",
    "need",
    "call",
    "quick",
    "sort",
    "function",
    "list",
    "numbers",
    "print",
    "list",
    "returns",
    "takes",
    "care",
    "base",
    "case",
    "need",
    "recursive",
    "case",
    "going",
    "rely",
    "technique",
    "common",
    "algorithm",
    "design",
    "called",
    "divide",
    "conquer",
    "basically",
    "going",
    "take",
    "problem",
    "split",
    "smaller",
    "smaller",
    "problems",
    "easy",
    "solve",
    "case",
    "means",
    "taking",
    "list",
    "splitting",
    "smaller",
    "lists",
    "viewers",
    "suggestion",
    "process",
    "describe",
    "complex",
    "way",
    "around",
    "trouble",
    "following",
    "along",
    "remember",
    "video",
    "playback",
    "controls",
    "feel",
    "free",
    "slow",
    "play",
    "back",
    "rewind",
    "pause",
    "video",
    "needed",
    "watch",
    "first",
    "time",
    "may",
    "also",
    "find",
    "helpful",
    "rewind",
    "make",
    "diagram",
    "process",
    "go",
    "okay",
    "ready",
    "goes",
    "suppose",
    "load",
    "numbers",
    "file",
    "list",
    "divide",
    "would",
    "probably",
    "smart",
    "quicksort",
    "function",
    "divide",
    "list",
    "way",
    "brings",
    "closer",
    "sorted",
    "let",
    "pick",
    "item",
    "list",
    "pick",
    "first",
    "item",
    "four",
    "call",
    "value",
    "picked",
    "pivot",
    "like",
    "center",
    "seesaw",
    "playground",
    "break",
    "list",
    "two",
    "sublists",
    "first",
    "contain",
    "items",
    "original",
    "list",
    "smaller",
    "pivot",
    "second",
    "contain",
    "items",
    "original",
    "list",
    "greater",
    "pivot",
    "sub",
    "list",
    "values",
    "less",
    "greater",
    "pivot",
    "sorted",
    "could",
    "join",
    "sub",
    "lists",
    "pivot",
    "together",
    "one",
    "list",
    "whole",
    "thing",
    "would",
    "sorted",
    "sort",
    "sublist",
    "call",
    "quick",
    "sort",
    "function",
    "recursively",
    "may",
    "seem",
    "like",
    "magic",
    "divide",
    "conquer",
    "algorithm",
    "design",
    "technique",
    "work",
    "quick",
    "sort",
    "function",
    "works",
    "big",
    "list",
    "work",
    "smaller",
    "list",
    "first",
    "sub",
    "list",
    "take",
    "first",
    "item",
    "pivot",
    "three",
    "break",
    "sub",
    "list",
    "two",
    "sub",
    "lists",
    "one",
    "everything",
    "less",
    "pivot",
    "one",
    "everything",
    "greater",
    "pivot",
    "notice",
    "value",
    "equal",
    "pivot",
    "gets",
    "put",
    "less",
    "finished",
    "quicksort",
    "function",
    "actually",
    "going",
    "put",
    "everything",
    "less",
    "equal",
    "pivot",
    "first",
    "want",
    "say",
    "less",
    "equal",
    "referring",
    "less",
    "pivot",
    "also",
    "notice",
    "values",
    "greater",
    "pivot",
    "okay",
    "join",
    "back",
    "together",
    "means",
    "nothing",
    "return",
    "list",
    "pivot",
    "still",
    "one",
    "sub",
    "list",
    "one",
    "element",
    "long",
    "call",
    "quick",
    "sort",
    "function",
    "see",
    "already",
    "sorted",
    "computer",
    "know",
    "call",
    "anyway",
    "case",
    "picks",
    "first",
    "element",
    "2",
    "pivot",
    "elements",
    "less",
    "pivot",
    "one",
    "element",
    "greater",
    "pivot",
    "recursive",
    "case",
    "finally",
    "hit",
    "base",
    "case",
    "quick",
    "sort",
    "function",
    "called",
    "empty",
    "list",
    "elements",
    "less",
    "pivot",
    "one",
    "item",
    "list",
    "elements",
    "greater",
    "pivot",
    "lists",
    "returned",
    "nothing",
    "sort",
    "level",
    "call",
    "stack",
    "return",
    "sorted",
    "lists",
    "used",
    "place",
    "unsorted",
    "less",
    "pivot",
    "unsorted",
    "greater",
    "pivot",
    "joined",
    "together",
    "one",
    "sorted",
    "list",
    "remember",
    "empty",
    "lists",
    "get",
    "discarded",
    "level",
    "call",
    "stack",
    "return",
    "sorted",
    "lists",
    "used",
    "place",
    "unsorted",
    "already",
    "sorted",
    "quick",
    "sort",
    "method",
    "called",
    "anyway",
    "case",
    "joined",
    "together",
    "one",
    "sorted",
    "list",
    "level",
    "call",
    "stack",
    "return",
    "sorted",
    "list",
    "used",
    "place",
    "unsorted",
    "less",
    "pivot",
    "everything",
    "less",
    "equal",
    "pivot",
    "sorted",
    "call",
    "quick",
    "sort",
    "unsorted",
    "greater",
    "pivot",
    "process",
    "repeats",
    "pick",
    "first",
    "element",
    "six",
    "pivot",
    "split",
    "elements",
    "less",
    "greater",
    "pivot",
    "recursively",
    "call",
    "quicksort",
    "function",
    "sorted",
    "eventually",
    "sorted",
    "returned",
    "first",
    "quick",
    "sort",
    "function",
    "call",
    "combine",
    "less",
    "equal",
    "pivot",
    "pivot",
    "greater",
    "pivot",
    "single",
    "list",
    "recursively",
    "sorted",
    "sub",
    "lists",
    "whole",
    "list",
    "sorted",
    "quick",
    "sort",
    "function",
    "going",
    "work",
    "next",
    "video",
    "show",
    "actual",
    "code",
    "quicksort",
    "works",
    "picking",
    "pivot",
    "value",
    "splitting",
    "full",
    "list",
    "two",
    "first",
    "values",
    "less",
    "equal",
    "pivot",
    "second",
    "values",
    "greater",
    "pivot",
    "quick",
    "sort",
    "function",
    "recursively",
    "calls",
    "sort",
    "sort",
    "full",
    "list",
    "sorted",
    "time",
    "actually",
    "implement",
    "code",
    "already",
    "base",
    "case",
    "written",
    "list",
    "passed",
    "consists",
    "0",
    "1",
    "values",
    "returned",
    "nothing",
    "sort",
    "need",
    "create",
    "list",
    "hold",
    "values",
    "less",
    "pivot",
    "list",
    "empty",
    "first",
    "values",
    "greater",
    "pivot",
    "next",
    "need",
    "choose",
    "pivot",
    "value",
    "grab",
    "first",
    "item",
    "list",
    "loop",
    "items",
    "list",
    "following",
    "pivot",
    "check",
    "see",
    "whether",
    "current",
    "value",
    "less",
    "equal",
    "pivot",
    "copy",
    "values",
    "less",
    "pivot",
    "otherwise",
    "current",
    "value",
    "must",
    "greater",
    "pivot",
    "copy",
    "list",
    "last",
    "line",
    "recursive",
    "magic",
    "happens",
    "call",
    "quick",
    "sort",
    "recursively",
    "less",
    "pivot",
    "greater",
    "pivot",
    "two",
    "calls",
    "return",
    "sorted",
    "lists",
    "combine",
    "sort",
    "values",
    "less",
    "pivot",
    "pivot",
    "sort",
    "values",
    "greater",
    "pivot",
    "gives",
    "us",
    "complete",
    "sorted",
    "list",
    "return",
    "took",
    "lot",
    "prep",
    "work",
    "ready",
    "let",
    "try",
    "running",
    "python",
    "quick",
    "sort",
    "dot",
    "pi",
    "numbers",
    "outputs",
    "sorted",
    "list",
    "know",
    "whole",
    "thing",
    "still",
    "seems",
    "little",
    "magical",
    "let",
    "add",
    "couple",
    "print",
    "statements",
    "program",
    "see",
    "first",
    "add",
    "print",
    "statement",
    "right",
    "first",
    "call",
    "quick",
    "sort",
    "function",
    "see",
    "unsorted",
    "list",
    "also",
    "add",
    "print",
    "right",
    "within",
    "quick",
    "sort",
    "function",
    "right",
    "recursive",
    "calls",
    "string",
    "formatting",
    "code",
    "keep",
    "info",
    "aligned",
    "columns",
    "let",
    "try",
    "running",
    "see",
    "new",
    "debug",
    "output",
    "time",
    "quicksort",
    "goes",
    "call",
    "recursively",
    "prints",
    "pivot",
    "well",
    "sub",
    "list",
    "items",
    "less",
    "equal",
    "pivot",
    "sub",
    "list",
    "items",
    "greater",
    "pivot",
    "see",
    "first",
    "sorts",
    "sub",
    "list",
    "items",
    "less",
    "pivot",
    "top",
    "level",
    "goes",
    "couple",
    "levels",
    "recursion",
    "actually",
    "additional",
    "levels",
    "recursion",
    "calls",
    "quick",
    "sort",
    "list",
    "0",
    "1",
    "elements",
    "calls",
    "return",
    "print",
    "statement",
    "reached",
    "starts",
    "sorting",
    "second",
    "sub",
    "list",
    "top",
    "level",
    "items",
    "greater",
    "original",
    "pivot",
    "see",
    "couple",
    "levels",
    "recursion",
    "sort",
    "well",
    "finally",
    "sublists",
    "recursively",
    "sorted",
    "original",
    "call",
    "quicksort",
    "function",
    "returns",
    "get",
    "sorted",
    "list",
    "back",
    "know",
    "works",
    "next",
    "question",
    "well",
    "work",
    "let",
    "go",
    "back",
    "file",
    "ten",
    "thousand",
    "numbers",
    "see",
    "sort",
    "first",
    "though",
    "going",
    "remove",
    "two",
    "debug",
    "calls",
    "print",
    "produce",
    "unreadable",
    "output",
    "quick",
    "note",
    "try",
    "running",
    "file",
    "lot",
    "repeated",
    "values",
    "possible",
    "get",
    "runtime",
    "error",
    "maximum",
    "recursion",
    "depth",
    "exceeded",
    "see",
    "teacher",
    "notes",
    "possible",
    "solution",
    "let",
    "try",
    "running",
    "quick",
    "sort",
    "program",
    "ten",
    "thousand",
    "dot",
    "text",
    "file",
    "python",
    "quick",
    "sort",
    "dot",
    "pi",
    "numbers",
    "10",
    "000",
    "dot",
    "text",
    "go",
    "seems",
    "pretty",
    "fast",
    "fast",
    "exactly",
    "let",
    "run",
    "time",
    "command",
    "see",
    "long",
    "takes",
    "time",
    "python",
    "quick",
    "sort",
    "dot",
    "pi",
    "numbers",
    "10",
    "remember",
    "need",
    "ignore",
    "real",
    "result",
    "add",
    "user",
    "sys",
    "results",
    "took",
    "less",
    "second",
    "cpu",
    "time",
    "sort",
    "10",
    "000",
    "numbers",
    "quicksort",
    "remember",
    "selection",
    "sort",
    "took",
    "13",
    "seconds",
    "pretty",
    "substantial",
    "improvement",
    "million",
    "numbers",
    "selection",
    "sort",
    "took",
    "long",
    "never",
    "even",
    "finished",
    "successfully",
    "let",
    "see",
    "quicksort",
    "performs",
    "better",
    "time",
    "python",
    "quick",
    "sort",
    "dot",
    "pi",
    "numbers",
    "1",
    "million",
    "dot",
    "text",
    "quicksort",
    "sort",
    "million",
    "numbers",
    "successfully",
    "took",
    "11",
    "seconds",
    "cpu",
    "time",
    "quicksort",
    "clearly",
    "much",
    "much",
    "faster",
    "selection",
    "sort",
    "much",
    "faster",
    "something",
    "discuss",
    "later",
    "video",
    "shown",
    "one",
    "way",
    "implement",
    "quicksort",
    "although",
    "basic",
    "algorithm",
    "always",
    "details",
    "vary",
    "like",
    "pick",
    "pivot",
    "see",
    "teacher",
    "notes",
    "details",
    "let",
    "review",
    "another",
    "sorting",
    "algorithm",
    "merge",
    "sort",
    "compare",
    "quick",
    "sort",
    "merge",
    "sort",
    "already",
    "covered",
    "elsewhere",
    "site",
    "wo",
    "go",
    "much",
    "detail",
    "info",
    "teacher",
    "notes",
    "want",
    "quicksort",
    "merge",
    "sword",
    "recursive",
    "difference",
    "sorting",
    "mechanism",
    "whereas",
    "quicksort",
    "sorts",
    "list",
    "two",
    "less",
    "greater",
    "pivot",
    "value",
    "merge",
    "sort",
    "simply",
    "splits",
    "list",
    "half",
    "recursively",
    "sorts",
    "halves",
    "merges",
    "back",
    "together",
    "called",
    "merge",
    "sort",
    "may",
    "recognize",
    "code",
    "top",
    "loads",
    "file",
    "full",
    "numbers",
    "list",
    "let",
    "define",
    "recursive",
    "merge",
    "sort",
    "function",
    "usual",
    "take",
    "list",
    "want",
    "sort",
    "base",
    "case",
    "quicksort",
    "list",
    "zero",
    "one",
    "values",
    "nothing",
    "sort",
    "return",
    "return",
    "means",
    "recursive",
    "case",
    "first",
    "need",
    "split",
    "list",
    "half",
    "need",
    "know",
    "index",
    "split",
    "get",
    "length",
    "list",
    "divide",
    "two",
    "example",
    "eight",
    "items",
    "list",
    "want",
    "index",
    "four",
    "odd",
    "number",
    "items",
    "list",
    "like",
    "seven",
    "ca",
    "index",
    "need",
    "round",
    "case",
    "since",
    "working",
    "python",
    "currently",
    "take",
    "advantage",
    "special",
    "python",
    "operator",
    "divides",
    "rounds",
    "result",
    "floor",
    "division",
    "operator",
    "consists",
    "double",
    "slash",
    "use",
    "python",
    "slice",
    "syntax",
    "get",
    "left",
    "half",
    "list",
    "pass",
    "list",
    "recursive",
    "call",
    "merge",
    "sort",
    "function",
    "also",
    "use",
    "slice",
    "syntax",
    "get",
    "right",
    "half",
    "list",
    "pass",
    "merge",
    "sort",
    "well",
    "need",
    "merge",
    "two",
    "halves",
    "together",
    "sort",
    "create",
    "list",
    "hold",
    "sorted",
    "values",
    "get",
    "complicated",
    "part",
    "merging",
    "two",
    "halves",
    "together",
    "sorted",
    "moving",
    "left",
    "right",
    "left",
    "half",
    "list",
    "copying",
    "values",
    "sorted",
    "values",
    "list",
    "go",
    "left",
    "index",
    "variable",
    "help",
    "us",
    "keep",
    "track",
    "position",
    "time",
    "also",
    "moving",
    "left",
    "right",
    "right",
    "half",
    "list",
    "copying",
    "values",
    "need",
    "separate",
    "write",
    "index",
    "variable",
    "track",
    "position",
    "well",
    "keep",
    "looping",
    "processed",
    "values",
    "halves",
    "list",
    "looking",
    "copy",
    "lowest",
    "values",
    "first",
    "first",
    "test",
    "whether",
    "current",
    "value",
    "left",
    "side",
    "less",
    "value",
    "right",
    "side",
    "left",
    "side",
    "value",
    "less",
    "copy",
    "sorted",
    "list",
    "move",
    "next",
    "value",
    "left",
    "half",
    "list",
    "otherwise",
    "current",
    "value",
    "right",
    "half",
    "must",
    "lower",
    "copy",
    "value",
    "sorted",
    "list",
    "instead",
    "move",
    "next",
    "value",
    "right",
    "half",
    "list",
    "ends",
    "loop",
    "point",
    "one",
    "two",
    "unsorted",
    "halves",
    "still",
    "value",
    "remaining",
    "empty",
    "wo",
    "waste",
    "time",
    "checking",
    "copy",
    "remainder",
    "lists",
    "sorted",
    "list",
    "one",
    "value",
    "left",
    "add",
    "value",
    "empty",
    "one",
    "add",
    "nothing",
    "numbers",
    "halves",
    "copied",
    "sorted",
    "list",
    "return",
    "finally",
    "need",
    "kick",
    "whole",
    "process",
    "call",
    "merge",
    "sort",
    "function",
    "list",
    "numbers",
    "loaded",
    "print",
    "result",
    "let",
    "save",
    "try",
    "file",
    "eight",
    "numbers",
    "python",
    "merge",
    "sort",
    "dot",
    "pi",
    "numbers",
    "eight",
    "dot",
    "text",
    "prints",
    "sorted",
    "list",
    "seems",
    "pretty",
    "magical",
    "let",
    "add",
    "print",
    "statements",
    "get",
    "insight",
    "first",
    "print",
    "unsorted",
    "list",
    "refer",
    "add",
    "print",
    "statement",
    "right",
    "call",
    "merge",
    "sort",
    "function",
    "first",
    "time",
    "add",
    "another",
    "print",
    "statement",
    "within",
    "merge",
    "sort",
    "function",
    "right",
    "recursive",
    "calls",
    "show",
    "us",
    "sorted",
    "left",
    "half",
    "right",
    "half",
    "returning",
    "worry",
    "fancy",
    "python",
    "formatting",
    "string",
    "keeps",
    "values",
    "neatly",
    "aligned",
    "let",
    "resize",
    "console",
    "clear",
    "screen",
    "try",
    "running",
    "seeing",
    "values",
    "returned",
    "recursive",
    "merge",
    "sort",
    "function",
    "calls",
    "original",
    "calls",
    "merge",
    "sort",
    "see",
    "reach",
    "base",
    "case",
    "list",
    "one",
    "item",
    "length",
    "recursive",
    "calls",
    "start",
    "returning",
    "original",
    "list",
    "gets",
    "split",
    "two",
    "unsorted",
    "halves",
    "four",
    "six",
    "three",
    "two",
    "nine",
    "seven",
    "three",
    "five",
    "first",
    "half",
    "gets",
    "split",
    "half",
    "four",
    "six",
    "three",
    "two",
    "halves",
    "halved",
    "single",
    "element",
    "lists",
    "nothing",
    "sort",
    "single",
    "element",
    "list",
    "returned",
    "merge",
    "sort",
    "function",
    "single",
    "element",
    "lists",
    "get",
    "merged",
    "two",
    "sub",
    "lists",
    "sorted",
    "four",
    "six",
    "looks",
    "sorting",
    "sorting",
    "three",
    "two",
    "get",
    "sorted",
    "combined",
    "new",
    "order",
    "two",
    "three",
    "order",
    "shifted",
    "two",
    "get",
    "combined",
    "back",
    "single",
    "list",
    "two",
    "three",
    "four",
    "six",
    "recursively",
    "sort",
    "right",
    "half",
    "original",
    "list",
    "nine",
    "seven",
    "three",
    "five",
    "gets",
    "split",
    "half",
    "nine",
    "seven",
    "three",
    "five",
    "halves",
    "get",
    "broken",
    "single",
    "element",
    "lists",
    "nothing",
    "sort",
    "single",
    "element",
    "lists",
    "returned",
    "first",
    "two",
    "sorted",
    "merged",
    "seven",
    "nine",
    "second",
    "three",
    "five",
    "two",
    "sub",
    "lists",
    "get",
    "sorted",
    "combined",
    "another",
    "sub",
    "list",
    "three",
    "five",
    "seven",
    "nine",
    "finally",
    "everything",
    "sorted",
    "merged",
    "back",
    "full",
    "sorted",
    "list",
    "two",
    "three",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "nine",
    "merge",
    "sort",
    "works",
    "list",
    "eight",
    "numbers",
    "let",
    "see",
    "works",
    "bigger",
    "list",
    "first",
    "remove",
    "two",
    "print",
    "statements",
    "get",
    "overwhelming",
    "amount",
    "debug",
    "output",
    "run",
    "list",
    "ten",
    "thousand",
    "items",
    "python",
    "merge",
    "sort",
    "dot",
    "pi",
    "numbers",
    "ten",
    "thousand",
    "dot",
    "text",
    "work",
    "pretty",
    "fast",
    "faster",
    "merge",
    "sort",
    "quick",
    "sort",
    "look",
    "next",
    "removed",
    "call",
    "print",
    "displays",
    "sorted",
    "list",
    "end",
    "selection",
    "sort",
    "quick",
    "sort",
    "merge",
    "sort",
    "scripts",
    "way",
    "still",
    "run",
    "sort",
    "output",
    "wo",
    "get",
    "way",
    "comparing",
    "runtimes",
    "let",
    "try",
    "running",
    "scripts",
    "see",
    "long",
    "takes",
    "time",
    "python",
    "selection",
    "sort",
    "one",
    "first",
    "numbers",
    "10",
    "000",
    "dot",
    "text",
    "combine",
    "user",
    "sys",
    "results",
    "gives",
    "us",
    "six",
    "seconds",
    "let",
    "try",
    "quick",
    "sort",
    "time",
    "python",
    "quick",
    "sort",
    "dot",
    "pi",
    "numbers",
    "ten",
    "thousand",
    "dot",
    "text",
    "much",
    "faster",
    "less",
    "second",
    "finally",
    "time",
    "python",
    "merge",
    "sort",
    "dot",
    "pi",
    "numbers",
    "ten",
    "thousand",
    "dot",
    "text",
    "little",
    "longer",
    "far",
    "less",
    "second",
    "even",
    "list",
    "10",
    "000",
    "numbers",
    "selection",
    "sort",
    "takes",
    "many",
    "times",
    "long",
    "quicksort",
    "merge",
    "sort",
    "remember",
    "ran",
    "selection",
    "sort",
    "script",
    "file",
    "million",
    "numbers",
    "took",
    "long",
    "workspace",
    "timed",
    "completed",
    "looks",
    "like",
    "selection",
    "sort",
    "running",
    "viable",
    "sorting",
    "algorithm",
    "may",
    "easy",
    "understand",
    "implement",
    "slow",
    "handle",
    "huge",
    "data",
    "sets",
    "real",
    "world",
    "let",
    "try",
    "quicksort",
    "merge",
    "sort",
    "file",
    "million",
    "numbers",
    "see",
    "compare",
    "time",
    "python",
    "quicksort",
    "dot",
    "pi",
    "numbers",
    "million",
    "dot",
    "text",
    "looks",
    "like",
    "took",
    "11",
    "seconds",
    "cpu",
    "time",
    "let",
    "try",
    "merge",
    "sort",
    "time",
    "python",
    "merge",
    "sort",
    "dot",
    "pi",
    "numbers",
    "1",
    "million",
    "dot",
    "text",
    "took",
    "15",
    "seconds",
    "cpu",
    "time",
    "looks",
    "like",
    "quicksort",
    "marginally",
    "faster",
    "merge",
    "sort",
    "sample",
    "data",
    "learn",
    "lot",
    "details",
    "algorithm",
    "covered",
    "course",
    "developers",
    "need",
    "implement",
    "algorithms",
    "often",
    "need",
    "choose",
    "algorithm",
    "every",
    "problem",
    "need",
    "solve",
    "often",
    "need",
    "discuss",
    "decisions",
    "developers",
    "imagine",
    "needing",
    "describe",
    "algorithms",
    "level",
    "detail",
    "time",
    "spend",
    "time",
    "meetings",
    "rather",
    "programming",
    "big",
    "notation",
    "created",
    "way",
    "quickly",
    "describing",
    "algorithm",
    "performs",
    "data",
    "set",
    "working",
    "increases",
    "size",
    "big",
    "notation",
    "lets",
    "quickly",
    "compare",
    "several",
    "algorithms",
    "choose",
    "best",
    "one",
    "problem",
    "algorithms",
    "discussed",
    "course",
    "well",
    "known",
    "job",
    "interviewers",
    "going",
    "expect",
    "know",
    "big",
    "run",
    "times",
    "let",
    "look",
    "remember",
    "n",
    "big",
    "notation",
    "refers",
    "number",
    "elements",
    "operating",
    "selection",
    "sort",
    "need",
    "check",
    "item",
    "list",
    "see",
    "lowest",
    "move",
    "sorted",
    "list",
    "operations",
    "suppose",
    "selection",
    "sort",
    "list",
    "five",
    "items",
    "case",
    "would",
    "five",
    "five",
    "operations",
    "move",
    "item",
    "sorted",
    "list",
    "selection",
    "sort",
    "loop",
    "entire",
    "list",
    "item",
    "want",
    "move",
    "five",
    "items",
    "list",
    "five",
    "comparisons",
    "move",
    "one",
    "like",
    "5",
    "times",
    "5",
    "operations",
    "replace",
    "5",
    "n",
    "n",
    "times",
    "n",
    "n",
    "squared",
    "wait",
    "might",
    "say",
    "half",
    "5",
    "5",
    "grid",
    "operations",
    "missing",
    "testing",
    "one",
    "fewer",
    "item",
    "unsorted",
    "list",
    "pass",
    "like",
    "one",
    "half",
    "times",
    "n",
    "times",
    "n",
    "true",
    "full",
    "n",
    "squared",
    "operations",
    "remember",
    "big",
    "notation",
    "value",
    "n",
    "gets",
    "really",
    "big",
    "constants",
    "like",
    "one",
    "half",
    "become",
    "insignificant",
    "discard",
    "big",
    "runtime",
    "selection",
    "sword",
    "widely",
    "recognized",
    "n",
    "squared",
    "quicksort",
    "requires",
    "one",
    "operation",
    "element",
    "list",
    "sorting",
    "needs",
    "select",
    "pivot",
    "first",
    "needs",
    "sort",
    "elements",
    "lists",
    "less",
    "greater",
    "pivot",
    "n",
    "operations",
    "put",
    "another",
    "way",
    "list",
    "eight",
    "items",
    "n",
    "eight",
    "take",
    "eight",
    "operations",
    "split",
    "list",
    "around",
    "pivot",
    "course",
    "list",
    "sorted",
    "splitting",
    "around",
    "pivot",
    "repeat",
    "eight",
    "operations",
    "several",
    "times",
    "best",
    "case",
    "pick",
    "pivot",
    "right",
    "middle",
    "list",
    "dividing",
    "list",
    "exactly",
    "half",
    "keep",
    "dividing",
    "list",
    "half",
    "list",
    "length",
    "one",
    "number",
    "times",
    "need",
    "divide",
    "n",
    "half",
    "reach",
    "one",
    "expressed",
    "log",
    "n",
    "need",
    "repeat",
    "n",
    "sorting",
    "operations",
    "log",
    "n",
    "times",
    "leaves",
    "us",
    "best",
    "case",
    "run",
    "time",
    "quick",
    "sort",
    "n",
    "log",
    "n",
    "best",
    "case",
    "worst",
    "case",
    "well",
    "pick",
    "wrong",
    "pivot",
    "wo",
    "dividing",
    "list",
    "exactly",
    "half",
    "pick",
    "really",
    "bad",
    "pivot",
    "next",
    "recursive",
    "call",
    "quicksort",
    "reduce",
    "list",
    "length",
    "one",
    "since",
    "quicksort",
    "function",
    "simply",
    "picks",
    "first",
    "item",
    "use",
    "pivot",
    "make",
    "pick",
    "worst",
    "possible",
    "pivot",
    "repeatedly",
    "simply",
    "giving",
    "list",
    "sorted",
    "reverse",
    "order",
    "pick",
    "worst",
    "possible",
    "pivot",
    "every",
    "time",
    "split",
    "list",
    "every",
    "item",
    "contains",
    "end",
    "sorting",
    "operations",
    "already",
    "know",
    "another",
    "sorting",
    "algorithm",
    "manages",
    "reduce",
    "list",
    "one",
    "element",
    "pass",
    "selection",
    "sort",
    "selection",
    "sort",
    "runtime",
    "n",
    "squared",
    "worst",
    "case",
    "run",
    "time",
    "quicksort",
    "well",
    "consider",
    "trying",
    "decide",
    "whether",
    "use",
    "quicksort",
    "best",
    "case",
    "worst",
    "case",
    "well",
    "long",
    "implementation",
    "pick",
    "first",
    "item",
    "pivot",
    "could",
    "demonstrate",
    "issue",
    "turns",
    "average",
    "quicksort",
    "performs",
    "closer",
    "best",
    "case",
    "many",
    "quicksort",
    "implementations",
    "accomplish",
    "simply",
    "picking",
    "pivot",
    "random",
    "recursive",
    "loop",
    "sorting",
    "reverse",
    "sorted",
    "data",
    "time",
    "pick",
    "pivots",
    "random",
    "reduces",
    "number",
    "recursive",
    "operations",
    "needed",
    "sure",
    "random",
    "pivots",
    "sometimes",
    "give",
    "best",
    "case",
    "sometimes",
    "randomly",
    "get",
    "worst",
    "case",
    "averages",
    "multiple",
    "calls",
    "quick",
    "sort",
    "function",
    "merge",
    "sort",
    "pivot",
    "pick",
    "list",
    "n",
    "items",
    "always",
    "gets",
    "divided",
    "half",
    "log",
    "n",
    "times",
    "means",
    "merged",
    "sort",
    "always",
    "big",
    "runtime",
    "log",
    "contrast",
    "quicksort",
    "runtime",
    "log",
    "n",
    "best",
    "case",
    "worst",
    "case",
    "quick",
    "sorts",
    "runtime",
    "n",
    "squared",
    "yet",
    "real",
    "world",
    "quicksort",
    "commonly",
    "used",
    "merge",
    "sort",
    "quicksort",
    "big",
    "runtime",
    "sometimes",
    "worse",
    "merge",
    "sorts",
    "one",
    "situations",
    "big",
    "notation",
    "tell",
    "whole",
    "story",
    "big",
    "tell",
    "number",
    "times",
    "operation",
    "performed",
    "describe",
    "long",
    "operation",
    "takes",
    "operation",
    "mergesor",
    "performs",
    "repeatedly",
    "takes",
    "longer",
    "operation",
    "quicksort",
    "performs",
    "repeatedly",
    "useful",
    "tool",
    "quickly",
    "describing",
    "runtime",
    "algorithm",
    "increases",
    "data",
    "set",
    "operating",
    "gets",
    "really",
    "really",
    "big",
    "ca",
    "always",
    "choose",
    "two",
    "algorithms",
    "based",
    "big",
    "runtimes",
    "sometimes",
    "additional",
    "info",
    "need",
    "know",
    "algorithm",
    "make",
    "good",
    "decision",
    "sort",
    "list",
    "items",
    "well",
    "way",
    "able",
    "search",
    "list",
    "efficiently",
    "well",
    "look",
    "next",
    "stage",
    "music",
    "covered",
    "sorting",
    "algorithms",
    "groundwork",
    "laid",
    "talk",
    "searching",
    "algorithms",
    "need",
    "search",
    "unsorted",
    "list",
    "items",
    "binary",
    "search",
    "option",
    "idea",
    "half",
    "list",
    "contains",
    "item",
    "looking",
    "real",
    "option",
    "start",
    "beginning",
    "compare",
    "item",
    "list",
    "target",
    "value",
    "one",
    "time",
    "find",
    "value",
    "looking",
    "algorithm",
    "called",
    "linear",
    "search",
    "sequential",
    "search",
    "search",
    "proceeds",
    "straight",
    "line",
    "sequence",
    "even",
    "though",
    "linear",
    "search",
    "inefficient",
    "searching",
    "one",
    "name",
    "happen",
    "fast",
    "wo",
    "able",
    "tell",
    "anything",
    "useful",
    "algorithm",
    "runtime",
    "let",
    "suppose",
    "hundred",
    "different",
    "names",
    "needed",
    "know",
    "appear",
    "list",
    "unsorted",
    "names",
    "code",
    "demonstrates",
    "usual",
    "code",
    "top",
    "relevant",
    "search",
    "algorithm",
    "like",
    "code",
    "loaded",
    "list",
    "numbers",
    "file",
    "previous",
    "stage",
    "code",
    "calls",
    "different",
    "function",
    "load",
    "strings",
    "loads",
    "list",
    "strings",
    "want",
    "load",
    "strings",
    "python",
    "code",
    "teacher",
    "notes",
    "separate",
    "list",
    "containing",
    "100",
    "names",
    "going",
    "search",
    "loop",
    "name",
    "list",
    "pass",
    "search",
    "function",
    "get",
    "index",
    "within",
    "full",
    "list",
    "appears",
    "let",
    "implement",
    "search",
    "function",
    "compared",
    "sorting",
    "algorithms",
    "going",
    "short",
    "index",
    "item",
    "function",
    "takes",
    "python",
    "list",
    "want",
    "search",
    "single",
    "target",
    "value",
    "want",
    "search",
    "need",
    "loop",
    "item",
    "list",
    "range",
    "function",
    "gives",
    "us",
    "range",
    "numbers",
    "first",
    "argument",
    "including",
    "second",
    "argument",
    "list",
    "length",
    "5",
    "would",
    "loop",
    "indexes",
    "0",
    "test",
    "whether",
    "list",
    "item",
    "current",
    "index",
    "matches",
    "target",
    "return",
    "index",
    "current",
    "item",
    "exit",
    "index",
    "item",
    "function",
    "without",
    "looping",
    "remaining",
    "items",
    "list",
    "reach",
    "end",
    "loop",
    "without",
    "finding",
    "target",
    "value",
    "means",
    "list",
    "instead",
    "returning",
    "index",
    "return",
    "special",
    "python",
    "value",
    "none",
    "indicates",
    "absence",
    "value",
    "languages",
    "similar",
    "values",
    "like",
    "nil",
    "null",
    "might",
    "return",
    "value",
    "would",
    "otherwise",
    "impossible",
    "like",
    "index",
    "negative",
    "let",
    "call",
    "new",
    "search",
    "function",
    "start",
    "looping",
    "list",
    "100",
    "values",
    "looking",
    "using",
    "values",
    "time",
    "indexes",
    "within",
    "list",
    "need",
    "mess",
    "python",
    "range",
    "function",
    "actual",
    "call",
    "index",
    "item",
    "function",
    "pass",
    "full",
    "list",
    "names",
    "loaded",
    "file",
    "plus",
    "name",
    "want",
    "search",
    "within",
    "list",
    "store",
    "index",
    "returns",
    "variable",
    "lastly",
    "print",
    "index",
    "get",
    "back",
    "index",
    "item",
    "function",
    "let",
    "save",
    "go",
    "console",
    "see",
    "works",
    "python",
    "linear",
    "search",
    "dot",
    "pi",
    "names",
    "unsorted",
    "dot",
    "text",
    "print",
    "list",
    "indexes",
    "name",
    "actually",
    "set",
    "last",
    "two",
    "items",
    "list",
    "names",
    "going",
    "search",
    "corresponded",
    "first",
    "last",
    "name",
    "within",
    "file",
    "open",
    "file",
    "see",
    "mary",
    "rosenberger",
    "first",
    "name",
    "alonso",
    "viviano",
    "last",
    "name",
    "last",
    "two",
    "values",
    "list",
    "names",
    "searching",
    "returned",
    "index",
    "zero",
    "second",
    "last",
    "name",
    "see",
    "name",
    "line",
    "one",
    "file",
    "line",
    "numbering",
    "starts",
    "one",
    "python",
    "list",
    "indexes",
    "start",
    "zero",
    "makes",
    "sense",
    "last",
    "name",
    "returned",
    "index",
    "109873",
    "see",
    "name",
    "line",
    "109",
    "874",
    "see",
    "returning",
    "correct",
    "indexes",
    "right",
    "searching",
    "hundred",
    "different",
    "names",
    "list",
    "one",
    "hundred",
    "thousand",
    "names",
    "real",
    "world",
    "going",
    "looking",
    "many",
    "names",
    "within",
    "much",
    "bigger",
    "lists",
    "faster",
    "yes",
    "need",
    "use",
    "binary",
    "search",
    "algorithm",
    "work",
    "need",
    "sort",
    "list",
    "strings",
    "next",
    "video",
    "use",
    "binary",
    "search",
    "algorithm",
    "list",
    "names",
    "need",
    "sort",
    "let",
    "need",
    "load",
    "unsorted",
    "list",
    "names",
    "file",
    "sorted",
    "write",
    "sorted",
    "names",
    "back",
    "new",
    "file",
    "code",
    "top",
    "loads",
    "file",
    "full",
    "strings",
    "list",
    "use",
    "quick",
    "sort",
    "method",
    "sort",
    "list",
    "names",
    "code",
    "completely",
    "unchanged",
    "saw",
    "previous",
    "stage",
    "call",
    "quick",
    "sort",
    "function",
    "list",
    "names",
    "loaded",
    "file",
    "save",
    "list",
    "variable",
    "loop",
    "name",
    "sorted",
    "list",
    "print",
    "name",
    "let",
    "save",
    "script",
    "try",
    "running",
    "python",
    "quicksort",
    "strings",
    "stop",
    "pi",
    "pass",
    "names",
    "file",
    "let",
    "resize",
    "console",
    "window",
    "little",
    "bit",
    "prints",
    "sorted",
    "list",
    "names",
    "terminal",
    "need",
    "file",
    "called",
    "redirect",
    "program",
    "output",
    "run",
    "command",
    "end",
    "put",
    "greater",
    "sign",
    "followed",
    "path",
    "file",
    "want",
    "program",
    "output",
    "written",
    "names",
    "sorted",
    "dot",
    "text",
    "redirecting",
    "works",
    "linux",
    "based",
    "systems",
    "like",
    "workspaces",
    "also",
    "macs",
    "even",
    "windows",
    "machines",
    "need",
    "careful",
    "redirect",
    "existing",
    "file",
    "contents",
    "overwritten",
    "without",
    "asking",
    "let",
    "refresh",
    "list",
    "files",
    "sidebar",
    "see",
    "new",
    "sorted",
    "dot",
    "text",
    "file",
    "names",
    "directory",
    "number",
    "lines",
    "unsorted",
    "dot",
    "text",
    "file",
    "names",
    "sorted",
    "load",
    "file",
    "sorted",
    "names",
    "list",
    "able",
    "use",
    "list",
    "binary",
    "search",
    "algorithm",
    "see",
    "next",
    "list",
    "names",
    "sorted",
    "use",
    "binary",
    "search",
    "algorithm",
    "let",
    "see",
    "use",
    "speed",
    "search",
    "indexes",
    "100",
    "names",
    "binary",
    "search",
    "keeps",
    "narrowing",
    "list",
    "value",
    "looking",
    "faster",
    "linear",
    "search",
    "discards",
    "half",
    "potential",
    "matches",
    "time",
    "code",
    "top",
    "binary",
    "search",
    "script",
    "unchanged",
    "previous",
    "scripts",
    "call",
    "load",
    "strings",
    "function",
    "load",
    "100",
    "000",
    "sorted",
    "names",
    "file",
    "hard",
    "coded",
    "list",
    "100",
    "names",
    "going",
    "search",
    "identical",
    "list",
    "linear",
    "search",
    "script",
    "except",
    "changed",
    "last",
    "two",
    "names",
    "correspond",
    "names",
    "first",
    "last",
    "lines",
    "file",
    "loading",
    "let",
    "write",
    "function",
    "implement",
    "binary",
    "search",
    "algorithm",
    "like",
    "linear",
    "search",
    "function",
    "take",
    "two",
    "arguments",
    "first",
    "list",
    "going",
    "search",
    "second",
    "target",
    "value",
    "searching",
    "binary",
    "search",
    "function",
    "return",
    "index",
    "found",
    "value",
    "special",
    "value",
    "none",
    "found",
    "binary",
    "search",
    "faster",
    "linear",
    "search",
    "discards",
    "half",
    "values",
    "search",
    "time",
    "needs",
    "keep",
    "track",
    "range",
    "still",
    "needs",
    "search",
    "start",
    "range",
    "going",
    "include",
    "full",
    "list",
    "first",
    "variable",
    "track",
    "lowest",
    "index",
    "range",
    "searching",
    "start",
    "going",
    "0",
    "first",
    "index",
    "full",
    "list",
    "likewise",
    "last",
    "variable",
    "track",
    "highest",
    "index",
    "range",
    "searching",
    "start",
    "set",
    "highest",
    "index",
    "full",
    "list",
    "first",
    "last",
    "variables",
    "equal",
    "means",
    "size",
    "search",
    "range",
    "shrunk",
    "zero",
    "match",
    "happens",
    "though",
    "keep",
    "looping",
    "continue",
    "search",
    "want",
    "divide",
    "list",
    "potential",
    "matches",
    "half",
    "time",
    "need",
    "check",
    "value",
    "middle",
    "range",
    "searching",
    "add",
    "indexes",
    "first",
    "last",
    "variables",
    "divide",
    "two",
    "get",
    "average",
    "might",
    "get",
    "fractional",
    "number",
    "ca",
    "used",
    "list",
    "index",
    "also",
    "round",
    "using",
    "python",
    "double",
    "slash",
    "floor",
    "division",
    "operator",
    "give",
    "us",
    "index",
    "list",
    "element",
    "midpoint",
    "range",
    "searching",
    "store",
    "midpoint",
    "variable",
    "whoops",
    "looks",
    "like",
    "indentation",
    "got",
    "mixed",
    "let",
    "fix",
    "real",
    "quick",
    "go",
    "test",
    "whether",
    "list",
    "element",
    "midpoint",
    "matches",
    "target",
    "value",
    "return",
    "midpoint",
    "index",
    "without",
    "looping",
    "search",
    "complete",
    "otherwise",
    "midpoint",
    "element",
    "value",
    "less",
    "target",
    "value",
    "know",
    "target",
    "value",
    "ca",
    "midpoint",
    "index",
    "prior",
    "move",
    "new",
    "start",
    "search",
    "range",
    "old",
    "midpoint",
    "otherwise",
    "midpoint",
    "element",
    "value",
    "must",
    "greater",
    "target",
    "value",
    "know",
    "target",
    "value",
    "ca",
    "midpoint",
    "index",
    "move",
    "new",
    "end",
    "search",
    "range",
    "old",
    "midpoint",
    "unindenting",
    "mark",
    "end",
    "loop",
    "loop",
    "completes",
    "means",
    "search",
    "range",
    "shrank",
    "nothing",
    "without",
    "finding",
    "match",
    "means",
    "matching",
    "value",
    "list",
    "return",
    "special",
    "python",
    "value",
    "none",
    "indicate",
    "lastly",
    "linear",
    "search",
    "script",
    "need",
    "search",
    "100",
    "names",
    "loop",
    "name",
    "list",
    "call",
    "binary",
    "search",
    "function",
    "sorted",
    "list",
    "names",
    "going",
    "load",
    "file",
    "current",
    "name",
    "searching",
    "store",
    "returned",
    "list",
    "index",
    "index",
    "variable",
    "finally",
    "print",
    "variable",
    "let",
    "save",
    "go",
    "console",
    "try",
    "running",
    "python",
    "important",
    "give",
    "name",
    "sorted",
    "file",
    "loads",
    "unsorted",
    "file",
    "binary",
    "search",
    "wo",
    "work",
    "names",
    "sorted",
    "dot",
    "text",
    "prints",
    "list",
    "indexes",
    "name",
    "set",
    "last",
    "two",
    "items",
    "list",
    "names",
    "going",
    "search",
    "corresponded",
    "first",
    "last",
    "name",
    "file",
    "returned",
    "index",
    "zero",
    "second",
    "last",
    "name",
    "see",
    "name",
    "second",
    "last",
    "name",
    "aaron",
    "augustine",
    "see",
    "name",
    "line",
    "one",
    "file",
    "last",
    "name",
    "returned",
    "index",
    "one",
    "zero",
    "nine",
    "eight",
    "seven",
    "three",
    "see",
    "name",
    "line",
    "one",
    "zero",
    "nine",
    "eight",
    "seven",
    "four",
    "let",
    "check",
    "third",
    "last",
    "name",
    "good",
    "measure",
    "looks",
    "like",
    "index",
    "97022",
    "printed",
    "name",
    "stephen",
    "daras",
    "let",
    "search",
    "steve",
    "daras",
    "within",
    "file",
    "line",
    "97023",
    "remember",
    "line",
    "numbers",
    "start",
    "one",
    "instead",
    "zero",
    "actually",
    "matches",
    "printed",
    "list",
    "index",
    "97022",
    "looks",
    "like",
    "binary",
    "search",
    "script",
    "working",
    "correctly",
    "let",
    "try",
    "linear",
    "search",
    "binary",
    "search",
    "scripts",
    "time",
    "command",
    "see",
    "compare",
    "commented",
    "lines",
    "print",
    "indexes",
    "matches",
    "two",
    "scripts",
    "way",
    "still",
    "call",
    "respective",
    "search",
    "functions",
    "100",
    "names",
    "searching",
    "wo",
    "actually",
    "print",
    "indexes",
    "wo",
    "bunch",
    "output",
    "obscuring",
    "results",
    "time",
    "command",
    "first",
    "let",
    "try",
    "linear",
    "search",
    "script",
    "time",
    "python",
    "linear",
    "search",
    "dot",
    "pi",
    "names",
    "use",
    "unsorted",
    "list",
    "names",
    "linear",
    "search",
    "remember",
    "want",
    "ignore",
    "real",
    "result",
    "add",
    "user",
    "sys",
    "results",
    "together",
    "looks",
    "like",
    "took",
    "seconds",
    "linear",
    "search",
    "find",
    "100",
    "names",
    "list",
    "one",
    "hundred",
    "thousand",
    "let",
    "try",
    "timing",
    "binary",
    "search",
    "script",
    "time",
    "python",
    "names",
    "one",
    "need",
    "use",
    "sorted",
    "list",
    "names",
    "looks",
    "like",
    "took",
    "around",
    "quarter",
    "second",
    "less",
    "half",
    "long",
    "bear",
    "mind",
    "part",
    "time",
    "spent",
    "loading",
    "file",
    "names",
    "list",
    "difference",
    "linear",
    "search",
    "binary",
    "search",
    "even",
    "pronounced",
    "search",
    "bigger",
    "lists",
    "search",
    "items",
    "let",
    "wrap",
    "course",
    "looking",
    "big",
    "runtimes",
    "linear",
    "search",
    "binary",
    "search",
    "going",
    "much",
    "simpler",
    "calculate",
    "sorting",
    "algorithms",
    "linear",
    "search",
    "need",
    "one",
    "comparison",
    "target",
    "value",
    "item",
    "list",
    "theoretically",
    "could",
    "find",
    "target",
    "value",
    "searching",
    "whole",
    "list",
    "big",
    "notation",
    "concerned",
    "worst",
    "case",
    "search",
    "entire",
    "list",
    "list",
    "eight",
    "items",
    "means",
    "eight",
    "operations",
    "big",
    "runtime",
    "linear",
    "search",
    "n",
    "n",
    "number",
    "items",
    "searching",
    "also",
    "known",
    "linear",
    "time",
    "number",
    "items",
    "number",
    "operations",
    "compared",
    "graph",
    "result",
    "straight",
    "line",
    "linear",
    "search",
    "looks",
    "pretty",
    "good",
    "compare",
    "binary",
    "search",
    "binary",
    "search",
    "number",
    "items",
    "search",
    "therefore",
    "number",
    "operations",
    "cut",
    "half",
    "comparison",
    "remember",
    "number",
    "times",
    "divide",
    "n",
    "two",
    "reach",
    "one",
    "expressed",
    "log",
    "n",
    "run",
    "time",
    "binary",
    "search",
    "big",
    "notation",
    "log",
    "n",
    "even",
    "large",
    "values",
    "n",
    "large",
    "lists",
    "search",
    "number",
    "operations",
    "needed",
    "search",
    "small",
    "binary",
    "search",
    "fast",
    "efficient",
    "algorithm",
    "tour",
    "sorting",
    "searching",
    "algorithms",
    "sure",
    "check",
    "teacher",
    "notes",
    "opportunities",
    "learn",
    "thanks",
    "watching"
  ],
  "keywords": [
    "course",
    "code",
    "learning",
    "kind",
    "let",
    "make",
    "like",
    "lot",
    "one",
    "link",
    "along",
    "time",
    "different",
    "name",
    "algorithms",
    "whether",
    "high",
    "run",
    "algorithm",
    "many",
    "seems",
    "reach",
    "computer",
    "know",
    "might",
    "already",
    "real",
    "anything",
    "level",
    "well",
    "get",
    "start",
    "going",
    "set",
    "need",
    "less",
    "specific",
    "evaluate",
    "understand",
    "perform",
    "compare",
    "statement",
    "given",
    "worry",
    "none",
    "learn",
    "concepts",
    "using",
    "also",
    "writing",
    "programming",
    "around",
    "even",
    "want",
    "python",
    "language",
    "check",
    "notes",
    "video",
    "useful",
    "long",
    "able",
    "pretty",
    "example",
    "good",
    "still",
    "write",
    "sure",
    "provide",
    "way",
    "something",
    "simple",
    "steps",
    "really",
    "means",
    "program",
    "takes",
    "written",
    "much",
    "mean",
    "say",
    "come",
    "find",
    "thing",
    "comes",
    "solution",
    "every",
    "single",
    "needs",
    "take",
    "sort",
    "better",
    "array",
    "class",
    "best",
    "solve",
    "go",
    "problems",
    "common",
    "working",
    "several",
    "talk",
    "two",
    "points",
    "saying",
    "particular",
    "important",
    "try",
    "wo",
    "efficient",
    "second",
    "part",
    "understanding",
    "problem",
    "hand",
    "data",
    "structures",
    "look",
    "break",
    "structure",
    "called",
    "algorithmic",
    "thinking",
    "together",
    "work",
    "complexity",
    "efficiency",
    "always",
    "big",
    "fact",
    "right",
    "though",
    "game",
    "brittany",
    "john",
    "may",
    "goes",
    "think",
    "number",
    "1",
    "10",
    "guess",
    "easy",
    "low",
    "tries",
    "ten",
    "answer",
    "three",
    "quick",
    "range",
    "works",
    "clearly",
    "define",
    "values",
    "count",
    "correct",
    "okay",
    "took",
    "another",
    "round",
    "5",
    "2",
    "3",
    "ways",
    "saw",
    "back",
    "instead",
    "current",
    "first",
    "pass",
    "amount",
    "turns",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "got",
    "britney",
    "see",
    "larger",
    "case",
    "strategy",
    "far",
    "results",
    "looking",
    "things",
    "worst",
    "scenario",
    "clear",
    "starting",
    "value",
    "searching",
    "matter",
    "us",
    "numbers",
    "exercise",
    "point",
    "without",
    "since",
    "starts",
    "keeps",
    "100",
    "fast",
    "forward",
    "happens",
    "end",
    "times",
    "done",
    "couple",
    "next",
    "last",
    "search",
    "result",
    "add",
    "type",
    "would",
    "put",
    "said",
    "use",
    "possible",
    "used",
    "beginning",
    "linear",
    "quite",
    "makes",
    "remember",
    "complete",
    "list",
    "target",
    "move",
    "step",
    "definition",
    "nothing",
    "could",
    "book",
    "read",
    "matches",
    "defined",
    "must",
    "input",
    "output",
    "looks",
    "series",
    "actually",
    "order",
    "comparison",
    "comparing",
    "additional",
    "verify",
    "correctly",
    "found",
    "sorted",
    "finally",
    "true",
    "known",
    "smaller",
    "keep",
    "earlier",
    "pick",
    "faster",
    "evaluating",
    "space",
    "memory",
    "build",
    "runs",
    "running",
    "graph",
    "half",
    "size",
    "give",
    "names",
    "j",
    "n",
    "large",
    "gets",
    "runtime",
    "easier",
    "bit",
    "middle",
    "equal",
    "greater",
    "left",
    "process",
    "discard",
    "everything",
    "4",
    "binary",
    "method",
    "mentioned",
    "element",
    "unsorted",
    "lists",
    "containing",
    "sorts",
    "implement",
    "return",
    "returns",
    "position",
    "determine",
    "elements",
    "match",
    "new",
    "sub",
    "contains",
    "equals",
    "grows",
    "operations",
    "000",
    "increases",
    "bring",
    "function",
    "notation",
    "variable",
    "call",
    "million",
    "variables",
    "inside",
    "log",
    "whole",
    "entire",
    "operation",
    "line",
    "constant",
    "head",
    "pattern",
    "item",
    "double",
    "midpoint",
    "learned",
    "raised",
    "power",
    "base",
    "divide",
    "plus",
    "overall",
    "logarithmic",
    "l",
    "runtimes",
    "sorting",
    "quadratic",
    "squared",
    "place",
    "create",
    "merge",
    "splitting",
    "k",
    "zero",
    "remaining",
    "0",
    "implemented",
    "needed",
    "length",
    "languages",
    "top",
    "hit",
    "implementation",
    "file",
    "empty",
    "created",
    "command",
    "underscore",
    "dot",
    "pi",
    "index",
    "error",
    "comment",
    "enter",
    "else",
    "string",
    "loop",
    "items",
    "track",
    "assign",
    "bottom",
    "test",
    "print",
    "save",
    "script",
    "copy",
    "returned",
    "named",
    "condition",
    "false",
    "division",
    "calls",
    "operator",
    "logic",
    "calling",
    "console",
    "version",
    "recursive",
    "previous",
    "returning",
    "slice",
    "indexes",
    "original",
    "recursion",
    "simply",
    "stopping",
    "either",
    "iterative",
    "store",
    "tail",
    "full",
    "reference",
    "arrays",
    "linked",
    "text",
    "strings",
    "stored",
    "key",
    "contiguous",
    "minimum",
    "access",
    "insert",
    "append",
    "argument",
    "node",
    "nodes",
    "load",
    "remove",
    "split",
    "recursively",
    "merged",
    "within",
    "sum",
    "thousand",
    "selection",
    "quicksort",
    "pivot"
  ]
}