{
  "text": "In this video, Brandon will teach you about 10 common JavaScript security vulnerabilities\nand how to protect against them.\nBrandon is an engineer at Semgrep and teaches at Carnegie Mellon University.\nTo make it interesting and fun, it's in a quiz format.\nHe shows you a small code snippet and asks you to find the vulnerabilities.\nFeel free to pause the video to see if you can answer.\nAfter that, he talks about the vulnerabilities, explains how they are vulnerable, and provides\nan example of remediation code.\nSemgrep provided a grant to make this video possible.\nSemgrep is an open source code security tool that can find vulnerabilities in your code\nand your dependencies.\nHow much do you know about software security?\nThink you've got what it takes to diagnose a real vulnerable application?\nMy name is Brandon.\nI'm a program analysis engineer at a software security company called Semgrep.\nIn this video, I'll be showing you 10 examples of common vulnerabilities in real code.\nAnd I'm here to challenge you on how many of them you can figure out.\nYour goal will be to figure out both the kind of vulnerability demonstrated as well as how\nit can be exploited.\nI'll show you the code and then go over the answers with you afterwards.\nGive it a try.\nYou might just learn something.\nAll right, without further ado, let's get started.\nThis first example I have for you is in JavaScript, and it's just rendering a simple web app.\nThis is known to be vulnerable.\nI'll talk a little bit about what it does, and then I'll let you try to figure out why\nit's vulnerable.\nSo this query params demo, it was demoing query parameters.\nWhat's happening is that we're using this use query function we defined and using this\nuse location function that we imported from this React router DOM library.\nAnd what that's doing is it's constructing this new object of the URL search params class.\nNow, the point of this class is that it lets us interface with these things called query\nparameters.\nFor instance, if our website that this web app was at was https colon slash slash example.com\nand let's say slash settings or a query parameter is something that looks like this.\nIt's redirect equals foo.\nWhat this means is that redirect is being is a query parameter whose value is foo.\nAnd that means that when we click on this button over here, we're going to get that\nquery parameters value.\nSo we'll get the foo here and then clicking upon this return home button will end up making us\ngo to that whatever that value is.\nOK, so, for instance, if this was our overall URL of the website that we were at, then that\nmeans that clicking on this return home button would make us go to this URL.\nIn other words, going home.\nSo I'll let you think a little bit about why this is vulnerable,\nbut we'll come back in a second and talk about it.\nAll right, let's get into it.\nSo this code is vulnerable because of a vulnerability called cross-site scripting.\nCross-site scripting is when a malicious attacker tries to get code to execute on\nyour machine through your browser.\nThey try to get a script to run cross-site.\nSo in this particular example, this has to do with this query parameters thing I was talking\nabout earlier.\nIn particular, something you need to know about is this JavaScript protocol.\nThe JavaScript protocol means that when you visit a URL that looks like JavaScript colon slash slash\neverything after the slash slash is interpreted as JavaScript code and executed within your\nbrowser.\nThat means that if I were to write do something bad as a function call here,\nif I visited this URL, it would try to execute this do something bad function,\nwhich potentially could be unsafe because it could execute arbitrary code.\nNow, in particular, if we combine it with this query parameter idea,\nwe know that for this code, for this website, if I click the return home button,\nit'll take this value from the redirect query parameter and go to it.\nIn particular, though, we might actually take this and put it in place of that query\nparameters value, meaning that if this were our URL,\nif we clicked on this button, instead of visiting through or home or whatever,\nwe would visit this, which executes the do something bad or any kind of arbitrary code.\nThat means that someone might give us a malicious link that could execute\narbitrary code in our machine across a scripting attack.\nTo fix this, what we need to do is we need to sanitize the URL or validate it to make\nsure that we're not going to run into this JavaScript protocol attack.\nSo, what we're going to do is we're going to do that by writing this validate URL function,\nand we're going to take in this URL.\nSo, what we're going to do is first, we're going to create a new URL object\nusing this built-in URL class.\nAnd what this will do is it'll give us access to some other information about this URL.\nIn particular, we want to know what its protocol is.\nWe know that if it's a JavaScript protocol, that's pretty unsafe,\nbut also in particular, HTTPS is okay.\nSo, let's say that we're going to condition on whether or not this user supplied URL object,\nwhether or not its protocol is equal to HTTPS.\nAnd if it is, then we know we're safe.\nIn that case, we're just going to return the original URL we were given\nbecause we know that it's not going to cause an attack.\nOtherwise, if we're not, then let's just say we return slash,\nwhich will essentially make us go home.\nAnd then once we have this validate URL function,\nwe're going to pass in the value that we got from the query parameter into it\nso that we can validate the URL\nand make sure that we don't fall prey to a cross-site scripting attack.\nAnd that's all.\nOkay, let's get into the second example.\nSo, this is another JavaScript program,\nand it's just defining a simple web app that listens for get requests.\nIt's going to be listening on this endpoint slash API slash data.\nSo, if we had our previous website as before, example.com slash API slash data,\nit's listening to these requests.\nAnd like the previous example, it's using query parameters.\nIn particular, we're looking at this URL query parameter, which would look like this.\nSo, in this example, if we were to visit this URL,\nthe foo would be what gets assigned to this URL const.\nAnd then what happens is the web app will then fetch the data from that URL\nand then return it, turn it to a JSON and then return it back to the user.\nNow, going along with this, in this hypothetical example,\nwe have some kind of like internal website where we're storing our data.\nAnd there's some publicly facing data.\nLike we have this countries.json file that is publicly facing,\nand there's also a states.json publicly facing data.\nSo, if we were to visit these two URLs, what would happen is that\nthe web app would then read in the query parameter and then try to fetch the data\nfrom this internal states.json or countries.json.\nAll right, try to figure out why it's vulnerable,\nand then we'll come back and talk about it in a second.\nOkay, let's do it.\nSo, this code is vulnerable because of a vulnerability called\nserver-side request forgery or SSRF for short.\nWhat that means is that an attacker tries to dupe a server into doing dirty work for them\nby using permissions that the attacker wouldn't ordinarily have,\nby getting the server to execute some kind of query\nthat the attacker wouldn't be able to normally do.\nSo, in this instance, I talked about how we have this setup that\nthis internal website has some publicly available data\nthat we're trying to scrape using this web app.\nBut it's not the case necessarily that all of the data is public.\nIn fact, there might be some kind of confidential.json on the server.\nIn which case, if we visited this URL, we would then get this URL from the query parameter,\nand this server, this web app, would then fetch the data from this confidential.json.\nAnd it might be able to do it because the server has more permissions in this case.\nSo, we want to make sure that we only visit the stuff that we're allowed to, this public data,\nwithout being able to do an SSRF attack to get confidential data we're not supposed to see.\nSo, to remedy this, something we can do is we can make a const of allowed URLs.\nAnd this is just going to be a list of two things.\nThe two, let's say, publicly available data JSONs that we want to see.\nSo, let's put both of them in there, states.json.\nAnd then what we want to do is we want to make sure that this URL,\nwhatever we're going to be fetching from, is not not in the allowed list.\nSo, we're going to say that if it's not the case that allowed URLs includes this URL,\nwell, then we have a problem.\nIt's not in our allowed URLs.\nSo, what we're going to do is we're going to do something like we did down here with these\nstatuses, we're going to return res.status 400 to signal there's an error.\nAnd we're going to say, error, we got a bad URL, because we don't want to visit this URL\nif it's not allowed explicitly.\nWe don't want the server to make that mistake.\nAnd just by doing that, we make sure that we only visit the public data that we're allowed to\nwithout the server being able to give away this confidential data that we wouldn't want to otherwise.\nAnd that's how we prevent an SSRF attack.\nAll right, let's talk about the next example.\nSo, in this example, suppose that we have some kind of check token function.\nBasically, we have some user supplied information specifying some kind of account.\nAnd we want to check whether or not the user supplied information\nhas some kind of secret token that matches the account's secret token that's on record.\nAnd we're going to use triple equals and return true if it's true.\nOtherwise, we'll return false.\nOkay, that's it.\nThink about why it's vulnerable.\nAnd we'll come back and talk about it in a second.\nOkay, this code is vulnerable because of something called a timing attack.\nBasically, what happens is that in JavaScript, when comparing two strings,\nthis triple equals function is going to just iterate through each character and compare them.\nAnd if they don't match, it'll just return false.\nSo, in particular, suppose that the account secret token was like ABC.\nWell, then if the token that we supply is like D, we look at A, we look at D, we compare them,\nwe see that it's false, and we return no. But what if it was a little bit more similar,\nlike it was AE? Well, then triple equals would look at both A's.\nIt would say, okay, looks good. It would move on to B and E.\nOh, they're not the same. It would return false.\nBut if you pay attention, you notice that it takes a little bit longer before it gets\nto returning false in the second case because the prefix, this A and A, were actually the same.\nThat means that if a malevolent attacker was sitting around with their stopwatch going,\nand they had all the time in the world, they could brute force a bunch of strings to try\nand see which strings take a little bit longer than others, at which point it would figure out\nthat it was getting closer and closer to the real token that it wouldn't otherwise know,\na timing attack. So, what we need to do is we want to make sure that that won't happen.\nWe want to make sure that we don't give away information about the token based on how fast\nwe return false. So, to fix this, what we'll do is we'll import crypto from this crypto package.\nAnd instead of using triple equals, we're going to use a crypto equality function that is\na little less transparent about the timing. So, this crypto timing safe equal function is going\nto be the same as our triple equals, but it'll be better about not giving away how similar the\ninputs were. And just by doing that simple one line, two line change, we prevent us timing attack.\nAll right, example number four. So, in this example, we've got a validate token function\nand it's taking an HTTP request. What's happening is that we're checking the header,\nthe header at this key of token, and we're going to pass it into this buffer.from function,\nwhich decodes it from this basic C4 encoding. And then what we're going to do is we also have\nthis sum object thing, which is let's say empty. We want to check whether or not this token that\nwe pass into the server is a member of this sum object. But right now it's empty. So,\nthis should always be false. And then if it were to be in it, we would send true.\nBut because it's empty, we should always send false in this case. But I'll tell you that\nthere's a vulnerability where we can get it to sometimes send true. All right,\nI'll let you think about it. We'll come back and talk about what the vulnerability is real soon.\nAll right, the vulnerability here has to do with prototype pollution in JavaScript. The idea is\nthat JavaScript is a prototype based every object has a prototype, which is a parent class that it\ninherits its methods from. Now the idea is that if you if you index in with a string underscore\nunderscore proto, it'll try and fetch that prototype object for you. And even though the\nsum object is empty, it does have a prototype because every object has a prototype. So if\nyou manage to pass in the string underscore underscore proto, what will happen is that this\nsum object indexed into it is going to fetch that prototype object, it'll end together with the\nproto string. And then because those are truthy, this if will actually evaluate to true, and then\nwe'll send true, even though it should have been false, even because we should have been looking\nfor the token in the object, and the token in the object is empty, so it shouldn't have had the\ntoken. So to protect against this, we want to make sure that instead of indexing in with this token,\nwe want to make sure that we only look at the properties of the object in question.\nAnd it turns out we can do that using this has own property function. So we use this method,\nwe pass in the token and then instead of even if we were to pass in this underscore underscore proto\nstring, it's not going to go and fetch the proto, it's going to go and just check whether or not\nthat property exists in the object. And because the object is empty, this will never evaluate to\ntrue, and then we'll never send true. And that's how we prevent the prototype pollution attack.\nAlright, example number five. So this is another JavaScript program that is just a simple app\nthat's taking in post requests from slash user. What we're doing is we're looking inside of a\ndatabase of users to try and find users whose username matches the thing that's in the request.\nIf we find it, then we just send it back. Otherwise, we're going to send an error message.\nAlright, think about why this one's insecure, and then come back when you're done.\nAlright, so this code is vulnerable because of a vulnerability called a NoSQL injection,\nwhich is basically like a SQL injection, but not limited to just SQL queries. In this case,\nthe user could possibly enter a query that could allow them to access things that they shouldn't.\nIn particular, what's happening is we're finding every entry, every document in our users\nthat has this username matching rec.body.username. But it's not guaranteed that rec.body.username\nneeds to be a string. In fact, what it might be is it might be this object here when we have\n$ne to null. And what this means is this is a special MongoDB operator, where $ne means\nnot equal, not equal to null. In essence, if we were to try and find with this query instead,\nwe would find every single instance of a user in our database that had a username where the\nusername was set. This is really bad, because we're not just finding the username, we're finding\nthings by the username, but finding all the data associated to it within our database. That means\nthat this username could be paired with all sorts of sensitive data, like credit card number, like\nsocial security number, like date of birth, stuff that we're not supposed to see. So what we want\nto do is make sure that someone can't abuse this database by putting in some malformed query,\nsomething that's not a string, essentially. So what we can do is we can do if type of rec.body.username,\nand we can case some other that's not string. And if it's not a string, then it could be one of\nthis MongoDB operator stuff that causes them to scrape data that they shouldn't be able to see,\nin which case, what we'll do is we'll return the status 400 on them, and then we'll say,\nwe'll return a message that says, this is a bad username or an invalid username. This way,\npeople can't access stuff that they don't want, and we're only constraining requests that are\nactually usernames that they want to look up. This way, we prevent the NoSQL injection attack.\nAll right, challenge six. So we've got another JavaScript program here, and we've got an app\ntaking in post requests at slash validate email. Now, what we've got here is assume that this\nregex is a gigantically, incredibly complex regex that happens to validate emails. And what we're\ndoing is we're taking in this rec.body.email in the request, and we're checking for whether or\nnot it passes against this regular expression. If it doesn't, then we'll say invalid email and\ncomplain, and otherwise, we'll send back valid as true. Okay? All right, try to figure out why this\ncode is vulnerable, and then we'll talk about it in a second. All right, let's talk about it.\nSo this code is insecure because of an attack called a redos attack, or regular expression\ndenial of service. What this means is that this regular expression is really complicated. Don't\nworry too much about what it does, but it might take a really long time to validate certain inputs\nbecause the regular expression has to try out a bunch of options. It might take a very long time,\ndepending on what the input that is being fed into it is. And because the input is under the\ncontrol of the person making the request, this is not within our control and could potentially be\ncrafted by some malicious attacker leading to denial of service, because we might hang on\ncertain inputs. So instead of rolling your own regular expression and doing this whole thing,\nwhat we can instead do is we could say we could use this validator library, which is very efficient.\nAnd then what we'll do instead is of instead of using this email regex test, we're going to say,\nif not validator dot is email, which is a function that already exists. And then this way, we can\ntest for whether or not it adheres to the email structure, both without needing to roll our own\nregex, and also while ensuring that we can do so relatively efficiently and prevent these denial\nof service attacks. All right, example number seven. Now, this one's actually not in JavaScript,\nbut it's a Dockerfile that's running in the root directory of some node.js application. And what\nthis Dockerfile is doing is it's going to create an app directory. It'll copy the package.json,\ndescribing the app dependencies to that directory. It'll set the user privileges to root,\nrun npm install, copy the source of the app to that directory, and then run the app on port 8080.\nOkay, think about why this code is vulnerable, and then we'll come back to it in a little bit.\nOkay, so this code is vulnerable because of a potential security misconfiguration.\nThis happens because when we set the user permissions, we set them to root,\nwhich means administrator level privileges on this whole Docker image. This is really bad\nbecause something that happens afterwards, like npm install, or even running the server itself,\nwe could be installing some kind of malicious package, or we could have a vulnerability\nwithin the app itself. If this happens, that means that because this whole Docker image has\nthese administrator level permissions, this could potentially have disastrous consequences\nfor the machine that we're running on. We don't want to give away administrator privileges\nwilly-nilly. So what we can do is instead of doing that, let's run with just user level\npermissions so that we don't have the potential to wreck everything, if there's something\nmalicious going on here. And by doing this, we prevent the security misconfiguration vulnerability.\nOkay, so this code is vulnerable because of hard coded credentials. We see here there's\nthis const secret that we have here, my super duper secret key, it is pretty secret, but not\nsecret enough, because we have it in our app source. In general, it's not a great idea to hard\ncode secrets like this inside of your application code. If you were giving up the source, you'd be\nable to see it. If you were giving out even a compiled version, it'd be quite possible to\nreverse engineer the precise value, which means that your secret would get leaked, which is really,\nreally bad. So what you want to do is in general, it's a better practice to use something like\nenvironment variables. So we could write something like process dot n dot JWT token, which means\nthat we're reading the environment variable JWT token to find the identity of the secret,\nbut it's not within the app source itself. This is both more secure for the reasons I mentioned\nearlier, as well as it makes it easier to swap out the token if we so need to, for instance,\nif we were to compromise our previous token. So just by using something like environment variables,\nwe no longer have hard coded credentials. And this is no longer a security vulnerability.\nAll right, example nine, we've got another JavaScript app that's taking in post requests\nat a slash sign up endpoint. And what we're doing is we're looking in a database of users\nto find a user whose username matches the username given in the request. And then what we do is if\nthere's an error, we do some error handling. But otherwise, if we don't find that user with that\nusername, then we just insert the rec dot body as a new user. And then we return success,\ntry to figure out why this code is vulnerable. And then we'll come back in a second.\nAlright, so this code is vulnerable because of something called a mass assignment attack.\nMass assignment is when user input might be able to set properties on an object that it shouldn't\nbe able to. Now, we the reason why this happens is because we're looking up usernames by the\nrec dot body dot username. But if we don't find it, we insert the entire rec dot body object.\nNow, suppose that our database has a few things in it associated to a username. It's not just a\nusername, but also let's say a password, an email and an is admin flag. Now when we insert the entire\nrec dot body, this could potentially be an object that sets this is admin flag that should not be\nable to be set by just anybody, nobody should be able to just make themselves an admin. But because\nwe insert the entire rec dot body, we don't have control over this. And someone could specify all\nthese fields together. So what we'll do is instead of inserting the entire rec dot body,\nwe'll make a new object that only sets the things that we know are safe. So we'll set username to\nbe string of rec dot body dot username, we'll set email to be string of rec dot body dot email.\nAnd let's also say that we set password to be string of rec dot body dot password.\nThis is cool, but also it's probably not a good idea for us to store the password in our database\nin plain text. So what we can do also is we can do import encrypt password. And supposedly just\nhave this dot slash utils, slash passwords thing lying around. And we have this encrypt password\nmethod. And the next thing we'll do is instead of storing the password as a string, we're just\ngoing to call encrypt password on it. This way, we prevent ourselves from the mass assignment\nattack. But also we encrypt the password so that it's not stored in our database in plain text.\nAnd just like that, we prevent the security vulnerability.\nAll right, by example. So here we've got this web app that's taking post requests,\nand they're taking a generate password reset URL link. What's happening here is that we're trying\nto generate a password reset for some kind of customer for some web app. So assuming the\ncustomer exists, we find the customer using the email, and then we get the password reset token\nvia the customer's ID. What then happens is that we generate this reset password URL using this\nrep dot header dot host. Using password reset, we just make the URL out of string interpolation,\nand then we send back the URL in a JSON object. Try to figure out why this one's vulnerable,\nand then we'll talk about it in a second. Okay, so this code is vulnerable because of\na host header injection attack. The reason why this might happen is we use this rec dot header\nof host. So we use the host header basically as one of the parameters to this URL. But this is\nactually under control of the person making the request in possible control of the attacker. By\nconvention, this is usually just going to be something that's safe, but this could be changed\nby the person who's making the request. So in general, it's not a great idea to use the host\nheader, because this could be used to send back a malicious link that then when clicked on could\nsend the user anywhere. So best not to use this host header. So what we want to do is we want to\nuse something that's more robust than just using the host header of the requests we're getting\nfrom the user. So suppose that we have this process dot m dot host URL environment variable\nlying around, it would be a lot safer if in the server in the web app, we were referencing this\nhost URL instead of looking at the host header given to us by the request itself. By doing just\nthe simple step, we prevent the host header injection because we're no longer using a\npotentially malicious source of data. Alright, that's it. Alright, that's the end of the video.\nI hope you managed to find all 10 vulnerabilities, but definitely leave a comment below on how many\nof them you managed to figure out. If you want more resources on how to learn about security,\nthey'll be linked in the description below. But definitely check out some of the other\nvideos that bring code camp has their excellent resources for learning more about computer\nscience. Security is something that's becoming more and more important by the day. So taking\nthe time to educate yourself now can pay off a lot in the future. Thanks so much for watching\nthe video. I hope you learned something more about security and till next time.\n",
  "words": [
    "video",
    "brandon",
    "teach",
    "10",
    "common",
    "javascript",
    "security",
    "vulnerabilities",
    "protect",
    "brandon",
    "engineer",
    "semgrep",
    "teaches",
    "carnegie",
    "mellon",
    "university",
    "make",
    "interesting",
    "fun",
    "quiz",
    "format",
    "shows",
    "small",
    "code",
    "snippet",
    "asks",
    "find",
    "vulnerabilities",
    "feel",
    "free",
    "pause",
    "video",
    "see",
    "answer",
    "talks",
    "vulnerabilities",
    "explains",
    "vulnerable",
    "provides",
    "example",
    "remediation",
    "code",
    "semgrep",
    "provided",
    "grant",
    "make",
    "video",
    "possible",
    "semgrep",
    "open",
    "source",
    "code",
    "security",
    "tool",
    "find",
    "vulnerabilities",
    "code",
    "dependencies",
    "much",
    "know",
    "software",
    "security",
    "think",
    "got",
    "takes",
    "diagnose",
    "real",
    "vulnerable",
    "application",
    "name",
    "brandon",
    "program",
    "analysis",
    "engineer",
    "software",
    "security",
    "company",
    "called",
    "semgrep",
    "video",
    "showing",
    "10",
    "examples",
    "common",
    "vulnerabilities",
    "real",
    "code",
    "challenge",
    "many",
    "figure",
    "goal",
    "figure",
    "kind",
    "vulnerability",
    "demonstrated",
    "well",
    "exploited",
    "show",
    "code",
    "go",
    "answers",
    "afterwards",
    "give",
    "try",
    "might",
    "learn",
    "something",
    "right",
    "without",
    "ado",
    "let",
    "get",
    "started",
    "first",
    "example",
    "javascript",
    "rendering",
    "simple",
    "web",
    "app",
    "known",
    "vulnerable",
    "talk",
    "little",
    "bit",
    "let",
    "try",
    "figure",
    "vulnerable",
    "query",
    "params",
    "demo",
    "demoing",
    "query",
    "parameters",
    "happening",
    "using",
    "use",
    "query",
    "function",
    "defined",
    "using",
    "use",
    "location",
    "function",
    "imported",
    "react",
    "router",
    "dom",
    "library",
    "constructing",
    "new",
    "object",
    "url",
    "search",
    "params",
    "class",
    "point",
    "class",
    "lets",
    "us",
    "interface",
    "things",
    "called",
    "query",
    "parameters",
    "instance",
    "website",
    "web",
    "app",
    "https",
    "colon",
    "slash",
    "slash",
    "let",
    "say",
    "slash",
    "settings",
    "query",
    "parameter",
    "something",
    "looks",
    "like",
    "redirect",
    "equals",
    "foo",
    "means",
    "redirect",
    "query",
    "parameter",
    "whose",
    "value",
    "foo",
    "means",
    "click",
    "button",
    "going",
    "get",
    "query",
    "parameters",
    "value",
    "get",
    "foo",
    "clicking",
    "upon",
    "return",
    "home",
    "button",
    "end",
    "making",
    "us",
    "go",
    "whatever",
    "value",
    "ok",
    "instance",
    "overall",
    "url",
    "website",
    "means",
    "clicking",
    "return",
    "home",
    "button",
    "would",
    "make",
    "us",
    "go",
    "url",
    "words",
    "going",
    "home",
    "let",
    "think",
    "little",
    "bit",
    "vulnerable",
    "come",
    "back",
    "second",
    "talk",
    "right",
    "let",
    "get",
    "code",
    "vulnerable",
    "vulnerability",
    "called",
    "scripting",
    "scripting",
    "malicious",
    "attacker",
    "tries",
    "get",
    "code",
    "execute",
    "machine",
    "browser",
    "try",
    "get",
    "script",
    "run",
    "particular",
    "example",
    "query",
    "parameters",
    "thing",
    "talking",
    "earlier",
    "particular",
    "something",
    "need",
    "know",
    "javascript",
    "protocol",
    "javascript",
    "protocol",
    "means",
    "visit",
    "url",
    "looks",
    "like",
    "javascript",
    "colon",
    "slash",
    "slash",
    "everything",
    "slash",
    "slash",
    "interpreted",
    "javascript",
    "code",
    "executed",
    "within",
    "browser",
    "means",
    "write",
    "something",
    "bad",
    "function",
    "call",
    "visited",
    "url",
    "would",
    "try",
    "execute",
    "something",
    "bad",
    "function",
    "potentially",
    "could",
    "unsafe",
    "could",
    "execute",
    "arbitrary",
    "code",
    "particular",
    "combine",
    "query",
    "parameter",
    "idea",
    "know",
    "code",
    "website",
    "click",
    "return",
    "home",
    "button",
    "take",
    "value",
    "redirect",
    "query",
    "parameter",
    "go",
    "particular",
    "though",
    "might",
    "actually",
    "take",
    "put",
    "place",
    "query",
    "parameters",
    "value",
    "meaning",
    "url",
    "clicked",
    "button",
    "instead",
    "visiting",
    "home",
    "whatever",
    "would",
    "visit",
    "executes",
    "something",
    "bad",
    "kind",
    "arbitrary",
    "code",
    "means",
    "someone",
    "might",
    "give",
    "us",
    "malicious",
    "link",
    "could",
    "execute",
    "arbitrary",
    "code",
    "machine",
    "across",
    "scripting",
    "attack",
    "fix",
    "need",
    "need",
    "sanitize",
    "url",
    "validate",
    "make",
    "sure",
    "going",
    "run",
    "javascript",
    "protocol",
    "attack",
    "going",
    "going",
    "writing",
    "validate",
    "url",
    "function",
    "going",
    "take",
    "url",
    "going",
    "first",
    "going",
    "create",
    "new",
    "url",
    "object",
    "using",
    "url",
    "class",
    "give",
    "us",
    "access",
    "information",
    "url",
    "particular",
    "want",
    "know",
    "protocol",
    "know",
    "javascript",
    "protocol",
    "pretty",
    "unsafe",
    "also",
    "particular",
    "https",
    "okay",
    "let",
    "say",
    "going",
    "condition",
    "whether",
    "user",
    "supplied",
    "url",
    "object",
    "whether",
    "protocol",
    "equal",
    "https",
    "know",
    "safe",
    "case",
    "going",
    "return",
    "original",
    "url",
    "given",
    "know",
    "going",
    "cause",
    "attack",
    "otherwise",
    "let",
    "say",
    "return",
    "slash",
    "essentially",
    "make",
    "us",
    "go",
    "home",
    "validate",
    "url",
    "function",
    "going",
    "pass",
    "value",
    "got",
    "query",
    "parameter",
    "validate",
    "url",
    "make",
    "sure",
    "fall",
    "prey",
    "scripting",
    "attack",
    "okay",
    "let",
    "get",
    "second",
    "example",
    "another",
    "javascript",
    "program",
    "defining",
    "simple",
    "web",
    "app",
    "listens",
    "get",
    "requests",
    "going",
    "listening",
    "endpoint",
    "slash",
    "api",
    "slash",
    "data",
    "previous",
    "website",
    "slash",
    "api",
    "slash",
    "data",
    "listening",
    "requests",
    "like",
    "previous",
    "example",
    "using",
    "query",
    "parameters",
    "particular",
    "looking",
    "url",
    "query",
    "parameter",
    "would",
    "look",
    "like",
    "example",
    "visit",
    "url",
    "foo",
    "would",
    "gets",
    "assigned",
    "url",
    "const",
    "happens",
    "web",
    "app",
    "fetch",
    "data",
    "url",
    "return",
    "turn",
    "json",
    "return",
    "back",
    "user",
    "going",
    "along",
    "hypothetical",
    "example",
    "kind",
    "like",
    "internal",
    "website",
    "storing",
    "data",
    "publicly",
    "facing",
    "data",
    "like",
    "file",
    "publicly",
    "facing",
    "also",
    "publicly",
    "facing",
    "data",
    "visit",
    "two",
    "urls",
    "would",
    "happen",
    "web",
    "app",
    "would",
    "read",
    "query",
    "parameter",
    "try",
    "fetch",
    "data",
    "internal",
    "right",
    "try",
    "figure",
    "vulnerable",
    "come",
    "back",
    "talk",
    "second",
    "okay",
    "let",
    "code",
    "vulnerable",
    "vulnerability",
    "called",
    "request",
    "forgery",
    "ssrf",
    "short",
    "means",
    "attacker",
    "tries",
    "dupe",
    "server",
    "dirty",
    "work",
    "using",
    "permissions",
    "attacker",
    "would",
    "ordinarily",
    "getting",
    "server",
    "execute",
    "kind",
    "query",
    "attacker",
    "would",
    "able",
    "normally",
    "instance",
    "talked",
    "setup",
    "internal",
    "website",
    "publicly",
    "available",
    "data",
    "trying",
    "scrape",
    "using",
    "web",
    "app",
    "case",
    "necessarily",
    "data",
    "public",
    "fact",
    "might",
    "kind",
    "server",
    "case",
    "visited",
    "url",
    "would",
    "get",
    "url",
    "query",
    "parameter",
    "server",
    "web",
    "app",
    "would",
    "fetch",
    "data",
    "might",
    "able",
    "server",
    "permissions",
    "case",
    "want",
    "make",
    "sure",
    "visit",
    "stuff",
    "allowed",
    "public",
    "data",
    "without",
    "able",
    "ssrf",
    "attack",
    "get",
    "confidential",
    "data",
    "supposed",
    "see",
    "remedy",
    "something",
    "make",
    "const",
    "allowed",
    "urls",
    "going",
    "list",
    "two",
    "things",
    "two",
    "let",
    "say",
    "publicly",
    "available",
    "data",
    "jsons",
    "want",
    "see",
    "let",
    "put",
    "want",
    "want",
    "make",
    "sure",
    "url",
    "whatever",
    "going",
    "fetching",
    "allowed",
    "list",
    "going",
    "say",
    "case",
    "allowed",
    "urls",
    "includes",
    "url",
    "well",
    "problem",
    "allowed",
    "urls",
    "going",
    "going",
    "something",
    "like",
    "statuses",
    "going",
    "return",
    "400",
    "signal",
    "error",
    "going",
    "say",
    "error",
    "got",
    "bad",
    "url",
    "want",
    "visit",
    "url",
    "allowed",
    "explicitly",
    "want",
    "server",
    "make",
    "mistake",
    "make",
    "sure",
    "visit",
    "public",
    "data",
    "allowed",
    "without",
    "server",
    "able",
    "give",
    "away",
    "confidential",
    "data",
    "would",
    "want",
    "otherwise",
    "prevent",
    "ssrf",
    "attack",
    "right",
    "let",
    "talk",
    "next",
    "example",
    "example",
    "suppose",
    "kind",
    "check",
    "token",
    "function",
    "basically",
    "user",
    "supplied",
    "information",
    "specifying",
    "kind",
    "account",
    "want",
    "check",
    "whether",
    "user",
    "supplied",
    "information",
    "kind",
    "secret",
    "token",
    "matches",
    "account",
    "secret",
    "token",
    "record",
    "going",
    "use",
    "triple",
    "equals",
    "return",
    "true",
    "true",
    "otherwise",
    "return",
    "false",
    "okay",
    "think",
    "vulnerable",
    "come",
    "back",
    "talk",
    "second",
    "okay",
    "code",
    "vulnerable",
    "something",
    "called",
    "timing",
    "attack",
    "basically",
    "happens",
    "javascript",
    "comparing",
    "two",
    "strings",
    "triple",
    "equals",
    "function",
    "going",
    "iterate",
    "character",
    "compare",
    "match",
    "return",
    "false",
    "particular",
    "suppose",
    "account",
    "secret",
    "token",
    "like",
    "abc",
    "well",
    "token",
    "supply",
    "like",
    "look",
    "look",
    "compare",
    "see",
    "false",
    "return",
    "little",
    "bit",
    "similar",
    "like",
    "ae",
    "well",
    "triple",
    "equals",
    "would",
    "look",
    "would",
    "say",
    "okay",
    "looks",
    "good",
    "would",
    "move",
    "b",
    "oh",
    "would",
    "return",
    "false",
    "pay",
    "attention",
    "notice",
    "takes",
    "little",
    "bit",
    "longer",
    "gets",
    "returning",
    "false",
    "second",
    "case",
    "prefix",
    "actually",
    "means",
    "malevolent",
    "attacker",
    "sitting",
    "around",
    "stopwatch",
    "going",
    "time",
    "world",
    "could",
    "brute",
    "force",
    "bunch",
    "strings",
    "try",
    "see",
    "strings",
    "take",
    "little",
    "bit",
    "longer",
    "others",
    "point",
    "would",
    "figure",
    "getting",
    "closer",
    "closer",
    "real",
    "token",
    "would",
    "otherwise",
    "know",
    "timing",
    "attack",
    "need",
    "want",
    "make",
    "sure",
    "wo",
    "happen",
    "want",
    "make",
    "sure",
    "give",
    "away",
    "information",
    "token",
    "based",
    "fast",
    "return",
    "false",
    "fix",
    "import",
    "crypto",
    "crypto",
    "package",
    "instead",
    "using",
    "triple",
    "equals",
    "going",
    "use",
    "crypto",
    "equality",
    "function",
    "little",
    "less",
    "transparent",
    "timing",
    "crypto",
    "timing",
    "safe",
    "equal",
    "function",
    "going",
    "triple",
    "equals",
    "better",
    "giving",
    "away",
    "similar",
    "inputs",
    "simple",
    "one",
    "line",
    "two",
    "line",
    "change",
    "prevent",
    "us",
    "timing",
    "attack",
    "right",
    "example",
    "number",
    "four",
    "example",
    "got",
    "validate",
    "token",
    "function",
    "taking",
    "http",
    "request",
    "happening",
    "checking",
    "header",
    "header",
    "key",
    "token",
    "going",
    "pass",
    "function",
    "decodes",
    "basic",
    "c4",
    "encoding",
    "going",
    "also",
    "sum",
    "object",
    "thing",
    "let",
    "say",
    "empty",
    "want",
    "check",
    "whether",
    "token",
    "pass",
    "server",
    "member",
    "sum",
    "object",
    "right",
    "empty",
    "always",
    "false",
    "would",
    "send",
    "true",
    "empty",
    "always",
    "send",
    "false",
    "case",
    "tell",
    "vulnerability",
    "get",
    "sometimes",
    "send",
    "true",
    "right",
    "let",
    "think",
    "come",
    "back",
    "talk",
    "vulnerability",
    "real",
    "soon",
    "right",
    "vulnerability",
    "prototype",
    "pollution",
    "javascript",
    "idea",
    "javascript",
    "prototype",
    "based",
    "every",
    "object",
    "prototype",
    "parent",
    "class",
    "inherits",
    "methods",
    "idea",
    "index",
    "string",
    "underscore",
    "underscore",
    "proto",
    "try",
    "fetch",
    "prototype",
    "object",
    "even",
    "though",
    "sum",
    "object",
    "empty",
    "prototype",
    "every",
    "object",
    "prototype",
    "manage",
    "pass",
    "string",
    "underscore",
    "underscore",
    "proto",
    "happen",
    "sum",
    "object",
    "indexed",
    "going",
    "fetch",
    "prototype",
    "object",
    "end",
    "together",
    "proto",
    "string",
    "truthy",
    "actually",
    "evaluate",
    "true",
    "send",
    "true",
    "even",
    "though",
    "false",
    "even",
    "looking",
    "token",
    "object",
    "token",
    "object",
    "empty",
    "token",
    "protect",
    "want",
    "make",
    "sure",
    "instead",
    "indexing",
    "token",
    "want",
    "make",
    "sure",
    "look",
    "properties",
    "object",
    "question",
    "turns",
    "using",
    "property",
    "function",
    "use",
    "method",
    "pass",
    "token",
    "instead",
    "even",
    "pass",
    "underscore",
    "underscore",
    "proto",
    "string",
    "going",
    "go",
    "fetch",
    "proto",
    "going",
    "go",
    "check",
    "whether",
    "property",
    "exists",
    "object",
    "object",
    "empty",
    "never",
    "evaluate",
    "true",
    "never",
    "send",
    "true",
    "prevent",
    "prototype",
    "pollution",
    "attack",
    "alright",
    "example",
    "number",
    "five",
    "another",
    "javascript",
    "program",
    "simple",
    "app",
    "taking",
    "post",
    "requests",
    "slash",
    "user",
    "looking",
    "inside",
    "database",
    "users",
    "try",
    "find",
    "users",
    "whose",
    "username",
    "matches",
    "thing",
    "request",
    "find",
    "send",
    "back",
    "otherwise",
    "going",
    "send",
    "error",
    "message",
    "alright",
    "think",
    "one",
    "insecure",
    "come",
    "back",
    "done",
    "alright",
    "code",
    "vulnerable",
    "vulnerability",
    "called",
    "nosql",
    "injection",
    "basically",
    "like",
    "sql",
    "injection",
    "limited",
    "sql",
    "queries",
    "case",
    "user",
    "could",
    "possibly",
    "enter",
    "query",
    "could",
    "allow",
    "access",
    "things",
    "particular",
    "happening",
    "finding",
    "every",
    "entry",
    "every",
    "document",
    "users",
    "username",
    "matching",
    "guaranteed",
    "needs",
    "string",
    "fact",
    "might",
    "might",
    "object",
    "ne",
    "null",
    "means",
    "special",
    "mongodb",
    "operator",
    "ne",
    "means",
    "equal",
    "equal",
    "null",
    "essence",
    "try",
    "find",
    "query",
    "instead",
    "would",
    "find",
    "every",
    "single",
    "instance",
    "user",
    "database",
    "username",
    "username",
    "set",
    "really",
    "bad",
    "finding",
    "username",
    "finding",
    "things",
    "username",
    "finding",
    "data",
    "associated",
    "within",
    "database",
    "means",
    "username",
    "could",
    "paired",
    "sorts",
    "sensitive",
    "data",
    "like",
    "credit",
    "card",
    "number",
    "like",
    "social",
    "security",
    "number",
    "like",
    "date",
    "birth",
    "stuff",
    "supposed",
    "see",
    "want",
    "make",
    "sure",
    "someone",
    "ca",
    "abuse",
    "database",
    "putting",
    "malformed",
    "query",
    "something",
    "string",
    "essentially",
    "type",
    "case",
    "string",
    "string",
    "could",
    "one",
    "mongodb",
    "operator",
    "stuff",
    "causes",
    "scrape",
    "data",
    "able",
    "see",
    "case",
    "return",
    "status",
    "400",
    "say",
    "return",
    "message",
    "says",
    "bad",
    "username",
    "invalid",
    "username",
    "way",
    "people",
    "ca",
    "access",
    "stuff",
    "want",
    "constraining",
    "requests",
    "actually",
    "usernames",
    "want",
    "look",
    "way",
    "prevent",
    "nosql",
    "injection",
    "attack",
    "right",
    "challenge",
    "six",
    "got",
    "another",
    "javascript",
    "program",
    "got",
    "app",
    "taking",
    "post",
    "requests",
    "slash",
    "validate",
    "email",
    "got",
    "assume",
    "regex",
    "gigantically",
    "incredibly",
    "complex",
    "regex",
    "happens",
    "validate",
    "emails",
    "taking",
    "request",
    "checking",
    "whether",
    "passes",
    "regular",
    "expression",
    "say",
    "invalid",
    "email",
    "complain",
    "otherwise",
    "send",
    "back",
    "valid",
    "true",
    "okay",
    "right",
    "try",
    "figure",
    "code",
    "vulnerable",
    "talk",
    "second",
    "right",
    "let",
    "talk",
    "code",
    "insecure",
    "attack",
    "called",
    "redos",
    "attack",
    "regular",
    "expression",
    "denial",
    "service",
    "means",
    "regular",
    "expression",
    "really",
    "complicated",
    "worry",
    "much",
    "might",
    "take",
    "really",
    "long",
    "time",
    "validate",
    "certain",
    "inputs",
    "regular",
    "expression",
    "try",
    "bunch",
    "options",
    "might",
    "take",
    "long",
    "time",
    "depending",
    "input",
    "fed",
    "input",
    "control",
    "person",
    "making",
    "request",
    "within",
    "control",
    "could",
    "potentially",
    "crafted",
    "malicious",
    "attacker",
    "leading",
    "denial",
    "service",
    "might",
    "hang",
    "certain",
    "inputs",
    "instead",
    "rolling",
    "regular",
    "expression",
    "whole",
    "thing",
    "instead",
    "could",
    "say",
    "could",
    "use",
    "validator",
    "library",
    "efficient",
    "instead",
    "instead",
    "using",
    "email",
    "regex",
    "test",
    "going",
    "say",
    "validator",
    "dot",
    "email",
    "function",
    "already",
    "exists",
    "way",
    "test",
    "whether",
    "adheres",
    "email",
    "structure",
    "without",
    "needing",
    "roll",
    "regex",
    "also",
    "ensuring",
    "relatively",
    "efficiently",
    "prevent",
    "denial",
    "service",
    "attacks",
    "right",
    "example",
    "number",
    "seven",
    "one",
    "actually",
    "javascript",
    "dockerfile",
    "running",
    "root",
    "directory",
    "application",
    "dockerfile",
    "going",
    "create",
    "app",
    "directory",
    "copy",
    "describing",
    "app",
    "dependencies",
    "directory",
    "set",
    "user",
    "privileges",
    "root",
    "run",
    "npm",
    "install",
    "copy",
    "source",
    "app",
    "directory",
    "run",
    "app",
    "port",
    "okay",
    "think",
    "code",
    "vulnerable",
    "come",
    "back",
    "little",
    "bit",
    "okay",
    "code",
    "vulnerable",
    "potential",
    "security",
    "misconfiguration",
    "happens",
    "set",
    "user",
    "permissions",
    "set",
    "root",
    "means",
    "administrator",
    "level",
    "privileges",
    "whole",
    "docker",
    "image",
    "really",
    "bad",
    "something",
    "happens",
    "afterwards",
    "like",
    "npm",
    "install",
    "even",
    "running",
    "server",
    "could",
    "installing",
    "kind",
    "malicious",
    "package",
    "could",
    "vulnerability",
    "within",
    "app",
    "happens",
    "means",
    "whole",
    "docker",
    "image",
    "administrator",
    "level",
    "permissions",
    "could",
    "potentially",
    "disastrous",
    "consequences",
    "machine",
    "running",
    "want",
    "give",
    "away",
    "administrator",
    "privileges",
    "instead",
    "let",
    "run",
    "user",
    "level",
    "permissions",
    "potential",
    "wreck",
    "everything",
    "something",
    "malicious",
    "going",
    "prevent",
    "security",
    "misconfiguration",
    "vulnerability",
    "okay",
    "code",
    "vulnerable",
    "hard",
    "coded",
    "credentials",
    "see",
    "const",
    "secret",
    "super",
    "duper",
    "secret",
    "key",
    "pretty",
    "secret",
    "secret",
    "enough",
    "app",
    "source",
    "general",
    "great",
    "idea",
    "hard",
    "code",
    "secrets",
    "like",
    "inside",
    "application",
    "code",
    "giving",
    "source",
    "able",
    "see",
    "giving",
    "even",
    "compiled",
    "version",
    "quite",
    "possible",
    "reverse",
    "engineer",
    "precise",
    "value",
    "means",
    "secret",
    "would",
    "get",
    "leaked",
    "really",
    "really",
    "bad",
    "want",
    "general",
    "better",
    "practice",
    "use",
    "something",
    "like",
    "environment",
    "variables",
    "could",
    "write",
    "something",
    "like",
    "process",
    "dot",
    "n",
    "dot",
    "jwt",
    "token",
    "means",
    "reading",
    "environment",
    "variable",
    "jwt",
    "token",
    "find",
    "identity",
    "secret",
    "within",
    "app",
    "source",
    "secure",
    "reasons",
    "mentioned",
    "earlier",
    "well",
    "makes",
    "easier",
    "swap",
    "token",
    "need",
    "instance",
    "compromise",
    "previous",
    "token",
    "using",
    "something",
    "like",
    "environment",
    "variables",
    "longer",
    "hard",
    "coded",
    "credentials",
    "longer",
    "security",
    "vulnerability",
    "right",
    "example",
    "nine",
    "got",
    "another",
    "javascript",
    "app",
    "taking",
    "post",
    "requests",
    "slash",
    "sign",
    "endpoint",
    "looking",
    "database",
    "users",
    "find",
    "user",
    "whose",
    "username",
    "matches",
    "username",
    "given",
    "request",
    "error",
    "error",
    "handling",
    "otherwise",
    "find",
    "user",
    "username",
    "insert",
    "rec",
    "dot",
    "body",
    "new",
    "user",
    "return",
    "success",
    "try",
    "figure",
    "code",
    "vulnerable",
    "come",
    "back",
    "second",
    "alright",
    "code",
    "vulnerable",
    "something",
    "called",
    "mass",
    "assignment",
    "attack",
    "mass",
    "assignment",
    "user",
    "input",
    "might",
    "able",
    "set",
    "properties",
    "object",
    "able",
    "reason",
    "happens",
    "looking",
    "usernames",
    "rec",
    "dot",
    "body",
    "dot",
    "username",
    "find",
    "insert",
    "entire",
    "rec",
    "dot",
    "body",
    "object",
    "suppose",
    "database",
    "things",
    "associated",
    "username",
    "username",
    "also",
    "let",
    "say",
    "password",
    "email",
    "admin",
    "flag",
    "insert",
    "entire",
    "rec",
    "dot",
    "body",
    "could",
    "potentially",
    "object",
    "sets",
    "admin",
    "flag",
    "able",
    "set",
    "anybody",
    "nobody",
    "able",
    "make",
    "admin",
    "insert",
    "entire",
    "rec",
    "dot",
    "body",
    "control",
    "someone",
    "could",
    "specify",
    "fields",
    "together",
    "instead",
    "inserting",
    "entire",
    "rec",
    "dot",
    "body",
    "make",
    "new",
    "object",
    "sets",
    "things",
    "know",
    "safe",
    "set",
    "username",
    "string",
    "rec",
    "dot",
    "body",
    "dot",
    "username",
    "set",
    "email",
    "string",
    "rec",
    "dot",
    "body",
    "dot",
    "email",
    "let",
    "also",
    "say",
    "set",
    "password",
    "string",
    "rec",
    "dot",
    "body",
    "dot",
    "password",
    "cool",
    "also",
    "probably",
    "good",
    "idea",
    "us",
    "store",
    "password",
    "database",
    "plain",
    "text",
    "also",
    "import",
    "encrypt",
    "password",
    "supposedly",
    "dot",
    "slash",
    "utils",
    "slash",
    "passwords",
    "thing",
    "lying",
    "around",
    "encrypt",
    "password",
    "method",
    "next",
    "thing",
    "instead",
    "storing",
    "password",
    "string",
    "going",
    "call",
    "encrypt",
    "password",
    "way",
    "prevent",
    "mass",
    "assignment",
    "attack",
    "also",
    "encrypt",
    "password",
    "stored",
    "database",
    "plain",
    "text",
    "like",
    "prevent",
    "security",
    "vulnerability",
    "right",
    "example",
    "got",
    "web",
    "app",
    "taking",
    "post",
    "requests",
    "taking",
    "generate",
    "password",
    "reset",
    "url",
    "link",
    "happening",
    "trying",
    "generate",
    "password",
    "reset",
    "kind",
    "customer",
    "web",
    "app",
    "assuming",
    "customer",
    "exists",
    "find",
    "customer",
    "using",
    "email",
    "get",
    "password",
    "reset",
    "token",
    "via",
    "customer",
    "id",
    "happens",
    "generate",
    "reset",
    "password",
    "url",
    "using",
    "rep",
    "dot",
    "header",
    "dot",
    "host",
    "using",
    "password",
    "reset",
    "make",
    "url",
    "string",
    "interpolation",
    "send",
    "back",
    "url",
    "json",
    "object",
    "try",
    "figure",
    "one",
    "vulnerable",
    "talk",
    "second",
    "okay",
    "code",
    "vulnerable",
    "host",
    "header",
    "injection",
    "attack",
    "reason",
    "might",
    "happen",
    "use",
    "rec",
    "dot",
    "header",
    "host",
    "use",
    "host",
    "header",
    "basically",
    "one",
    "parameters",
    "url",
    "actually",
    "control",
    "person",
    "making",
    "request",
    "possible",
    "control",
    "attacker",
    "convention",
    "usually",
    "going",
    "something",
    "safe",
    "could",
    "changed",
    "person",
    "making",
    "request",
    "general",
    "great",
    "idea",
    "use",
    "host",
    "header",
    "could",
    "used",
    "send",
    "back",
    "malicious",
    "link",
    "clicked",
    "could",
    "send",
    "user",
    "anywhere",
    "best",
    "use",
    "host",
    "header",
    "want",
    "want",
    "use",
    "something",
    "robust",
    "using",
    "host",
    "header",
    "requests",
    "getting",
    "user",
    "suppose",
    "process",
    "dot",
    "dot",
    "host",
    "url",
    "environment",
    "variable",
    "lying",
    "around",
    "would",
    "lot",
    "safer",
    "server",
    "web",
    "app",
    "referencing",
    "host",
    "url",
    "instead",
    "looking",
    "host",
    "header",
    "given",
    "us",
    "request",
    "simple",
    "step",
    "prevent",
    "host",
    "header",
    "injection",
    "longer",
    "using",
    "potentially",
    "malicious",
    "source",
    "data",
    "alright",
    "alright",
    "end",
    "video",
    "hope",
    "managed",
    "find",
    "10",
    "vulnerabilities",
    "definitely",
    "leave",
    "comment",
    "many",
    "managed",
    "figure",
    "want",
    "resources",
    "learn",
    "security",
    "linked",
    "description",
    "definitely",
    "check",
    "videos",
    "bring",
    "code",
    "camp",
    "excellent",
    "resources",
    "learning",
    "computer",
    "science",
    "security",
    "something",
    "becoming",
    "important",
    "day",
    "taking",
    "time",
    "educate",
    "pay",
    "lot",
    "future",
    "thanks",
    "much",
    "watching",
    "video",
    "hope",
    "learned",
    "something",
    "security",
    "till",
    "next",
    "time"
  ],
  "keywords": [
    "video",
    "javascript",
    "security",
    "vulnerabilities",
    "semgrep",
    "make",
    "code",
    "find",
    "see",
    "vulnerable",
    "example",
    "source",
    "know",
    "think",
    "got",
    "real",
    "program",
    "called",
    "figure",
    "kind",
    "vulnerability",
    "well",
    "go",
    "give",
    "try",
    "might",
    "something",
    "right",
    "without",
    "let",
    "get",
    "simple",
    "web",
    "app",
    "talk",
    "little",
    "bit",
    "query",
    "parameters",
    "happening",
    "using",
    "use",
    "function",
    "new",
    "object",
    "url",
    "class",
    "us",
    "things",
    "instance",
    "website",
    "slash",
    "say",
    "parameter",
    "like",
    "equals",
    "foo",
    "means",
    "value",
    "button",
    "going",
    "return",
    "home",
    "making",
    "would",
    "come",
    "back",
    "second",
    "scripting",
    "malicious",
    "attacker",
    "execute",
    "run",
    "particular",
    "thing",
    "need",
    "protocol",
    "visit",
    "within",
    "bad",
    "potentially",
    "could",
    "idea",
    "take",
    "actually",
    "instead",
    "attack",
    "validate",
    "sure",
    "information",
    "want",
    "also",
    "okay",
    "whether",
    "user",
    "equal",
    "safe",
    "case",
    "otherwise",
    "pass",
    "another",
    "requests",
    "data",
    "looking",
    "look",
    "happens",
    "fetch",
    "publicly",
    "two",
    "urls",
    "happen",
    "request",
    "server",
    "permissions",
    "able",
    "stuff",
    "allowed",
    "error",
    "away",
    "prevent",
    "suppose",
    "check",
    "token",
    "basically",
    "secret",
    "triple",
    "true",
    "false",
    "timing",
    "longer",
    "time",
    "crypto",
    "one",
    "number",
    "taking",
    "header",
    "sum",
    "empty",
    "send",
    "prototype",
    "every",
    "string",
    "underscore",
    "proto",
    "even",
    "alright",
    "post",
    "database",
    "users",
    "username",
    "injection",
    "finding",
    "set",
    "really",
    "way",
    "email",
    "regex",
    "regular",
    "expression",
    "control",
    "dot",
    "directory",
    "environment",
    "insert",
    "rec",
    "body",
    "entire",
    "password",
    "encrypt",
    "reset",
    "customer",
    "host"
  ]
}