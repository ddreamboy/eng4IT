{
  "text": "this is a beginner-friendly introduction\nto Common data structures and algorithms\nin Python this course is taught by Akash\nNS the co-founder and CEO of Jovian data\nstructures and algorithms in Python is a\npractical beginner-friendly and coding\nfocused online course that will help you\nimprove your programming skills solve\ncoding challenges and Ace technical\ninterviews you can also earn a verified\ncertificate of accomplishment by\ncompleting this course learn more in\nregister at python\ndsa.msc\ncoding using the Python programming\nlanguage you will get a chance to\npractice and improve your coding skills\nwith weekly programming assignments\nconsisting of real interview questions\nand you will also build a course project\nthat you can showcase on your resume or\nLinkedIn profile this is a beginner\nfriendly course and some basic\nprogramming knowledge will help you\nfollow along with the course don't worry\nif you're new to programming you can\nlearn it as you work on this course with\na little extra effort you will also get\nto access the course Community Forum\nwhere you can ask questions participate\nin discussions and share what you're\nworking on during the course this course\nis created by Jovian a platform for\nlearning data science and machine\nlearning with a global community of tens\nof thousands of Learners from over 150\ncountries I'm your instructor Akash\nco-founder and CEO of Jovian and I'm\nreally excited to kick off this course\nwith you register now and invite your\nfriends to join the course at python\ndsa.org orith in\nPython this is an online certification\ncourse brought to you by\nJovian and today we are at lesson one\nbinary search link lists and complexity\nanalysis\nmy name is Akash I am the CEO and\nco-founder of Jovian and I will be your\ninstructor you can find me on Twitter at\naashis this course runs over 6 weeks and\nover the 6 weeks if you enroll with for\nthe course work on four programming\nassignments and build a course project\nyou can earn a certificate of\naccomplishment along the process you\nwill also learn about common data\nstructures and algorithms in Python and\nhow to use these skills to Ace coding\ninterviews and Technical assessments so\nlet's get started then to begin we need\nto go to the course website python\nds.com so if you open up python ds.com\nin your browser that will bring you to\nthis page this is the course page and\nyou can watch an introductory video\nabout the course here you can enroll for\nthe course for free you will need to\nsign in into Jovian you can use your\nGoogle G GitHub or email to sign in into\nJovian and once you're enrolled into to\nthe course you can also invite your\nfriends to join the course the course is\nstill open for enrollments so please\ninvite your friends and\ncolleagues this course is a beginner\nfriendly introduction to Common data\nstructures and algorithms in Python and\nthis course will help you prepare for\ncoding interviews we have coding focused\nHands-On video tutorials every week so\nyou can either follow along with this\nvideo you can pause and run the code as\nwe speak and you can practice coding on\nthe cloud or you can watch the video\nright now and you can practice\nlater in this course we will solve\nquestions from real programming\ninterviews and you can earn a verified\ncertificate of\naccomplishment so let's go to lesson one\nbinary search link list and\ncomplexity on the lesson one page you\ncan see a recording of the lesson once\nit is completed and you will also be\nable to see a Hindi version here and all\nthe code used in this lesson is linked\nbelow so the\nfirst set of code that we will look at\ntoday is called linear and binary search\nso let's open it\nup so this is the first tutorial that we\nwill work through in this lesson and you\nwill be able to work through it it as\nwell and this is part one and there are\na total of 12 notebooks or 12 tutorials\nwe will go\nthrough now this course assume very\nlittle background in programming and\nMathematics but you still do need to\nknow a little bit for instance you do\nneed to know basic programming with\npython things like variables data types\nloops and functions and don't worry if\nyou don't know them already you can\nclick through and follow these links\neach of these is a separate tutorial the\ntutorial will take you about half an\nhour or so each of these and you can\nlearn the basic programming with python\nin just a couple of hours you will also\nneed to know some high school\nmathematics and if you want to brush up\nthings like polinomial vectors matrices\nand probabilities you can click through\nand read these but no prior knowledge of\ndata structures or algorithms is\nrequired you do not need to have an\nextensive coding background and we'll\ncover any additional mathematical and\ntheoretical Concepts as we we need as we\ngo\nalong so how to run the code what you\nwill see here is the some explanations\nand then you will also see some code so\nyou can see here that there is some code\nwritten here and there is\nsome fun so the library is imported and\na function from the library is used here\nnow to run this code you have two\noptions you can either run this code\nusing free online resources which is\nwhat we recommend or you can run it on\nyour computer locally and you can read\nthese instructions I'm going to use free\nonline resources provided by Jovian so\nwe just scroll up here at at the top of\nthis page and click run and then click\nrun on\nbinder so this will take a second or two\nand what we're doing here essentially is\nsetting up a machine for you on the\ncloud using a software called binder\nit's an open source software and now\nwhat you were looking at here this was\nactually not a blog post this is\nactually something called a Jupiter\nnotebook a Jupiter\nnotebook is something that\ncan not only contain explanations but\ncan also contain code and you can look\nat the code and its outputs right here\nin an interactive fashion so if I scroll\ndown down here you can see that we have\nall the same content that we were\nlooking at except this time we can\nactually run this code so we can click\nthe Run button here and the Run button\nwill run the code and here we click the\nsecond run button and that is going to\nrun the second line of code now we will\nbe using jupyter notebooks extensively\nthroughout this course because jupyter\nnotebooks are a great way to do\ninteractive programming you can change\nthe\ncode for example inside of the Matt\nmatt. square root you can use matt. seal\nand you can change the value here so\njupyter notebooks are great for\nexperimenting with\ncode now just a couple of tips that you\nwant to do as soon as you run a jupyter\nnotebook you can click on kernel and\nclick restart and clear\noutput what this will do is this will\nremove all the pre-execution\nis gone and you can see that the numbers\nhere go away so now you can execute the\nthe code line by line yourself and see\nthe output discover the\noutput and then so one other thing you\ncan do if you want to hide the UI a\nlittle bit is to toggle the header and\nalso toggle the toolbar now you might\nneed the toolbar for the Run button but\nthere's a tip here instead of pressing\nthe Run button you can use shift plus\nenter so if you press shift plus enter\nthat will execute a cell and that's a\npretty handy shortcut\nso once again you go on the lesson page\non the lesson page you will find a link\nto the notebook called linear and binary\nsearch on the linear and binary search\nyou can read the explanations but you\ncan't run them to run the code you need\nto click run and then select run on\nbinder and clicking run on binder will\nset up a cloud machine for you and all\nthe code that you see here will get\nexecuted on the cloud so you do not need\nto set up anything on your computer you\ndo not need to download anything we've\ndone all that for you so let's get\nstarted\nthen so this course takes a coding\nfocused approach towards learning and in\neach notebook or each tutorial we will\nfocus on solving one problem and then\nlearn the techniques algorithms and data\nstructures to device an efficient\nsolution for that specific problem we\nwill then generalize the technique and\napply it to other problems so in this\nspecific tutorial we will focus on\nsolving this problem\nhere's the problem we're\nsolving and this is a typical problem\nthat you will come across in a coding\nchallenge or a coding interview so\nhere's how the problem goes Alice has\nsome cards with numbers written on them\nand then she arranges the cards in\ndecreasing order and lays them out face\ndown in a sequence on a table so this is\nwhat it looks like these are cards each\nof these cards has a number below it and\nthe numbers are in decreasing order she\nchallenges Bob to pick out the card\ncontaining a given number for example\nshe could say Bob I want you to pick out\nthe number seven by turning over as few\ncards as\npossible so this is the puzzle that's\ngiven to us and we're not told how many\ncards Alice has so you need to write a\nfunction to help Bob locate the card so\nAlice can put down any number of cards\nand the target number that Bob has to Pi\npick out could be anything so we have to\ntell Bob not a spec not the solution for\na specific problem but a general\nstrategy that he can use to turn over as\nfew cards as possible so for instance\nlook at these seven cards and maybe put\nsome imaginary imaginary numbers before\nthem below them and try to figure out a\nstrategy try to start thinking about the\nproblem and this may seem like a simple\nproblem especially if you're familiar\nwith the concept of binary search but\nthe strategy and technique that we're\nlearning here will be widely applicable\nand we will soon use it to solve harder\nproblems now before while you think\nabout the problem and before we start\nsolving it uh I just want to talk about\nwhy you should learn data structures and\nalgorithms and whether you're pursuing a\ncareer in software development or data\nscience it's almost certain that you\nwill be asked programming problems like\nreversing a leg list or balancing a\nbinary Tre in a technical interview or\ncoding assessment now it's well known\nthat you never face these problems in\nyour job as a software developer so it's\nokay to wonder why such problems are\nasked in interviews and they're asked\nbecause they demonstrate the following\ntraits and these are very important\ntraits for a programmer number one is\nthat you can think about a problem\nsystematically and then solve it\nsystematically step by step too and the\nnumber two is that you can Envision the\ndifferent inputs and outputs in edge\ncases for your\nproblem because programs when you put\nthem out in the wild as part of software\ncan encounter any kind of inputs and as\nyou have thousands or millions of users\nyou will encounter any and every\npossible input and often this has many\nsecurity implications it can take down\nthe server it can take down your\napplication or you can have a loss of\ndata or loss of\nproperty you can communicate your ideas\nclearly to co-workers that's a very\nimportant part of problem solving and\nmost importantly you can convert your\nthoughts and ideas into working code and\nthe code should also be readable to\nother people so it's not really the\nknowledge of specific data structures or\nalgorithms that's tested in an interview\nbut it is your approach towards the\nproblem so you may fail to solve the\nproblem but you may still clear the\ninterview or vice versa you may solve\nthe problem and still not clear the\ninterview so in this course we will\nfocus on the skills to both solve the\nproblem and to clear interview\nsuccessfully so that's why you need to\nlearn data structures and\nalgorithms so coming back to the problem\nat hand now you've read the problem and\nyou may have been thinking about it and\nmaybe you have some ideas on how to\nsolve it and your first instinct might\nbe to just start writing the code for it\nbut that is not the optimal strategy and\nyou may actually end up spending a\nlonger time to solve the problem due to\ncoding errors or you may not be able to\nsolve the problem at all so what we are\ngoing to cover here is a systematic\nstrategy that you should apply in\ninterviews or in coding problems on in\ncoding assessments or in general\nwhenever you're faced with a problem\nlike this so here's the strategy that we\nwill apply step one state the problem\nclearly identify the input and output\nformats step two come up with some\nexample inputs and outputs and try to\ncover all the edge cases step three come\nup with a correct solution for the\nproblem it can be as simple as possible\nand state it in plain English step four\nand this is a step that is optional\nsometimes implement the solution and\ntest it using example inputs and then\nfix any bugs in your in your first\nsolution in step five analyze the\nalgorithm's complexity and identify any\ninefficiencies and finally step step six\napply the right technique to overcome\nthe inefficiency and then go back to\nstep three which is come up with a new\ncorrect solution which is also efficient\nthen implement the solution and analyze\nthe algorithm's complexity so this is\nthe technique that we will apply over\nand over for the course of 6 weeks to\nmany different problems and applying the\nright technique is where the knowledge\nof common data structures and algorithms\ncomes in handy so this is the method\nwe'll be using so let's jump into the\nsolution step one state the problem\nclearly now you will often encounter\ndetailed word problems and coding\nchallenges and interviews they will go\non for paragraphs and paragraphs for\ninstance here we talking about Alice\nhaving a deck of cards and then\nshuffling them putting them out on a\ntable talking to Bob etc etc\netc the first step is to State the\nproblem clearly and precisely in\nabstract terms because computers don't\nunderstand people computers don't\nunderstand cards computers understand\nnumbers so for in this case we can\nrepresent the sequence of cards as a\nlist of numbers so a list is a basic\ndata structure in\nPython and the turning over of a\nspecific card is equivalent to the\naccessing of the value of the number at\na certain position in the list for\ninstance if we think of this set of\ncards being represented by this list you\ncan see here that this list is sorted in\ndecreasing order then turning over a\ncertain card is equivalent to accessing\nthat specific element from the list so\nturning over card number two or or as we\nsay in computer science card number one\nbecause this is card number zero and\nthis is one thing that you might want to\nget into your head as well that whenever\nyou're counting always start counting\nfrom zero otherwise you may run into\nmany off by one errors so this is\nposition zero and this is position one\nso if you turn over the card at position\none it is as good as accessing an\nelement from a given\nlist which in this case will turn out to\nbe 11 so these are the positions in the\nlist starting from zero and now what\nwhat we have to figure out is how many\nelements do we need to access so we need\nto access the minimum number of elements\nto get to a particular element right so\nthe problem can now be stated as follows\nwe need to write a program to find the\nposition of a given number in a list\narranged in decreasing\norder we also need to minimize the\nnumber of times we access the elements\nfrom a list so we're finding the\nposition of the given number seven and\nthe position in this case is three and\nwe want to minimize the number of times\nwe access elements from the list so if\nwe go in this direction for example we\nwould need to access 13 11 12 and\nfinally we discover seven if we come\nfrom this end we may discover 7 6 5 4\nand finally we may discover 7even so\ndefinitely coming from the left is\nbetter than coming from the right but is\nthat the best that's what we're solving\nnow once we've defined the problem and\nwhat you should do is you should try to\nwrite down the problem in your own words\nand primarily this is for you to make it\nclear to yourself uh either speak it out\nloud to the interviewer or write it down\nin your own words as short as make it as\nshort as as long as possible so that you\nclearly understand what's in it and then\ncome up with the inputs and the outputs\nso there are two inputs here there's the\ninput cards which is a list of numbers\nsorted in decreasing order and then the\nsecond input is a query which is a\nnumber whose position in the array is to\nbe determined and there is one output\nwhich is position and the position is\nsimply the position of query in the list\nof cards for example 7 is at position\nthree counting from zero of course and\nas soon as you've written the input and\noutput out you can now write what is\ncalled the signature of our function\nwhich is a structure of our function\nwithout any actual code inside it so now\nwe can call it def locate card with\ncards and query and the single statement\ninside it called pass because a function\nin Python cannot have an empty body you\nneed to put in at least one statement so\nyou always put in the past statement\nfirst because it doesn't do anything\nanything there you go so now we have\nframed our problem in abstract\nterms and now we have a function\nsignature to work with now a couple of\ntips here this is something that\ninterviewers specifically will look for\nbut also in coding assessments because\nyour code is also shared with the\ncompany so you may want to name your\nfunctions properly and think carefully\nabout the signature for example here you\nshould not call your function F1 or Funk\none or F or something like that it's\nbetter to call it locate card because\nthat's what it is doing and the similar\nthing is true for variable names as well\nuse descriptive variable names one\nbecause it's good coding practice and\nsecond because as you work on the\nproblem you may lose track of what a\nvariable represents for example if you\ncall this a and you call this B now 20\nminutes down the line talking about the\nproblem writing different lines of code\nyou may forget what A and B represent so\nplease call them what they represent\neven even if it can get a little long\nand finally if you're unable to come up\nwith a function signature if you're\nunable to come up with a simple\ndescription then discuss the problem\nwith the interviewer if you're unsure\nhow to frame it in abstract terms so\nkeep that in mind and this is really the\nfirst and most important step which is\nstating the clarifying the problem\nstatement and stating it clearly do not\nstart coding before you have done this\notherwise you may get halfway into the\ncode and realize that you have not\nunderstood the problem at all\nso step two now we will come up with\nsome\nexamples some example inputs and outputs\nand our goal will be to cover all the\nedge cases so before we start\nimplementing a function we want to have\nsome examples so that once we implement\nit the first thing we'll want to know is\nis it correct and in general the answer\nis no because coding especially when\nyou're get getting started is hard\nbecause you have to think about many\ndifferent scenarios\nso and and especially especially\ninterviews or coding assessments are\nalso stressful situations so you may not\nbe able to focus and think about all the\ndifferent things that you need to keep\nin mind so simplest way to reduce the\nrisk of going wrong is to\nuse uh test cases so here's one test\ncase that we came up with we what we've\ndone is we've taken the information that\nwe had listed above in the inputs and\noutputs and we've written it in as code\nso now we have a variable called cards\nwhich is a list of cards a list of\nnumbers then we have a query which has\nthe value seven and then we have the\noutput which has the value three so the\nexpected output from the function is\nthree and once you have a test case you\ncan test your function at any point\nanything you want to test you can simply\npass the input for example cards and\nquery into the locate card function and\nget back a\nresult and you can see here right now\nbecause there's nothing inside the\nfunction the result you get back is none\nbut later you'll start getting back a\nproper result from your function and\nwhat you can then do is you can compare\nthe result with the output of the test\ncase so in this case when we compare\nthem obviously the output is three the\nresult is none we get back\nfalse now one thing we will do in this\ncourse to make testing easier because we\nwill be testing our algorithms again and\nagain as we keep improving them is that\nwe will represent our test cases as\ndictionaries so here for example this\nthis test case will be represented or\nevery test case will be represented as a\ndictionary containing two keys input and\noutput and the input will contain one\nkey for each argument to the function so\nif your function arguments are called\ncards and query in the function\nsignature and that's why we wrote down a\nfunction signature first so that we\ndon't get confused here so if your\nfunction arguments are called cards and\nquery then we can take one AR one key\ncalled cards and put the value of cards\nthere one key called query put the value\nof query there and then in in the output\nwe simply contain we simply put the\noutput that we expect from the function\nand now you can test this function like\nthis so how you might want to test it\nfirst is Maybe by actually passing\nvalues like this so you have test input\ncards and then test input\nquery but there's a trick here whenever\nyou have a dictionary so here we have a\ndictionary with two keys and we want to\npass these two keys as two arguments to\na function so we want to pass cards as\nthe card argument to the function locate\ncard and query as a query argument to\nlocate cards what you can do is you can\nsimply put the dictionary itself and\njust write star\nstar now if you write star star what\npython does is it takes the keys from\nthis dictionary and the values are then\nused as Arguments\nfor parameters with these names so there\nwe now calling locate card on test input\nand we can compare it with test output\nand you can see that we get back\nfalse so that's one test case for us but\nis that enough is that enough for you to\nnow start writing code probably not\nbecause out in the wild your function\nshould be able to handle any number of\nany set of valid inputs that we pass\ninto it and here are some possible\nvariations that we might encounter and\nit really helps to list them in fact\nwhile I was writing these variations I\nrealized that there are many cases that\nI had not thought of so even after\ncoding for 12 15 years almost uh I still\nfind it really useful to list out all\nthe scenarios that we can find our input\nin so the simplest scenario is that the\nquery occurs somewhere in the middle on\nthe list of cards this is what you\nimagine when you read the question this\nis what is called the general case but\nthen there are some special scenarios as\nwell what if the query is the first\nelement in cards and what if the query\nis the last element in\ncards what if the list cards contains\njust one element which is the query\nitself or and this is something that I\nhad not thought of what if the list\ncards does not even contain the number\nquery what if Alice is bluffing so what\nshould be Bob's strategy then to figure\nout that the number does not exist what\nif the list of cards is\nempty and what if the list contains\nrepeating numbers this is again another\ninteresting thing that may not come to\nmind because we said a list of numbers\nand we did not specify that the numbers\nare unique so the list can contain\nrepeating numbers and finally what if\nthe number the query itself occurs more\nin more than one position in cards so\nthose are eight cases that I could think\nof and just see if you can think of any\nmore\nvariations and it's likely that when you\nfirst heard the problem you did not\nthink of all these cases because you\noften tend to just focus on one generic\ncase it's hard to hold too many cases in\nmind and that's why it helps to list\nthem down actually write them down in a\ncoding interview or in a coding\nassessment or an interview you may want\nto put this in comments if you have a\npage coding page you can just create a\ncomments and list out all the test cases\nand some of these especially things like\nthe empty array or query not occurring\nin cards are called edge cases because\nthey represent rare or extreme examples\nand while edge cases may not occur very\nfrequently your program should be able\nto handle edge cases otherwise they may\nfail in unexpected ways or or somebody\nwith\nthe with malintentions can use the edge\ncases to hack your\nsoftware so let's create some more test\ncases for the variations that we've\nlisted and we'll store all our test\ncases in a list for easier testing so\nhere we are creating a list called tests\nand this time we will create all our\ntest cases in the format that we discuss\nwhich is a dictionary format and we will\nkeep appending them to our list now if\nyou do not understand understand lists\nand dictionaries and appending then you\ncan go back and review some of the basic\nmaterial on python which is linked at\nthe top of this\nnotebook so first we take the one test\ncase that we already have we put that\nand we take maybe one more example of\nthe query occurring somewhere in the\nmiddle so here you can see this is the\ncards list and then the query one occurs\nsomewhere in the middle although it's\ncloser to one\nend then here's one case where the query\nis the first element four and the output\nobviously the output expected is zero\nhere's one case where the query is the\nlast element minus 127 and this is\nanother thing the numbers could be\nnegative as well something you may want\nto keep in\nmind here's another one the where the\ncard contains where cards contains just\none element the query\nitself now the problem does not State\nwhat to do if the list cards does not\ncontain the number\nquery and you may often face these\nquestions where it may not be clear what\nto do in a certain situation or if a\ncertain situation can occur and when you\nhave questions like this this is the\nprocess you should follow step one read\nthe problem statement carefully or ask\nthe interviewer to repeat the question\nso read the problem statement carefully\nand you you will often find hints and\nsometimes these hints are just single\nnumber single words somewhere often you\nwill also find some examples provided\nwith the problem you will also find if\nyou scroll down to the bottom you will\nfind some conditions you will find\nlimits on what the numbers can be\nwhether they can be integers or can be\ndecimal s whether they can be negative\nor positive so it's important to read\nthe problem carefully before you start\ncoding and look through the examples and\nthen ask the interviewer or maybe post a\nquestion on the platform for a\nclarification often it happens that\ninterviewers because they take so many\ninterviews they may forget to specify a\ncertain detail and or they might expect\nyou to ask the question because you\nshould not be coding with an\ninsufficient requirement so to clarify\nthe specifications of the problem is\nvery important so if you have any ask\nthe interviewer even if you are somewhat\nsure about it but just want to verify\nit's a good idea to\nask then finally if you are done with\nall of these and you still do not have a\nsolution then you just make a reasonable\nassumption state it and move forward so\nwe will assume that our function will\nreturn minus one in case cards does not\ncontain query so if cards does not\ncontain\nquery then\nwe return we expect the function to\nreturn minus one now here's one other\ncase where the card's array is empty and\nobviously then it does not contain the\nquery as well and finally there's one\nlast case which is the number itself can\nrepeat in\ncards numbers can repeat in cards and\nthen the query itself can repeat in\ncards so here the query does not repeat\nthree does not repeat but the numbers on\nthe in the cards areay do\nrepeat and then the last case is when\nthe query itself repeats so you can see\nhere here in cards the query occurs many\ntimes once again it is not specified\nwhat to do here and sometimes it may be\nokay sometimes the problem statement may\njust say that return any one position\nbut more likely than not what you will\nwant to do is you may want to make it\nmore\ndeterministic and that will also make it\neasy for you to test the function so\nwhat we can say we can impose this\nadditional restriction that we will\nexpect our function to return the first\noccurrence of query\nand that will make it easier for us to\ntest so that when we when we're testing\nour problem we we know that if we're\ngetting a failure it's not\nbecause of multiple possible answers but\nbut it's because of some issue in our\ncode right so you want to get good\nfeedback from failures and that's why\nyou want your tests to be deterministic\nso here is the final\ntest and now we can see the full list of\ntest\ncases so now we can see the list of test\ncases here\nso you have about eight or 10 test cases\nhere you may not need to create this\nmany test cases in an interview or a\ncoding assessment depending on how much\ntime you have but you should create at\nleast a few at least cover the three or\nfour edge cases a good number to aim for\nwould be five and this will not only\nhelp you in the coding interview help\nyou solve the problem this will also be\nappreciated by the interviewer because\nit shows that you're thinking about\nabout the problem so definitely take a\nminute or two now we've spent 10 15\nminutes talking about this but once you\nstart applying this technique over and\nover you will see that you will start\ncreating test cases in seconds so as\nsoon as you read the problem and you\nstate the problem find the um find the\ninput format find the output format\nwrite a function uh signature and write\nthe test uh then you will start working\non test the ideas will automatically\nstart coming to you and within maybe 2\nor 3 minutes you will be done with both\nall two both of these\nsteps so great we now have a fairly\nexhaustive set of test cases and\ncreating test cases beforehand allows\nyou to identify different variations and\nedge cases and sometimes it may happen\nthat you may have no clue how to work on\nthe problem you may feel completely\nconfused but if you simply start writing\nmultiple test cases and start looking at\nthem like literally just just staring at\nthe test cases the question and the\nanswer the solution will reveal itself\nto you so don't underestimate the power\nof writing things\ndown and don't stress it don't stress\nout if you can't come up with an\nexhaustive list of test cases because\nthis takes time it's a skill that you\ncultivate with time so what you can do\nis you can list out maybe the test cases\nthat come to your mind right now and put\nthem in a single place and keep coming\nback whenever a new test case comes to\nmind while coding or while discussing or\nwhile analyzing you can just come back\nto the same place and write down the\ntest case the important thing is that\nyou have a a single place where you're\nlisting all test cases so we've written\nour test cases now and now we can come\nup with a correct solution and how do\nyou come up with the correct solution\nnot by writing code but by first stating\nit in plain English so your first\ngoal and by correct we do not mean the\nbest or the most efficient solution\nfirst we want to solve the problem we\nwant to figure out where the particular\nnumber lies in the list and not to\nminimize because that's solving two\nproblems at once and sometimes that can\nget tricky so first aim for correctness\nthen aim for\nefficiency and the simplest or the most\nobvious solution which almost always\nexists and is almost always very easy to\nsee involves checking all the Poss\npossible answers and this is also called\na Brute Force solution so in this\nproblem coming up with a Brute Force\nsolution is quite easy Bob can simply\nturn over the cards in order one by one\ntill he finds the card with the given\nnumber on it so this is what this is how\nit might work if we want to implement it\nin code and this is where writing it in\nyour own words becomes\nimportant so we create a variable called\nposition inside a function with the\nvalue zero then we check that the number\nat the index position in the card list\nequals query or not now if it does since\nwe starting from the beginning if it\ndoes then position is the answer and we\ncan return it from our function but if\nit doesn't then we simply increment ment\nthe value of position by one and then we\nrepeat the steps so we go back to step\ntwo and then we check whether the number\nat the index position on in cards equals\nquery and once again if it does we\nreturn position if not we increment the\nposition once again and repeat and we\nrepeat that till we reach the last\nposition and if the number was not found\nwe return minus one so it's a simple\nfour five step description doesn't take\nvery long you can either say it out loud\nto the interviewer they will also\nappreciate it that they will know you\nknow you may know that you know the\nBrute Force solution and you may not say\nit because it seems too simple or\nobvious but the interview doesn't the\ninterviewer doesn't know that so it's\nimportant to State The Brute Force\nsolution you may say that I The Brute\nForce solution is fairly straightforward\nand it goes like this steps 1 2 3 4 it\njust take 30 seconds but at the very\nleast it informs the interviewer that\nyou're able to think of some\nsolution and it happens very often I've\nseen it in interviews where 30 40\nminutes have passed out of 45 minutes\nand not a single solution has been\nproposed so far even though many lines\nof code have been written so it's\nimportant to State Your solution and if\nyou state Your solution the interviewer\nwill also help you and correct you as\nyou go forward right so it is a\ncollaborative experience it is a\ndiscussion so use that and if you are in\na coding assessment you may just want to\nwrite out a few\ncomments and what we imple implemented\nhere is congratulations is just our\nfirst algorithm and an algorithm is\nsimply a list of statements a list of\nsteps that can be converted into code\nand executed by a computer on different\nsets of\ninputs so this particular algorithm is\ncalled linear search because it involves\nsearching through a list in a linear\nfashion element by\nelement so now we ready to implement the\nsolution\nand just a quick tip as I've already\nsaid always try to express the algorithm\nin your own words and it can be as brief\nor as detailed as you like and don't\nunderestimate the power of writing\nwriting can be a great tool for thinking\nit's likely that you will find that some\npart of the solution is difficult for\nyou to express and that simply suggests\nthat you are probably unable to think\nabout that part clearly so the most more\nclearly you are able to express your\nthoughts the easier it will be for you\nto turn it into code and you will not\nhave to come up with a strategy while\nyou're writing the code so you can focus\non coding and focus on avoiding errors\nand that brings us to The Next Step\nimplement the\nsolution and then test it using the\nexample input so now you can see how\neverything comes together we've already\nknow what the function signature looks\nlike what the inputs look like we\nalready have some test cases and through\nthe test cases we've also identified\nwhat are the different edge cases we\nneed to handle and we've already written\nout a descript description aough\ndescription of what the algorithm looks\nlike and in fact what you can do is you\ncan simply write out comments within\nyour function as the English description\nand then you simply need to fill out\ncode for those comments so for instance\nhere are the five steps that we had just\nwritten down create a variable position\nwith the value zero set up a loop check\nif the element is matches the query if\nyes the answer is found if not increment\nthe position and then go back and then\ncheck if you've reached the end of the\narray if you have then we return minus\none so and the code now is pretty\nstraightforward now we create the\nposition variable zero we set while true\nso while true kicks off a loop and we\njust want to first set up a loop and\nthen we can break out of it when we need\nto then we check if the element at the\nvalue position matches the query if it\ndoes we return the position if it\ndoesn't so if it doesn't then this we\ncome to this part if it does then we\nsimp the function exits and none of this\ncode gets executed but if it doesn't\nthen we increment the position and then\nwe check if we have reached the end now\nif we have reached the end obviously we\ndon't want to continue so we can simply\nreturn minus one and exit the loop and\nexit the function\nitself but if it if we have not reach\nthe end then we go back to the top of\nthe loop and now position starts out\nwith value one so we check value 0 1 2 3\nso on up to the end of the array simple\nenough great so now we have our first\nfunction and let's test our fun function\nwith the first test case so here's our\ntest case once again and we can simply\ncall locate card with the test input and\nthe test the cards and the query and\nthis is the result we get and you can\nalready see that the result matches the\noutput and that's why when we compare\nthem we get the value true so yeah the\nresults match the output\nand because this is something that you\nshould be doing very often in this\ncourse we have put together a small\nfunction for you within the Jovian\npython Library so the Jovian platform\nalso offers a python helper library that\nis that contains some utility functions\nso we've put together a small function\nfor you called evaluate test case and\nyou can write it on your own as well but\nyou can use this Library version so\nlet's install the library we will\ninstall the Jovian Library using pip\ninstall Jovian minus minus\nupgrade and then from jan. python DSA so\nJovian is the name of the library and\nthen inside the Jovian Library since we\nhave many courses the python DSA the\nutilities for this course are present\ninside the python DSA module from that\nmodule we import the function evaluate\ntest\ncase and finally we can call evaluate\ntest case and then we can give it the\nfunction that we want to test so we want\nto test the locate card function and the\ntest case the test case needs to be\ndefined in this\nformat so all it is going to do is it it\nis going to pick out the input pass it\ninto the function get the output compare\nthat output uh with the expected output\nand also print some information for you\nto see so here's what it does it prints\nout the input it prints out the expected\noutput it prints out the actual output\nit prints the execution\ntime and um this is something that will\nbecome important later and tells you\nwhether the test has passed or not so\nit's nice to have this you know because\nso we don't have to look through the\noutput and input and compare them\nespecially when you are in a situation\nwhere you need to think fast it's\nhelpful to create a small function that\ncan just print pass or fail for a test\ncase so now while it may seem like we\nhave a working solution because our test\ncase has passed we can't be sure about\nit until we test the function with all\nthe test cases so for doing that we can\nuse the evaluate test cases function so\njust as you have evaluate test case you\nhave evaluate test cases also part of\nthe Jovian library and you can call\nevaluate test cases with the same\nfunction locate card and this time pass\nset a list of test cases each of the\ntest cases is a\ndictionary again you don't have to use\nthis function you can simply put things\ninto a loop so you can always just do\nfor test in tests and then simply call\nevaluate test with locate\ncard and test or you can even just\ndirectly call locate card\nwith the test inputs\nand the test out and compare the output\nwith the test output right so you can do\nthis as well and you can simply print\nthat so here's a simple way to do this\nwhat we are doing\nhere but what we'll do is we'll use the\nevaluate test cases function because it\nprints out a lot of useful information\nfor us so now you can see that it prints\nout Case Case by case now test case Zero\nwe have input expected output actual\noutput the case test case has pass\nthat's what we saw in fact it's the same\ntest we just did test case one passes as\nwell test case 2 passes test case 3 4 5\nsix okay all of them are fine okay test\ncase six seems to have caused an error\nso here is the error it says list index\nout of\nrange so that's okay it's perfectly all\nright for your functions to encounter an\nerror so the first thing the most\nimportant thing is not to panic in fact\nit's a good thing that we know exactly\nwhere the function is failing if you\nlook back here you can see what the\nissue is and then we'll see how to fix\nthe error but one one good strategy to\napproach this is to keep in mind\nthat there will always be bugs in your\ncode and approach writing code not with\nthe assumption that your code will be\ncorrect but go with the default\nassumption that your code will be wrong\nthat there will be issues what that lets\nyou do is one you do not feel\ndemotivated or you do not panic when you\nsee an error and second you then tend\ntend to be a little more careful while\nactually writing the code so the way you\nshould be writing code is every time you\nwrite a line of code you should be\nasking yourself how can this line of\ncode go wrong or in this particular case\nhow can cards position equals equals\nSquare in a if statement go wrong and\nthrow an error and let's look at it one\neasy way to check this is to add what is\ncalled a logging or what is called\nprinting the information inside a\nfunction so we'll just rewrite a\nfunction in in a locate card function we\nwill put in cards and we will put in\nquery the exact same function that we\nhave we'll set the position but before\nwe create the value we'll simply print\nthe cards in the query so just for our\ninformation just so that we can see what\nthe function is working through we can\nget some visibility into the function we\nprint out cards and query and then while\ntrue so this is the same loop at the\nbeginning of the loop we will print out\nthe position that we are\ntracking okay so let's do that we've\nsimply added some print statements and\nthis print statement will\ngive us an insight into the inner\nworking of the function now if you do\nnot put in a print statement then you\nwill have to work it out yourself by\nreading the code and executing it in\nyour head it's always easier to just\nprint all the all the information and\nthen print it nicely just say cards and\nquery you know we could also have done\nthis without saying cards here but then\nthat would make make it a little harder\nto read then that would be more\ncognitive overload apart from already\ndealing with the stress of solving an\nerror right so just add nice pretty\nprint statements to make it very obvious\nwhat we\nprinting so let's see now let us get the\ntest case out so let's get from test six\nget the input get the cards get the\nquery as well and pass it into locate\ncard and now we see that initially the\ncards array is empty and the query seven\nand the position is zero and then we\nencounter an error we encounter the\nerror list index out of range on the\nline cards position equals equal query\nand now at this point it should be\nfairly obvious what the issue is the\nissue obviously is that we have an empty\nlist and empty list has no elements but\nwe're trying to access the position zero\nwhich is in normal human conversation\nthe first element of a\nlist but there is no first element to\naccess and that is why we get the error\nlist index out of range so this is very\nimportant whenever you get an error do\nnot try to start looking at the code\nfirst just try to understand the error\nfirst and if you're unable to understand\nthe error just add some print statements\nthere are tools like debuggers that\npeople use but I personally in 15 years\nhaven't used a debugger I maybe used it\na couple of times but I don't know how\nto use it print statements are really\nsimple you just put them in Chuck them\ninto the function wherever you need them\nas many print statements as you need\nwith nice clear messages make it very\nobvious and that will almost certainly\nsolve the issue for you so the cards\narray is empty we cannot access position\nzero so what what's the solution here\nthe solution obviously is that before we\naccess anything\nfrom a list we need to make sure that we\ncan access that list and this is the way\nto do it so now we've Rewritten our\nfunction slightly we once again start\nout with position zero but this time\ninstead of putting in a while true\ninstead of assuming that we can access\nthe zeroth element of the list we say\nthat the position should be less than\nthe length of cards now if if you have a\ncards list of n elements the indexes go\nfrom 0 to n minus one or in the case of\nzero elements there are no indexes to\nAIS so the position has to be less than\nthe length of cards for you to be able\nto access it and in this case the length\nof the cards will be zero so 0er is not\nless than zero so the while loop will\nnot run at all and we will directly\nreturn minus\none but if the card does have elements\nthen we can check the element at the\nvalue position compare it to the query\nand return the position\nif it does not if it does not match the\nquery we can increment the\nposition so that was a fairly\nstraightforward fix easy save so let's\ntest the failing case\nagain great so looks like the failing\ncase is now passing because we have\noutput minus one and the expected output\nmatches the actual output of the\nfunction minus one because the query\ndoes not exist in the array which is\nempty of\ncourse now this is not enough it is\nevery time you make a change to the code\nyou want to go back and test all the\ntest cases because what H what may\nhappen is while fixing one error you may\nintroduce another error and that that is\nwhere having a good set of test cases is\nvery important so let's run evaluate\ntest cases once again you can see here\nthis time that all the test cases are\npassing and it's just nice to it just\nmakes you feel good as well makes you\nfeel motivated as well to see that a\nbunch of test cases are passing\nnow in a real coding assessment or a\nreal interview you can probably skip the\nstep of implementing and testing The\nBrute Force solution in the interest of\ntime because it may take about 5 to 10\nminutes to implement the solution and\nthen if you have errors in the solution\nit may take some more time to fix those\nerrors so it's generally quite easy to\nfigure out the complexity which we'll\ntalk about in a second of the Brute\nForce solution from the plain English\ndescription and that is why you should\nfirst state it in plain English which\nonly takes around 20 seconds or so and\nthe computer doesn't throw errors at you\nfor speaking so you can just State the\nplain English description and move on\ntalk about the complexity and start\noptimizing it but while you're\npracticing always always implement the\nBrute Force solution too and there's an\nimportant reason why you should know how\nto implement the Brute Force solution\nbecause in case you're not able to\nfigure out the optimal solution to the\nproblem you can still go back and\nimplement the Brute Force solution and\nin a lot of cases that's okay sometimes\ninterviewers ask hard questions just to\npush your boundaries a little bit but if\nyou're unable to figure out the optimal\nsolution then they will allow you to\nimplement the Brute Force solution so\nthat is why you should state it and that\nis why you should know how to implement\nit okay so we're done\nwith so we're done now with the\nimplementation of our brute force or\nsimplest solution and now we need to\nanalyze it and this is where we'll now\nlearn about what is called the\ncomplexity of an algorithm what does it\nmean now recall the statement from the\noriginal question Alice challenges Bob\nto pick out the card containing the\ngiven number by turning over as few\ncards as possible but right now what\nwe're doing is we can we simply turning\nover cards one by one and before we talk\nabout what does it mean to minimize the\nnumber of times we turnover cards or the\nnumber of times we access elements we\nneed a way to measure it and let's think\nabout it you know it's it's as simple as\njust thinking about it since we access\nthe list element once in every iteration\nso here's our code our code is pretty\nstraightforward and this is where we are\naccessing an element from the list so\nsince we access the\nelement since we access the element once\nin every iteration for a list of size n\nwe access the elements from the list up\nto end times because we may have to\naccess this element El and then this\nelement and this element and so\non so Bob may need to overturn up to end\ncards in the worst case to find the\nrequired card now let's introduce an\nadditional condition that suppose Bob is\nonly allowed to overturn one card per\nminute so that means it may take him 30\nminutes to find the required card in the\nworst case if 30 cards are laid out on\nthe table now is this really the best he\ncan do or is there a way for Bob to\narrive at the answer by turning over\njust five cards and save 25 minutes\ninstead of turning over all\n30 and this field of study and and by\nthe way Bob in this case is\nrepresentative of what a computer does\nand a computer takes some amount of\nfinite time to perform each instruction\nso each array AIS actually takes some\ntime although it's so fast that we do\nnot see it especially for small\ninputs but this is something that will\nbecome increasingly important as we go\nweek over week where we'll see that we\nwill start to see the limits of how long\nit takes computers to solve certain\nproblems so the field of study concerned\nwith finding the amount of time or the\namount of space or the amount of other\nresources required to complete the\nexecution of a program is called the\nanalysis of algorithms and the process\nof figuring out the best algorithm to\nsolve a problem is called algorithm\ndesign and that is what we are doing\nhere we are actually doing the analysis\nof algorithms right now and algorithm\ndesign\nnext so there are a couple of terms we\nneed to understand and then we'll go\nback to writing code uh first thing is\ncomplexity and the second thing is the\nBig O notation and both of these are\nterms that you will hear very frequently\nin when you're talking about data\nstructures and algorithms when you're\ntalking about coding uh interviews\nassessments so these are terms that you\nneed to understand and they're fairly\nsimple terms although the term itself is\ncomplexity but all it means is that the\ncomplexity of an algorithm is simply a\nmeasure some some measure of the amount\nof time or space is required by an\nalgorithm to process an input of a given\nsize example if you have a list of size\nn then the complexity is the amount of\ntime required or the amount of space\nrequired on the ram to process an input\nof that\nsize now unless otherwise stated the\nterm complexity always refers to worst\ncase complexity so it's possible that\nthe Bob turns over the first card and\nthat is the answer but we always talk\nabout what is the longest the highest\npossible time or space that may be taken\nby the program to process an input right\nso we need to design our programs\nkeeping the worst case in mind now in\ncase of a linear search which is what\nwe've implemented just now the time\ncomplexity of the algorithm is some\nconstant C * n assuming n is the size of\nthe list uh n is the number of cards\nright so now this constant C obviously\ndepends on the number of operations that\nwe perform in each iteration so in each\nLoop for example we have four to to five\nstatements and then the time taken to\nexecute a statement on your specific\nHardware now if you have a 2 GHz\ncomputer that may be twice as fast as a\n1 GHz computer if you're running it on a\nphone it may be different so the C\ncaptures all of these things so\ninformation about the number of specific\noperations that we perform in each\niteration and information about the\nactual Hardware that you're running\non so CN is the time complexity and N is\nthe size of the input so in some sense\nwhat we understand from this is that the\ntime complexity is proportional to the\nsize of the input and that's the\nimportant part here the constant you\nknow it doesn't change as you change the\ninput the constant doesn't really change\nnow similarly the space complexity now\nsince we are already given an array the\nadditional space that our linear search\nrequires is simply a single constant\nwhen we are calling it C prime or\nc-h and it is independent of n so no\nmatter how many no matter how large a\nlist is given to you and the list is\nalready present in memory we just need\nto allocate one new variable called\nposition and that variable is used to\niterate through the array and it\noccupies a constant space in the\ncomputer memory because we keep go on\nupdating the variable right so the space\ncomplexity is C or constant it is\nindependent of\nn now what we do normally is to\nrepresent the worst case complexity we\noften use the Big O notation and in the\nbig or notation what we do is we drop\nany fixed constants\nand we lower the powers of the uh and we\ndrop any fixed constants and we drop any\nlower powers of variables so the idea\nhere is to capture just the trend just\nthe trend of the relationship between\nthe size of the input and the complexity\nof the algorithm for example if the time\ncomplexity of an algorithm is some some\nconstant time n Cub plus some constant\ntime n s plus some constant time n plus\nsome constant where n is the size of the\ninput in the Big O notation we simply\nsay that it is order of n Cube which is\nthat you know in the long run in the if\nyou just study the trend it the trend\nwill be some something which looks a\nlittle bit like the N Cube function and\nit may be offset by a constant or such\nso putting it this way the time\ncomplexity of linear search is order n\nbecause we just dropped the constant C\nand the space complexity is order 1 so\nwe again drop the constant C\nPrime and we'll see why it's okay to\ndrop the constant sometimes you may find\nthat okay we not exactly doing n\niterations but we're doing n minus one\niterations so we drop the minus one\nsometimes you'll find that we are just\ndoing n by two iterations and that's\nsimply half of n so we dro the half and\nyou might wonder that okay that that\nmight take twice or three times the\namount of time how why are we dropping\nthat constant because that's probably an\nimportant thing to keep in mind but\nwe'll see we'll see soon as we Implement\nour efficient solution to the\nproblem so before we move forward before\nwe optimize is the algorithm we just\ngoing to save our work because this\nnotebook as I mentioned to you is\nrunning on an online platform we've set\nup everything for you you've not had to\ninstall anything but because thousands\nof people are using this using this\nplatform this will shut down this will\nnot keep running forever and what you\nneed to do is you need to save your work\nfrom time to time and here is how you\ncan save your work and then pick it up\neverything happens on the Jovian\nplatform there's no need to download\nanything although you could download it\nif you want but you does no need to\ndownload anything so all you need to do\nis use the Jovian Library once again\nwe've got another helpful function for\nyou so you say import Jovian and then\nrun Jovian do commit so you run Jovian\ndoc commit and then give it a project\nname the project Name by which you want\nto identify this specific\nnotebook and then there are some other\narguments this is not too important so\nyou can even skip this and that should\nbe perfectly fine so now when you run\ncommit we will capture a snapshot of\nyour notebook from this online platform\nor wherever it is running even if you're\nrunning it on your own computer we will\ncapture a snapshot of your notebook from\nyour\ncomputer wherever it's running and we\nwill upload it and give you a link where\nyou can access it so let's open up this\nlink here so now you will be able to see\nthis page called python binary search\nand it will be on your\nprofile and you can see you can scroll\ndown and see that it contains all the\nexplanations and it contains all the\ncode so this is a readon version of The\njupyter Notebook so the read only\nversion of The jupyter Notebook\nobviously does not require us to keep\nservers running so that you can run this\ncode and when when you need to run it\nyou know your work is saved to whatever\nextent you have executed things and now\nwhen you need to run it you simply click\nrun and then click run on binder once\nagain okay so and that is how you resume\nyour work so what this will do is this\nwill set up a new machine for you and on\nthe new machine it will post a jupyter\nnotebook and uh it will start up the\nmachine for you open up the jupyter\nnotebook and you will be able to start\nrunning the code and not just you now\nyou can make your notebooks public or\nyou can keep them private you have\nmultiple viewership options so you have\npublic and private not just you but\nanybody else so you can take this link\nand tweet it out if there's an\ninteresting problem that you worked on\nyou want to tweet it out you can just\nshare this link online and anybody will\nbe able to read through your\nsolution and they can run it as well\nright in fact The Notebook that I have\nshared with you is hosted on my profile\nso Jovin is not just a platform for you\nto learn it's also a platform for you to\nbuild a repository of projects now if\nyou go back to your profile you click on\nyour profile or click on the Jovian logo\nand you can see here that you will find\na notebooks Tab and in the notebooks tab\nyou will find all the notebooks that you\nhave worked on in the past okay so\nanything that you have committed using\njin. comit you will be able to to resume\nworking on\nit so that's uh that's how you save your\nwork and keep saving your work from time\nto time all you need to do is run jan.\ncomit you do not even need to put in\nthis project argument this is just\nsomething if you want to actually give\nyour project a name otherwise the name\nwill be picked automatically so just\nkeep running Jovian docit from time to\ntime especially if you're leaving your\ncomputer for half an hour or so uh then\nand your computer get goes to sleep then\nthe server will shut down and you may\nlose your work coming back to a problem\nwe've just implemented linear search and\nwe understood that it has the complexity\nof order n which is and that's why it's\ncalled linear it runs in a linear time\nis another expression that is used it is\nalso called linear because we are going\nthrough the array step by\nstep now the next step is to apply the\nright technique to overcome this\nefficiency now of course we've not\nlearned any techniques yet but we can\nprobably figure it out if we think about\nit and maybe this is something that\noccurred to you right at the beginning\nand the idea that occurred to you is\nsomething that we will now Implement so\nat the moment we simply going over the\ncards one by one and not even utilizing\nthe fact that they are sorted and that's\nwhy our approach is pretty poor we're\nbasically checking everything so it's\nnot a great solution but it would be\ngreat if somehow this would be the this\nwould be the best case if somehow Bob\nrealized somehow Bob could guess the\ncard at the first\nattempt that would be perfect then that\nwould be an order one that would be a\nconstant time solution but with all the\ncards turned over it's simply impossible\nto guess the right\ncard now the next best idea is to maybe\npick a random card so maybe let's say\nBob picks this card and this card turns\nout to be a\nnine now Bob can use the fact that the\ncards are in sorted order so if this\ncard turns out to be nine that means all\nof these cards have numbers greater than\nnine and the Target card is\nso the Target Card cannot lie in this\nregion so the Target card has to lie in\nthis region and just by picking a random\ncard rather than picking the first card\nBob has\neliminated four out of seven cards to be\nchecked right so with one check Bob has\neliminated a total of five cards 1 2 3 4\n5 and of course if this number turns out\nto be seven perfect great guess but even\nif it doesn't we've still eliminated\nquite a few if this number turns out to\nbe less than seven we've still\neliminated three cards so that's the\nbasic idea here that we pick something\nnot from the edges but somewhere in the\nmiddle now what is the best place to\npick something in the middle obviously\nwhen we are picking a card we do not\nknow whether it is going to be less than\nor greater than the number that we want\nespecially when everything is closed so\nwe it's best to just pick the middle\ncard so that whichever case turns it\nturns out to\nbe we still left with as at most three\ncar cards to process right so if you\npick this card and it doesn't turn out\nto be seven you either need to look at\nthese three or you need to look at these\nthree so that is the strategy we'll\nfollow and this technique is called\nbinary search and why do it just once\njust keep repeating it so each time you\npick the middle card and you can\neliminate half of the array and this is\nwhat the strategy looks like so here we\nhave the array and in the array we want\nto figure out the number six so a\nslightly different problem but still\ndecreasing order we want to figure out\nthe number six so we access the middle\nelement okay we compare it with six now\nit is not six okay it was a bad guess no\nproblem but we know that four is less\nthan six so that means that six lies to\nthe left of four so we've suddenly\neliminated half of the array we've done\none axis and eliminated half of it and\nnow we left with three numbers we pick\nthe middle number we get\nseven 7 is greater than six that means\nthe number number lies on the right now\nwe left with just one card we overturn\nthat last card or we check that last\nnumber okay it is equal to six great if\nit is not well nothing more left to\ncheck all the numbers here are greater\nthan are less than six and all the\nnumbers before this are greater than six\nso if this number isn't six then there's\nno\nsix and just like that for an array of\nSeven Elements we have done just three\nchecks and arrived at the answer and\nthat was the worst case right it mean it\nwill never take you can verify that it\nwill never take more than three checks\nif six comes at this position we guess\nit immediately if six comes at this\nposition or this position we guess it in\ntwo checks and then if six comes at any\nof the other positions we will guess it\nin three checks so that's pretty\ngood and now the idea if you if you read\nthis part it says apply the right\ntechnique to overcome the inefficiency\nand then repeat the steps 3 to six so\nnow we're going to go back to step three\nwhich was come up with a correct\nsolution for the problem and State in\nplain English and we have come up with a\nsolution already we just need to State\nit so here is how this technique called\nbinary search is applied to the problem\nit's called binary because well we take\na left and right decision so first we\nfind the middle element of the list if\nit matches the queried number then we\nreturn the middle position as the\nanswer and if it is less than the\nqueried number then we search the first\nhalf of the list and if it's greater\nthan the queried number then we search\nthe second half of the list so the exact\nthing that we saw here we apply it here\nand finally if no more elements remain\nwe simply return minus\none so let's just save our work now\nlet's from this point on we'll keep\nsaving our work from time to time using\nJovian doc commit uh so now we've come\nup with the algorithm and you can again\nit's important to write it in your own\nwords whether you want to write a short\ndescription a paragraph or a\nstep-by-step guide but write it in your\nown words and you'll do this in the\nassignment\nso let's implement the solution now and\ntest it using the example inputs so\nhere's the implementation so what we'll\ndo is we will look at once again let's\ngo back to this visual representation\nand we will keep a track of our search\nspace so current initially our search\nspace is the entire array so that means\nwe have an array of seven numbers so our\nsearch space goes from position 0 to\nposition six and slowly we'll keep\nreducing our sear search space over time\nso to keep track of the search space\nwe'll create two variables low and high\nlow will have the value zero which is it\nwill point to the first position in the\narray and high will have the\nvalue pointing to the last position last\nvalid position in the array which is\nwhich is len cards minus\none so while low and then the while loop\nbecomes very simple because as long as\nwe have at least one element in our\nsearch space we can go ahead now to have\nat least one element in a search\nspace the low value which is the\nstarting index\nshould be less than or equal to the end\nvalue right so why low is less than\nequal to high because if the starting\nindex is higher than the end index\nbasically we've exhausted and we've\ncovered the entire list and there's\nnothing more that we can search for so\nwe should exit at this point okay so now\nonce we have uh uh once this condition\nis satisfied and it is initially let's\nsay you have seven cards low is zero\ncards is uh Len cards minus one is six\nthen you find the middle position and\nyou can get the middle position by doing\nlow plus High divided by two and now\nlet's start applying that strategy here\nwhere we say that every time we write a\nline of code we should think about how\nit can go wrong now if you write it like\nthis low plus High divided\n2 and think about how it can go wrong\nokay low plus High may not be divisible\nby two and if low plus high is not\ndivisible by two you may end up with a\ndecimal number now if you do end up with\na decimal number and in fact the\ndivision operator in Python always\nretains a floating Point number then you\ncannot use it as an array index because\nwe want to use this as a position within\nthe array so that's why we need the\ndouble slash which is the which is the\ninteger division which simply Returns\nthe\nquotient so we get the middle position\nand then we get the number at the middle\nposition so we also get cards made so we\naccess that element from the array now\nthis is where we it makes it easy for us\nto count the number of times we access\nbecause here is one access happening\ninside the list and there are no other\naccesses then we get the mid number and\nremember last time we faced an error and\nwe had to add print statements you might\nas well just add print statements right\naway so here's what you can do we can\njust print the value of low the value of\nhigh the value of mid and the value of\nmid number what this will do is this\nwill help you check whether the number\nis working as expect whether the\nfunction is working working as expected\nor not so now here comes the actual\ncheck the meat of the problem if the\nmiddle number matches the query then we\nreturn the middle number great we found\nit well done now if the middle number is\nless than the query now remember the\nelements are in sorted array and we are\nlooking for the number\nquery now the middle number is less than\nthe\nquery so that means the query probably\nlies to the left of it because the query\nbecause the elements are in a decreasing\norder right so if the query lies to the\nleft of it so then we need to search\ndecrease the search space from the\nbeginning to the position just before\nthe middle number right so what we can\ndo is we can simply set High to Mid\nminus one on the other hand if mid\nnumber is greater than query so that\nmeans because of the decreasing order of\nthe array the query lies to the right\nnow we need to move the starting of the\nsearch space to beyond the middle number\nso we simply set low to mid + one and\nthat's it and you can see that we've\nwritten we've used the if L if L if Loop\nhere so L if stands for lse if in Python\nand here the last condition could might\nas well just have been else because\nthere are only three possibilities\neither they're equal or mid number is\nless or it's greater but sometimes it's\nnice to list out all possibilities just\nto make it super clear and it makes it\neasy for you while debugging fixing\nissues as well okay okay so that's our\nbinary search based algorithm and\nfinally when we exit out of the loop uh\nif you have not returned the middle\nnumber if we've not exited the function\nyet then we return minus one that the\nnumber was not found so let's test it\nout using our test cases and we have our\nhandy evaluate test cases function here\nbut you can also test it manually if you\nwant by passing individual test cases\nbut I'll just do this from now on so\ngreat so now we have test case zero this\nis the input and this is the query and\nit passed here we have test case one\nthis is the input and this is the query\nand it passed and now because we have\nthese print statements we can clearly\nlook into our test cases and actually\ntell if if this is tested correctly or\nnot because now you can see here that we\nstarted out with low 0 High 7 and a mid\nmid value of three so 0 1 to three we\nfound the number seven the query is one\nso we need to check this half of the\narray and that's exactly what we did we\nmoved low to four and high remained\nseven then mid number became three so\nthat means once again we need to check\nthis half of the array and then we check\nthis number and then we found the output\nso now you can see exactly how the\nalgorithm works and this is in general\nwhat you want as a programmer you want\nto have a full understanding of the code\nthat you've written you don't want your\ncode to work incidentally you don't want\nit to you don't want to be in a position\nwhere you are just fixing\nthings trying out different things and\nsomehow at at once the code works you\nwant to be in complete control you want\nto know that these this is exactly what\nthe code is doing and if it is failing\nwhy it is failing so we go to test case\n2 3 4 5 6 uh looks good looks like we\nmay have solved everything H probably\nnot so test case 8 seems to have failed\nso test case 8 is this number this list\nand this list contains repeating numbers\nand not just repeating numbers but the\nquery itself occurs multiple times and\nnow if we look here and maybe let's go\ngo down and evaluate just the test case\nseparately so here we are now using the\nsingular version of the evaluate\nfunction so if you look here you can see\nyou have 88 66 a bunch of sixes then 3\n22 0 the query is six so we start out\nwith a low of zero high of 14 total of\n15 elements that gives you a middle\nposition of\n7 and the mid number at that position so\nlet's count 1 0 1 2 3 4 5 6 7 okay and\nthe mid number at that position is six\ngreat uh six is also the query so that's\nwhy our function returns seven but\nremember that we had decided that our\nfunction should return the first\nposition of the number within the\narray so our function is failing that\ncondition and why is that happening\nbecause unlike linear search where we\nstart from the left and so we'll always\nbump into the first position because of\nthe decreasing order of elements so\nwe'll hit we'll encounter this six\nbefore we encounter this\nsix binary search does not access\nelements in an order it access elements\nsort of randomly there's still a\nstrategy but it goes left and right and\nit also depends on the values of\nspecific elements whether this element\nis accessed before this element can\ndepend on the value of let's say this\nelement right so as such it's kind of a\npseudo random kind of\norder and so we need an additional\ncondition to keep track of it right so\nhow do we fix it so the way to fix it is\nactually quite\nsimple when we find that the middle\nposition in a particular range is equal\nto the query we simply need to check\nwhether it is the first occurrence of\nthe query in the\nlist or not that is whether the number\ncome that comes before it is it equal to\nquery or not if the number that comes\nbefore the middle element is also equal\nto query then obviously the middle\nelement is not the first occurrence so\nthat simply means that we can go back\nand because it can occur multiple times\nbefore that simply means that we can go\nwe can now search the left half on the\nother hand if the middle element if the\nnumber before the middle element is not\nequal to query and obviously because it\nis a sorted list it will be greater than\nquery then all the numbers here are\ngoing to be greater than the query and\nknow the the and and so\nthis must be the first or the only\nposition okay so make sure you\nunderstand that this must be the first\nor the only position where the query\noccurs so once again to make it easier\nwhat we will do is because there is some\nlogic involved here what we'll do is\nwe'll Define a helper function called\ntest\nlocation and this is a very helpful\nthing that you can do every time you\nfind that okay you have to you have to\ncover these special cases and your\nfunction may start to get slightly\nlonger slightly more complicated what\nyou may want to do is create a a helper\nfunction and A good rule of thumb is not\nto have functions that are more than 10\nlines of code or so I try to keep my\nfunctions below seven lines of code\nbecause seven eight lines is\napproximately the amount of information\nthat you can hold in your head at once\nso if a function is about seven eight\nlines you can probably take a quick\nglance and tell what it's doing identify\nissues but anywhere beyond that it's\nvery hard and if you writing functions\nthat are going into hundreds of lines\nplease stop doing that please start\nbreaking your code into small\nfunctions there's a there's a quote\nby I forget who it is by but he's a\ncreator of I think it's Eric Meyer he\ncreated the RX library for reactive\nprogramming and he said that great\nprogrammers write baby code which is\nreally small bits of code that anybody\ncan understand with a single look so you\nshould be writing as many functions as\nas many small pieces of code small\npieces of logic as\npossible so let's see a test location\nfunction its purpose is to take the\nquery and then take just a specific\nposition so forget about binary search\nfor now just take a specific position\nand tell if that\nposition is the answer and how do we do\nthat we first get the mid number from\nthe cards so we get a mid number from\ncards so we then we print out mid and we\nprint out mid number and then we compare\nthe mid number with the query so this is\nthe special case that we need to handle\nthis is where we had the error now what\nwe need to check is if the element\nbefore the midn number is also equal to\nquery so if the element before the mid\nnumber is also equal to query then we\nneed to go left so just to make it super\nclear what we'll do is instead of\nsetting high low Etc we'll simply say\nthat we need to go left so we'll return\nthe the actual string left but one thing\nto keep in mind here because once again\nwhenever you're accessing an array you\nneed to make sure that the index is\nvalid so we simply check that mid minus\none should be greater than or equal to\nzero that we mid is not this position\nand which can happen as your search\nspace decreases for example if this is\nyour search space your mid will actually\nbe this\nposition so if it is equal to if the\nnumber before the mid number is equal to\nquery then we return left otherwise we\nreturn found once again making it very\nobvious that we have found the number so\nwe return\nfound else the other case is if the mid\nnumber is less than\nquery that means that the query lies on\nthe left because of the decreasing order\nof the list so once again we need to\nsearch on the left else it returns right\nso a test location simply tells us\nwhether we found the solution or we need\nto look on the left or we need to look\non the right now in sometimes you will\nsee program especially in C++ Java\nreturn something like minus one 0 and 1\nand then use that to represent whether\nyou should go left and right but python\nis a high level language and strings are\na first class strings are a first class\nfeature of the language so just use\nstrings because they're really\ndescriptive they make your code readable\nsomebody else reading your code will be\nable to understand now if you're looking\nat minus one + one Etc that is going to\nbe difficult for people to understand so\nnow we can now simplify a locate card\nfunction once again we have our low high\nLen cards minus one uh zero and L cards\nminus one the Y Loop is the same and we\nprint low and high as well so we are\nprinting low and high inside the locate\ncard function and then we are printing\nmid and mid number inside the test\nlocation function wherever is the right\nplace to print something you print it\nthen we get the mid\nposition and now we simply call test\nlocation so we testing if mid is the\nanswer and if it is not the answer\nshould we go left or should we go right\nnow that makes it really simple because\nnow we get this result and we check this\nresult and if it says found then we\nreturn mid that's the answer if it says\nleft then we return midus one or then we\nsimply move High to Mid minus one and if\nit returns right then we simply set low\nto mid plus one so we are simply\nchanging the start position of the\nsearch space to after the middle element\nand here we are changing the end\nposition of the search space to before\nthe middle element right so this makes\nit extremely obvious and it's really\nhard to go wrong when you write code\nlike\nthis especially so when you have and\nbinary search problems are especially\ntricky because they always have certain\nthese special cases that you need to\nhandle and if you start handling them\nwithin this if Loop so now you have a\nwhile loop inside which you have an if\nLoop inside which you have another\nanother if statement and it can get\npretty tricky and difficult to\ndebug so let's evaluate that test case\nand looks like that test case has passed\nthis time perfectly you can go through\nthe logs here to verify it let's\nevaluate the test case all the test\ncases as well we should do this every\ntime we change the function and that is\nwhy it's helpful to have a function\nwhere you can every time you make a\nchange you can just run the test and on\na coding platform like lead code or\nhacker rank you will be given some test\ncases although those test cases will not\nbe visible to you so you can submit your\nsolution but you may not get an actual\nresult you may not get to know what the\ntest case was or where your answer was\nwrong and that's where you may want to\ncreate your own test cases if you're\ngetting a lot of\nerrors and in fact once you've written\nout the algorithm you may realize that\nokay maybe you need to add more test\ncases what if the number lies in the\nfirst half of the array what if the\nnumber lies in the second half of the so\nthis was not an important factor when we\nwere not thinking about binary search\nbut now that we are thinking in this\ndirection of splitting the array into\nhalf we may want to add some test cases\nwhere the number lies exactly in the\nmiddle in the left in the right and the\nsimplest way to do that is now go back\nto the tests array so you can open you\ncan create a new cell\nhere by pressing the character B so if\nyou click outside and press the\ncharacter B you can create a new cell\nand then you can simply do tests. append\nand then write your test\ncase so here is the final code for the\nalgorithm without without the print\nstatements so we have test location and\nthen we have locate card and try\ncreating a few more test cases to test\nyour algorithm more extensively and once\nagain at every step we are going to save\nour work by running Jovin\ndocit so now we're down to analyzing the\nalgorithm's complexity and identifying\ninefficiencies if there are any now you\nmay have just read online you can\nactually look it up just search for\ncomplexity of binary search and you will\nread an you will find an\nanswer but and and you may even just say\nthat in interviews but it's always nice\nto just come up with that answer from\nfirst principles it's always nice\nespecially in an interview if you can\ntalk through it if you can talk through\nwhy it is order why it is whatever it is\nand we'll see what that is\nso now let's once again try to count the\nnumber of iterations in the algorithm\nbecause we need to minimize the number\nof times we access elements from the\narray\nand to do that we know that in each\niteration we are accessing the element\njust once and then we are comparing it\nso we're doing a bunch of other\noperations but in each iteration we're\naccessing one element so we need to\ncount just the number of iterations the\nnumber of times the Y Loop was executed\nnow if we start out with an array of n\nelements then each\ntime each time the size of the array\nreduces to half for the next iteration\nnow that's roughly true because when you\ncome when you check the middle element\nand then you decide whether to go left\nor right it's actually probably n by 2\nminus 1 if n\nis if n is even and if n is odd it is\nthe floor of n by2 but again with\nalgorithms with complexities we are\ngenerally want interested in studying\nthe trend so we can ignore that small\npart in the calculation so let's say uh\nthe important part is that even it's\nokay to overestimate a little bit but\ntry not to underestimate so after the\nfirst iteration we may be left with the\nsearch space of size n by2 it may be\nslightly less than that but it's okay to\noverestimate so we have n so we after n\nwe have after the first iteration we we\nare left with a search space of n by2\nthen we split it into half again so next\ntime we may be left with a search space\nof n by 4 which is n / 2 s and then then\nwe may be left by we may be left with n\nby 8 and it's possible that at any of\nthese iterations we may just exit\nbecause we may have found the right\nnumber but what we always try to analyze\nis the worst case complexity of an\nalgorithm what is the longest possible\namount of time or the largest amount of\nspace it can take so right now we are\ntalking about time because we're\ncounting iterations and each iteration\ntakes some\ntime so n by 8 after iteration 3 that's\n2 the^ 3 and I think then you can start\nto see the trend here\nthat after the K iteration you will end\nup with n / 2^ K elements now when does\nthe iteration stop so the final\niteration is on an array of length one\nand that is when we access that last\nelement and check whether after all this\nchecking the last element is equal to\nthe index or\nnot so we can do n / 2^ K and if we set\nthat to one we can rearrange the\nterms and we get back Nal 2 the^ K so\nafter the K iteration if you want to be\nleft with one element then that means n\n/ 2 the K should be equal to 1 or n\nshould be 2 to the K or in other words K\nshould be equal to log log n remember\nlogarithms and here obviously log refers\nto log to the base 2 but what I will\nargue is that you can change the base of\nthe logarithm and that will simply add a\nconstant so that will simply if you're\ntaking the natural log then then that\nwill simply add a constant here and\nremember when we talk about time\ncomplexity we ignore constants so we can\njust generally say that our algorithm\nbinary search has the time complexity of\norder of log n that means as the input\ngrows the amount of time taken by binary\nsearch is proportional to the logarithm\nof the number of elements in the list\npassed to it or the amount of time taken\nis logarithm to the size of the initial\nsearch space and you can verify this you\ncan verify that the space complex you\ncan you can check this out by simply\nwriting it out as well you can take some\nexamples let's say you take a card list\nof size 10 and then work through it the\nworst case and count how many iterations\nyou have and compare if that is close to\nlogin or\nnot and then as an exercise you can\nverify that the space complexity of\nbinary search is order one can you you\ncan try posting in the YouTube comments\nor in the YouTube live chat how the\nspace complexity of binary search is\norder one I'll let that\nstay so let's now compare linear search\nwith binary\nsearch how are the two different and\nwhat we'll do is we will create a large\ntest case because you start to see the\nbenefits of the difference between the\norder n algorithm and the order log in\nalgorithm only when you have larger test\ncases because small test cases\neverything runs instantly so it's not\nreally that much of a hassle so here we\nhave a locate card linear and this is\nthe linear version of the algorithm\nwhere we simply go through each of the\ncards one by\none and then we have a really large test\ncase here so we have the input and then\nwe have the cards which goes in the\nrange okay let's see so that's 1 2 3 so\nthat's th another three that's million\nso we have 10 million elements here so\nwe have 10 million\nelements and\nwe are looking at so we are actually\ncreating a range here so we are using a\nfunction in Python so we creating a list\nof numbers going down from 10 million\nall the way to 1 so a decreasing list\ngoing from 10 million to 1 and this is\nhow you create it and you can check it\nout and in this list we are looking for\nthe number two which occurs at the very\nend so we sort of creating this is as we\nwill see if you want to really analyze\nit this is going to be a worst case\nscenario both for linear search and for\nbinary research approximately worst case\nso the query is two and then the output\nis this is the output that we expect\nobviously because 0 to\n9999999 is are the array indices and the\nlast element is one so the element just\nbefore is two so this is the expected\noutput great so now we have this large\ntest let us call evaluate test case and\nlet us pass check the linear search pass\nin the last test and because this is a\nhuge list we may want to turn off the\ndisplay of the output we may want not\nnot want to actually see the input being\ndisplayed so we can simply turn off the\ndisplay by passing display equals false\nand we can just get back the result from\nthe evaluate test case function so the\nresult will give the output the actual\noutput of the function whether the test\npassed and the running time of the\nalgorithm so it takes a second so it\nlooks like the test did pass our\nalgorithm is correct so that's great and\nit took 1 122 4. 291 milliseconds\nor about 1.2 seconds to answer\nit and you can probably tell why because\nit because this is the result so it\nprobably took 999 9998 iterations so it\nhad to go through all the elements to\nget to the very end on the other hand\nwhen we talk about binary search so now\nwe are passing in the binary search\nversion once again turning displayed of\nfalse and we displaying the output okay\nso this time the result is the same the\ntest did pass but the execution time is\n0.019 milliseconds so that's 55,000\ntimes faster than the linear search\nversion and in fact you can tell how\nmany elements we actually had to access\nso if we just check log\nof so log of this number is about 7 and\nmaybe know if you if you're checking log\n2 we can maybe check something like this\nso not more than 20 elements had to be\naccessed so where we linear search\nneeded to access\nabout 10 million elements binary search\nwas able to get to the answer with just\nabout 20\nchecks so that's a lot of time saved and\nyou can increase the size of the array\nby a factor of 10 and increase this by a\nfactor of 10 as well and then you will\nsee far bigger difference\nwhere for a 10 times larger array linear\nsearch would run for 10 times longer\nwhereas binary search would only require\nthree additional\noperations so the linear search would go\nfrom 10 million operations to 100\nmillion operations binary search would\ngo from 20 operations to\n23 and that is the real difference\nbetween the complexities order n and\nOrder login and as the size of as the\nsize of the arrays grows bigger another\nway to look at it is that if you just\ndivide the complexities binary search\nruns n by login times faster than linear\nsearch for some fixed constant because\nthere's always some constants involved\nand as the size of the input grows\nlarger the difference only gets bigger\nthe difference in\nperformance and that is what algorithm\nanalysis of algorithms and optimization\nof algorithms is all\nabout it's about overcoming the\nlimitations of computers by devising\nclever techniques to solve problems\nand it's something that you can actually\napply in real life as well in a lot of\ncases there are a lot of things that you\nmay see a Brute Force solution to but if\nyou just apply your mind and you may\nfind a more optimal solution a more easy\nway or a more lazy way to do it with\nless\nwork so think about\nthat and here is a graph showing how the\ncomp how you can compare common\nfunctions how the how the running times\nof common functions vary so we will look\nat all kinds of functions we will look\nat constant time functions order one for\nexample accessing an element from an\narray is order one so even if you have\nan element of 10 m a list of 10 million\nelements you can access the last element\nin constant time on the other hand we've\nlooked at binary search which has which\nis order log n and we've also looked at\nlinear search which is order n now in\nthe future we will look at other\ntechniques which have complexities of n\nn Cub n the^ n or far far higher and\nsomewhere in between there is a very\nnice special type of complexity called n\nlogin which is rather nice so we'll talk\nabout that as well and login in fact a\nlot of questions in coding assessments\nand coding interviews tend to\nbe taking algorithms which would be\nwhich would have n Square complexity\nin in a Brute Force approach and\noptimizing them either to order n or to\norder n login\nso we'll we'll discuss all of this so\ndon't worry if this doesn't make sense\njust yet but I hope you see now why we\nignore constants and lower order terms\nwhile expressing the complexity of the\nbig on\nnotation so we've covered binary search\nbut we've seen it in the context of a\nproblem and now we can step away one\nmore step and Abstract it out further\nand identify the general strategy behind\nbinary search and this General strategy\nis actually applicable to a wide variety\nof problems and this is what you want to\nkeep doing as a programmer you need to\nabstract away peel away the layers of\nspecific problem specific details and\nfind the general technique find the\ngeneral strategy and then encode that\nusing your functions and programs so\nhere's the general\nstrategy come up with a condition to\ndetermine whether the answer lies before\nafter or at a given position so we are\nassuming here that we have some kind of\na range and we have to identify a\nposition within a range or maybe an an\nelement within that range but we can\naccess elements using the position so\ncome up with a condition that that first\ntells you whether given a position the\nanswer lies at or before or after that\nposition once you have that condition\nfirst retrieve the midpoint and the\nmiddle element of the list now if the\nmiddle element of the midpoint is the\nanswer then return the middle position\nthat is the answer you're done if the\nanswer lies before it repeat the search\nso repeat the process with the first\nhalf of the list or the first half of\nthe search space and if the answer lies\nafter it repeat the search with the\nsecond half of the search space so here\nis the generic algorithm for binary\nsearch implemented in\nPython and you can see\na classic detail documentation\nhere so\nwhile so here you have the binary search\nis going to take a search space low and\nhigh so low is going to be zero and high\nis going to\nbe well we will pass in maybe the final\nwe will pass in maybe the final position\nthe final index of the array but writing\nit this way rather than passing passing\nan array also allows you to use binary\nsearch for problems that are not based\non array sometimes these could just be\nnumbers for example if I ask you to find\na number between 1 million and 10\nmillion that is a perfect square then\nyou can use binary search to do\nthat then it takes a condition so what\nit does is uh it starts the loop so\nwhile low less than equals High we get\nthe midpoint so low plus High divided by\ntwo that gives us a midpoint then\nremember uh earlier we had this\ncondition test location so our condition\nsimply is supposed to take the middle\nposition and\nidentify if if the middle position is\nthe answer or we need to go left or\nright so the condition should return\neither found left or right so if the\ncondition returns F found we return the\nmidpoint as the answer if the condition\nreturns left we return the high we we\nmove to the left side so which is we\ntake the end of the search space and set\nit to before the midpoint so we set High\nequal to Mid minus 1 and if the\ncondition returns right which is the\nelse case here we set low to mid plus\none so we take the start point of the\nsearch space and move it after the\nelement then we return minus one so\nthat's your binary generic binary search\nalgorithm and if you start using this\nwhat will happen is now this is a tested\npiece of code and in fact we can see it\nhere now now we can rewrite locate card\nand locate card can be uh we're passing\nin cards and we're passing in the query\nand we need to write a condition and\nhere we're using a very interesting\nfeature of python we are writing a\nfunction inside a function so this is\ncalled function closure and it's a very\nhandy feature so now we can simply write\ncondition inside locate card and what\nthat does is binary search is going to\npass the middle value the middle\nposition but condition can also access\ncards and query so which is because it\nlies inside locate so what we do inside\ncondition is okay we check the we get\nthe middle element cards mid if cards\nmid is equal to query then here we have\nthat check we check whether it is the\nfirst occurrence of query or can query\noccur before it if query occurs before\nit we return left else we return found\nand then these are the original\nconditions that we already had so you\ncan verify this by going back and\nchecking but the important part here is\nnow the while loop has gone away now we\ncan simply call binary search with zero\nL cards minus one so the start index the\nend index and the condition and we can\nevaluate the test cases and you can see\nthat the test cases are\ncorrect and now you can use this binary\nsearch function because we have now\ntested it with one problem you can use\nthis exact same function to solve other\nproblems too in some sense it is a\ntested piece of logic so here's what\nwe'll do we'll take a quick question and\nwe will implement it now we've spent\nwhat one and a half hour talking about\nuh particular problem but let's spend\nmaybe 2 minutes talking about a new\nproblem and solving it so now here's a\nslightly related question given an array\nof integers sorted in increasing order\nfind the starting and ending position of\na given number so once again you have a\nsorted array this time they're\nincreasing the only difference is now\napart from the fact that they are sorted\nin increasing order the other uh\ndifference is that we're looking for\nboth the start\nindex and the end index so we're looking\nfor both the start index and the end\nindex of a particular number because the\nnumber can repeat like we saw one\nexample and there's a very simple way to\nSol solve this a simple strategy is do\nbinary search Once to find the first\nposition and that's what this function\ndoes I'll let you read through\nit the only changes here are this\nvariable this has changed this order\nbecause now the now the elements are in\nincreasing order and then the second\nchange uh and there's no other change\nhere so that there's just one change\nhere and then there is another function\ncalled last position here instead of\nchecking the left we are checking the\nright so instead of checking mid minus\none we are checking mid + 1 and if mid +\n1 equals a Target we go to the right and\nof course we have the same change here\nin this code because instead of\ndecreasing we have increasing order\nright so now we write two position now\nwe write two functions first position\nlast position and then first and last\nposition is simply getting the first\nposition once so that's one binary\nsearch and getting the last position\nonce that's two binary searches and\nthat's not bad know the complexity still\norder login two * login or two times\nsome constant times login when you\nexpress it in the big on notation is\nstill login so that's okay and that was\nquick we we were able to reuse most of\nthe code that we have written and that's\nthe Ben benefit of uh making generic\nfunctions like binary search and in fact\nwe can test a solution by making a\nsubmission here so let's go to lead\ncode.com\nlet us here what I've done is I have\nalready copied over the binary\nsearch function the first first position\nfunction and the last position function\nso by the way lead code is a great\nplatform for practicing so you can go to\nlead code.com sign up with uh any\naccount and you will find a lot of\nproblems especially on the in the\nproblems Tab and here you can see that\nthis is exactly the problem that we have\nbeen solving just\nnow so we just post the code here binary\nsearch First Position last position\nfirst and last position and Lead code\nrequires you to write this class called\nsolution this is something that they\ngive you beforehand and inside the\nsolution you need to define a function\ncalled search range where we are simply\ncalling our first and last\nposition here I'll let you see and we\nsimply we can test this code with a uh\ntest case so we can pass a test case\nhere and test it out create or we can\nsimply submit\nit and here you can see that the problem\nwas submitted\nsuccessfully and it tells you things\nlike how much runtime it used what was\nthe memory it used and your and a\nsolution was accepted right so check out\nlead code.com go to the problem section\nand you can see all the different\nproblems that they have you can also\nexplore and you have different problems\nthat come up every day it's a great\nplace to\npractice so that's binary search for you\nbut I just want to revisit the method\nonce again so this is the systematic\nstrategy that we've applied for solving\nthe problem we State the problem clearly\nand we identify the input and the output\nformats this this shows that you've\nunderstood the problem problem you know\nwhat the solution will look like then\ncome up with some example inputs and\noutputs and try to cover all the edge\ncases so this shows that you are\nenvisioning what are the different\ninputs that can come in before you write\ncode then you come up with the correct\nsolution not necessarily the most\nefficient one and state it in plain\nEnglish now when you try to State it you\nwill have to clarify it and that will\nhelp you clarify your own thoughts and\nthen you can analyze the algorithm's\ncomplexity and uh you you can implement\nthe solution and test it using example\ninputs so this is the basic solution now\nin interviews and in coding assessments\nmaybe you know where there's a time\nlimit you may not want to implement the\nBrute Force Sol Brute Force solution\nbecause then you may get stuck in fixing\nissues with brute force and you can\ndirectly Jump Ahead to step five but\nwhile you're practicing always Implement\nBrute Force then step five analyze the\nalgorithm's complexity and most of the\ntime it is simply a matter of counting\nthe number of iterations how many times\na while loop or maybe Loop within a loop\nis getting\nexecuted and identify inefficiencies and\nif it is a Brute Force solution it's\ngenerally quite easy to see the\ninefficiency for example in this case\nthe inefficiency was that we know that\nthe array is sorted that anything we do\nwill be better than going line by line\nright we could pick a random element and\nthat would help us eliminate a good\nchunk of the\narray so that is the inefficiency and\nthen apply the right technique and we\nare learning the techniques so we've\nlearned binary search today and the then\nwe're going to learn a lot more\ntechniques that are asked in interviews\nso apply the right technique to overcome\nthe inefficiency and repeat steps 3 to\nsix which is go back and come up with a\ncorrect solution with the optimized\ntechnique implement the solution and\ntest it using some example inputs and\nthen Analyze That algorithm's\ncomplexity and identify any\ninefficiencies so what we've done for\nyou is we have created\na\ntemplate so you can see this python Pro\nproblem solving template and how you can\nuse this template is\nto Simply run it so you run the code you\nrun this template and then when you run\nthe template inside it you will see this\nquestion mark in a bunch of places so\nyou can give it a nice project name and\nyou can commit it to your profile one\nway you can save a copy over this\ntemplate to your profile is by clicking\nthe duplicate button now if you click\nthe duplicate button you can copy it in\nyour profile and you don't have to look\nfor it you can just find it on your\nJovian profile but but anyway once you\nhave it copied you can click the Run\nbutton and then click run on binder and\nrun run the template then you go down\nonce you run it and you can copy over a\nproblem statement you can copy over a\nlink to the problem so that when you\nneed to make a submission you can go\nback and refer and then here the method\nis summarized for you and here we have\ncreated sections for you so you can\nsimply start filling out this method say\nstep one step two step three step four\nstep five so whenever you're fa based\nwith a difficult problem just use this\ntemplate and I guarantee it one if you\nwork through this course you will be\nable to solve a majority of the problems\nthat you come across and specifically\neven if you are able to follow maybe\nabout 30 to 40% of this course you will\neasily be able to solve most questions\nthat are asked in interviews because\nquestions asked in interviews are fairly\nsimple in terms of the data structures\nor algorithms they test but the\nintention there is more to test your\napproach look at the quality of of your\ncode and see how clearly you expressing\nyourself right and this is what this is\nexactly what this method teaches you to\ndo now to encourage you to do this to\nencourage you to try it out and you can\ntake problems from places like lead code\num code Chef code forces there are a few\nlinks listed here you can see practice\nproblems there are a bunch of links\nlisted here so that was today's lesson\nfor the next\nlesson common data structures in\nPython so this is data structures and\nalgorithms in Python an online\ncertification course brought to you by\nJovian thank you hello and welcome to\ndata structures in algorithms in Python\nthis is an online certification course\nbeing offered by Jovian today we looking\nat assignment one binary search\npractice so let's get started first\nthing we'll do is go to the course\nwebsite python\nall the previous lectures and\nassignments for assignment one you may\nwant to review the video and notebook\nfor lesson\none let's open up assignment one it's\ncalled binary search\npractice now in this assignment you will\napply and practice the concepts that we\ncovered in the first lesson so you will\nunderstand and solve a system uh solve a\nproblem\nsystematically Implement linear search\nand analyze it then optimize a solution\nusing binary search and ask questions\nand help others on the\nForum let's open up the starter notebook\nfor the\nassignment which contains that problem\nstatement and other\ninformation now this is a notebook\nyou're looking at hosted on Jovian you\ncan see some description here and if you\nscroll down below you can also see some\ncode and you will need to execute this\nnotebook modify the code with within it\nand record a new version which you can\nthen submit to see your score so let's\nstart reading through\nit as you go through the notebook you\nwill find three question marks in\ncertain places to complete the\nassignment you have to replace the\nquestion marks with appropriate values\nexpressions or statements to ensure that\nthe notebook runs properly end to end\nnow keep in mind that you need to run\nall the cells otherwise you may get\nerrors like name error or undefined\nvariables you should not be changing any\nvariable names or deleting any cells or\ndisturb any existing code you can add\nnew code cells or new\nstatements but do not redefine or do not\nchange some of the existing\nvariables you will be using a temporary\nonline service for code execution and\nwe'll see how to use it in a moment so\nkeep saving your work by running jan.com\nat regular intervals and then the\nquestion marks optional will not be\nconsidered for evaluation although we\nrecommend doing them they are for your\nlearning but you can make a submission\nbefore you have solved the optional\nquestions\nnow you can make a submission back on\nthe assignment notebook page and we'll\nsee how to do that and if you're stuck\nyou can ask for help on the community\nForum it's listed\nhere and we'll see how to do that as\nwell now one final thing I want to\nmention is you can get help with errors\nor ask for hints you can even share your\ncode and errors that you are getting in\nthe code but please don't ask or share\nthe full working answer code on the\nForum this is so that everybody has the\nopportunity to work through the problem\nstatement on their own make mistakes\nlearn from their own mistakes and arrive\nat the right\nsolution now how do you run this code\nthe recommended way to run this code is\nby clicking the Run button at the top of\nthe page and selecting run on binder but\nyou can also run it using some other\noptions like Google collab or\nkagle or you can run it on your computer\nlocally\nso we're going to use the recommended\nmethod run on\nbinder now we have the notebook running\nin front of us the first thing I like to\ndo is go to Kernel and click restart and\nclear output so that we can see all the\noutputs of the notebook from\nscratch and I'm also going to toggle the\nheader and the\ntoolbar so that we can zoom in a bit\nso now the same Jupiter notebook is now\nrunning online on a platform called\nbinder and before starting the\nassignment let's save a snapshot of the\nassignment to our Jovian profile so that\nwe can access it later and continue our\nwork I'm going to run pip install Jovian\nthis is going to install the Jovian\nlibrary then run import Jovian to import\nthe library and set a project name here\nI'm just calling it binary search\nassignment and run Jovian doc commit now\nyou have taken a stter notebook which\nwas hosted on my profile and then you've\nrun it on binder but as soon as you run\nJovian docit a copy of the starter\nnotebook gets Sav to your profile so\nwhat you will see here is a link to a\nnotebook hosted on your Jovian profile\nlet's open it up here and see so now\nthis is your personal copy of the\nassignment notebook any changes that you\nmake here and run jan. commit will get\nadded to your profile so if you want to\ncome back and continue your work then\nyou do not have to go back to the\noriginal starter notebook which contains\nall blanks rather you can come back to\nyour\nprofile and you can come to your profile\nsimply by opening jan. a and on your\nprofile you can go to the notebooks Tab\nand on the notebooks tab you will be\nable to\nfind as you can see here you will be\nable to find\nthe binary search assignment here there\nyou go this is the binary search\nassignment that we just\ncreated and you can open it and run it\non binder to continue your\nwork so moving along this is the problem\nwe looking at\nhere you are given a list of numbers\nobtained by rotating ass sorted list an\nunknown number of times okay so we have\ntwo new terms here rotating ass sorted\nlist and don't worry if you don't know\nwhat that means normally if you see any\nnew terms in a problem they will be\nexplained some where within the problem\nitself for instance here you can see\nthat there's a definition we Define\nrotating a list as removing the last\nelement of the list and adding it before\nthe first element for instance rotating\nthe number the list 3 2\n41 leads to removal of the last number\nand then placing it at the very\nbeginning so you end up with the list 1\n3 2 4 this is a new operation that we\nare defining this is not something\nstandard but you will find that a lot of\nproblems will Define new terms or new\noperations so that they it becomes\neasier for you to understand the problem\nso that's rotating a list now rotating a\nlist once produces 1 3 2 4 now if you\nrotate that list again the resulting\nlist one more time then you will end up\nwith 4 1 3 2 and so on and then the\nother term is sorted so sorted refers to\na list where the elements are arranged\nin increasing order in this this case we\nhave numbers and the numbers 1357 are\nincreased arranged in increasing order\nso this is a sorted list but if this was\n3241 well that's not the numbers are not\narranged in increasing order so that's\nnot a sorted list so you are given a\nlist of numbers OBT obtained by rotating\na sorted list an unknown number of times\nfor instance this sorted list 0 2 3 4 5\n6 9 is rotated a certain number of times\nand you can verify that if you rotate\nthis three times you end up with the\nlist 569\n0 2 3 4 right you can see that first 9\ncomes to the beginning then six come\ncomes to the beginning and then five\ncomes to the\nbeginning so you need to write a\nfunction and you're given just this the\nlist you're not given the original\nsorted list you're given the list\nobtained by rotating some sorted list an\nunknown number of times now you need to\nwrite a function to determine the\nminimum number of times the original\nsorted list was rotated to obtain the\ngiven list your function should have the\nworst case complexity of order log n\nwhere n is the length of the list and\nyou can assume that all the numbers in\nthe list are unique okay so three parts\nwrite a function to determine the\nminimum number of times you need to\nrotate the original sorted list in this\nin this case it is three the function\nshould have the worst case complexity of\nlog n so this determines correctness and\nthis determines\nefficiency and then this is some\nadditional information to help you that\nyou can assume all the numbers in the\nlist are unique\nif this was not mentioned you would also\nhave to handle the case where your list\ndoes not contain unique\nnumbers now we will apply the method\nthat we have been applying all\nthroughout this course for solving the\nproblems number one state the problem\nclearly identify the input and output\nformats number two come up with some\nexample inputs and outputs and try to\ncover all the edge cases number three\ncome up with a correct solution for the\nthe problem and state it in plain\nEnglish number four implement the\nsolution and test it using some example\ninputs and having test cases and then\nimplementing a solution allows you to\ntest them using the example inputs and\nfix any bugs that's why it's very\nimportant to have some test cases number\nfive analyze the algorithm's complexity\nand identify any inefficiencies and\nnumber six apply the right technique to\novercome the\ninefficiency and then you go back and\nrepeat steps 3 to six come on up with a\ncorrect solution implement the solution\nand test it and analyze the algorithm's\ncomplexity and you can review lesson one\nfor a detailed explanation of this\nmethod now let's apply it step by step\nthe first step is to State the problem\nclearly and identify the input and\noutput formats now while it is stated\nclearly enough it always helps to\nexpress it in your own words in the way\nthat it makes it most clear for you and\nthis is something that you can keep\nreturning to rather than the original\nproblem statement\nbecause this is something that you will\nunderstand better and it's okay if your\nproblem overlaps with the original\nproblem statement but do try to express\nit in your own words so in this case\nwhat I've just done is I have double\nclicked here once you double click you\ncan now edit this text cell and now we\ncan start writing a\nproblem so let's say given a rotated\nlist we need to find\nthe number of\ntimes it was rotated and okay I think\nwhat I've probably missed here is that\nit is a sorted list so given\na sorted list that was\nrotated some unknown number of\ntimes we need to find the number of\ntimes it was rotated right maybe I'm\njust going to say given a rotated sorted\nlist because technically the input is\nnot a sorted list it's a rotated sorted\nlist so given a rotated sorted list that\nwas rotated in an unknown number of\ntimes we need to find the number of\ntimes it was rotated now doing this\nexercise helps\nyou\ndetermine if you've understood the\nproblem correctly and you may often find\nthat okay there's a certain detail in\nthe problem that you missed okay but at\nthis point I'm happy with my\ndescription and you will see that it is\nmatching the description to a large\nextent but it's something that I\nunderstand better so I'll just refer to\nthis from this point now I'm assuming\nhere that I know what rotation and\nsorted means otherwise I could also\ninclude those then here's a question the\nfunction will you will write will take\none input called nums what does it\nrepresent and given an example okay so\nonce again we double click on this and\none input\nis nums so this\nis a sorted rotated\nlist and let's give an example here\nlet's say we take the sorted list 3 5 6\n7 9 and then we rotate it a few times\nlet's say we rotated a couple of\ntimes so we end up with this sorted\nrotated\nlist so that's our input so we've\nanswered the question here now the first\nquestion was to express the problem in\nyour own word words this is a solution\nthe second question was what does the\ninput nums represent Give an example it\nrepresents a sorted rotated list\n79356 the third question is the function\nyou will write will return a single\noutput called rotations what does that\nrepresent well you have to write a\nfunction that identifies how many times\nthe list was rotated so this is the\nnumber of times the sorted list was\nrotated okay\nand in this case the example that we\nhave is that this sorted list was\nrotated twice 356 79 was rotated two\ntimes so you mentioned two here now you\ncan see these back quotes that I'm using\nhere this is next\nto the number one on your keyboard or\nbelow the Escape\nkey what these back quotes let you do is\nthey let you express text as code within\nmarkdown you can see that they have a\ngray background and they have different\nfont this looks a lot more like code\nsame is here true for nums so you can\nuse markdown and its\nfeatures to your advantage to organize\nyour descriptions and your text\nbetter okay so now based on the above we\ncan now create a signature of our\nfunctions we have a function called\ncounts rotations it takes a num list of\nnumbers and it returns well right now we\njust putting pass in here but we know\nthat it's going to return a single\nnumber rotations\nnow after each step remember to save\nyour notebook so we going to just run\njin.\ncommit and now if you leave your\ncomputer you do not have to be worried\nthat your work may be lost so you can go\nin here and you can open up this\nnotebook from your Jovan profile and R\npress run at any point to run this\nnotebook\nnow step two is to come up with some\nexample inputs and outputs and try to\ncover all the edge cases and our\nfunction should be able to handle any\nset of valid inputs so here is some\nvariations that you can encounter a list\nof size 10 rotated three times a list of\nsize eight rotated five times so these\nare two generic examples and then a list\nthat wasn't rotated at all a list that\nwas rotated just once a list that was\nrotated n minus one times where n is the\nsize of the list\na list that was rotated end times and\nwhat do you mean by rotating the list\nend times well let's see an empty list\nand a list containing just one element\nand if you can think of more test cases\nyou should definitely add more test\ncases here and what we'll do is we will\nexpress our test cases as dictionaries\nso this will help us organize the test\ncases and test them all at once more\neasily using helper functions so you can\nsee here that we've organized one test\ncase here and we've expressed the test\ncase as a dictionary so here we have the\ninput to the test case that is the input\nkey and then we have the output to the\ntest case now because a function can\ntake many arguments the input itself is\ngoing to be a dictionary and then for\neach argument in this case there's just\none so we just call it\nnums we have the input\nhere and this is the size of the output\nokay so let's create this test case and\nlet us uh then if you want to fetch the\nactual input and output out of it so\nhere we can fetch test input nums that's\ngoing to give us the nums we can use\ntest input the output should be test\noutputs this seems to be an\nerror and the result is Count rotations\nnum\nzero okay so this is the actual result\nobtained by passing the test case into\ncount\nrotations and you can see that the\nresult we get back is none because right\nnow we do not have any code we it just\nsays pass\ninside and the result and the output are\nnot equal because the output is the\nnumber three but the result is none so\nthat's okay our test case is failing\nright now because we have not yet\nimplemented the function but as soon as\nwe implement it we expect to see the\ntest case passing now to help you aoid\nvoid all of this work we have given you\na function called evaluate test case so\nfrom jan. python DSA you can just import\nevaluate test case and then call\nevaluate test case with the function you\nwant to test and the actual test\ncase and you can see here it prints the\nout input that was passed in the\nexpected output the actual output that\nwas obtained and the test result in this\ncase the test result was failed and the\nexecution time is also printed here if\nyou just want to evaluate\nif a certain implementation is faster\nthan\nanother so now your job is to create\ntest cases for each of the scenarios\nlisted above so here is test zero that\nis same as the original test case that\nwe had created now here is test one a\nsize a list of size eight rotated five\ntimes I will let you create this but it\nwill look something like this you will\nopen up you'll replace the three\nquestion marks with let's say a list of\nsize eight so 1 2 3 4 5 6 7 8 and you\ncan imagine that if this was rotated\nfive times then 1 2 3 4 five four five\nof these numbers will then move to the\nfirst\nposition and you get this as the input\nnumbers and the output well it was\nrotated five times so I think you can\nguess that the output here should be\nfive now here is a list that wasn't\nrotated at all\nwhat should be the output\nhere I'm sure you can guess that the\noutput here should be zero so I let you\nfill this out here is a list that was\nrotated just once so let's try let's\nfill out this\none so\nthis this list rotated once would give\nus 735\nthere you go a list that was rotated n\nminus one times where n is the size of\nthe\nlist okay I'll let you do that a list\nthat was rotated n times where n is the\nsize of the list okay what does that\nlook\nlike so you take this list and then you\nfirst put 10 in the first position and\nthen you put 9 in the first position so\n9 10 comes to the beginning and 3578\ncomes after it\nthen you move eight to the first\nposition then you move seven then you\nmove five then you move three if if you\nmove all of these back to the first\nposition you end up with the same list\nso you've rotated it end\ntimes now what should be the output in\nthis case there are about six numbers\nhere so is the output\nsix I don't know I'm not so sure because\nremember the question the original\nquestion\nsays write a function to determine the\nminimum number of times the original\nsorted list was rotated to obtain the\ngiven list so it has to be the minimum\nnumber of times we may want to just go\nback and change this we need to find not\nthe number of times it was rotated but\nthe minimum number of times it was\nrotated or it needs to be rotated right\nso coming back\nhere the output should be not six but\nzero so keep that in mind then here's an\nempty list I'll let you figure out what\nshould be the nums and the output here\nand here is a list containing just one\nelement once again should be pretty\nstraightforward can you rotate a list\nwith one\nelement I'll let you decide and then we\ntaking all the tests and putting them\ninto a single list now since I have not\ndefined all the tests I am not going to\nuse this definition which contains all\nthe tests but I'm just going to pick the\nnumber of tests that I have defined\nso we have defined here test zero test\none test three test\nfive I'm just going to put\nin test zero test one test\nthree and test\nfive and that's the full set of tests\nthat we have you definitely need to fill\nout all the test test cases and if you\ncan think of some other cases that you\nshould be\ntesting then you should include those\ntest cases here as well\nokay now to evaluate your function\nagainst all the test cases together you\ncan use the evaluate test cases helper\nfunction from Jian so there are two\nfunctions evaluate test case works with\na single test case and evaluate test\ncases works with a list of test cases so\nwe have a list of test cases here I have\nfour but you should have about eight at\nleast and a few more if you've created\nthem so we can import from jan. python\nDSA evaluate test cases and then invoke\nevaluate test cases with the count\nrotations function still it we\ndon't have any logic in the function so\nall the test cases should pass and the\nlist of test cases we've created so you\ncan see test cases zero fails one fails\ntwo fails three fails so out of the four\ntest cases none of them have\npassed no\nproblem we have completed step two which\nis to create some test cases and we'll\nknow once we've defined a function\nwhether the function definition is\ncorrect now the next step is to come up\nwith a correct solution for the problem\nand state it in plain\nEnglish and there's a hint here for you\nalready a coming up with the correct\nsolution is quite easy and it's based on\nthis simple Insight if a list of sorted\nnumbers is rotated K times so you keep\nrotating it step by step moving the last\nnumber to the first\nposition then the smallest number in the\nlist ends up at position K okay and you\ncan verify this it's very simple to do\nthis whenever you have a doubt just\ncreate a new cell by the way you can\ncreate a new cell by clicking on the\nleft side of a cell and click insert\ncell below or if you're in a code cell\njust click here near the prompt and\npress the B\ncharacter and that adds a new cell\nbelow so let's take the list 1 3 5 7 5\n67 and let's rotate it K times let's try\nwith k equal 2 so if you set k equal to\ntwo then you're going to take two of\nthese numbers from the very end and move\nthem to the beginning\nso that means 0 comes at position six\ncomes at position 0 7 comes at position\n1 and the starting element in the sorted\nlist now comes at position\ntwo that's interesting let's move the\nthird element as\nwell okay so now we've moved three\nelements or rotated the list three times\nand the smallest element ends up at\nposition\nthree so it seems to hold true and you\ncan verify this now with a larger list\nsmaller list empty list and all the the\ntest cases that you have if a list was\nsorted K times sorted list was rotated K\ntimes then the smallest number in the\nlist ends up at position K counting from\nzero further it is the only number in\nthe list which is smaller than the\nnumber before it and you can see this\nonce again the smallest number is at\nposition three and all of these numbers\nare higher than the numbers that come\nbefore them except the number one which\nis smaller than seven\nso we simply need to check for each\nnumber in the list whether it is smaller\nthan the number that comes before it if\nthere is a number before it then our\nanswer is simply uh which is the number\nof rotations is simply the position of\nthis number right so if you can find the\nposition of the\nnumber which is smaller than the number\nthat comes before it the position of the\nnumber is also equal to the number of\ntimes the sorted list was rotated and if\nwe cannot find such a number then the\nlist wasn't rotated at\nall and that's it you can see here in\nthis list now applying this logic three\nis the number the smallest number and\nnot only that three is the only number\nwhich is lower than the number that\nprecedes it the predecessor which is 29\nand since three occurs at position 4\nwell actually three occurs at position\nthree 0 1 2 3\nthe list was rotated exactly 3\ntimes now we can use the linear search\nalgorithm as a first attempt to solve\nthis problem and the linear search\nsimply involves working through this\nlist walking through this list from the\nleft to the right so now the task for\nused to describe the linear search\nsolution in your own words and please\nwrite it in your own words but here's\nhow I'm going to write it\nlet's say create a\nvariable position with value zero so\nthis is the position for tracking this\nis for tracking the position\nthen look at\nthe number\nat the given position and not only look\nat it\nbut compare the number at the let's say\nthe current position\nto the number before\nit now if you're starting position with\nthe value zero\nmaybe we may not there's no number\nbefore it so we may not be able to\ncompare it with something we may even\njust start with the value one that's all\nright if the number\nis smaller\nthan its read this\ncessor then return position because\nposition is the answer we found the\nnumber that is smaller than its\npredecessor there's only one such\nnumber\notherwise\nincrement position and\nrepeat till we\nexhaust all the\nnumbers\nokay simple\nnow you can add more steps if your\ndescription of the algorithm requires\nmore steps that's perfectly all right\nbut at this point we have a very clear\ndescription of the solution now we\nstarting with the position one not zero\nbecause we also want to track the\nprevious\nposition now we import Jovian here and\ncommit our project once again I keep\nsaving your work after every step so\nthat you can continue your work\nso now we're talking about implementing\nthe solution and testing it so let's\nimplement the solution we said that we\nwant to start with\nposition we want to start with position\none and while when should the loop be\nterminated well while\nposition is less than the Len of nums I\nguess that's fair and then what is the\nsuccess criteria so we have if position\ngreater than zero\nand nums of position less than nums of\nposition minus one okay so that's a\nsuccess criteria here now you can see\nthat there's a condition if position\ngreater than zero here so we don't\nreally need to start position at zero we\ncan start position at or we don't really\nneed to start position at one we can\nstart position at zero as well and all\nthat will happen is this condition will\nget skipped and Position will get\nincremented and this\nis a good practice because whenever you\niterate over a list you normally just\nwant to start with zero just to avoid\nany confusion later when you're reading\nthe code that did you intend to write\nzero here or one etc etc so just put in\nposition equals 0 here and simply skip\nthe check here or simply skip this\ncomparison if position is not valid\nright so whenever you're accessing an\nelement from inside a list or inside a\ndictionary you always want to make sure\nthat that index or that key is valid\nokay here we are making sure that the\nkey position minus one is valid by\nchecking position greater than\nzero in any case we now have the logic\nand\nfinally we are saying that if the number\nat position is less than the number that\ncomes before it then we return that and\nthat's just going to if it's not then\nit's going to increment the position and\nit's going to check again and again and\nagain till we run out of numbers now if\nyou've ex exhausted the entire\nlist then it follows\nthat there were no rotations or there\nwere n rotations exactly in either case\nthe number we return should be zero okay\nso keep this in mind some you may have\nthe doubt should you be returning minus\none here or should you be returning zero\nhere well the question does specify\nclearly that you are given a sorted\nrotated list and you have to find the\nnumber of times it was rotated now\nobviously minus1 rotations are not\npossible so minus1 would not be a Val\nvalid return value from your function\nand this is the reason we write test\ncases\nto now let's evaluate the test case so\nlet's call evaluate test case for a\nsingle test case on count rotations\nlinear and let's see what the test case\nis this is the test case here and this\nis the output we call evaluate test case\nwith count rotations linear and test and\nthat gives us a linear search\nresult you see here this was the number\nthe list of numbers this was the\nexpected output and this was the actual\noutput so great our function seems to\nhave passed the test case now we can\nevaluate all the test cases by calling\ncount rotations linear on all the test\ncases together and give that gives us a\nwhole list of test results test case 0\nand 1 and two and three all of them have\npassed now if you had put in minus one\nhere\nyou would see\nthat one of the test cases would fail\nwhich is the case where the list wasn't\nrotated at all or was rotated end\ntimes okay so that should tell you that\nthe answer here should be\nzero so that's our linear search\nalgorithm and at this\npoint you may face issues you may feel\nstuck you may not be able to figure out\nhow to write the code and that's\nperfectly all right that's part of\nlearning you may face errors you may\nface exceptions for instance if you did\nnot have this check here position\ngreater than zero or maybe you what you\nhad here\nwas some other condition like position\nless than equals position + 1 and that's\nokay then you can go to the Forum and\npost your issue so let's open up The\nForum\nhere this is\nthe Forum discussion for assignment one\nand you can go into the original topic\nhere which is a longer discussion so\nthis is where everybody's posting small\nissues so you can see that there's about\n321 messages that have been posted you\ncan start looking through this forum you\ncan start reading through some of the\nposts you can even search if you press\nCRF and you can even search for\nquestions here now if you want to post\nyour own question scroll down to the\nvery end or you can just click this\nbutton here and click\nreply okay and mention your question\nhere I have\n[Music]\na an\nissue should I return minus one or zero\nin the case the list has not been\nrotated okay maybe that's and if you\nwant if you have code that's not working\nor there's an error you can also include\na screenshot of your code or I'll show\nyou another trick you can actually\ninclude let's say you commit your\nnotebook so let me come up here I've\ncommitted my\nnotebook and if you have a particular\nline of code that you want to share you\ncan actually click copy cell link and\npaste it\nhere so that will give a link to the\nentire cell and if somebody clicks on\nthe link then they can view that\nspecific cell of the notebook directly\nlet's\nsee you can see here that it brings us\ndirectly to this specific\ncell there's another option you can even\nclick on embed\ncell okay for embed for secret notebooks\nwe do not allow embedding but copying\nthe cell link should\nwork and then click reply and your\nquestion will be posted and somebody\nwill reply to your question just come\nback to the Forum in a few hours or\nmaybe the next day and you should see an\nanswer you will also receive an\nemail so that's the discussion topic you\ncan also go back to the topic here the\ncategory here and create a new question\nyou can see if you want to start your\nown thread if you think your question\ndeserves a deeper discussion where\nmultiple people can reply you can also\ncreate a new thread by clicking new\ntopic okay so keep this in mind and do\nmake use of the Forum what we've seen is\npeople who are active on the Forum are\nat least four to five times more likely\nto complete the course and earn the\ncertificate of\naccomplishment and continue\nworking on these topics after the course\nas well\nokay so the next step is to analyze the\nalgorithm's\ncomplexity and the way to do this if\nyou've seen lesson one is to Simply\ncount the number of iterations the\nnumber of executions of the while\nloop now if you have a list of numbers\nof size\nn then you can see here that this is the\nkey Loop\nhere while position less than the length\nof numbers so then then there will be n\nLoops or n iterations and then inside\neach each iteration we performing\ncertain comparisons and returning things\nso all of these are in effect constant\ntime and based on this you can probably\ntell that the complexity of linear\nsearch is order of n so you can just put\nin a big o n in the Big O notation this\nwould be order n so that's the first\npart of the assignment linear search now\nthe next step is to apply the right\ntechnique to overcome the inefficiency\nsee and that's where you can now you can\nnow read through the rest of the\nassignment now the idea here is this\nbinary search is the technique we'll\napply and the key\nquestion we need to answer in binary\nsearch is given the middle element can\nyou decide if it is the answer which\nmeans if it is let's say the smallest\nnumber in the list or whether the answer\nlies to the left or the right of it okay\nso given the middle given if the middle\nelement is smaller than its\npredecessor then it is the answer we\nalready know that because there's only\none number in the list that is smaller\nthan its predecessor so you can see here\nfor example now if the middle element\nwas one which it's not but suppose it\nthe middle element was one and you can\nsee that one is smaller than 8 then we\nknow that one is the answer so the\nposition of the middle element is the\nanswer however if it isn't then we need\na way to determine whether the answer\nlies to the left left of the middle\nelement or to the right of it and\nconsider these examples so here you can\nsee that the middle element is three and\nthe answer\nis the position two uh\nso in this case the answer or the\nsmallest element lies to the left on the\nother hand in this case you can see the\nmiddle element is four and the smallest\nelement minus one lies to the right of\nit so now you need to apply your mind\nand think of a check that will help you\ndetermine if the middle element given\nthe middle element if the answer lies to\nthe left or the right of it right and\nwe're looking for the smallest element\nremember so the logic here if you just\nspend a couple of minutes you will come\nup with this quite easily if the middle\nelement of the list is smaller than the\nlast last element of the list okay or\nthe last element of the range that we're\ncurrently looking at that means that all\nthe numbers here are in increasing\norder so then the answer lies to the\nleft of\nit on the other hand if the middle\nelement of the list is larger than the\nlast element of the\nrange that means that because we know\nthat the list is a rotated sorted list\nso that means that the numbers increase\nup to a point and then there's a\ndecrease and then they continue\nincreasing that's the only way in which\nthe final element can be\nsmaller so that means the answer lies to\nthe right of it so that's the logic here\nfor binary search and now what you have\nto do is describe the binary search\nsolution in your own words so here once\nagain you have these four five lines\nit's very important that you do this\nbecause if you cannot express it then\ncoding it is also going to be difficult\nfor you so always do this exercise of\nexpressing the solution in your own\nwords when you're practicing when you're\nsolving a coding challenge or something\neven in an interview it's also very\nimportant because the first thing you\nneed to do is to communicate to the\ninterviewer your thought process and how\nyou're thinking about the problem so the\nfirst thing you need to do is describe a\nsimple solution in your in simple words\nand then they may or may not ask you to\ncode that solution and then the next\nthing is to identify the complexity or\nidentify the\ninefficiency then the next step for you\nis to describe the optimal solution or\nthe binary search solution in your own\nwords okay\nnow if you don't describe the solution\nin your own words and you start writing\nthe code they may not be able to follow\nyour code so even if you've written\nmostly correct code maybe with one or\ntwo edge cases wrong they may still have\na feeling that you don't know what\nyou're writing but if you explain the\nsolution clearly to them they will know\nthat now you understand the solution and\nthey will be able to follow the code as\nyou write it and they will be able to\npick up mistakes or errors and help you\nwith the errors one secret is that\ninterviews are always open to helping\nyou unless you make them really confused\nso keep that in mind and describe the\nsolution in your\nwords once you do that you can commit\nnow the next step is to implement the\nsolution now you implement the binary\nsearch solution as described in the\nprevious\nstep let's run this\nagain yeah\nso you run count rotations Define the\nfunction count rotations binary now you\nmay want to review lesson one here on\nhow to start it out you'll see that low\nstarts out at zero and high starts out\nat\nLen nums minus one and I will not solve\nthe rest of\nthis but there is a certain condition\nhere between low and high so in binary\nsearch we are starting with the entire\nlist as the range then we looking at the\nmid number so we getting the first the\nmid position and we look at the number\nat the mid position then we check if the\nmiddle position is the answer so if the\nmiddle position is the answer we return\nthe middle position then we check if the\nanswer lies in the left half so here's a\ncondition where you decide if the answer\nlies in the left half and we once that\nif the condition holds true all we do is\nwe change the high so which we change\nthe end point of the range to midus one\nand then we check if the answer lies in\nthe right half and in that case we\nchange the starting point of the range\nto Mid + 1 and the Y Loop repeats okay\nso that's the general logic of binary\nsearch and one thing you have to keep in\nmind is if none of the elements satisfy\nthe criteria that you have what is the\nanswer and this is a very important\ncondition this is\nwhere it is very easy to go wrong this\nis also called The Edge case or the\ntrivial case so you should handle and\nthink about this carefully okay and then\nonce you've done that you can evaluate\nthe test case and you can a single test\ncase you can evaluate multiple test\ncases now if your test cases are failing\nyou may want to enable this print\nstatement Inside by uncommenting it but\nmake sure to comment it out at the end\nonce again and the print statement will\nhelp you see what the low high and mid\npoints were now you may want to then\ntake a pen and paper look at an example\nthat is failing and see if the printed\nnumbers match what you expect to\nsee debugging your function is a very\nimportant skill so keep that in\nmind and use a debugging technique like\nthis by adding print statements and\nworking out the same problem side by\nside on paper to fix your issues\notherwise you may feel lost if you're\nnot able to look into the internal\nworkings of the\nfunction next you have to analyze the\nalgorithm's complexity and identify\ninefficiencies this should be\nstraightforward enough we've already\nlooked at the complexity of binary\nsearch but all you need to do is make\nsure that what you're doing within the\nalgorithm matches the analysis that\nwe've done earlier so the problem size\nreduces by half each time and then we\nare doing constant work in each step\nbefore solving a problem of half the\nsize so that should roughly give you an\nanswer and keep committing your\nwork now finally to make a submission\nyou have two\noptions now one option is to take this\nlink so your notebook has been committed\nhere and you can come to the assignment\npage let's open up the assignment Page\nminary search practice come down here\nand paste\nthis link here and click\nsubmit now once you click submit the\nassignment will be submitted\nand it will go into automated evaluation\nso in about a couple of minutes maybe up\nto an hour depending on the Que of\nsubmissions from different participants\nyou will receive a grade over email\nlet's just refresh the\npage and it seems\nlike there was an issue here the issue\nwas that count rotations binary was not\ndefined so it's possible\nthat this happened count additions\nbinary did not get defined because there\nare a bunch of question marks here so we\nmay need to then fix the issue and then\ncome back\nand make a submission once again okay so\nI have received fail grade I will go\nback and I will fix the issue and then\ncome back okay now it's very important\nfor you that's why to have good a set\ngood set of test cases for you to test\nyour\nfunction so that when you submit it or\nwhen you get an error you can maybe look\nat your functions performance on the\ntest cases and fix anything that needs\nto be fixed and add new test cases if\nyou need\nto now one other way you can submit is\nby simply running the code P jan. submit\nassignment equals python DSA hyphen\nassignment 1 the code is mentioned here\nyou can see here that the submission was\nmade and you can verify your submission\non this\npage okay\nso that's assignment\none so what should you do next review\nthe lecture video if you need to and\nexecute the jupyter notebook you may\nneed to keep you may want to keep the\njupyter notebook running side by side as\nyou're working on the assignment then\ncomplete the assignment and even attempt\nthe optional questions if you scroll\ndown here on the assignment notebook you\nwill find that there are some optional\nquestions for\nyou here's one bonus question use the\ngeneric binary search algorithm so\ninside the python DSA module in Jovian\nthere is a function called binary search\nyou can use the generic binary search\nexample then here's an optional bonus\nquestion to handle repeating numbers we\ndid say that you can assume\nthat there are no repeating numbers in\nthe list but here's one list with\nrepeating numbers can you modify your\nsolution to handle the special case and\nthen here's an optional bonus question\nthree about searching in a rotated list\nso you're given a rotated list now\ninstead of finding the number of times\nit was rot you're you're trying to find\nthe position of a certain number for\ninstance the position of six can you\napply binary search and modify your\nprevious solution slightly to search\nwithin the rotated list and find the\nposition of a given number okay now\nhere's a hint you can simply Identify\ntwo sorted sub arrays within the given\narray and perform a binary search on\neach\nsubarray using so the to identify the\ntwo sorted subarrays you can use the\ncount rotations binary function so\nthat's one potential solution another\nway is to modify the count rotations\nbinary function to solve the problem\ndirectly so it's a very interesting\nproblem to solve and if you found the\nassignment easy then you should\ndefinitely solve these bonus questions\nand if you can solve this question by\nyourself without taking additional help\nthen you can solve pretty much any\nproblem related to binary search that\nthat may be asked in an interview\nbecause most of the questions are some\nvariations of something like this and\nthis is pretty much the hardest problem\nyou may get\nasked you can also test your Solution by\nmaking a submission on lead code and\nthis is only for the final optional\nquestion and there's a thread on the\nForum where you can discuss the bonus\nquestions separately as well so do make\nuse of the Forum thread\ntwo here it is optional bonus questions\ndiscussion\nso that was assignment one of data\nstructures and\nalgorithms this is called binary search\npractice hello and welcome to data\nstructures and algorithms in Python this\nis an online certification course by\nJovian my name is Akash and I am the CEO\nand co-founder of\nJovian you can earn a certificate of\naccomplishment for this course by\ncompleting four weekly assignments and\ndoing a course project today we are on\nlesson two of six\nnow if you open up python saa.com you'll\nend up on this course website where you\nwill be able to find all the information\nfor the course you can view the pr\nprevious lessons which is lesson one and\nuh you can also work on the previous\nassignment which is assignment one and\nyou can also check out the course\nCommunity Forum where you you can get\nhelp and have\ndiscussions so let's open up lesson\n2 this is the lesson page here you will\nbe able to see the video for this\nlesson you can watch live or you can\nwatch a recording here and you can also\nsee a version of this video lecture in\nHindi and in this lesson we'll explore\nthe use cases of binary search trees and\ndevelop a step-by-step implementation\nfrom scratch solving many common\ninterview questions along the way so\nhere is the code that we are going to\nuse in this lesson all the different\nnotebooks containing the code are list\nhere and let's open up the first\none so here you can see all the\nexplanations and the code for this\nlesson this is binary search trees\ntraversals and balancing in\nPython and this is the second notebook\nin the course you can check out the\nfirst notebook in lesson one and if\nyou're just joining us this is a\nbeginner friendly course and you do not\nneed a lot of background in programming\nwith a little bit of understanding of\npython and a little bit of high school\nmathematics you should be able to follow\nalong just fine if you do not know these\nthen you can follow these tutorials to\nlearn the prerequisites in just about an\nhour or\ntwo now the best way to learn the\nmaterial that we are covering in this\ncourse is to actually run the code and\nexperiment with it\nyourself so to run the code and you can\nsee here if we scroll down you can see\nthat there is some code here on this\npage as well now to run the code you\nhave two options you can either run it\nusing an online programming platform or\nyou can run it on your computer\nlocally so to run this code we will\nscroll up and click on the Run button\nand then click run on binder and this is\ngoing to start executing the code that\nwe were just looking at so once again\nyou can go on the course page python\nand you can watch the video there and on\nlesson two you can open up the link to\nthe code where you can read the code and\nthe explanations here and if you want to\nrun the code just click the Run button\nand that will execute the code for\nyou so once you click the Run button on\nbinder you should be able to see an\ninterface like this this is the Jupiter\nnotebook interface the same explanations\nthat we were seeing on the lesson page\nyou can see here the same explan exps\nare now available here but the\ndifference is you can now edit these\nexplanations and you can go down and you\ncan actually run some of the code in\nthis tutorial you can see here that you\nhave a run button and when you click the\nRun button that is going to run the code\nin this particular cell and this is a\nJupiter Notebook made up of cells now\nwe'll do a couple of things here the\nfirst thing we'll do is we'll click on\nkernel and click on restart and clear\noutput what this will do is this will\nclear all the outputs of the code cell\nso that we can execute them ourselves\nand then I'm just going to zoom in\nhere and hide the interface so that we\ncan look at the explanations and the\ncode so finally we have some running\ncode and in this notebook we will focus\non solving this specific problem and\nthis is a common question a question of\nthis sort can be asked in interviews so\nthis is an interview question but along\nthe way we will also learn how to build\nbuild binary trees and binary search\ntrees and how to apply them to several\nother questions so here's the question\nas a senior backend engineer at Jovian\nyou are tasked with developing a fast\ninmemory data structure to manage\nprofile information which is username\nname and email for 100 million users it\nshould allow the following operations to\nbe performed efficiently you should be\nable to insert the profile information\nfor a new user find the profile\ninformation for a user given their\nusername and then update the profile\ninformation of a user once again given\ntheir username and list all the users of\nthe platform sorted by username and you\ncan assume here that usernames are\nunique so this is a very realistic\nproblem that you might face if you're\nworking at a company where you have a\nlot of\nusers so let's see how we solve this\nproblem now here's a systematic strategy\nthat we'll apply for solving problems\nnot just here but throughout this course\nthe first step is State the problem\nclearly and in abstract terms and then\nidentify the input and output formats\nthen come up with some example inputs\nand outputs to test any future\nimplementations and try to cover all the\nedge cases then come up with a simple\ncorrect solution for the problem it\ndoesn't have to be efficient it just has\nto be correct and state it in plain\nEnglish and then implement the solution\nand test it using some example inputs\nfix bugs if you face any and finally\nanalyze the algorithm's complexity and\nidentify inefficiencies if\nany now once you identify inefficiencies\nthen we apply the right technique and\nthat's where data structures and\nalgorithms comes into picture so we\napply the right technique to overcome\nthe inefficiency and then we go back to\nstep three so come up with a new correct\nsolution which is also efficient state\nit in plain English implement it and\nthen analyze the complexity now if you\nfollow this process you should be able\nto solve any programming problem or\ninterview question\nso step one we State the problem clearly\nand we identify the input and output\nformats now we can reduce the problem to\na very simple single line statement we\nneed to create a data structure which\ncan efficiently store 100 million\nrecords and we should be able to perform\ninsertion search update and list\noperations all of them as efficient as\npossible now the input the key input to\nour data structure the solution that we\nare building is going to be user\nprofiles which contains username name\nand email of a user now before we come\nup with a solution we need a way to\nrepresent user profiles and a python\nclass would be a great way to represent\nthe information for a user so you may\nhave heard of the term objectoriented\nprogramming and that is what we're going\nto look at now if you're not familiar\nwith a class it's very simple a class is\nsimply a blueprint for creating object\nand what's an object well everything in\nPython is an object whether you're\nlooking at a number a dictionary a list\nuh anything and you can create your own\ncustom objects with custom properties\nand custom methods by creating your own\ncustom classes so here's the simplest\npossible class in Python with nothing\ninside it we creating a class user so\nthis is how you declare a class and then\nwe're putting nothing inside it so\nwhenever you put nothing inside a\nfunction or a class or anything uh you\ncan put you need to put the past\nstatement because python cannot accept\nempty blocks of code so here we're\ncreating a class which does not have\nanything inside\nit and we can create an object or it's\noften called instantiation which is take\ncreating an instance of a class\ninstantiate an object of the Class by\ncalling it like a function so we say\nuser one is\nuser so this creates an object and the\nvariable user one points to that object\nnow we can verify that the object is of\nthe class user by simply printing it or\nby checking its type user one and type\nuser one are both user now the object\nuser one does not contain any useful\ninformation so let's add what's called a\nConstructor method so Constructor method\nis used to construct an object to store\nsome attributes and\nproperties so now we're defining the\nclass user once again but inside it we\nare defining this function and you can\nsee that this function is inside the\nclass because there is some indentation\nhere so we Define this function\nunderscore uncore init and it takes four\narguments now the first argument is a\nspecial argument called self and we'll\ntalk about this and then we have three\narguments username name and email and\ninside in it what we're doing is we are\nsetting self. username so we're setting\na property on self to username we\nsetting a property on self to name and\nwe're setting a property on self to\nemail and finally we're printing user\ncreated so let's see let's create\nanother user user 2 and you can see that\nuser 2 is also an object of the class\nuser now here's what happening\nconceptually when we do this the first\nthing that happens is when you invoke\nthis function when you invoke user as a\nfunction python first creates an empty\nobject of the class\nuser and then stores it in the variable\nuser to and then python invokes the init\nfunction\nand to the init function it passes user\nto the object that was just created as\nself and then the other arguments that\nwere passed while creating the object as\nthe rest of the arguments so you can\nimagine that we are basically\ndoing we basically calling user doore\ninit the function with user two an empty\nobject and these arguments John jondo\nand joh.com and then inside the init\nfunction we simply set these properties\non user two so now we get user two.\nusername is John user two. name is John\ndo and user two. email is John dojo.com\nso that's basically how classes work in\nPython then that's why you always have\nthis additional extra argument in all\nclass methods which will refer to the\nobject that finally gets\ncreated okay\nso once user 2 is created with the\nvalues John joho and John do.com you can\ncheck that user two.\nname is John do and user two. email is\nJohn do.com and user two. username is\nJohn now you can also Define some custom\nmethods in inside a class so obviously\nwe had the init method but here we are\nalso defining another method called\nintroduce yourself now introduce\nyourself uh takes again two arguments\nthe first argument is self which will\ndef refer to the actual object that gets\ncreated later and then we have a guest\nname and we basically say hi guest name\nI am such and such contact me at such\nand such so these blanks are filled in\nusing the guest name self. name and\nself. email okay so that's how you\ndefine a method in a class so here we\nhave uh another user we're creating Jane\nand Jano at Jane ato.com\nand you can see here that when we call\nintroduce yourself with David So user\nthree which is Jane becomes self and\nthen David becomes guest name and that's\nwhy we get hi David I am Jane do contact\nme at Jan\ndo.com so that's a quick refresher on\nclasses in Python now there's a lot more\nto classes but the simplest thing you\nneed to know is you how to define a\nclass how to create a Constructor um\nwhich is underscore uncore in it how to\nset some properties like we said the\nproperties name\nemail and username and finally how to\ndefine methods like we defined the\nmethod introduce yourself and that's all\nwe will need today so we won't need much\nmore than\nthat and one final thing that we're\ndoing with our class is we're defining\ntwo other special functions underscore\nuncore repper andore uncore s strr\nso now these two\nfunctions these two functions are used\nto create a string representation of the\nobject and you can see here once we\ncreate an object user 4 now and if we\ntry to print user 4 you can see that\nuser 4 is now printed like this so user\n3 was not printed I mean user 3 was\nprinted just as a user but with user 4\nwe have all this information printed\nhere as well\nso now here's an exercise for you which\nalso brings us to the first quiz of the\nday now we are going to do three\nquizzes in this video and you can answer\nthese quizzes on LinkedIn so go to our\nLinkedIn\nprofile if you see the posts you will\nsee a new post here which will give you\na question and the question is what is\nthe purpose of defining the functions\nStr Str and repper within a class and\nhow are these two functions is different\nnow leave a comment with your answer and\nwe will pick the right answer one right\nanswer and one lucky winner will get a\nswag back from\nus so that was the input we have we now\nhave a way to represent users by\ncreating\nclasses and then the output that we want\nthe final output that we want to create\nfor our problem is a data structure so a\ndata structure is once again something\nthat we can Define using a class so we\ncan Define we can expect our final\noutput to be a class called user\ndatabase which has four methods insert\nfind update and list all and insert\ntakes a user and inserts it into the\ndatabase find takes a username and\nReturns the user update takes a\nuser and updates the data for that user\nand finally list all returns a list of\nthe users so this is what the class will\nlook like and we have not implemented it\nyet\nbut we now have an\ninterface so now the next step is to\ncome up with some example inputs and\noutputs so let's create some sample user\nprofiles that we can use to test our\nfunctions once we Implement them so\nwe're going to create these seven user\nprofiles and you can see that we're\ncreating these seven user profiles with\na username name and an email and storing\nthem in these\nvariables using the user class that we\nhave just defined\nearlier and we're also going to store\nthe list of\nusers in this variable called\nusers and as you can see we can access\ndifferent fields within a user profile\nusing the dot notation so you can check\nbar. username is barage and bar. email\nis barage at example.com and bar. name\nis\nBarajas now you can also view a string\nrepresentation of the user as we have\nseen so if we print the user you can see\nsome information about the user and here\nis the full list of users that we have\ncreated\nso it's always a good idea to set up\nsome input data set up some test inputs\nthat you can use to test with your\nimplementation later\non and since we haven't implemented our\ndata structure yet it's not possible to\nlist any sample outputs but you can try\nto come up with some different scenarios\nto test any future implementations so\nlet's let's list some scenarios for\ntesting the methods of our user database\nclass so the methods are insert find\nupdate and list install and for\ninserting you may want to test that\nyou're inserting a user into an empty\ndatabase of users so that's what's\ncalled an edge case and then the general\ncase is to insert a\nuser into the database assuming that the\nuser already does not exist then another\nEdge case is trying to insert a user\nwith a username that already exists\nright so these are all the different\nways in which you can use the insert\nfunction and there can be some more so\nhere's an exercise for you try coming up\nwith all the different scen scarios in\nwhich you would like to test the\ndifferent functions insert find update\nand\nlist so that completes step two now we\nhave some sample inputs and then we\nhave some scenarios in which we are\ngoing to finally test our function so\nthe next step is to come up with a\nsimple correct solution and then state\nit in plain English now here's a simple\nand easy solution to the problem we\nsimply store the user user objects in a\nlist sorted by\nusernames that's simple enough and\nsuppose we do that so inside our data\nstructure we have a\nlist which simply contains a bunch of\nuser objects then the various functions\ncan be implemented like this so you have\nthe insert function the insert function\nsimply requires looping through the list\nand then adding the new user at a\nposition that keeps the list sorted so\nfor instance if you have the users\nAkash hant and sidhant already and then\nyou're inserting the user barage then\nyou can tell that barage should go\nbetween Akash and hon in alphabetical\norder so that's how you insert a new\nuser and maintain the sorted property of\nthe list then to find a user we simply\nLoop through the list and then find the\nuser object with the username matching\nthe query so that's you if you're\nlooking for hon for instance you start\nfrom the beginning you go through Akash\npaj and finally hit hon and then you can\nretrieve the user object associated with\nhon and then you have update now\nupdating is very simple as well it's\nsimilar to find so you find the user\nobject matching the query and then\nupdate the details of that user object\nand then finally because our internal\nrepresentation is already a list of user\nobjects sorted by usernames so we can\nsimply return that list when we want to\nlist the users\nso that's our plain English description\nand it's always a good idea to describe\nyour solution in plain English so\nthat you can clarify any doubts you\nhave and even during interviews it's a\ngood idea to have a conversation with\nthe interviewer before you\nactually implement the\nsolution and now one fact that we can\nuse is that usernames which which are\nstrings can be compared using the less\nthan greater than or equal to operators\nso we can compare strings just like\nnumbers in Python so that'll make it\neasy for us to implement these functions\nand that brings us to the implementation\nand the code for implementing these is\nalso fairly straightforward so now we\nhave the user database class we're\nactually implementing this class and\nhere you see that we have a Constructor\nand the Constructor does not take any\nadditional arguments apart from self and\nall we do is side self we set a\nproperty. users and that property do\nusers is set to an empty\nlist then we come to insertion so now\nassume that we already have some users\nin our user database so we start out\nwith a pointer set to zero and we go\nthrough all the valid positions in the\nusers list so which is from 0 to n minus\none if there are n users and then we\nfind the first username greater than the\nnew users's username so for instance if\nyou're\ninserting hon then you go through Akash\nand barage and then finally you realize\nthat the next value is probably sidhant\nso you want to insert H before sidhant\nright so you want the first username\nthat's greater than the new users\nusername and you check this property and\nas soon as you find the next that the\nnext user\nis greater then the the user that needs\nto be inserted we break\nout and then we insert that user at that\nposition okay so this is the insertion\nyou can a just four five lines of code\nso you can work through this code try to\nread this code line by line and see how\nit\nworks now similarly you have the find\nfunction the update function and the\nlist function they're all pretty\nstraightforward there's really not much\nhere so this is an exercise for you\nbecause this is also the brute force of\nthe simple implementation so this is an\nexercise for you to go through each of\nthese functions and try it out and use\nthe interactive nature of jupter to\nexperiment and add print statements\ninside each of the functions if you need\ninside each of the loops if you need\nmore visibility into what's happening\nokay uh but what we will do is we will\ntry and test this implementation out and\nthe first thing we do is instantiating a\nnew database of users using the user\ndatabase class so here we say user\ndatabase and that gives us a database of\nusers\nand now let's insert some entries into\nthis database so we can now insert for\ninstance we can insert the value hant\nAkash and sidhant so here we have\ninserted three values into the database\nand now we can retrieve the data for a\ngiven user given their username using\nthe find method so now if we say\ndatabase. find sidon that Returns the\nuser and we can check the value of user\nand you can see that now we have\nretrieved the data for sidhant which is\nusername sidhant name sidhant sin and\nemail sidhant example.com\nnow let's try changing the information\nfor a user so to change the information\nwe can call database. update and then\nsimply pass in a new user object so\nlet's say we want to change the\ninformation from sidhant Sena to sidhant\nU so this is how we do it we call\ndatabase.\nupdate and now if you find the\ninformation once again now if you find\ncall database. find once again we get\nback a user object and this time with\nthe updated information so we have\ncreated the database we have inserted\nsome values into it and then we have\nretrieved values out of it and we've\nalso updated them and finally we can\nretrieve a list of the users in\nalphabetical\norder so now if we listed out you can\nsee see here that we have the username\nAkash we have the username hant and we\nhave sidhant these are the three values\nthat were inserted and they are all in\nalphabetical order of\nusername now if we insert a new user\nlet's say let we insert\nbarage we can make sure that barage is\ninserted into the right\nposition okay so that's how we use the\ndata structure that we just created and\nyou can use the empty cells here\nto try out the various scenarios when\nyou run the\nnotebook so just to recap we created a\nsimple class inside which we are storing\na list of users in sorted order of\nusernames and then insertion is pretty\neasy we simply Loop through find the\nright position and insert any new values\nfinding values is very easy as well we\nsimply Loop through and keep\ncomparing and updating values is simply\na matter of finding them and then\nupdating that specific value and listing\nis simple because we can simply return\nthe internal list representation that\nwe're already storing in the sorted\norder of usernames so that's the\nsimplest solution or one of the simplest\nSolutions there can be even Simple\nSolutions\nmaybe so the next step now is to analyze\nthe algorithm's complexity and identify\nany inefficiencies so typically in an\ninterview setting you may not want to\nimplement the simplest solution so you\nyou can actually skip step four you know\nwhen you've described what the simplest\nsolution is in English in plain English\nwhich was step three you can directly\njump to analyzing its complexity and\nthen move on to optimization and\nimplementing the optimized version but\nwhen you are practicing or when you're\nlearning it's always a good idea to\nimplement even the brute force\nsolutions so let's analyze the\ncomplexity the operations insert find\nupdate involve iterating over a list of\nusers and in the worst case they may\ntake up to n iteration to return a\nresult where N is a total number of\nusers now the list all function uh is\nslightly different because it simply\nreturns an existing list so the list all\nfunction does not take linear time it\ntakes constant time now based on this\ninformation it's very easy to check to\nguess the time complexities of the\nvarious operations insert find and\nupdate have a order n worst case time\ncomplexity which means they can take up\nto n\niterations however the list function has\nan order one complexity which means\nirrespective of how many users you have\nin your database it Returns the list in\nthe same amount of time now if you want\nto display the list or if you want to\niterate over the list that may take you\nadditional effort but getting the list\nitself is a constant time\noperation so that was the time\ncomplexity and an exercise for you is to\nverify that that the space complexity of\neach operation is order one and if\nyou're wondering what we mean by\ncomplexity then you can go back and\nwatch lesson one where we talk\nabout analysis of algorithms\ncomplexities and the Big O\nnotation what we're calling order of n\nthe big on notation all of these\nexplained in a lot more detail so you\ncan go back to lesson one and check it\nout now we've created a simple solution\nand our first question might be to\nwonder if this is good enough\nand to get a sense of how long each\nfunction might take if there are 100\nmillion number users on the\nplatform let's create a while loop let's\ncreate a for Loop and let's run it for\nlet's see how many this is 1 2 3 4 5 6 7\n8 so let's run it for 10 million or 100\nmillion numbers so here we are creating\na range of 100 million numbers and we're\nrunning a for Loop which iterates over\nthe entire range and we simply\nperforming a simple operation which\nwe're not really using we just we're\njust multiplying the number by itself to\nsimulate what might happen if we have a\ndatabase of 100 million users and we're\ntrying to access find a user now what is\nthe worst case scenario here and let's\nrun\nthis and you can already see that it is\ntaking a while for 100 million users the\nloop takes about 10 seconds to complete\nhere it took about\n9.45 and it 10-second delay for fetching\nuser profiles will definitely lead to a\nsuboptimal user experience and that may\ncause users to stop using the platform\nall together now imagine you came to\njin. and it took 10 or 15 seconds to\nload your profile and then maybe even\nlonger to load the other information and\ndisplay it you would not be happy with\nthe experience and then a 10-second\nprocessing time for each user for each\nrequest each profile request will also\nsignificantly limit the number of users\nthat can access the platform at a time\nbecause if you're running the backend\nserver on one computer which has eight\ncores then each core will be busy for 10\nseconds each time a user tries to access\nthe platform so you can only serve about\neight users in 10 seconds time now\nthat's pretty\nbad that could significantly limit the\nnumber of users uh you will have a\nsignificant outage if a lot of users\ncome to the platform or on the other\nhand you may have to increase the cloud\ninfrastructure add more servers add\nbigger Hardware more CES more RAM and\nthat could increase the cloud\ninfrastructure cost for your company by\nmillions of dollars so as a senior\nbackend engineer you must come up with a\nmore efficient data structure and this\nis why choosing the right data structure\nfor the requirements at hand is a very\nimportant\nskill now we can clearly see that using\na sorted list of users may not be the\nbest data structure to organize a\nprofile information so let's see what\nbetter we can do\nhere and before we do that let's save\nour work so remember that this\nnotebook we were running it on an online\nplatform called binder and binder can\nshut down at any moment because it is a\nfree service so what you want to do is\nrun pip install\nJovian and then\nimport the Jovian\nlibrary and you can then run jan. commit\nnow when you run jan. commit what this\ndoes is this captures a snapshot of your\njupyter notebook whether you're running\nit on binder or you're running it on\nyour own local computer and it saves a\nsnapshot of this Jupiter Notebook on\nyour Jovian profile so here you can see\nnow on my Jovian\nprofile I have this\nnotebook and I can go back on my profile\nand view the other notebooks that I've\nhave created in the past so so your\nJovian profile becomes a collection of\nall the jupyter notebooks that you're\nworking on so always just it it takes\njust a couple of lines import Jovian and\nrun jin. commit so always run jin.\ncommit inside your notebooks and if you\nwant to resume any work that you were\ndoing then all you need to do is Click\nOn The Run button and then click run on\nbinder once again and then you can start\nexecuting the code within the jupyter\nnotebook once again right so remember\nthat binder is a free service so it will\nshut down if after after about 10\nminutes of inactivity which is if your\ncomputer goes to sleep or you change\nyour tab so keep running jan.com it from\ntime to time so now we have a simple\nimplementation and we've analyzed it and\ndetermined that it is not efficient it\nis inefficient so now we need to apply\nthe right technique to overcome the\ninefficiency and we can limit the number\nof iterations required for common\noperations like find insert and update\nby ditching the linear structure that we\nhad earlier and organizing our data in a\nmore tree like structure so this is a\nstructure that we'll use for our data\nand we will call this a binary tree now\nthis is called a tree because it vaguely\nresembles an inverted tree trunk with\nbranches so you can think of this as the\nroot so this has the root and then you\ncan see each of these are like branches\nand then there are nodes where branches\nthen split into multiple branches so\nthese are called nodes and finally at\nthe end you will have individual nodes\nwith which do not have any more branches\nand those are called leaves so these are\nsome terms that are used the tree\nrepresents the entire structure the top\nnode is called the root and each each\nelement in the tree is called a node the\ntop node is called a root and then the\nbottommost nodes which do not have any\nsub trees or what are called children\nwhich do not have any children are\ncalled leaves right so the root node has\ntwo children and then each node there\nwith can have zero one or two children\nso it's not necessary to have exactly\ntwo children but up to two children is\nwhat determines a binary\ntree so that's a binary\ntree but the binary tree that we need\nwill have some additional properties\nwhich was what will make it efficient\nfor our purposes so you can see one\nthing you can observe here is that the\nroot node seems also seems to be the\ncentral value if you sort the keys in\nincreasing order so what you will notice\nis on the left we have uh Keys which\nhave which lie before Jades and on the\nright we have keys which lie after Jades\nso that's one thing and that is actually\nthe second property listed here that the\nleft subtree of any node consists only\nof\nnodes which have keys that are\nlexicographically smaller than the nod\nkey right so the key for this node is\nbarage and that is lexic graphically\nsmaller than Jades and similarly hant\nand Akash are all smaller than Jades and\nthen this property holds at every node\nso at every node if you check sonak you\ncan see that sidhant is less than sonak\nand Vishal which comes to the right is\nmore than sonak and then sonak sidhant\nand Vishal all three are greater than\nJades\nright so when a binary tree satisfies\nthis property it is called a binary\nsearch tree so that's what we looking at\nhere this is a binary search tree so\nthat's the first property that we need\nthe second property is that our nodes\nwill have both keys and values now\nsometimes you can create binary nodes\nbinary trees with just Keys each node\nwill have a single number or a string\ninside it and you can call it the key or\nvalue or element or whatever you wish\nbut what we want is we want the keys to\nbe usernames so that we can compare the\nkeys easily but along with each node we\nalso want to associate a value which is\nthe actual user object so if we look\nlooking for hant let's say we start at\nthe root node we see that Jades is the\nroot node and since it is a binary\nsearch tree we know that hon lies to the\nleft then we reach barage we know that\nhon will lie to the right of barage so\nwe go right we reach hon and then we\naccess the value stored at hon which is\nthe user details for hon right so we\nneed both keys and values in our binary\ntree and this is what is called a tree\nmap or a map in many languages\nand then\nfinally this tree that we will create\nthis data structure that we will create\nit will be balanced so here what we're\nlooking at is each node has two children\nleft and right but it is also possible\nto have an unbalanced tree where you\nonly have one child on each on on maybe\none of the sides so we will require it\nto be balanced which means that it does\nnot skew too heavily in One\nDirection and we'll talk about what\nbalancing means and we'll talk about how\nto check if a tree is balanced or how to\nkeep a tree balanced okay so we'll go\nover all of these things step by step\nbut these are some of the properties\nthat we want our final data structure to\nhave okay so one important property of a\ntree of a binary\ntree is the height of a tree in fact if\nyou start counting you can say this is\nlevel zero where you have one node and\nthis is level two or this is level one\nwhere you have two nodes the left and\nright\nthe left and right\nchild of the root node and then this is\nlevel three level two where you have\nfour nodes the left and right child of\nthe first node on level one and the left\nand right child of the second node on\nlevel one right so you can see that the\nnumber of nodes in each level in a\nbalanced binary\ntree is double of the number of nodes of\nthe previous\nlevel so if you have a tree of height K\nor which which means is a tree which has\nexactly K levels then here's the list of\nthe number of nodes at each level now\nlevel zero will have one node the root\nnode level one will have two nodes it's\nchildren level two will have four nodes\ntheir children so that's four nodes is 2\n* 2 or 2 to the^ two level three will\nhave eight nodes two nodes for each of\nthese four nodes so that's 2 to the^ 3\nand similarly if you keep going down\nlevel kus1 the final level will have 2 ^\nof kus1 nodes so the if the total number\nof nodes in the tree is n then it\nfollows that n is 1 + 2 + 2 s + 2 CU\nplus so on+ 2 to K minus 1\nokay so what we're trying to determine\nhere is what is the relationship between\nthe height of the tree and the total\nnumber of nodes in the tree and this is\nthe relationship and we can simplify it\na bit if we add one to each side you can\nsee here that this side we get n + 1 and\nthis side we get 1 + 1 which gets\nsimplified as 2 or 2 to the^ 1 and then\nwe can add 2 ^ 1 with 2 ^ 1 and that\ngets simplified as 2 ^ of 2 then we can\nadd 2 ^ of 2 and 2 ^ of two and that get\nsimplified to 2 ^ 3 and we can keep\nperforming this reduction we can keep\nadding these together till we finally\nend with 2 ^ K - 1 + 2 ^ Kus 1 which is\nsimply 2 ^ of K so what that gives us is\nthat K the height of the tree is log of\nn + 1 which is approximately or in\nalmost in every case less than log n + 1\nso that's a a bit of an approximation\nwe're doing here but it is the height of\nthe tree is less than log n + 1 so to\nstore n records we require a balanced\nbinary search tree of height no larger\nthan log n + 1 now this is a very useful\nproperty in combination with the fact\nthat nodes are arranged in a way that it\nmakes it easy to find a specific key\nsimply by following a path down from the\nroute the binary search tree property\nand we'll see soon\nby the end of this\nlesson that the insert find and update\noperations in a balanced binary search\nTre have complexity order of login so in\nour original implementation our Brute\nForce implementation they had order n\nand this time we've reduced the\ncomplexity to order login and that is\nfar\nbetter and we'll see how that happens\nokay so that's a quick introduction to\nbinary search trees we have we've had\nenough Theory now let's get into some\nimplementation\nbut before that we have the second\nquestion now binary trees are very\ncommonly used as data\nstructures for a variety of different in\na variety of different languages for\ninstance Java C++ python Java and C++\nhave this concept of a map which is\nrepresented using a binary\ntree and it is also used in file systems\nso binary trees are also used in file\nsystems to store indexes of files so\nwhen you browse your file system or when\nyou search for a specific file it is a\nbinary tree that is used to look up the\nfile and find the location of the file\nnow that's where that brings us to our\nsecond question of today now you and you\ncan find the second question on our\nLinkedIn profile so once again go to\nlinkedin.com\nschool/ Jovan aai and you will find the\nsecond second question\nhere the second question is which tree\nbased data structure is used to store\nthe index in the Windows File system and\nwho invented this data\nstructure\nso like this question follow us and\ncomment with your\nanswer and you can stand a chance to win\na swag pack right so if we repeat the\nquestion which tree based data structure\nis used to store the index in the\nWindows File system also known as NTFS\nand who invented this data\nstructure okay so let's get to the\nimplementation of binary trees and\nhere's a very common interview question\nthat you might get Implement a binary\ntree using Python and then show its\nusage with some examples so what we'll\ndo as we Implement binary trees and\nbinary search trees is to also cover\nmany common interview questions in fact\nwe'll cover exactly 15 so that's a quite\na\nfew and the first one is to implement a\nbinary tree and to begin we'll create a\nvery simple binary tree so we will not\nhave any of the special properties like\nkey value Pairs and binary search tree\nand balancing rather and we'll also use\nkey numbers as Keys within our nodes\nbecause they're simpler to work with so\nhere is an example binary tree so we\nhave a root node and then we have a left\nchild and a right child and here's a\nsimple class representing this\nrepresenting a single node within the\ntree so we're calling this class tree\nnode and it has a Constructor function\nit simply takes a key and it sets self.\nkey to key it also has a couple of other\nproperties self. left and self. right\nwhich are initially set to none so each\nnode when it's created exists\nindependently of other\nnodes and now let's create nodes\nrepresenting each of these nodes so we\nhave node zero we're calling it\nwe're calling tree node with the value\nthree then we have node one and node\ntwo so there you go now we've created\nthe nodes and we can verify that it is\nof the type three node you can see here\nand if we check the key of node zero you\ncan see that it has the value three and\nwe can now connect the nodes by setting\nthe left and right properties of the\nroot node so if you go to node zero and\nset left to node one so now we've\nconnected node 0 to node one and\nsimilarly if we set node 0. right to\nnode two now we've connected node zero\nand node two and that's it we're done so\nnow we have three nodes and then we've\nconnected each of those nodes and we may\nalso just want to track which is the\nroot node so we can create a new\nvariable called tree and simply point it\nto node zero so tree points to the root\nnode of the tree and then the root node\nis connected to its children and the\nchildren will be connected to their\nchildren and so on so you can check here\nthat if we check tree. key we get three\nand if you check tree. left. key so tree\nis the root node it has a value three\ntree. left is this node so it should\nhave the value of four and tree. wr. key\nshould have the value of\nfive okay so pretty straightforward and\nthat's pretty much the answer to the\nquestion Implement a binary tree in\nPython now going forward we will use the\nterm tree to refer the no root node to\nrefer to the root node and the term node\ncan be used to refer to any node in a\ntree not necessarily just a root okay so\nhere's an exercise for you try to create\nthis binary tree so now you have a root\nnode here and then you have a left child\nand right child and then this left child\nhas another left child but does not have\na right child similarly here you have\nanother right child and then it has a\nleft child which does not have a left\nchild but has a right child okay so\nthere's a slightly more complicated tree\nstructure and try to use these cells\nthese empty cells that are given here to\nreplicate this tree structure\nand then try to view the different\nlevels of that tree manually okay now\nplease do that because that's a great\nexercise and understanding how the\nstructure works and how to connect the\nnodes but it's a bit inconvenient to\ncreate a tree by manually connecting all\nthe nodes in fact here you may have to\nmake a total of 1 2 3 4 5 6 7 8 Nine\nConnections right so what we can do is\nwe can write a helper function which can\nconvert a\ntuple and the Tuple will have this kind\nof a structure so a tuple is\nsimply is kind of like a list except\nthat it is represented with these round\nbrackets of\nparenthesis so a tuple will have this\nkind of a structure it will have three\nelements and then the middle element\nwill represent the value or the key\nwithin the root\nnode the first element will itself also\nbe either a tuple if the left child is\nis an entire sub tree or if it is a\nsingle number then it will be just a\nnumber\nand then the right element will\nrepresent the right sub tree okay so\nhere's an example here is One Tree Tuple\nnow if you see this tree Tuple it has\nthree elements this is the first element\nthis is the second element and then this\nis the third element so this first\nelement two represents the root\nnode and then this so the second element\ntwo represents the root node this first\nelement or element at position zero\nrepresents this sub tree so you can see\nhere that in this sub tree if you look\nat just that sub tree of that tree three\nis the root in that subtree and then one\nis the left child and there is no right\nchild so that's what this represent and\nthen for this sub tree where five is the\nroot node and then you have two other\nsub trees that's represented here so\nfive is the root node and then you have\na sub tree here and a subtree here so\nthis is a very easy way this this is a\nconvenient way for us to represent a\nbinary tree and what we can do is we can\ndefine a function par Tuple and this par\nTuple function can take a tuple like\nthis and then convert it into a tree\nlike structure of linked nodes using the\ntree node data stru using the tree node\nclass that we have defined\nabove so we call the past Tuple function\nwith some data for instance this\nTuple and the pass Tuple first\nchecks if data is of the type Tuple and\nit has a length three if these two\nthings hold true then first we create a\nnode we create a node with data one so\nin this case we create a node with two\nas the key and then we set the left and\nthe right sub trees of the node and then\nwe're doing something very interesting\nhere we calling the past Tuple function\nonce again so we call pass Tuple this\ntime so this is called recursion when a\nfunction calls itself inside it that's\ncalled recursion so we call pass Tuple\nwith the first element which itself is a\ntuple right so once again that calls\nanother invocation to pass Tuple and for\na moment let's assume that that Returns\nthe proper subtree the proper node so we\nset that node which which got created to\nnode. left and similarly we create the\nright sub tree using these values and\nthen we set that node to node. right\nokay\nnow you might wonder in the function\nwe're calling it itself so when will\nthis stop can't it go on forever and\nthat's where you have to track the\nactual function calls so when we call\npass Tuple with the\nentire Tuple first it calls pass Tuple\nwith this and when you call pass Tuple\nwith this uh then you can see that three\nis used to create a node and then P\nTuple is called with one so when P Tuple\nis called with\none this condition no longer holds\ntrue and we also check the the next\ncondition which is if the data if one is\nnone and one is not none so this\ncondition does not hold true so we fall\ninto the else condition and we simply\ncreate a node right so we just create a\nnode and this time we are not calling\npast duple once again right so this is\ncalled a terminating condition of the\nrecursive function and similarly once we\nget back the result from one then we\ncall P truple with the value none once\nagain this condition is not entered and\nthis condition matches so we set node\nequal to n and then we return the node\nokay so when we reach either a leaf node\nwhich is either a single number or we\nreach the value none that is when we\nstop invoking the function recursively\nand then the function returns and that's\nhow the entire tree gets con gets\nconverted so this is a very powerful\nidea in programming the idea of\nrecursion the idea of functions calling\nthemselves and it can seem unintuitive\nand confusing at first so one thing you\ncan do is you can add a print statement\nhere in inside this function to see how\nit works to see how the different calls\nare going so when you call past Tuple\nwith the entire Tuple what are the\ninternal calls that are made uh and and\nstudy how the result comes out maybe try\nit on pen and paper but it's a very\nimportant technique for you to learn you\nwill be asked or you will find\napplications of recursions in many\nplaces throughout your programming or\ndata science career so do learn it so\nlet's now call Par stuple with this\nTuple as an\ninput and let's see okay so that\nreturned a tree and then that tree is of\nthe type tree node that's great and now\nlet's examine the tree to verify that it\nwas constructed as\nexpected so now we check tree2 do key so\ntree2 do key should be pointing to the\nroot node which has the key2 and then\nlet's check the level one so that was\nlevel zero let's check level one so\nlet's check 32. left. key and 32. right.\nkey\nyou can see here we get the values three\nand five let's check the next level on\nthis level we have 32. left. left and\nthen we have 32. left. right but there's\nno value there so we can't really check\nfor a key here then we have 32. right.\nleft and 32. right.\nright so you can see that 32. left.\nleft. key is one but 32. left. right is\nnone because there is no child here no\nright\nchild then we have left. key and and\nright dot key and that gives you three\nand a\nseven and similarly you can now check\nlevel four level three as\nwell so here are all the levels of the\ntree so it looks like the tree was\nconstructed properly and you can see the\npower of recursion at play here that the\nrecursive function can now construct\ntrees of any levels now you can create\ntles within tles within tles and as long\nas they have the right structure as long\nas you have this\nthree element structure where the left\nelement represents the left sub tree the\nright element represents the right right\nsub tree and the middle element\nrepresents the current node you can\nconstruct a tree of any\nsize so now here's an exercise for\nyou we've defined a function to convert\na tuple into a\ntree Define a function now to convert a\ntree back to a tuple so if you have a\nbinary tree con return a tuple\nrepresenting the same tree for instance\nfor the tree created above tree 2\ncalling tree to tle should return this\noriginal tupple which is used to create\nthe tree and here's a hint on how to do\nthis use\nrecursion so do fill this\nout and see if you can figure out how to\ndo\nthis so now we have defined a class for\na binary tree and we also have a way for\ncreating a binary tree from a tuple so\nnow let's create another helper function\nto display all the keys of of the tree\nin a tree like structure for easier\nvisualization so here we'll just use\nwe'll call this function display keys\nand uh we will not get into the code for\nthis because it's once again it's a\npretty straightforward but there are a\nfew conditions we need to handle but\nhere's what it will give us when we call\ndisplay keys on a tree then we then\nwe'll get this kind of a representation\nof a tree and you can see that this is\nnot exactly the same representation as\nthis you will have to take this\nrepresentation and then mentally rotate\nit by 90 in the clockwise direction to\nget a representation like this but you\ncan see roughly that the root node is\ntwo and then it has a left child three\nand it has a right child five then three\nagain it has a left child one and there\nis no right child now five has a left\nchild three and uh three has no left\nchild and three has a right child four\nand so on so the exact same structure\nhas been replicated here for us to view\nvisually now this is a very useful thing\nwe're spending all this time here or\ntalking about how to create trees and\nhow to\nvisualize trees because the easier you\nmake it for yourself to create trees the\nmore likely you are to test the easier\nit is for you to test different\nscenarios out so always spend a little\nbit of time coming up with good string\nrepresentations for any data structure\nyou create something that helps you\nvisualize them and an easy way to create\nthese data structures\nokay so now we have a way to visualize\nthe tree as well that's great now here's\nan exercise for you try to create some\nmore trees and visualize them using\ndisplay keys and you can use this tool\nexcal draw.com and that's where how\nthat's how these diagrams were created\nas a digital whiteboard so you can\ncreate some trees you can create trees\nlike this and then try to create come up\nwith tuples for those trees try to\ncreate those trees using the par stuple\nfunction and finally try to display them\nokay so experiment with it and see\nexplore what are all the different tree\nstructures that you can create\nnow the next one of the frequently asked\nquestions in interviews is to Traverse a\nbinary tree binary tree traversals are\nvery common so you may face one of these\nthree questions write a function to\nperform the in order traversal of a\nbinary tree or write a function to\nperform the pre-order traversal of a\nbinary tree or write a function to\nperform the post-order traversal of a\nbinary tree now what do you mean by a\ntraversal a traversal refers to the\nprocess of visiting each node of a tree\nexactly\nonce now what do you mean by visiting by\nvisiting it could mean any operation but\ngenerally it refers to either printing\nthe key or the value at the node or\nadding the nodes key to a list and then\nthere are three ways to Traverse a\nbinary tree and return a list of visited\nkeys so the first one is called inorder\ntraversal and the in order traversal now\ntraversal is defined recursively because\nbinary trees have this recursive\nstructure so you will see that almost\nall the function that we write will have\nsome sort of a recursive\nstructure so in order\ntraversal involves first traversing the\nleft subtree recursively in order then\ntraversing the current node and then\ntraversing the right subtree recursively\nin order so what does that mean well we\nstart out with this tree and we we're\ntraversing it in doing an in Ord\nreversal so we try we look at the root\nnode and then we realize that there it\nhas a left ch so it has a left sube so\nwe do not visit it yet which means we do\nnot print it or we do not add it to our\nlist yet rather we follow the we follow\nthe path on the left side and then we\ncome across three and then we realize\nthat okay three also has a left child so\nwe don't visit it yet so then we go down\nto one we go down to one and now it does\nnot have a left child or a right child\nso we can visit one then we go to three\nand now we so we visited the left sub\ntree of three so now we can visit three\nand then the next step is to visit the\nright sub tree of three but of course\nthree does not have a right child so\nthere is no right subtree to visit so we\ncan move back up to two so now we've\nvisited the left subtree of two so now\nwe can visit two so we we print 1 3 2\nand now once we've visited two we can\nnow visit the right sub tree of two so\nto visit the right subtree we go to Five\nonce again we realize that five has a\nleft sub tree so we go to three now\nthree doesn't have a left sub tree so we\ncan visit Three then we visit four then\nnow since we visited the left sub tree\nof five we can now visit five and\nsimilarly we then visit 6 7 and 8 okay\nso that's the in order traversal of the\ntree and then there is another traversal\ncalled pre-order traversal which is\nslightly different where you Traverse\nthe current node first so here we start\nout at two and we say that okay we're\ngoing to visit two first so we visit two\nor print it or add it to a list then we\nTraverse the left sub tree and then we\nTraverse the right subtree so we go we\nvisit three and one and then we come to\nthe right side we visit five and three\nso you can compare these two diagrams\nand see how in order and pre-ordered\nreversal are different now these are\nvery important for you for you to\nunderstand because they are great\nexamples of\ndifferent functions which have very\nsimilar implementations but there are\njust one or two things you will need to\nchange uh and these are recursive as\nwell so do understand the CER difference\nbetween them and second they are very\ncommonly asked in interviews you will\nmost likely face some coding assignment\nor an interview where you will be a\nasked to perform a traversal of a binary\ntree and then finally there's\nanother order called another traversal\ncalled the post order traversal and I'll\nlet you guess how it works you can also\nlook it up and here's an implementation\nof in ordit reversal now it may seem a\nlittle complicated but it's actually\npretty straightforward so let's look\nlook at it here what we do is given a\nnode we first Traverse the node left sub\ntree then we create so that should\nreturn a list a list of all the keys and\nthen we create a list with just the\nnodes key so we get the list of keys\nfrom the left sub Tree in with the in\norder traversal then we get add to it\nthe current nodes key and then we call\nTraverse in order with the right sub\ntree and that recursively keeps adding\nthese Keys each one and the end\ncondition so the terminating condition\nfor the recursion is when we hit none so\nwhen we hit a node which does not exist\nso that means we come there from a\nparent which does not have a left or\nright child then we return the empty\narray okay so let's try out with this\ntree so this is the tree we have and we\njust saw its\ntraversal now if we Traverse the tree in\norder we get the values 1 3 2 3 4 5 6 7\n8 and we can verify here we have 1 3 2 3\n4 5 6 7 8 so that was the in order\ntraversal of a\ntree now the exercise for you is to\nprint the pre-order and postorder traval\nof the binary tree and you can test your\nimplementations by making submissions to\nthese problems on lead code.com\nokay so that was our discussion about\ntraversals another thing that you may\nget asked commonly is writing functions\nto calculate the height or the depth of\na binary tree and then writing a\nfunction to count the number of nodes in\na binary\ntree Once Again these can be expressed\nrecursively as well now the height of a\ntree given a node is simply 1 plus\nmaximum of the height of the right sub\ntree or the left sub\ntree the height of the tree def is\ndefined as the longest path from a root\nnode to a leaf so you can see that the\nlongest path from root node of the of to\nthe leaf\nis of length four so 2 5 3 and\n4 and the way to do get the longest\nlength of the longest path is by\nchecking the max of the left height\nright height and then adding one to it\nand of course the terminating condition\nhere also is if you hit a node that does\nnot exist you return\nzero so that's how you get the height of\na tree and you can check that the height\nof a three is four then here's another\nuh function to count the number of nodes\nin a tree once again really simple all\nyou do is this time instead of checking\nthe maximum we simply get the size of\nthe left subtree get the size of the\nright sub tree add them and add one to\nit so here you can see that there are\nnine elements in the tree 3 6 and nine\nso we get tree size of tree as\nnine now here are a few more questions\nrelating to the path length in a binary\ntree so you can just check there's a\nconcept of Maximum depth and minimum\ndepth and then there's also the concept\nof a diameter so you can try out both of\nthese\nnow as a final step what we can do is we\ncan compile all the functions we've\nwritten all the methods uh as methods\nwithin the tree node class itself and\nthis technique is called encapsulation\nwhere we are encapsulating the data as\nwell as the functionality related with\nthe data of the data structure within\nthe same class and this is really is\nreally good programming practice so as\nyou write more code try to think about\nhow you can create these classes with\nnot just the information inside them but\nalso with the relevant methods inside\nthem okay so we've now added the methods\nheight size Traverse in order display\nKeys two Tuple and we've also added\nthese methods Str Str and repper and\nremember quiz one you can go on LinkedIn\nand post an answer to what these\nfunctions do and finally par Tuple as\nwell so all of these functions are now\nadded within the class and you can try\nit out here so for instance here we have\na tree Tuple and we can call tree node.\npass Tuple to convert this tree Tuple\ninto a tree so you can see that now we\nare also representing the binary tree\nitself using this Tuple like\nrepresentation but we can also display\nit in this hierarchical structure using\ndisplay Keys then we can check the\nheight using tree do height we can check\nthe size using tree do size and we can\nTraverse the tree in order using\nTraverse in order and we can convert the\ntree to a tuple using 3.2 Tuple\nso to create some more trees and try out\nthe operations that we've just defined\nand try you can also try adding more\noperations to the tree node class and\nbefore continuing we can just save our\nwork so I'm just going to import Jovin\nand run jin.\ncommit so that concludes our discussion\non binary\ntrees next let's talk about binary\nsearch trees now a binary search tree\nor a BST is a binary tree that satisfies\nthese two conditions the left subtree of\nany node should only contain nodes with\nkeys less than the current nodes key and\nthen the right sub Tre of any node\nshould only contain nodes with keys\ngreater than the current nodes key and\nwe can see that this is let's just copy\nthis over\nso we can see that this not this tree\nhere is actually a binary search tree\nand you can verify that these two\nproperties hold for each of these\nnodes and it should follow from these\ntwo conditions that every sub tree of a\nbinary search tree must also be a binary\nsearch tree so I can I'll let you verify\nthat that if you pick up any sub tree\ninside so you pick up any node and you\nsee the tree under that node you will\nsee that it is a binary search\ntree so here are some questions that are\noften asked relating to Binary trees and\nbinary search trees and we've lumped\nthem together because we'll answer them\nwith a single\nfunction so here's a function that you\nmight be expected to write so write a\nfunction to check if a binary tree is a\nbinary search tree which means ensure\nthat these two conditions\nhold and second write a function to find\nthe maximum key in a binary tree so this\ncould be a generic question finding the\nmaximum\nkey and here another question that you\nmight face write a function to find the\nminimum key in a binary tream so what we\nwill do is we'll answer we'll answer all\nof these questions\ntogether with a single function called\nis BST so is BST takes a node and then\nis BST returns three things so if you\nlook at the return value it returns\nwhether the node and the tree under that\nnode is a BST so here so this is going\nto be the value determining it's going\nto be either true or false telling us\nwhether the tree under that\nnode with that node as root is that a\nBST it also Returns the minimum key from\nthat entire tree and it also Returns the\nmaximum key from that entire tree now\nwhy are these two useful we'll see in\njust a moment so the way we calculate is\nBST node is by actually looking at the\nleft sub tree and the right subtree\nrecursively so we call is BST on the\nleft subtree of the node and we we call\nis BST on the right subtree of the node\nso we get back three values which is is\nthe left subtree of binary search tree\nis the right subt tree binary search\ntree the minimum key in the left sub\ntree the minimum key in the right sub\ntree and then the maximum key in the\nleft subtree and the maximum key in the\nright sub\ntree so now what we can do is we can say\nis is BST node so is the entire tree of\nbinary search tree well if the left sub\ntree is a binary search tree and the\nright sub tree is a binary search tree\nand then we verify these two\nproperties which is the maximum key in\nthe left sub tree is either none which\nmeans that there is no left sub tree or\nthe current nodes key is greater than\nthe maximum\nkey and the minimum key in the right sub\ntree the smallest key in the right sub\ntree is either none which means that\nthere is no right subt tree or the\nminimum key in the right subtree is\ngreater than the current nodes key so\nthat this was condition one and\ncondition two and that tells us\nwhether this entire tree is now a binary\nsearch\ntree and then finally we can also\ncalculate the minimum key and maximum\nkey simply by Computing the minimum of\nthe left minimum node do key and right\nminimum and the maximum can be\ncalculated by checking the maximum of\nthe left maximum node. key and right\nmaximum okay so what we return from the\nsbst function is whether the a node and\nthe tree represent Ed rooted at that\nnode is a binary search tree and then\nthe minimum and maximum key out of it so\nif we look at this tree right\nhere let's verify whether this is a bstd\nwell before we check we can probably\ntell that it's not because you can see\nthat three appears as a left sub child\nof two but three the key is greater than\ntwo and that's a problem so this is a\nviolation of the property elsewhere this\nproperty is satisfied you can check any\nother node here and you will find that\nthe left sub tree is\nalways smaller than the right than the\nnode and the right sub tree is larger\nthan the\nnode so let's check is BST tree 1 it's\nnot so that's false now on the other\nhand this tree is a BST this is the tree\nthat we've been looking at all this\nwhile so once again we can create this\nusing tree node. par stuple and note\nthat the keys can the way we've\nimplemented tree node keys can not not\nonly be numbers but they can also be\nstrings so we don't need to change\nanything here and that creates\ntree2 and we can even display tree2 so\nif we do tree2\ndot display\nKeys you can see that it has the\nstructure where Jades is at the center\nand then on the left you have barage on\nthe right you have sonak barage and\nsonak then you have Akash H sidhant and\nVishal and this is a St so you get back\ntrue here and the smallest value here is\nAkash and the highest value is Vishal as\nyou can verify in alphabetical\norder so that's pretty handy now we have\na way to check if a binary tree is a\nbinary search tree and this again a very\ncommon interview question that you might\nface next remember that we need to store\nnot just keys but also user objects\nwithin each key uh with each key within\nour BST so what we do is we we'll Define\na new class called BST node to represent\nthe notes of our binary search tree and\nBST node will not only have the key but\nin the Constructor it can also accept a\nvalue and this is\noptional so we will set the key and we\nset the value we will also set the left\nand right apart from this we also set\nanother property called parent and the\nparent will point to the parent node so\nfor instance if this node is a left\nsubtree of this route then the parent of\nbarage will point to Jades and this will\nbe useful for Upward travel now if\nyou're given a pointer to a node and you\nhave to go back and find the root of the\ntree the parent will be helpful there so\nthis is our BST\nnode and let's try to recreate this BST\nright here with usernames as keys and\nuser objects as values so first we\ncreate level zero so level Z we create\nBST node now the key is Jades username\nwhich will be just the string Jades and\nthen the value will be the Jades user\nobject so we've created that and we can\ncheck its key and value you can see that\nJades is the key and then the user\nobject is the\nvalue let's create let's create level\none now level one is we set tree. left\nto BST node barage do username and\nbarage now one other thing that we\nshould do here is once we set it we\nshould set tree. left.\nparent to tree and similarly we said\ntree. write it's not tree. WR is Sono so\nwe set BST node with son. username as\nthe key and Sono is the value and then\nwe can set tree. wr. parent as\nTre and now can you can view these\nvalues so now you can see that we've\ninserted barage and the username barage\nwe've inserted sonak and the user sonak\nhere as keys and values\nrespectively now the uh exercise for you\nto is then try to add the next level of\nkeys and values and then verif that they\nwere inserted properly but you can see\nnow that we now have a way to represent\nthe\ndata the both both the usernames and the\nuser objects in a binary search tree so\nwe're getting pretty close to the data\nstructure that we want to create once\nagain we can display the keys of the\ntree by calling the display Keys\nfunction now this is also rather nice\nthere a good thing about python that\nbecause python functions are dynamic\nbecause you do not need to specify the\ntypes of the objects while defining the\nfunction the same display Keys function\ncan be used both with tree node and BST\nnode classes so all it requires is that\nthe object of your class should have a\nproperty do key for it to be able to\ndisplay the keys in this visual setting\nand the same is true with most of the\nother functions that we've defined in\nfact any function we've defined for tree\nnode will also work for BST\nnode okay so moving right to\nalong now we have a way to construct a\nbstd but it it's a bit inconvenient to\ninsert values manually because what\nwe're doing so far is we manually\nchecking whether we should insert a\nvalue in the left or the right rather\nthere should be a way to do it\nautomatically we should be able to call\na function insert and here's this is a\ncommon question as well write a function\nto insert a new node into a binary\nsearch stream so we'll use the BST\nproperty to perform insertion\nefficiently\nonce again let's grab a copy of this\ntree here so that we can think about it\neasily okay so now we have this tree and\nlet's say we want to insert a new user\nwith the username Tanya into this tree\nso first we start at the root and then\nwe compare the key to be inserted with\nthe current nodes key so the current\nnode is the root so we compare Tanya\nwith Jades and we see that Tanya is\ngreater than Jades because t comes after\nJ so obviously Tanya should not be\ninserted into the left sub tree rather\nTanya should be inserted into the right\nsubtree so if the key is smaller we\nrecursively insert it into the right\nleft sub tree and if the key is larger\nwe recursively insert it into the right\nsub tree so then we encounter sonak\nTanya is also greater than sonak T is\ngreater than s t comes after s so once\nagain we call recursively call insert on\nthis subtree the subtree rooted at\nVishal this time we notice that Tanya is\nsmaller than Vishal so T is less than V\nso then we need to recursively insert in\nthe left sofry but there is no left\nsofry here and this is the point at\nwhich we can create a new node and\nattach it as the left child of Vishal so\nyou can see that the node Tanya will get\nadded here at this position in the\ntree so here is a recursive\nimplementation of insert exactly what we\njust\ndiscussed first we check if the key is\nless than the current nodes key and if\nthat is the case then we insert it into\nthe left sub tree then we check if the\nkey is greater than the current nodes\nkey and if that is the case we insert it\ninto the right sub tree and the ending\ncondition is that if the node is none\nwhich means we've hit a position where\nwe do not have a left subtree and we\nneed to go left or we do not have a\nright sub tree and we go need to go\nright then we create a new node so we\ncreate new node node equal to BST node\nand then we return the node so we return\nthe node\nand this is an interesting thing that\nwe're doing here we're returning the\nroot node back from insert so when we\ncalled insert with node. left we get\nback the pointer to the left sub tree so\nwe can set it back to node. left and we\ncan also set the parent of the left\nsubtree to node okay so this is just\nupdating the parent so just study this\nfunction carefully see how it works uh\nit does exactly what we just talked\nabout and it finally return turns a\npointer to\nthe to the tree once again so let's use\nthis to recreate the tree that we had\nhere now to create the first node we can\ncall the insert function with none so\ninitially we don't have a tree to begin\nwith so we just called insert with none\nand remember that insert after\nperforming an in insertion Returns the\npointer to the tree so we call insert\nwith none and we want to insert the\nvalue Jades do username and we want to\ninsert the we want to insert the key\nJades username with the value Jades so\nthat gives us a\ntree and now the tree has one element\nyou can see tree\ndot key and tree.\nvalue and now the remaining nodes can\njust be inserted into tree so now we\ncall insert with\ntree and call it with barage do username\nand barage then we call it with son.\nusername and sonak Akash username and\nAkash and this way so we're adding bage\nthen we adding sonak then we're adding\nAkash H sidhant Vishal and see that we\nnot specifying exactly where these notes\nneed to be inserted uh but you can see\nthat once these nodes are inserted then\nthey are inserted in the right places so\nJades you can see that the binary\nsearchy properties preserved here and\nalso we've exactly replicated the tree\nstructure that we had here so the left\nsub child of Jades is birj and the right\nchild is sonak for barage the left child\nis Akash and the right child is hon and\nso\non now note however that the order of\ninsertion of nodes can change the\nstructure of the resulting tree so for\ninstance if we\ninsert all the nodes in the increasing\norder of username so here for example\nhere we're inserting Akash Jades San\nsonak so this is the lexicographic\nincreasing order and we try to display\nthat tree this is what we end up with so\nwe end up with an unbalanced or a very\nskewed tree and you can see why it was\ncreated as a skewed or unbalanced tree\nwell let's look at it so we start out\nwith Akash so we have a single node and\nthen when we try to insert barage we\nrealize that we need to go right so we\ninsert barage here then we try to insert\nhon then we realize that we need to go\nright from Akash and right from barage\nand go to him and then we keep going\nthis way so how you set up the root node\nand how you set up each subtree and the\norder in which you insert the nodes is\nvery important and that can create a\nhuge skew within the tree now skewed or\nunbalanced trees are problematic because\nthe height of sub such trees is no\nlonger logarithmic compared to the\nnumber of nodes in the tree right so\nearlier we had deduced that in a\nbalanced tree if containing n nodes the\nheight is log n or log n +\none and that makes the operations like\ninsert update and find very efficient\nbut here where you have a very skew tree\nthe height can actually match the number\nof nodes for instance this tree has\nseven nodes and it has height\nseven and in these cute trees once again\nyou may get back the fact that insertion\nfinding and update can be order n\nbecause you may have to Traverse the\nentire height of the tree which is equal\nto the number of nodes of the\ntree and that may once again defeat the\npurpose of using a binary search tree in\nthe first place so maintaining the\nbalance of a binary search tree is very\nimportant and we'll see how to do that\nso we've seen how to insert a node now\nthe next thing is to find the value\nassociated with a given key in a binary\nsearch tree so once again we can follow\na recursive strategy here similar to\ninsertion so we check we start from the\ntop let's say we want to find the key\nhon we start from the top and we compare\nit with the root node now here if it\nmatches the root node we can simply\nreturn this node if it does not then we\ncheck whether we need to go left or\nright since hon comes before Jades we we\nneed to go left then we encounter barage\nand here we realize that we need to go\nright and finally we encounter hon and\nwe return another option is that we have\na value let's say Tanya which does not\nexist here so if you try to search that\nwe may go in this kind of a direction\nand we end up at an empty place so in\nthat case we simply return\nnone so you either find a node and\nreturn it or you return none so you can\nsee here that if we call find\ntree with hon we get back the details\nfor him\nand very interestingly because it's is a\nbalanced tree we only had to take two\nsteps and not go through the entire tree\nand in the worst case you can check that\nany path from the root to any Leaf in a\nbalanced tree will only be two steps\nlong and that's what makes it so\nconvenient now on the other hand if we\ntry to\nfind the kitan\nyou can see that it's not\nfound now try creating larger bsts and\ntry finding some more notes it's\nimportant to experiment with these\noperations once they are defined because\nnow it's simply a matter of calling the\nfunction we've written the code for it\nso experiment with it try creating\nlarger trees with multiple levels and\ndozens or maybe hundreds of nodes try\ngenerating some fake data putting it\ninto the trees and see how trees build\nup and that'll give you a feel for how\nbinary search trees\nwork next let's talk about updating a\nvalue in a\nBST now updating a value is fairly\nsimple we already have a way of finding\na node so if you want to update a node\nlet's say we want to update the node\nheon the key\nhmon and here we want to update it we\nwant to update it to this value which is\nthe new value of the user hon and we're\nchanging the name and we're changing the\nemail here so we first find find the\nnode and if the node is not none then we\nsimply change the value at that node\nit's as simple as\nthat and we what we're also seeing is we\nreusing the find function here and this\nis a good practice to always incorporate\ninto your programs into your functions\nwhenever you find yourself copy pasting\nsome code and maybe changing one or two\nthings here and there think about\nwhether you can extract that piece of\ncode into a function and then reuse that\nfunction so always try to make your code\nmore and more generic the less code you\nwrite the less uh there are the chances\nfor errors the easier it is to\nunderstand and the smaller your\nfunctions become so write small reusable\ngeneric functions whenever you can and\nthis is a principle called the Dr\nprinciple or the dry principle which\nstands for don't repeat yourself\nwhenever you're writing programs so in\nupdate we are not repeating ourselves by\nusing the find function to find the\nright node and simply updating it by\nsetting it\nvalue so let's update hmon here to the\nnew value and you can see that now we\nhave the updated data here so we have\nhon J and hon j@ example.com\nnow the value of the node was\nsuccessfully updated and you can and it\nand you can easily check that the time\ncomplexity of update is same as that of\nfine now finally we have the\nlast operation that was required and\nthis was to write a function to retrieve\nall the key value pairs stored in a\nbinary search tree in the sorted order\nof\nkeys this is a question that you might\nface uh once again and this is simply\nthe in ordit reversal it's a different\nway of stating the in ordit reversal now\nwhat you will have to figure out or\nReason about is why the inorder\ntraversal of a binary search tree\nproduces a sorted aray of our sorted\nlist of\nkeys think about\nit so here's the list all function all\nwe do here is we call list all on node.\nleft and then we call list all on node.\nright and in between them and these give\nus two arrays so we assume that list\nall. node. left gives us the list of key\nvalue pairs from the left subtree in\nsorted order similarly here we get the\nlist of key value pairs from the right\nsubtree in sorted order and between them\nwe simply insert this key value pair\nfrom the current node and recursively it\nautomatically fills out the entire array\nand this is the end condition where we\nencounter an empty node we simply return\nthe empty\narray you can see now when we pass in\nthis tree we get back the list of users\nkey value\npairs arranged by the sorted order of\nkeys now here's an exercise for you\ndetermine the time complexity and state\ncomple St space complexity of the list\nall function now you can do this for a\nbalanc tree or an unbalanced tree and\nhere's a Hint it will not make a\ndifference but think about\nit so once again let's save our work and\nnow we've talked\nabout binary trees and operations on\nbinary\ntrees now the next thing is to look at\nbalanced binary trees and this is once\nagain a a very common question that gets\nasked write a function to determine if a\nbinary tree is\nbalanced and here's a recursive strategy\nto do\nthis in fact this is really the\ndefinition of balance binded trees the\nleft sub tree should be balanced the\nright sub tree should be\nbalanced and the difference between the\nheights of the left and right sub tree\nshould not be more than one okay so this\nis an important thing now when we're\nlooking for balance we're not always\nlooking for perfect Perfect Balance\nbecause it may not always be possible to\ncreate a tree with perfect balance\nbecause to have a perfectly balanced\ntree where for every node the left sub\ntree and the right sub tree have the\nexact same height you will have to fill\nout all the nodes at all the\nlevels and that can only have that can\nonly happen for certain numbers for\nexample you can have one node which\nsatisfied this property or you can have\na tree with three nodes which satisfy\nthis property or you can have a tree\nwith seven nodes which satisfies this\nproperty but but you may not be able to\nget a tree with six nodes to satisfy\nthat property for instance if you remove\nVishal here you will see\nthat the left sub tree and right sub\ntree of this node Sono will not be of\nequal height that's why for balancing we\nrelax the criteria slightly we simply\nneed to ensure that the difference\nbetween the heights of the left and the\nright sub trees is not more than\none so here's the code for is\nbalanced once again pretty\nstraightforward but we will return two\nthings here we will this is balance will\nnot only return whether the tree node is\nbalanced it will also return the height\nof the tree which is rooted at that node\nso the way we implement it is first\ncalling is balanced on node. left and\nthen calling is balanced on node. write\nand by the way this is exactly how we\nImplement recursive functions as well\nsometimes we write the recursive\nfunctions signature then we immediately\nwrite the return value and then we\nassume assume that a recursive call is\ngoing to return these values so a\nrecursive call is balanced node. left is\ngoing to return whether the left subtree\nwas balanced and the height of the left\nsubtree and then we assume that is\nbalanced for node. right is going to\nrecall uh is going to return whether the\nright sub tree is balanced and the\nheight of the right sub tree because\nthat's what we return here then the\nentire tree is balanced if the left sub\ntree is balanced and the right sub tree\nis balanced and the absolute value of\nthe differences in their height is less\nthan 1 which means the height L minus\nheight R is either -1 0 or 1 and finally\nwe calculate the height of the tree\nitself which is simply 1 plus the\nmaximum of the height of the left sub\ntree and the right sub tree and we\nreturn it so that's how you implement a\nrecursive function or think recursively\nand there's one last thing which is the\nend condition and the end condition\nalthough it's often the last thing you\nthink about it's the first thing that\nyou have to put in the end condition is\nto check whether a node is none because\nas we call node do left you may not have\na left sub tree so you may call is\nbalanced with none and if the node is\nnone we simply return true because uh an\nempty tree is balanced by default\nbecause there's no imbalance there and\nits height is\nzero so that's our is balanced function\nit's just four or five lines of\ncode but if you are not able to reason\nabout recursion easily you may get stuck\nwith this and you may spend an entire 45\nminutes trying to write this function\nand debug it so always try to think in\nrecursive terms and that's why always it\nalways helps to write down what you want\nto do in plain English so that you can\ndetermine what should be the inputs and\noutputs to your function maybe also have\nsome test cases ready and then start\nimplementing your function and it\nbecomes really\neasy so this tree for instance is\nbalanced here you can check is balanced\nyou get back\ntrue but this tree here that you're\nlooking at this is not balanced so this\nwas tree 2 and if you check is balanced\nhere you get back\nfalse so here you also get the height of\nthe tree which is three and here you get\nthe height of the tree which is\nseven now here's another\ntree is this tree is this tree shown\nhere balanced why or why not now create\nthis tree and check if it's balanced\nusing the is balanced function\nso there's another concept called\ncomplete binary trees which is slightly\nsimilar to balanced binary trees but\nit's a slightly stricter criteria so you\ncan check out this problem here and you\nsimply need to modify the is balanced\nthe code for is balanced slightly to get\nthe code for complete binary trees so do\ncheck out this problem on lead code.com\nall right so we've looked at binary\nsearch trees and we've looked at\nbalanced binary trees now let's bring\nthem both together into balanced binary\nsearch trees and here's one question\nthat you will face at some point write a\nfunction to create a balanced binary\nsearch tree from a sorted list of key\nvalue pairs so you have a sorted list of\nkey value pairs so the keys could for\nexample could be usernames the values\ncould be the user objects and they are\nsorted by key and you have a list and\nyou have to create a balanced binary\nsearch tree from\nit and here's the basic logic which is\nsome similar to binary search which is\nsomething that we've covered in lesson\none do check it\nout what we can do is we look at the\nmiddle element for instance if you have\na a list of 15 elements then the element\nat position 7 counting from\nzero the element at position 7 is the\nmiddle element now we can take the\nmiddle element and then create a new\nbinary search tree with the middle\nelement as the root node okay so you\ntake the you make the middle element the\nroot\nnode and then you take the left half of\nthe list and use that to create a\nbalanced BST and make it the left child\nof the middle\nelement the root node and then you take\nthe right half which both of the halves\nwill have seven elements each so if you\ntake the right half and you create a\nbalanced BST out of it and then make it\nthe right child of the middle\nelement so that's the idea here\nand how do you make a balanced bstd for\nthe left or right child recursion right\nso once again here's a recursive\nsolution make balance BST takes data\nwhich is a list of key value pairs it\ntakes a low and a high and it also takes\na parent and we look at those now low is\nset to Zero by default and high by\ndefault is set to the last index in the\ndata so we use that to get the middle\nindex so for instance if low is zero and\nhigh is 14 the middle index is\n7 then we get back the key and the value\nfrom the middle index so we calculate we\nfind data made and that gives us the key\nand the value for since the username and\nthe user object then we create the root\nnode so we create the root node using\nBST node and then we call make balance\nBST on data but this time from low to\nmid minus one so from the indices 0 to\n6 and make that the left child of the\nroad and we call make balanced BST on\nthe right\nnode so on the right half so from mid +\n1 so which is index 8 to 14 and we make\nthis the right sub tree and then we\nreturn the root and that's it that's\npretty much it the only thing that we\nmight need here is the terminating\ncondition when low becomes less than\nhigh which means that we have no more\nelements to create trees out of we\nsimply return none so the left or right\nsub Tre for those for the parents of\nthose nodes get set to\nnone so that's your makes balance BST\nfunction we also have this other thing\ncalled parent going around and this I\nwill let you figure out what the parent\ndoes here but this is the basic\nidea so here is a list of key value\npairs you have uh key value pairs sorted\nin increasing in the increasing or lexor\ngraphic order of keys and we calling\nmake balance BST with data and that\ngives us a tree and let's view the tree\nhere so there you go now we've created\nthe tree perfectly as we wanted it Jades\nis at the center and we have bar sunak\neach side and then the appropriate nodes\non each side as the children of those\nnodes now recall that the same list of\nusers when inserted one by one resulted\nin a skewed tree here we are getting the\nlist of users username and user from\ndata and inserting them and you can\nsee calling display keys on tree three\nreturns a skewed tree okay so whenever\nyou have a sorted array and you want to\ncreate a balanced BST the way to do it\nis to start from the middle\nout now finally one other question you\nmay be asked is\nto balance an unbalanced binary search\ntree and this is pretty simple at this\npoint and this is kind of a trick\nquestion because if you were given given\nthis question directly you may not be\nable to think about what to do how do\nyou balance an unbalance binary search\nstring but now that we have we have a\nway\nto create a b balanced binary search\ntree from a sorted array of key value\nPairs and we have a way to get a sorted\narray of key value pairs so now it\nsimply becomes calling the sorted array\nso calling list all on the Node which is\nalso the in ordered traval so doing an\nin ordered TR veral of the binary search\ntree which gives us a sorted array of\nkey value Pairs and then passing that\ninto the make balanced BST function okay\nso that's the trick here it's a two-part\nquestion and once again we see the\nbenefit of reusing our functions\nhere now we this now balancing an\nunbalanced BST now becomes a single line\nof code that's very nice so we created a\ntree here uh with the value none and now\nwe insert into it the values one by one\nand you can see that that creates a skew\ntree because we are\ninserting the values in increasing order\nelect graphic order so we keep adding\nright children and we never add a right\nleft child but then we call the balance\nBST function which internally takes this\ngets in ordered traversal so the in\nordered traversal lists all the keys and\nkey value pairs in sorted\norder and then we call the make balance\nbstd function which starts from the\nmiddle and then creates a balance binary\nsearch tree out of it so there you see\nthis is how you balance a binary search\ntree and what we can do now to maintain\nthe balance as we grow our data\nstructure is a simple thing that we can\ndo is to in to insert to balance the\ntree after every\ninsertion and that brings us to the\ncomplexities of the various operations\nin a balanced BST so if we doing an in\nif you're doing an insertion that takes\norder login because now if a tree is\nbalanced its height is order login so\nfor insertion you may have to Traverse a\npath from the root down to a leaf and\nthat path can be of\nlength at maximum equal to the height\nwhich is order login but if we are also\ndoing a balancing with every insertion\nthen we also have an order n term added\nhere and Order n plus order log n\nbecause a log n becomes much smaller\nthan n as n grows so order n plus order\nlogin is the same as order n so that\nmakes insertion order in finding a node\nbecomes order login updating a node\nbecomes order login and you can verify\nthat listing getting a list of all the\nnotes is order n so what's the real\nImprovement between order n and order\norder login so let's think about it if\nyou're looking at a 100 million records\nthen log to the base 2 of 100 million is\nabout 26 or 27 so it only takes 26\noperations to find or update a node\nwithin a balance\nBST as opposed to 100 million operations\nso you can see here a\n26 a loop of size of length 26 and we're\ndoing some operation inside it only\ntakes about 19.1 microc seconds that is\n1 microc is 10 ^ - 6 seconds on the\nother hand order n involves looping\nthrough the entire list so looping\nthrough 100 million numbers rather than\n26 and that obviously takes far far\nlonger and we saw that it took about 10\nseconds right about 9.98 seconds so to\nfind an update finding and updating a\nnode in a balanced binary search tree is\n300,000 times faster than our original\nsolution and all we've changed here is\nthe data\nstructure and that's the importance of\ndata structures because\nnow each user will be able to view their\nprofile in just 19.1 microc seconds at\nleast that part of the request will take\nonly this long so the user experience\nwill be better and your CPU will be busy\nfor a shorter time so you will be able\nto serve not eight but hundreds of\nthousands of users every\nsecond and finally your Hardware cost\nwill also be far lower because now your\nCPU is busy for a lesser time so you do\nnot need to use a very large machine or\nyou do not need to use too many machines\nto support hundreds of millions of users\nusers and that is the benefit of\nchoosing the right data\nstructure now there's one tip here how\ndo you speed up\ninsertions so what we may do is we may\nchoose to perform the balancing\nperiodically instead of at every\ninsertions for example we can balance\nfor every 100th insertion or every\nthousandth insertion or every 100,000th\ninsertion whatever know that and that's\nwhere we have to balance how often do we\nneed to insert things versus how often\ndo we need to restore the balance\nanother idea is to do the balancing\nmaybe periodically at the end of every\nhour so for a second or two there may be\na slight dip in the performance because\nyou may be performing The Balancing but\neven that there's a way to do it so you\ncan take a copy of the tree and then\nbalance it and then simply replace the\npointer to the original tree so there\nare many other tricks that you can apply\nand in fact there's also an algorithmic\ntrick which brings insertion and\nbalancing together into an order login\noperation which we look at right at the\nvery end so stay till the\nend uh but before we do that let's come\nback and answer our original problem\nstatement so remember now as a senior\nbackend engineer you are tasked with\ndeveloping a fast in-memory data\nstructure to manage profile information\nusername name and email for 100 million\nusers and it should allow insertion find\nupdate and listing the users by username\nall as efficiently as possible and to\nanswer this question instead of creating\na user database class we we can create a\ngeneric class called tree map because we\nhave been making things more and more\ngeneric as we have gone along so let's\ndefine a function called Tre map which\ninternally\nstores a binary search tree a balanced\nbinary search tree inside it so when we\ninitialize a tree map we set self. root\nTo None which means we have not created\na tree so far and then instead of\ndefining functions insert update and\ndelete we are going to use some special\nfunctions in Python classes so we're\ngoing to use the function set\nitem we're going to use the function set\nitem here and set item is just like\ninsert except it is a combination of\nboth insert and update so to set item we\nwill pass a key and a value and of\ncourse self will refer to the tree map\nobject\nitself so the first thing we do is we\nget the root which which is basically\nthe binary search tree that we are\nstoring internally here so we get the\nbinary search tree and then we find we\nlook for the key inside the binary\nsearch tree so if the key is found so if\nwe find the node in our\ntree then we come into this else\nposition and then we simply update its\nvalue and if we do not find the node so\nwhich is what happens initially because\ninitially our self. root is none so when\nyou call find with none and pass a key\nyou get back none so then we first set\nself.\nroot by inserting the\nkey into the tree okay so if a key\nexists within our binary search\ntree then we update it and if the key\ndoes not exist within our binary search\ntree then we insert it into our binary\nsearch tree Okay so we've combined\ninsert and update into the single\noperation called set item and similarly\nwe Define another operation called get\nitem this is the find operation all we\ndo here is we find the node inside self.\nroot using the find function we had\ndefined earlier and if the node is\npresent if it is found then we return\nthe value of the node otherwise we\nreturn none so given a key we retrieve\nthe\nvalue and then we have we defined one\nlast function called iter and this is\nthe replacement for our list all\nfunction so what we do is we simply say\nwe call list all on self. root so that\ngives us a list of key value Pairs and\nthen we have this special syntax we say\nx for X in this list and we put these\nround brackets around it so what this\nround brackets around it does is that\nthis creates a generator out of it so\nnow this is no longer list but this is a\ngenerator and a generator is something\nthat you can use within a for Loop\nso the iter function will allow our\nclass to be used directly within a for\nLoop and we'll see the example in just a\nsecond and finally we have another\nfunction called underscore uncore Len so\nremember there are double underscores\nhere so there's double underscore set\nitem Dore dcore get item dcore similarly\ndouble uncore uh\nLenore here we simply return the size of\nthe self. root so here we simply return\nthe size of the binary tree and then we\nhave this function called display this\nis going to Simply display the\nkeys okay so now we've defined the\nStream app structure and it has all of\nthese funny looking methods like we know\nin it but what about all of these but\nwe'll see what these do in just a moment\nand we know what the what the\nfunctionality is but you may be\nwondering why we've Define them like\nthis so the reason is these are\nspecial methods that are treated\nspecially in Python so here's how you\ncan use them let's first uh get a list\nof users that we'll later insert into a\ntree let's get a tree map so we\ninstantiate the tree map function uh the\ntreap class and that gives us a new\ntreap map inside it there is no binary\ntree you can\ncheck if you check tree map. root you\nwill see that it is none there's no\nvalue\nhere and if we try to display it you can\nsee that this tree map is empty then to\ninsert instead of calling treap do\ninsert or instead of calling treap doore\nuncore set item we can use this indexing\nnotation so we open these square\nbrackets\nand we put in the key that we want to\ninsert so if we want to against the key\ninsert against the key Akash which is\nthe string if you want to insert the\nvalue Akash then we simply say tree of\nAkash is\nAkash and similarly tree of a certain\nkey with the indexing notation set to\nthis right so this is going to First\nLook for the key as we have defined in\nset item if it finds the key then it is\ngoing to update the value for the key if\nit does not find the key then it is\ngoing to insert that key value pair as a\nnew node into our tree so let's check it\nout\nnow and let's see here if we now check\ntree\nmap. root you will see that now it is a\nBST node and if we try to display it you\ncan see that now it has a\nstructure Jades sonak and Akash also\nnote that this is a balanced tree if you\ngo back here to set item you will notice\nthat whenever we insert right after this\nwe also balance B the tree and now you\ncan change the logic here so that we do\nthe balancing not after every insertion\nbut maybe after every 100 insertions so\nyou may need to track somewhere what is\na current number of what is the current\ninsertion counter and when it gets to\n100 only then do the balancing and then\nset the counter back to zero so that's\nan exercise for you perform the\ninsertion perform the balancing at only\nat certain\nintervals and here's a way to retrieve\nan element so retrieving element is also\nnow really simple you just call treap\nwith Jades as um the index and that\ngives you the value if it is found and\nif it is not found it simply returns\nnone now because we' have defined the\nfunction underscore uncore Lenore\nuncore so you can see here that has the\nvalue three because that now we can use\nit with the Len function which is used\nfor lists and\ndictionaries and let's add a few more\nthings and let's set the values and\nlet's see here\nso you can see all this works exactly as\nexpected now we are able to set values\nwe are able to update values we're able\nto display the tree it is remaining\nbalanced and remember I mentioned that\nyou can use this in a for Loop so you\ncan now put the tree map directly into a\nfor Loop and what this will do is\nbecause we have defined the underscore\nuncore iter function and the iter\nfunction returns a generator so now you\ncan use this in a for Loop and you get\nback the key value pairs from the list\nall function that was used inside iter\nyou can print the keys and the values\nand in fact if you want to convert it to\na list all you need to do is pass it\ninto the list and once again because\nthis is a generator because this is an\niterable this is now an iterable class\nand you have defined that the way to\niterate over this class is to get\nelements out of the key value pair list\nso when you call list you get back this\nlist of key value\npairs okay so now we've made it a very\npython friendly class you know\ninstantiating it is very easy we simply\ncreate a new tree map adding values is\nvery easy we simply use the indexing\nnotation removing elements is very easy\nwell not removing finding elements is\nvery easy we simply use the indexing\nnotation updating elements is the same\nas inserting we can also check the size\nof the tree quite easily using the Len\nfunction and then we can also use\niterate over the keys iterate over all\nthe users in a for Loop quite\neasily and we can also update values as\nas you see here values have been\nupdated\nnow the the purpose of doing this is to\nmake it easier for other people to use\nthis data structure now as a senior\nbackend engineer you may have designed\nthis data structure and you may have\nimplemented binary search trees inside\nit but it's not important for other\npeople on the team or other people using\nyour data structure to know what the\ninternal implementation is what's\nimportant for them is to be able to use\nit easily so that's why always think\ncarefully about the interface or the API\nof your functions or of your modules or\nof your classes try to make them as\npython friendly as possible this was\nsomething that will be appreciate that\nwill be appreciated in interviews and by\nco-workers so make them python friendly\nso that when people want to use\nsomething you've created it is extremely\nintuitive and they do not need to really\nunderstand the underlying details for\ninstance I could be using this class and\nI could have no idea that it is a binary\nsearch tree all I know is how to insert\nand how to get a value out of it and I\nknow that it is super efficient because\nyou have designed it and I don't don't\nneed to worry about the internal\ndetails so encapsulation and good apis\nare very important skill to have to\ncultivate so do that as you work on\nprogramming problems now once again\nlet's save our work before committing uh\nnow I did tell you that there is a way\nto create self balance B ing binary\ntrees and a self balancing binary tree\nremains balanced after every insertion\nor deletion and in fact several decades\nof research has gone into creating\nself-balancing binary trees and not just\nbinary trees but other trees as well\nwhich are not binary in nature and many\napproaches have been devised for\ninstance red black trees AVL trees and B\ntrees so here's an example this is an\naval tree so here whenever a node goes\nout of\nbalance we rotate the tree and you can\nsee visually what we're doing here now\nwhenever you see that there is an\nimbalance in the tree we rotate it and\nhow do you do this we do this by\ntracking the balance factor which is the\ndifference between the height of the\nleft sub tree and the right sub\ntree for each node and then rotating\nunbalanced sub trees along the path of\ninsertion or deletion to balance them so\nyou can see the balance factor is zero\nright now the balance Factor becomes one\nand the balance Factor becomes two then\nwe rotate it to set the balance Factor\nback and then the balance Factor here\nbecomes minus 2 so here we do a right\nrotation here the balance\nFactor becomes minus 2 here and minus\none here so here we do two rotations so\nthere are four cases in\ntotal there's the left right case the\nright left case the left left case and\nthe right right case all four cases were\ndemonstrated here as well and then you\nmay need to do this rotation not just\nonce but you may need to do this\nmultiple times along the path of\ninsertion so when you insert a node and\nthat node creates an imbalance then you\nneed to work backwards so you need to\nkeep going from parent to parent and\nkeep rotating nodes whenever you need to\nrebalance them based on the updated\nbalance factor of each node so it seems\na little complicated but it's actually\nnot it's just that there are multiple\ncases to handle so you will need to\nwrite a couple of helper functions\nyou'll need to write a function left\nrotate which rotates node left while\nstill preserving the binary search Tre\nproperty you will need to write a\nfunction right rotate which rotates the\nfunction which rotates it to the right\nwhile preserving the bstd property and\nthen in the insertion you will also need\nto perform the rotation at the right\nplaces and you will need to track the\nbalance Factor inside each node so there\nare a few things to work out here and\ndon't worry you will normally not be\nasked to implement an aval tree within\nwithin an interview or within a coding\nassessment so you do not really need to\nlearn the implementation but it's\nnevertheless a very interesting data\nstructure to study and here are a couple\nof resources you can check out so you\ncan check out this YouTube video which\nexplains it very wonderfully and you can\ncheck out this implementation on Geeks\nfor geek. org and the important thing\nfor us to take away here and which is\nsomething that you may be asked if not\nthe implementation but just the\ncomplexity the important thing is\nthat each rotation takes constant time\nand at most log and rotations may be\nrequired because if you starting with a\nbalance tree and you're inserting a new\nmode then you may Traverse a path of\nheight at most of length at most log n\nso you may need to perform at most login\nrotations maybe twice of that so what\nthat means is in order login time you\nwill be able to insert and maintain the\nbalanced property of a binary tree right\nso you do not need to recreate the\nentire tree again and that makes your\ntree very efficient because now when\nyou're working with 100 million records\ninserting will also take 20 steps and\nfinding will also take 20 steps and\nupdating will also take 20 steps and all\nof these will work in micros\nseconds so that makes your data\nstructure very\nefficient and with that we conclude our\ndiscussion of binary search\ntrees so here's a quick summary we we\nlooked at this problem of creating a\ndata structure which allows efficient\nstorage retrieval and updation also\nefficient iteration in a sorted order\nwe first started out with a list of\nsorted a list of values sorted by the\nkeys and we realized that that was\nprobably not the right idea because we\nwere working with really large number of\nRecords then we created this binary tree\nstructure so we looked at binary trees\nwe looked at how to create them we\nlooked at easy ways to visualize them\neasy ways to create them from tupes we\nlooked at how to calculate their heights\ntheir sizes how to Traverse them in in\norder pre-order postorder we then looked\nat binary search trees which have this\nproperty that the left sub tree has keys\nthat are smaller than the root noes keys\nand the right subtrees keys are larger\nthan the root node keys and that\nproperty holds at every\nsubtree and that makes it really easy to\nfind to locate a specific element or\nfind the position to insert an element\nso we created binary search trees we\ncreated the operations insert update\nfind and list all in a binary search\ntree we also\ndetermined ways to check if a binary\ntree is a binary search tree or not then\nwe talked about balancing and we saw how\nto create balanced binary search\ntrees and binary search trees form the\nbasis of many modern programming\nlanguages language features for\ninstance maps in C++ and Java are binary\nsearch trees and data storage systems\nlike file system indexes or relational\ndatabases also use something called B\ntrees which is an extension of binary\nsearch trees\nso it's very important to know about\nbinary search trees even if you may not\never need to implement\nthem you may be asked about them and in\nmany cases you may need to pick a binary\nsearch tree as a data structure for a\nproblem like we did in this\ncase now you may wonder if dictionaries\nin Python are also binary search trees\nwell they're not dictionaries and python\nare not binary search trees so you will\nsoon release an assignment that you can\nfind on the lesson page and you will\nwork on hash tables in the\nassignment and here are some more\nproblems that you can try out so you can\ntry to implement rotations and self\nbalancing insertion you can try to\nimplement the deletion of a node in a\nbinary search tree that's slightly more\ncomplicated because what do you do if\nyou have to delete a node that has both\nleft and right\nsubtree you can try deletion with\nbalancing if you really are up for a\nchallenge here are a couple more find\nfinding the lowest common ancestor of\ntwo nodes in a tree so the common node\nwhich is a common parent of both nodes\nhere you can use the parent property\nfinding the next node in lexicographic\norder so given a node how do you find\nthe next node what's its complexity or\ngiven a number K how do you find a k\nnode in a binary search tree so to do\nthis you will have to employ some clever\ntricks and then there are a couple more\nresources here you can open up these and\nfind more questions the important thing\nto take away is that almost all of these\nwill involve some form of recursion so\nyou will either work with uh the left\nsubtree or the right sub tree or both\nand some of them may also require you to\nstore additional information within the\nnode for instance for uh for this one uh\nthe given the number c find the K node\nthis may require you to store the size\nof each balanced binary search tree in\neach\nnode so what to do next you should\nreview the lecture video and execute the\nJupiter notebook experiment with the\ncode\nyourself then complete the assignment\nhopefully the next lesson is called\ndivide and conquer and sorting\nalgorithms this is data structures and\nalgorithms and Python and I will see you\nnext\ntime thank you and goodbye let's look at\nassignment two of data structures and\nalgorithms in Python the topic of the\nassignment is Hash tables and python\ndictionaries\nso let's get started the first thing\nwe'll do is go to the course website\nPython\nds.com and on the course website you can\nfind all the lessons and previous\nassignments now we are looking at\nassignment two so you may want to open\nthat up and assignment 2 is based on or\ninspired from some of the topics\ndiscussed in assign lesson two so you\nmay also want to watch lesson two and\ncomplete the notebook before you work on\nassignment 2 let's open it up now in\nthis assignment you will apply some of\nthe concepts learned in the first two\nlessons to implement a hash table from\nscratch in Python that's very\ninteresting you will and hash tables are\nvery important data structure they're\npresent in pretty much every programming\nlanguage and are a common topic\ndiscussed and asked in coding interviews\nso we'll see how to implement them from\nscratch and one of the central problems\nin hash tables is called collisions so\nwe'll see how to handle hashing\ncollisions using linear probing and we\nwill also replicate the functionality of\npython dictionary so python dictionaries\nare actually implemented using hash\ntables so we see how to\nreplicate the way python dictionaries\nare created and used and modified and\nthe way we access keys and iterate over\nkeys and set values and change values\nand so on so we'll pretty much\nreimplement the python dictionary now we\nhave an assignment starter notebook here\nso we can click on view notebook to open\nup the\nnotebook once again this is a Jupiter\nnotebook and as you work through the\nnotebook you will find question marks in\ncertain places to complete the\nassignment you have to replace all the\nquestion marks with appropriate values\nexpressions or statements to ensure that\nyour notebook runs properly end to end\nokay so make sure that you run all the\ncode cells do not change any variable\nnames and in some cases you may need to\nadd code cells or new statements and\nsince you'll be using a temporary online\nservice for code execution keep saving\nyour work by running Jovian doc commit\nat regular\nintervals there are some optional\nquestions they are not considered for\nevaluation but they are for your\nlearning okay so let's run the\ncode recommended way to run the code is\nusing free online resources binder\nspecifically but you can also run it on\nyour computer locally so we're going to\nclick run and click run on binder once\nagain this may take a few minutes\nsometimes depending on the current\ntraffic on the\nplatform there we have it now we have\nthe jupyter notebook running the first\nthing I like to do is Click kernel and\nrestart and clear output so that we can\nexecute all the code cells and see their\noutputs from scratch I'm also going to\nhide the header and the toolbar and zoom\nin here a little bit so we can see\nthings a little\nbetter the first thing we will do is set\na project name import the Jovian library\nand run joan. commit this will allow you\nto save a snapshot of your work to your\nJovian profile so now you have a copy of\nthe assignment starter notebook any\nmodifications that you make every time\nyou run j.com will get saved to your\npersonal copy and it is this personal\ncopy that you will submit at the very\nend so let's talk about the problem\nstatement in this assignment you will\nrecreate python dictionaries from\nscratch using a data structure called\nhash tables and dictionaries in Python\nare are used to store key value pairs so\nkeys are sto used to store and retrieve\nvalues and here's an example here's a\ndictionary for storing and retrieving\nphone numbers using people's names so we\nhave a dictionary called phone numbers\nand the way you create a dictionary is\nusing this special character the brace\nor the curly bracket as it's called and\nthen in a dictionary you have these key\nvalue pairs so this is one key value\npair where you have a\nkey the key in this case is a string\nAkash and here you have a colon\nand then here you have a value the value\nin this case is a phone number so that's\nhow you create a key value pair and\ncomma separated key value pairs is what\nyou need to create a dictionary you can\nsee once the dictionary is created it is\ndisplayed in the exact same way and then\nyou can access a person's phone number\nusing their name so if we have the\nvariable phone numbers and we use the\nindexing notation so this is the square\nbracket and we pass in a key here we get\nback the name and you may wonder what\nhappens if the key is not present the\ngreat thing about Jupiter is you can\ninsert a new cell like you can just\nclick insert cell below or you can use\nthe keyboard shortcut b as I just did\nand check maybe let's check the key\nVishal okay and you get back a key error\nand you may also wonder what happens if\nis it case sensitive does that matter\nyou can check it very easily so a lot of\nthe questions that you might get a lot\nof the questions that you may want to\neven ask on the Forum or look up online\ncan be resolved simply by creating a new\ncell and typing out some code right what\nhappens if questions can all be answered\nby writing some code so now let's add\nsome new phone numbers so this is how\nyou create an initial set of phone\nnumbers this is how you access a phone\nnumber and this is how you add new\nvalues so adding new values is like\naccessing them but instead of accessing\nit you put an equal to and then you\nactually set the value here so we can\nadd a new value here the phone number\nfor Vishal and we can also update an\nexisting value in a dictionary simply by\naccessing that value and putting an\nequal to and putting in a new value\nthere you can see now that the\ndictionary is updated to contain the new\nphone number 7878 and not the original\nphone number 948\n948 you can also view all the names and\nphone number stored in the phone number\ndictionary using a loop so you can say\nfor for name in phone numbers so when\nyou put a dictionary into a for Loop you\nget back a key within each Loop you can\nsee here that the name and the phone\nnumber here is displayed for you using\nthe print\nstatement so those are some things that\nyou can do within a dictionary and\ndictionaries in Python are implemented\nusing a data structure called a hash\ntable and hash table uses a list or an\narray to store key value Pairs and uses\na hashing function to determine the\nindex for storing a retrieving the data\nassociated with a given\nkey so here's what it looks like here\nyou have uh the key John Smith and you\nhave a function called hash and the\nfunction hash takes any key and it\nreturns an index within the list so why\ndo we use a hashing function well one\napproach as we've discussed in lesson\ntwo is we can store key value pairs in a\nlist and we can simply search through\nthe list each time we want to look up\nthe value for key but that is\ninefficient because that requires\nlooking through potentially all the keys\nbefore we get to the key that we want or\nmaybe half of the keys so that makes it\nan order n operation if N is a size of\nthe\nlist that's pretty inefficient we want\nsomething faster and a hash function\nactually operates in constant time so\nhash simply takes the\nkey and it converts a key into a number\nso in that sense it gives you the index\nof the specific key value pair in\nconstant time rather than order in and\nthat is what makes hash table so\nefficient right so hash\nfunction does not require looping\nthrough the list it simply takes a key\ngives you the index and you can simply\nthen get the key value pair or the value\nfrom that index now your objective in\nthis assignment is to implement a hash\ntable class which supports these\noperations and insert operation a way to\ninsert a new key value pair a find\noperation to find the value associated\nwith a given key an update operation to\nupdate the value associated with a given\nkey and then list operation to list all\nthe keys stored in the hash\ntable and here's where we are going to\nuse Python\nclasses and there's a brief introduction\nto python classes in lesson two of this\ncourse so do check out lesson to if you\nwant a refreshing on python classes you\nhave the class hash\ntable and inside the class hash table\nyou have a bunch of methods now the\ninsert method apart from taking the self\nargument and remember that the self\nargument is refers to the object of the\nclass that will be created so this is\nequivalent to the\nthis variable in Java or\nC+ but these are the actual arguments of\nthe method the actual arguments are key\nand value so the in insert function or\nthe insert method will take key and\nvalue then the find method will take a\nkey the update method will take a key\nand value once again so the find method\ntakes a key and your job is to return\nthe value the insert method takes a key\nand value and you insert the key value\npair into the hash\ntable then you have the list all method\nwhich is used to list all the keys from\nthe table so before we begin our\nimplementation let's just save and\ncommit our work so we're running jin.\ncommit here let's just just run that\nonce again there we go The Notebook has\nnow been committed so what you can do is\nyou can come back to this particular\npage and you can find this from your\nprofile and then you can click run to\ncontinue your work based on the\nmodifications that you've already made\nokay so we build hashtable class step by\nstep and the first step is to create a\npython list which will hold all the key\nvalue pairs now remember that a\nhashtable internally uses a list to\nstore the key value Pairs and and we\nwill create a list of a fixed size so\nwe'll set this variable Max hashtable\nsize of size\n4096 initially and we are going to\ncreate a python list of this size how do\nyou create a python list of the size and\nwe want all the values to be set to none\nso this is the way to do it you can of\ncourse you can start typing none and\nthat would take a long\ntime or you can use a simple technique\njust put in n *\n496 and this one one of the great things\nabout python it is such an expressive\nlanguage that creating a list of 4,000\nelements simply requires this\nsingle expression here you can check\nthat here you can even check the length\nof the data list now if the list was\ncreated successfully here are some test\ncases here is one check that the length\nof the list is\n4096 here's another check and we simply\npicking a random value from the list 99\nand just checking if that is equal to 9\nn but if you really want to have a shot\ntest here what you should be doing is\nyou should be checking\nfor item in data list item equals\nnone okay and here's a trick you can do\nyou can write a word called assert and\nwhat assert does is if this comparison\nis true then it does nothing it lets\nyour code proceed as usual but if at any\npoint this comparison becomes false\nthen it throws an error so let's see\nhere you can see here there was no error\nso that means it worked fine but if this\ncomparison was wrong so let's say if\nitem if we had here we wanted the items\nto be equal\nto 7 if you put it and and data list\ndoes not contain the item 7even at\ncertain position then you will get an\nassertion error here\nokay this is how you can create your own\ntest cases by putting in assert but the\nidea here is that whatever you try to do\nmake sure that you're adding some more\ntest cases and not just depending on the\ntest cases that are given here okay\nthese are simply to guide you in the\nright\ndirection okay so next up we have a list\nnow we need a way to store or insert key\nvalue pairs into a\nlist that's where the hashing function\ncomes into picture the hashing function\nis used to convert strings and other\nnon-numeric data types into numbers\nwhich can then be used as list indices\nfor example example if a hashing\nfunction converts the string Akash into\nthe number four then the key value pair\nAkash and the phone number 78 78 78 78\n78 will be stored at the position four\nwithin the data list and here's a simple\nalgorithm for hashing which can convert\nstrings into numeric list indices and a\nhashing algorithm does not have a single\ndefinition you can come up with the\nhashing algorithm and in fact coming up\nwith a good hashing algorithm is\nan area of research in itself now of\ncourse python dictionaries use hashing\nthat is in built into Python and that's\na fairly optimized hashing algorithm\nthat's probably the result of several\nyears of research but here's one very\nsimple Technique we iterate over the\nstring character by character and then\nwe convert each character into a number\nusing Python's built-in o function and\nyou can see here that if you call\nardd on the character X you get back a\nnumber\nalready gives you a way of converting\ncharacters into numbers but not entire\nstrings that's why we need to iterate\nover the string character by character\nthen we simply add the numbers for each\ncharacter to obtain the hash for the\nentire string it's a very simple\nTechnique we just keep if you have the\nnumber hello we take the odd for hello\nthe odd for E the odd for L the odd for\nL and the odd for o and add them\ntogether and since we want that number\nthe final result to be an index or a\nposition within the list so we take the\nremainder of the result with the size of\nthe data list right so it's possible\nthat once you add the numbers together\nyou may end up with a pretty big number\nbut if you take the remainder with\n4096 or the max hash table size\nvariable you get back a number that is\nsmaller than 4096 so you can use just\nthat remain as the\nindex so let's first Define a function\ncalled get index\nall it does is it takes the data list\nand it takes a string and it returns it\napplies this hashing algorithm to return\nan\nindex for that string for that key so\nfor a character in a string we need to\nconvert the character to a number so we\nconvert the character from the string\ninto a number by calling o on a\ncharacter great then we update the\nresult by adding the number so we say\nresult\nplus equals a number pretty\nstraightforward and that repeats for all\nthe characters in the string and then we\nget back the final result now that\nresult may be longer than the actual\nsize of the\nlist and this is where we we may then\nwant to check the size of the list okay\nnow remember there's one I could also\nhave probably written Max hash table\nsize here but that would be wrong isn't\nit because we are passing in a data list\nhere we are passing in a data list and\nalthough we have so far created a data\nlist of size\n4096 your function should ideally be\nlooking at the size of the data list\nthat you have here and not any Global\nvariables so keep that in mind and the\nright thing you should check here is L\ndata list and what this will allow is\nnow this will allow your function to\nwork with data lists of different sizes\nand not just the standard size 40 96\nthat we have defined above okay very\nimportant thing always make sure that\nyour\nfunctions use the arguments that that\nare passed into them that they are\ngeneric that they can work with any\ninput and not just a particular input\nthat have been that has been defined\nearlier okay so there you go now we have\nthis is our function get index that has\nbeen defined and here are some tests now\nif you pass in the data list and you\npass in the empty string because there\nare no characters the result is likely\nto be zero create here's another one the\nresult here is 585 here's another one\nthe result here is 941 great now this is\nwhere you should be testing your\nfunction with some custom test cases I'm\ngoing to create a new data list 2 and\nthis is going to have the size 9 * 48 so\nthis is only going to have the size\n48 and I should should be testing get\nindex with this data list as well so\nlet's say we're looking at the key Akash\nnow we know that let's see we can\nactually test this out here what happens\nif you add o of\na plus o of a plus K A S and\nH that number is 585 but since the size\nof the list is 48 what we should be\ngetting back as the result is 48 divided\nby\n585 so we should be getting oh sorry 585\nand its remainder with 48 we should be\ngetting back the number 9 this should be\nequal to\n9 okay so let's check that if this is\nequal to\n9 and indeed this is equal to 9 on the\nother hand if we\nhad Max\nhash table size you will see here that\nsince we're not taking into\nconsideration the actual size of the\nlist that was passed into the\nfunction we getting back the value 585\nbecause we are taking the remainder with\n4096 okay so remember to take the result\nremainder with the size of the data list\nthat was passed\nin so this is one of the several gas in\nthis assignment and they're there for a\nreason\nbecause this is something that you need\nto keep in\nmind a function which only uses its\narguments and does not depend on any\nexternal Global variables or constants\nand things like that is called a pure\nfunction of course a pure function also\ndoes not modify any external Global\nvariables so it simply takes some\narguments and Returns the result\nirrespective of anything else\noutside so now we can\nto insert a key value pair into a hash\ntable we can simply get a hash of the\nkey so here we have a key value pair and\nwe simply get a hash of the key by\ncalling get index for data list and key\nand we get back the index 585 and then\ninside the data list at the given index\nwe can simply set the key value pair as\nthe element stored at that\nindex and the same operation can be\nexpressed in a single line of code so\nhere we're calling get\nindex for data list and he month and\nthat's going to give us an index and\nwe're going to then invoke a set at that\nparticular index within data list the\nthe\nelement hon comma Hon's phone\nnumber now to retrieve or find the\nelement associated with the pair we can\nsimply get a hash of the ele the value\nassociated with a key we can simply get\na hash of the key and look up that index\nwithin the data list so here we have the\nkey Akash and we have the data list and\nwe call get\nindex so we get the index of the key\nAkash and that gives us the index here\nand we can then call data list and pass\nin the position idx and that should give\nus a key value pair remember that we\nstored a key value pair at the given\nindex so we should get back that value\nhere so now we know how to store a value\nyou get its hash for the key and you\nstore the key value pair how to retrieve\nvalue so you get a hash for the key and\nthen you retrieve the key value pair and\nfrom there you can get the value we can\nalso list the keys to list the keys here\nis some special code we using so let's\nsee this is called list comprehension\nand let's take a quick look at list\ncomprehension so list comprehension\nworks like this if you create a list y\nfrom a list x uh let's say let's call\nthis list one and list two good variable\nnames all always help so if you have a\nlist one and you write this X for X in\nlist\none what does that\ndo that for X in list one patches\nelements one by one from the list and\nthen here you can specify what to do\nwith the numbers that were fetched so\nright now I'm not doing anything I'm\nsimply returning that number and then\nI'm putting the entire thing into a list\nwhat this does is this creates a new\nlist so you can see this is a copy of\nthe original list what I could do is I\ncould write x * 2 for X in list one and\nnow I would end up with a list which in\nwhich each element is the double of that\nparticular\nelement I could also do x * X if I\nwanted I could also call a function on\nit let's see what function we can call\nhere let's maybe put in some numbers\nhere\n1.3\n2.4\n3.2 so we could put maybe the function\nmath. round\nX oh sorry math.\nseal this is going to give us a ceiling\n1.3 becomes 2 2.4 becomes 3 so you can\ndo any operation with each element of\nthe list and once you put that in a\nbracket and you have this four here\nthat's going to apply that same\noperation to the entire list and this is\ncalled list comprehension in Python it's\na very powerful way to express complex\noperations on lists and\ndictionaries and there's one final thing\nin list operations which is the if\ncondition so for X in list one can be\nfollowed by an if condition and the if\ncondition can once again apply on X so\nif x is greater than three let's say we\nput this condition then what happens is\nwe choose only those numbers from list\none which satisfy this condition X\ngreater than 3 so that means we would\nskip 1.3 we would skip 2. .4 we would\nget 3.2 we would get 6 we would get 7\nand we would apply math. SE to them and\nthat's how we get back 467 so that's\nlist comprehension in a nutshell so to\nget a list of keys all we can do is four\nkey value pairs in data list if the key\nvalue pair is not none remember that we\nhave a lot of none values and it's a\nhuge list if the key value pair is not\nnone then we simply return kv0 so\nremember if you have a key value pair\nyou if you have like a key value pair\nthat's uh Akash and a phone\nnumber and you can also put because\nthese are tuples you can also put a\nround bracket here if you want but even\nwithout it it's the same thing that's a\nkey value pair so KV 0 is going to give\nyou the key and kv1 is going to give you\nthe\nvalue so we simply get the key for those\nkey value pairs in data list where the\nelement at that position or the key\nvalue pair is not none\nand that should not be called pairs that\nshould probably be called keys you can\nsee that the keys are Akash and\nHTH so that's how we can now use the get\nindex function and the next step for you\nis to complete the hash table\nimplementation here by following the\ninstructions given in the comments so\nnow you have this basic hash table class\nand in this class you have a\nConstructor now the Constructor takes\nthe object self or this and the self is\ngoing to point to the actual object or\nthe actual hash table that gets created\nusing the class and then it takes a\nmaximum size what are we doing here we\nwant to make our hash table configurable\nwe don't always want to have\n4096 elements in our internal list we\nmay need a hash table that can store\nmore values or we may need a hash table\nthat can only store fewer values so we\nare going to set a a default value for\nit which is the max hash table size so\nif you do not provide this argument by\ndefault it will create a list of size\n4096 but we also want the option to\nspecify a maximum size now you need to\ncreate a list of size Max size with all\nthe values set To None now you may be\ntempted to do this but that would be\nwrong remember that always use the\narguments to a function try not to\ndepend on an external value or an\nexternal constant so this would be wrong\nyou may also be tempted to do this data\nlist s. data list equals data list that\nwe've already created this would also be\nwrong not just because you're not using\nthe max size but also\nbecause now you are tying this class\nimplementation to a global variable and\nthat Global variable is a list which can\nbe modified so if you all the objects of\nthis class any number of hash tables\nthat you create using this class will\nall use the same data list and that's\nnot what you want each hash table that\nyou create in maybe you have a hash\ntable for phone numbers you have a hash\ntable for addresses you have a hash\ntable for something else each of them\nshould have their own internal data\nlist and this is not going to create a\ncopy of that original list this is\nsimply going to point to the original\nlist so what you want to do is you want\nto\ndo\nnone and you want to multiply it with\nMax size there you go this is the\ncorrect way to do this now we're looking\nat insert here now to insert\nwe did see that to get the index all you\nneed to do is you need to pass the key\nand remember here you need to pass not\ndata list but self. datal list right\nbecause now we want to use the data list\nthat is stored inside this specific\nobject of the class we do not want to\nuse the global data list and this is\nsomething that is an mistake that we\noften make initially I've still made\nthis mistake where I have certain Global\nvariables defined and I'm using those\nglobal variables inside my class avoid\ndoing that anything that you want to put\ninside a class object you need to put\ninside self like we've done here and\nthen to access it you need to use self\ndot to access that\nspecific property\nor element or even method so now we have\nself. datal list and we pass in the key\nand the data list into get\nindex and that gives us the\nindex now the get index function was\ndefined earlier we've seen it already\nnow we we want to store the index inside\nthe list so we call self. datal list idx\nand we want to store the key value pair\nthere so we can simply put in key comma\nvalue here if you wish we can also put\nin the brackets but they're not\nnecessary and that's going to insert the\nkey value pair now how do we find the\nvalue associated with the given key\nfirst we get the index for the key so we\ncall get index on self. datal list and\nkey\nthen we retrieve the data stored at the\nindex so this would be\nsimply self. data list of idx and then\nif the key value pair is not none if the\nkey value pair is none well there's\nnothing at that index we can return none\nanother option would be to also maybe\nraise an index\nerror and with a\nmessage etc etc but return on good\nenough for now then if not from the key\nvalue pair we get back the key and the\nvalue and then we return the value keep\nthat in mind if you simply return this\nyou would get an error you would get an\nexception that may go unexplained so\nwhenever you are destructuring or you're\ntrying to get two values out of a tuple\nmake sure that the Tuple is not none\nespecially in this case because we're\nstarting with a list of nuns in a place\nwhere we're supposed to be storing key\nvalue\npairs so that's fine\nNow update is going to be pretty much\nidentical to insert I don't see any\ndifference here so we can simply say get\nindex for\nself. data list and\nkey and then now we simply store the key\nvalue pair inside it so we can simply\nstore oops the key comma value inside\nself. datal list\nidx then for list all again\nstraightforward self do\nif KB is not none so get all the key\nvalue pairs that are not empty and then\nwe simply get kv0 is going to give us\nthe key from KV so that there it is here\nyou can see already that we are creating\na basic hash table of Max size\n1024 so the first thing that we can\nverify is that the length of the basic\nof the data list is\n1024 there you\ngo then you insert some values here so\nwe insert\nthe value Akash we insert the key value\npairs so we insert the value 9999 for\nAkash so this is one key value pair we\nare inserting hon and 8888 and what this\nwill do is when you call Basic table.\ninsert it will call this insert\nfunction and self will now point to the\nbasic table that we have just created\nbecause we're calling insert on that\nspecific basic table so self will point\nto the basic\ntable so self. datal list will become\nbasic table. datal list and then the\nremaining arguments Akash and 9999 will\nget passed in as the key and the value\nso this code will execute we will get\nthe\nindex within self. data list for the key\nAkash and then within self. datal list\nor basic table. datal list in this case\nadd the given index that we just\ncomputed we will store the key value\npair which is Akash and the phone number\nand that's how it'll work so we\ninserting some values and then we're\nfinding a value so when once we insert\nthe two values and then we find a value\nthat should give us the value 8888 you\nmay want to then maybe modify this test\ncase to also include the test for the\nother value that we inserted so feel\nfree to modify the test cases or add new\ntest cases so that we're checking not\njust one value but both the values next\nlet's see how we if we can update a\nvalue so we call Basic table. update and\nwe set\n7777 now suppose you not implemented\nupdate here let for a\nmoment return suppose you not\nimplemented update here then if you\ncalled update you would get false here\nbecause the value did not get updated\nand you can check that by simply\nchecking basic table. find akash you can\nsee that it still has the value\n9999 that's how test cases are helpful\nlet's remove the return\nokay so now the value seems to have been\nupdated just fine then let's get a list\nof all the keys and the list of keys\nshould match true once again if we did\nnot have this KV is not none then we\nwould get back not just the Kei value\npair but we would get back all the nuns\nand we don't want\nthat so these were some test cases but\nyou need to now create more test cases\nand test them out to make sure that your\nimplementation is correct now once\nyou've done that you would want want to\nrun jan. commit now the next step and\nthis is something that you may have\nthought about while working through the\nassignment is that how do you ensure\nthat different keys do not point to the\nsame index because we're doing all these\nthings where we converting each\ncharacter into a number and then adding\nup the characters now obviously if you\nhave words which have the same\ncharacters but in different orders now\nobviously are different keys but they do\nnot have they have the same hash listen\nand Silent have exactly the same\nKeys exactly the same hash so for in\ninstance you can check get index listen\nand get\nindex\nsilent okay we also need a data list\nlet's put in a data list here both of\nthem have the hash\n655 that means if you insert a value at\nwith the key listen and then you insert\na value with the key silent the data at\nthis position will get overwritten so\nwhen you try basic table. find listen\nyou will get the value associated with\nsilent and that's bad and this is called\ncollisions this is called a collision\nbecause here the two keys are colliding\nin some sense because they're leading to\nthe same hash and any hash table that\nyou implement is ultimately going to\nhave collisions because the number of\nstrings or the number of keys is\npossible infinite but you have a limited\nnumber of positions or indices in your\ntable so our hashtable implementation is\nincomplete because there can be data\nloss and it does not handle collisions\nand there are multiple techniques to\nhandle collisions and we the technique\nwe will use in this assignment is called\nlinear probing and here's how it works\nwhile inserting a new key value pair if\nthe target index for a key is occupied\nby another key then we simply try the\nnext index and if the next index is also\noccupied by another key we try the next\nand then if we try the next and then we\ntry the next till we find the closest\nempty location and then while finding a\nkey value pair we apply the same\nstrategy but inste of searching for an\nempty location this time we search for a\nlocation which contains the key value\npair with the matching\nkey we get the hash of the key that we\nwant to find and then we check if that\nposition is occupied by another key not\nthe same key then we try the next index\nand then we try the next index and then\nwe try the next index till we find a\nposition which is occupied by a key\nvalue pair for the same key and if we\nfind an empty position that means the\nkey does not exist because if it did\nexist then it should have been somewhere\nin that string of searches that we just\ncome that we just did now by updating\nthe key value pair again we apply the\nsame strategy but instead of searching\nfor an empty location we look for a\nlocation which contains a key value pair\nwith the matching key and update its\nvalue\nso that's how you handle collisions in a\nhash\ntable and to handle collisions we will\nDefine a function called get valid index\nwhich first gets the hash using get\nindex and then start searching the data\nlist and Returns the first index which\nis either empty or contains a key value\npair matching the given key so we are\nnow addressing two requirements in one\nshot with the get valid index function\nfor insertion we looking for an empty\nposition\nfor find an update we're looking for a\nposition which is occupied by a by the\ngiven key value by the given key value\npair okay or the given key\nspecifically so here's the get valid\nindex function and I will let you work\nthrough this so you will start with the\nindex returned by get index then while\ntrue because we don't know how long we\nmay need to iterate get the key value\npair stored at the index this is where\nyou may have have\nto it's simply a question of putting the\nindex into Data list getting the key\nvalue pair now if the key value pair is\nnone which means that there is nothing\nat that index it is empty that's great\nwe're done we can simply return the\nindex on the other hand if it does have\nvalues so then we get the key and value\nout of it if the key matches the key\nthat we want to\nstore great then we can return the index\nonce again if neither of these hold true\nwe move the index to the next position\nbut as we move to the next position it's\npossible that we may run out of indexes\nso or the index may become equal to the\nlength of the data list so then we wrap\naround and go back to the zeroth\nposition so this is an important part\nwhere we go around so now our list is in\nsome sense circular where we can keep\nlooping around it so that if we have\nsomething that needs to be stored at the\nlast\nposition but the last position is\noccupied then we move back to the zero\nposition and so on and then you can\ncheck if get valid index was defined\ncorrectly and if it was then these cells\nshould output true once again these are\njust some sample test cases so you\nshould include some more of your own\ntest cases here and finally once you're\ndone just save your\nwork now the next step is to incorporate\nlinear probing into your hash table so\nhere's a new class called probing hash\ntable here you need to use not get index\nbut get valid index it has pretty\nsimilar code so I'll let you work this\nout\nbe aware not to Simply copy paste code\nand you will run into issues if you copy\npaste code so always make sure that you\nare writing the code yourself and\ncarefully writing each word or each\nvariable and each method and each\nargument of the\ncode then there are some test cases here\nfor you to test a probing hash table\nonce again you can try it out with some\nexamples and see if it works fine\nspecifically here we taking the same\nexample listen and Silent both of which\nin basic hashtable would have the same\nkey but in probing hash table would have\ndifferent we have the same position but\nin probing hash table we'll have\ndifferent\npositions and that's it at this point\nyou're done with the assignment so you\ncan make a\nsubmission if you have run jan.\ncommit you can take this link and make a\nsubmission on the assignment page or the\nother option for you is to Simply run\njin. submit python DSA assignment 2 and\nonce you make a submission it will be\nevaluated automatically so let's click\nthrough here so it will be evaluated\nautomatically and if you scroll down\nhere you will see that you will get a\ngrade and not just grade but you will\nalso get comments for each question so\nif you see here there are question\nnumbers here you can see that there's\nquestion five question four and so on so\nit seems like we since we implemented\nthe get index function since we\nimplemented the data list correctly\nquestion one was a pass let's see what\nquestion one was very quickly question\none create a python list of size Max\ntable hash size question two was a pass\nso question two was the get index\nfunction question three was a pass so\nquestion three was complete the\nhashtable implementation question four\nwas a fail get valid index we've not\ndefined it yet and question five led to\nan exception obviously because we have\nsome\ncode which will not execute because we\nhave some blanks that need to be filled\nin so keep that use this as feedback you\nwill know exactly what to\nfix and if you are stuck at any point\nyou know what to do you can go to the\nForum so let's see the Forum here this\nis the forum subcategory for assignment\n2 you can create a new topic here if you\nwant to have a longer discussion or you\ncan simply go to the main topic\nassignment to # tables and python\ndictionaries and you can ask a question\nhere there are already a lot of\ndiscussions going on here so it's\npossible that your question may already\nhave been answered and after this there\nare also some optional questions now\nhere the optional question is for you to\nimplement a python friendly interface\nfor the hash table so instead of\ndefining functions insert update and\nfind you will Define the functions get\nitem set item and instead of list all\nyou will Define the function\nater and also also instead of using the\nhash function instead of using the\ncustom hash function that we have\ndefined you will Define you will use a\nfunction that's inbuilt into python\ncalled\nhash and it takes any string or any\nobject and it returns a number for\nit now since hash does not accept a list\nso you will have to take the remainder\nmanually so in this case for example\nwe've taken the remainder and gotten\nback the number\n3569 so you define a hash table here and\nand once you have done that you will be\nable to use it just like a python\ndictionary you will be able to use it\nexactly like this you create a hash\ntable and then to insert a value you use\nthe indexing notation and insert a value\nto retrieve a value you use the indexing\nnotation to get the value back and here\nyou can compare it with the number to\nupdate a value you simply use the\nindexing notation again and to get a\nlist of values you simply call the list\nfunction or you can also use it within a\nfor Loop and we've also defined a\nfunction called repper and Str Str what\nthat will do is that will let python\nprint a representation like this when\nyou simply run a cell which just\ncontains the name of this\nvariable that's one and then there are a\nbunch of improvements that you can try\nto Hash tables this is a great exercise\nif you want to improve your Python\nProgramming skills and also understand\nhow hash tables work if you can complete\nthese four exercises there's pretty much\nno question related to Hash tables that\nyou cannot answer you will know know\neverything about them and each of these\nexercises may take another 30 minutes to\n45 minutes but it's completely worth the\ntime maybe spend aside set aside a few\nhours on the weekend to work on these\noptional exercises now here's one how to\ntrack the size of the hash table instead\nof having to Loop through the entire\ntable to get the number of key value\npairs can you store the length somewhere\nso that you can track it in size order\none here's one to implement deletion so\nto implement deletion you have a topic\ncalled technique called tombstones that\nare used so you can use this Tombstone\ntechnique and implement it just a little\nmore code can you implement Dynamic\nresizing so instead of starting out with\na hash table of a given size or\nrequiring the user to specify a size can\nyou maybe start with a hash table of\nlet's say 128 elements and then double\nit as soon as you reach 128 elements or\nmaybe even before to avoid collisions\nyou may want to double it as soon as you\nreach 64 elements like 50% of the\ncapacity so Dynamic resizing is the\ntechnique that allows you to\nautomatically grow and shrink the data\nlist internally and then here's another\ntechnique for Collision resolution this\nis called separate chaining so instead\nof going to the next index what you do\nis you maintain a linked list at each\nposition and for all the key for all the\nkeys you still use that position but you\nlook through the link list while looking\nfor a key or you add a new element to\nthe link list\nfor that\nposition if you're adding a new key\nthere so here's separate chaining\nexplained in a YouTube video you can\nlook through that and try to explain it\non your own and one final thing here is\nalso the complexity analysis and here's\nwhere you talk about average case time\ncomplexity because on average if you\nhave a good hashing function and you've\nimplemented some improvements like\nDynamic\nresizing then the average time\ncomplexity for insert update find and\ndelete are order one and list of course\nis still order n on the other hand the\nworst case time complexity because there\ncan be collisions are still order\nin so here's something for you to ponder\nupon what is average case complexity and\nhow does it differ from worst case\ncomplexity is also something that is\ndiscussed in lesson three of the course\nwhere we talk about quick sort and you\nsee why insert find and update have an\naverage case complexity of order one and\na worst case complexity of order n if\nnot it is something that you can look up\nonline try to see if you can search a\ntutorial and learn why this happens then\nhow is the complexity of hash tables\ndifferent from that of binary search\ntrees we've discussed binary search\ntrees in a lot of detail in lesson two\nso now the question becomes when should\nyou prefer using hash tables and when\nshould you prefer using binary search\ntrees or vice versa\nso all these very interesting questions\nand you may get asked some of these\nquestions in interviews as well\nit will help you especially to ponder\nupon some of these questions even if you\ndo not end up solving all of these\noptional questions do look at the\ncomplexity analysis and think about\nit and there's a forum thread where you\ncan discuss your thoughts so what do you\ndo next review the lecture video review\nthe assignment work through video and ex\nexecute the Jupiter\nnotebook complete the assignment and\nattempt the optional questions as well\nand do participate in Forum discussions\nso this was a walkthr of assignment two\nof data structures and algorithms in\nPython hello and welcome to data\nstructures and algorithms in Python this\nis an online certification course\nconducted by Jovian and today we are on\nlesson\nthree my name is Akash I'm the CEO of\nJovian and I'm your instructor for the\ncourse if you follow along with this\ncourse and complete four weekly\nassignments and a course project\nyou can earn a certificate of\naccomplishment for this\ncourse we so let's get\nstarted the first thing we'll do is\nvisit the course\nwebsite python\nds.com so when you visit python\nds.com this will bring you to the course\nwebsite here you can find all the\ninformation and material for the course\nyou can check out lessons 1 and two and\nassignments 1 and two\nboth of which are still open for\nsubmission and let's open up lesson\nthree so the topic today is sorting\nalgorithms and divide and\nconquer and you can watch a video\nrecording of the lesson here you can\nalso catch a version in\nHindi now the code used for the lesson\nis provided here so let's open up this\nlink sorting and divide and conquer this\nis where all the code is\npresent so here we have it now we're\nlooking at the tutorial and the code for\nthis lesson if you scroll down you can\nsee that there is some code\nhere now to execute this code you have\ntwo options you can either execute this\ncode online using free online resources\nwhich is what we recommend or you can\ndownload it and run it on your computer\nLo\nlocally and the instructions for both of\nthese are given here we are going to use\nthe first one which is to click the Run\nbutton at the top of this page and\nselect run on binder so let us scroll up\nhere and let us click the Run button and\nthen click run on\nbinder now once you do this it will open\nup an interface like\nthis and what you're looking at here is\na jupyter notebook so a jupyter notebook\nis an interactive programming\nenvironment where you can write code\nlook at the results and you can also\nwrite\nexplanations and we've provided you with\na cloud-based jupyter notebook setup so\nyou don't have to install anything all\nthe code that you execute here will be\nrunning on our Cloud but you can also\ndownload it and run it on your own\ncomputer by following the\ninstructions so the first thing we'll do\nis click on the Kernel menu and click\nrestart and clear output to remove any\nof the outputs from previous executions\nof the code so that we can execute the\ncode and see the outputs fresh for\nourselves now I'm also going to zoom in\na little bit here so we can look at the\ncode and let's get\nstarted so this is a coding focus in\nPractical\ncourse and we talking about different\ndata structures and algorithms the topic\ntoday is sorting algorithms and divide\nand conquer algorithms in Python so in\nevery lecture we focus on a specific\nproblem so in this notebook in this\ntutorial we will focus on this problem\nwhich you're looking at here so let's\nread the question you're working on a\nnew feature on Jovian called top\nnotebooks of the week write a function\nto sort a list of notebooks in\ndecreasing order of likes keep in mind\nthat up to millions of notebooks can be\ncreated every every week so your\nfunction needs to be as efficient as\npossible that is the key Point\nhere now this is a classical problem in\nComputing the problem of sorting a list\nof objects and it comes up over and over\nin computer science and software\ndevelopment and it's important to\nunderstand common approaches for sorting\nhow they work what the tradeoffs are\nbetween them and how to use them so\nbefore we solve this problem we'll solve\na simplified version of the problem it's\nquite simple to State write a program to\nsort a list of\nnumbers and sorting usually refers to\nsorting in ascending order unless\nspecified\notherwise so that's our question for\ntoday write a program to sort a list of\nnumbers and we'll expand upon it to\nanswer this original question as\nwell now this is the method that we've\nbeen following throughout the course and\nwe will continue to follow a systematic\nstrategy for solving programming\nproblems step one state the problem\nclearly identify input and output\nformats step two come up with some\nexample inputs and outputs and try to\ncover all the edge cases and step three\ncome up with a correct solution for the\nproblem stated in plain English step\nfour implement the solution and test it\nusing example inputs so this is very\nimportant that you implement The Simple\nSolution so you just need a correct\nsolution first not the efficient one and\nthen you implement it and test it then\nyou analyze its complexity identify\ninefficiencies and then you apply the\nright right techniques to overcome the\ninefficiency and that is where the\nknowledge of the right data structures\nand algorithms comes into picture and\nonce you apply the new technique then\nyou once again State the solution\nimplement it and analyze its complexity\nand repeat if necessary so this is a\nstrategy we'll follow here today as well\nso step one state the problem clearly\nand identify input and output formats\nnow the problem is stated clearly enough\nfor us we need to write a function to\nsort a list of numbers in ascending or\nincreasing order now here's the input\nthe input is a single argument called\nnums and that is a list of numbers so\nfor instance here's a list of numbers\nyou can see that they're not in any\nspecific order and then the output is\nthe sorted version of the input so here\nis the same list of numbers in sorted\norder and based on these two we can now\nwrite a signature of our function so our\nfunction will be called sort or\nsomething else but it will accept just\none input and right now we've not\nwritten any code here so we just put in\npass\nnow I'm running this code here using the\nshift plus enter shortcut but you can\nalso use the Run button on the toolbar\nso either run or shift plus enter and\nthe great thing about Jupiter notebooks\nis that you can add more code cells\nanywhere and test anything that you want\nfor instance if you want to insert a\ncode cell below just click the insert\ncell below menu option or click outside\na cell on the left and press the B\nbutton\nand now you can write some code here and\nrun\nit so please feel free to experiment\nwith this\nnotebook as you go along so step two\ncome up with some example inputs and\noutputs now this is very important you\nneed to think about all the different\nscenarios in which you may want to test\nout your function before you put it into\nproduction so that you catch errors\nearly on and thinking about scenarios\nwill help you identify what are the\nspecial cases you need to handle in code\nand it's easier to do it right now than\nwhile writing your code because that may\nlead to bugs so here are some scenarios\nthat I was able to come up with and\nthere may be more so you can continue\nand increase this list so the first one\nis some list of numbers in random order\nso\nsome numbers in any random order and you\ncan try slightly smaller list and larger\nlists and so on second is a list that's\nalready sorted we need to ensure that an\nalready sorted list does not become\nunsorted\na third is a list that sorted in\ndescending order we may want to check\nthat see if we need to handle that case\nseparately somehow then a list\ncontaining repeating elements this is\nsomething you may not have thought of\nbut the question never said that the\nnumbers should be unique so there could\nbe repeating elements here an empty list\ninteresting input the output is also an\nempty list or a list containing just one\nelement or a list containing one element\nrepeated many many times or even a\nreally long list U this is something\nthat we may want to test because we want\nour algorithm to be efficient at the\nvery end so a long list may help us just\nevaluate the efficiency empirically so\nthese are the scenarios and what we now\nneed to do is create some test cases for\nthese scenarios so test cases involve\ncreating an input and an output for\ninstance here's an input\nnum0 and this could be the list 431 and\nhere's the expected output so let me\ncall it output zero and this would be 13\n4 now this is a good way to put create a\ntest case and you can use it later for\ntesting but we will put our tests into\nthis particular structure we'll create a\ndictionary and creating a dictionary\nlike this will help us automate the\ntesting of all our test cases with a\nsingle helper function so what we're\ngoing to do is for each test case create\na dictionary and then\nit it'll have two keys first key is\ncalled input and the second key is\ncalled\noutput and in the inputs for each of the\narguments that go into the function and\nremember there's just one argument here\nwe will have one key so we will have the\nkey nums and the key nums will have the\ninput value for the test case and the\noutput will simply contain the output\nreturned by the function so that's how\nwe'll set up our test\ncases so there's our test zero a list of\nnumbers in random order\nthen we have test one this is also\nanother list of numbers in random order\nyou can see here no specific order now\nwe have a list that's already sorted and\nthe output obviously is the same now for\nthe random ordered list the output is\nthe same numbers in sorted\norder now we have a list that's sorted\nin descending\norder and the output is the same list in\nincreasing\norder then we have a list containing\nrepeating\nelements you can see that the numbers 1\n2 6 and 7 and even- 12 repeat here here\nwe have the empty list here we have a\nlist containing just one element and\nhere we have a list containing one\nelement repeated many many\ntimes and then the final test case which\nwas to create a really long list that's\nwhere we can start with a sorted list\ncreated using the range function and\nthen Shuffle it to create the put\notherwise you may spend a lot of time\njust creating a list and then writing\nthe sorted version of it that's too much\nwork so always use a computer always use\nhelper functions whenever you can even\nto create test cases so we'll use the\nrange function now the range function\ntakes either a single number or two\nnumbers so you can have something like\nthis range 2 to 10 or just range 10 and\nif you just look at it this way it just\nprints range 0 to 10 now if you actually\nwant to see what's in it there are a\ncouple of ways you can you can do list\nrange 10 and that gets converted into a\nlist or you can use it in a for Loop so\nyou can put for X in range\n10 print X so you can see that it\ncontains the numbers 0 to 9 and that's\nimportant that the range does not\ninclude the end element of the range\nokay so just keep that in mind now\nwhat's the difference between a range in\na\nlist a list contains all the 10 numbers\ntogether at once but a range internally\nsimply maintains a counter so when you\nuse a range in a for Loop it simply\nstarts the counter from zero and\nincrements it up to the starts a counter\nfrom the starting value so if it's 2 to\n10 then it starts a counter from Two and\nincreases it up to the end value minus\none so it does not use as much space as\na list it simply uses one single\nvariable internally and that's why it's\nmore efficient in any case right now we\nneed lists so what we'll do is we we\nwill create a list of 10,000 numbers so\n0 to 9\n9,999 that is our in list and then our\nout list is also going to be 0 to 99,999\nthat's our out list both of them are\nsorted now what we do is we Shuffle the\ninner list so we import the random\nmodule from Python and then we call\nrandom.\nShuffle and we call random. Shuffle on\nin list and that shuffles the the first\nlist the in list so now we have that as\nthe input nums and then the out list the\nsorted list is the\noutput now once again we can even check\nthat in list is actually shuffled Maybe\nby looking at the first 10 elements you\ncan see here that these are all shuffled\nnumbers on the other hand if you check\nthe out\nlist you can see that these are all in\norder so those are our test cases and\nit's very important to create good test\ncases even in interviews before you\nstart coding or before you even suggest\na solution you should try and list out\nyour test cases either verbally to an\ninterviewer in a coding assessment you\nmay create a block of comments at the\ntop and start listing some test cases at\nthe top or you can create proper test\ncase dictionaries like this it takes a\nfew minutes but it's totally worth it\nbecause you can then test your\nalgorithms very easily and finally we'll\ntake all our test cases test0 to test 8\nand put them into a single list called\ntests\ngreat so we've made some good progress\nso\nfar next let's come up with a simple\ncorrect solution and stated in plain\nEnglish and coming up with a correct\nsolution is pretty\nstraightforward we have a list of\nnumbers so we iterate over the\nlist let's grab a list of numbers so\nthat we have something to look\nat here you go\nso we have a list of numbers so we\niterate over the list of numbers\nstarting from the left so we start from\nthe very left and then we compare each\nnumber with the number that follows it\nso we compare 99 with\n10 and if 99 is greater than 10 then we\ncan say for sure that 99 should appear\nafter 10 in the final sorted array and\nthe sorted array by default it means the\nincreasing order of numbers right so\nthat's what we're solving first\nso what we can do is we can simply swap\n99 and 10 because we know that 10 should\nappear before 99 and 99 should appear\nafter\n10 now once we continue the swap we move\nto the next position and then we compare\n99 with the next element 9 that turns\nout to be higher as\nwell so we swap it and then we keep\ngoing so we iterate over the list and\nfor each element compare the number with\nthe number that follows it and if the\nnumber is greater than the one that\nfollows it swap the two elements now you\ndo that once and that alone is probably\nnot enough to compile the entire list\nbecause the entire sorted list because\n99 in this way will end up at the end if\nyou follow the process but the rest of\nthe list is still not\nsorted so we repeat these steps 1 2 3 so\nonce again we start from the left and\nthen we start comparing 10 with 9 and\nthen 10 with 8 and so on\nand keep swapping elements as we go\nforward now I have a claim here that you\nmay you will need to repeat the steps 1\nto 3 at most n minus one times to ensure\nthat the array is sorted can you guess\nwhy and here's a hint after one\niteration of the process the largest\nnumber in the list will reach the very\nend so that means that each time you're\nputting one of the largest numbers at\nthe very end so you need around end\nsteps so here's an animation showing the\nsame thing here we compare six and five\nand then we switch them then we compare\nsix and three and we switch\nthem then we compare 6 and one and we\nswitch\nthem now we compare 6 and\n8 and we don't switch them because\nthey're in order next We compare eight\nand seven and we switch them\nnext We compare eight and two and we\nswitch\nthem and finally we con compare eight\nand four and we switch\nthem and in this way the largest number\neight has reached the very end so now we\ncan froze freeze its position and we can\nstart again from the beginning and you\ncan see that this time the next number\nseven will end up here and then the next\ntime the number six will end up here and\nthen next time the number five will end\nup here and so on so so in N repetitions\nof this process of comparison left to\nright we will have sorted the array and\nthis approach is called bubble sort\nbecause it causes the smaller elements\nto Bubble to the top or to the beginning\nyou can see that the numbers 1 three\nslowly bubble up to the top and it\ncauses the larger numbers like eight and\nseven to sink to the bottom and you can\nwatch this entire animation to get a\nfull sense of how bubble sort Works what\nwill also really help is if you can take\nan example on paper and work it out on\nyour own step by step especially with\nsorting algorithms this really\nhelps okay so now we've come up with a\ncorrect\nsolution let's implement it and let's\ntest it using an example now the\nimplementation itself is also pretty\nstraightforward so we have the bubble\nsort function here def bubble sort it\ntakes a list of numbers now we may not\nwant to modify the list of numbers in\nplace because then our test cases will\nnot be\nreusable so just to avoid modifying our\ntest\ninputs we're going to create a copy of\nthe list to avoid changing it and the\nway to create a copy simply call the\nlist function with the list as input so\nnow we are set replacing nums with a\ncopy of\nnums now depending on your particular\nuse case this may not be necessary so\nthis is something that you can actually\ncheck while you're in a coding a\nassessment or in an interviewer or\ntalking to an interviewer just check\nwith them do do they want an array to be\nsorted in place or do do they want a new\narray to be created if they want if\nthey're okay with sorting it in place\nthen you probably don't need this but\nyou may still just want to keep it in\nbecause otherwise you may end up\nmodifying some of your test cases\nunintentionally and that may lead to\nproblems so always good to create a copy\nof the input rather than modifying it in\nplace okay so then let's come to steps 1\n2 and three and then we'll see step four\nwhich is the outermost step really so we\niterate over the array so we go from we\ntake I and we check the range Len nums\nminus one so the number of elements in\nthe array is n and n can be obtained\nusing Len nums then we want to go from\nindexes 0o to N - 2 so the total number\nof indices is 0 to nus1 but if you go to\nthe nus1 for the last element there is\nno further element to compare it with\nokay so keep that in mind that you only\nwant to run this iteration till your\npointer comes to this point not till the\nlast element and that is why we check we\nput I in the range 0 to Len nums minus\none so the highest value that it can\ntake is len nums minus\n2 next We compare nums I with nums I + 1\nso we compare the number with the\nelement that comes after it and if it is\ngreater so that means these two are out\nof order so then we simply swap them so\nwe set nums I comma nums I + 1 = to nums\nI + 1 comma nums I now this is a very\ninteresting way of sorting in C or C++\nor Java you would have to write three or\nfour steps to swap numbers but in Python\nit's really simple first you say XY is\nlet's say we're saying X comma y are 2A\n3 so you can see they have the values 2\nand three and then we simply write X Y =\nYX so what happens is the value of y\ngets placed into X and the value of x\ngets placed into y it's single step for\nswapping two numbers there you\ngo so we swap the two elements exactly\nwhat we showing here swapping the two\nelements next we repeat this so now\nwe're doing this from left to the\npenultimate element and in this way we\nhave pushed the largest element to the\nend now we need to repeat this process n\nminus one times so that each time we are\npushing one of the largest elements to\nthe very end and in N minus\none repetitions of these three steps we\nwill end up with a sorted\nlist and finally we return the sorted\nlist and that's it so let's test it out\nwith an\nexample and by the way if some of this\ndoesn't make sense so a simple way\nto debug it is is to add print\nstatements here so you can add a print\nstatement and maybe just print this\nvalue so we've used underscore here\nbecause we don't actually use this value\nbut let's say we wanted to use this\nvalue then we can print that this is\niteration J and then inside it you can\nprint that the value of I is I and you\ncan also print the value of nums I and\nyou can also print the value of\nnums I + 1 and at the very top you can\nalso print nums now if you add all of\nthese print\nstatements and then execute your\nalgorithm now you will be able to see\nexactly what is happening inside each\niteration so that's a great way to debug\nyour code if you're facing any issues\nand also understand what the code does\nbut in any case we won't need\nthese so I'm just going to comment\nthese so let's test it out so we get\nfrom test zero we get the nums as input\nand then we get the output and we can\nprint the input and the expected output\nand then finally calculate the result by\npassing num zero into bubble sort and\nthen printing the actual output and\nfinally whether the two\nmatch so you can see here now that the\ninput was this unsorted list and then\nthe expected output was the sorted\nversion and that's what we got so in\nfact there was a perfect\nmatch and that's it so we implemented\nour first sorting algorithm it was\npretty straightforward a few lines of\ncode as an exercise you can try to\nimplement it once again from your memory\nuh just write it in plain English first\nand then try to implement it it's a good\ncoding\npractice and we can also evaluate all\nthe test cases that we have remember we\nhad created about nine test cases\nand to EV help you evaluate the test\ncases we've given you a helper function\ncalled evaluate test cases which is part\nof the Jovian Library so we install the\nJovian Library here pip install Jovian\nand then from jan. python DSA so python\nDSA is the name of the course and that's\nalso the module where we have helper\nfunctions for this course import\nevaluate test cases and evaluate test\ncases simply goes over the list of test\ncases that you have and it pulls out the\ninputs and passes them as arguments to\nthe function provided here which is\nbubble sort and then gets the outputs\nand compares the outputs and also prints\nthe information with like what was the\ninput what was the expected output and\nthe actual output and whether they match\nso let's check it out so you can see\nhere this was test case zero and that\nwork which we just tested out here's a\nlarger list including some negative\nnumbers this worked as well you can see\nthe test result is passed then you have\nanother list here\nthis seems to work fine too this is\nalready\nsorted here you have one which is sorted\nin decreasing order that works here you\nhave one with repeating numbers that\nworks two the empty list works the\nsingle element\nworks and this works too this is the\nsame element repeated over and over and\nfinally here is our final test case this\nhad 10,000 elements remember so you can\nsee that this was the expected output\nand this was the actual output so we\nhave successfully sorted 10,000 elements\nand that's really the power of\nprogramming that without having to look\nat any of the numbers we've just written\nfour or five lines of code and we've\nsorted 10,000 elements so all our test\ncases passed although do look here that\nit took about 15 seconds for the Sorting\nof 10,000\nelements now maybe that's not maybe\nthat's not that bad but we we are\nlooking at probably millions of\nnotebooks every week at Jo so we want\nthere to be a faster sorting\nalgorithm okay so to before we improve\nthe algorithm we need to understand the\nalgorithm's\ncomplexity and identify any\ninefficiencies now the core operation in\nbubble sort if you look at the code here\nonce again is this operation of\ncomparison so we're comparing a number\nwith the next number and swapping now\ncomparison almost always happens and\nswapping doesn't happen nearly as often\nso if you want to find the time\ncomplexity and we want an upper bound or\nthe worst case time complexity we can\nassume that roughly every comparison\nalso leads to a\nswap in the worst case so if we just\ncount the number of\ncomparisons as a function of the input\nsize the size of the list that was given\nas an input that should give us an idea\nof the time complexity\nokay so here we can see that there are\ntwo loops and the length of each Loop is\nn minus one and inside the inner loop\nthere is a comparison so the total\nnumber of comparisons is n minus1 * n -1\nwhich is n -1 s or n - 2 n + 1 now\nexpressing this in the Big O notation\nwhich is to get a rough idea of how the\nnumber of comparisons or the number of\noperations in the algorithm grow grows\nwith time we can ignore the lower order\nterms like 2 n +\n1 so we can now conclude that the time\ncomplexity of bubble\nsort is order of n square and this is\nalso known as quadratic\ncomplexity so we can now verify that\nbubble sort requires order one\nadditional\nspace that this is an exercise for you\nbut here's a quick hint you can see that\nwe not allocating any new lists we did\ncreate a copy of the list but we didn't\nhave to so let's not count that but\napart from that there is no additional\nspace that was required here we're not\nallocating any new variables we are\ncreating this range but remember I\nmentioned that a range simple simply\ncontains a single variable inside it\nwhich it keeps incrementing for a for\nLoop so we have these two ranges so\nmaybe we have two variables assigned so\nit's constant irrespective of the size\nof the input and that's how bubble sort\nrequires order one additional space now\nyou may be asked about space complexity\nand this is where it's a slightly tricky\nthing because sometimes strictly\nspeaking space complexity also includes\nthe size of the input because to store n\nnumbers or n elements you need n spaces\nin memory so the space complexity of\nbubble sword in that sense is order n\nand this is something you can check with\nthe interviewer if they're asking you\nwhat is the space complexity and you can\nask them if they just want to know what\nis the additional space required so the\noverall space complexity is order in\nbecause we need to store the actual\ninput list somewhere but on the other\nhand the amount of additional space\nrequired is order one which is a\nconstant Factor independent of the size\nof the\nlist so that's that's how bubble sort\nworks now analyzing this order and\nSquare\ncomplexity and keeping in mind that a\nlist of 10,000 numbers takes about 12\nseconds so if n is 10,000 and N square\nis multiplied by some constant is about\n12 seconds then if you had a list that\nwas of 100,000 elements so that would be\n10 n whole square or 100 times the same\namount of time that it would take to\nsort it so that means it would take\nabout 20 minutes to sort 100,000 numbers\nwhich is I would say is a bit\ninefficient now and a list of a Million\nnumbers would take close to 2 days to be\nsorted in Python now if you do it in C++\nmaybe it might be four or five times\nfaster but again the moment you go from\na million to 10 million that will\nactually end up taking a year or\nso and that's bad and that is why n\nsquare or quadratic complexity\nis something that we would like to do\naway with because is it grows very fast\nas soon as you hit maybe 10,000 or\n100,000 elements then it starts taking\nlonger than a few seconds or a few\nminutes or a few days and at that point\nyou can no longer use that particular\nalgorithm so we need to optimize bubble\nsort and the inefficiency in bubble sort\ncomes from the fact that we are shifting\nElements by at most one position at a\ntime so each time we go through the list\nwe capture some information about the\nlist but we are simply moving one\nelement from left to right so to speak\nand each time we just moving it one at a\ntime by doing swaps rather it would be\nnice to just Place elements directly\nmaybe a few positions\nahead and that's where we will look at\nsome optimized\nalgorithms now another common algorithm\nthat is used is called insertion sort\nand this is here is the code for\ninsertion sort so you can look through\nthe code for insertion sort\nhere and here is uh an example you can\nsee how it works and we'll not look into\ninsertion sort in a lot of detail but\nroughly this is how you arrange cards in\nyour hand which is by starting to move\ncards around so that at the maybe on the\nleft Edge you have sorted cards on the\nright Edge you have the unsorted cards\nand you keep moving the new cards into\nsorted positions that's how it works so\nhere's an exercise for you go through\nthis function read the source code and\nthen describe the algorithm in plain\nEnglish now reading source code is an\nessential skill for software development\nthis is something that you'll have to do\nin your work whether you're doing\nsoftware development or data science\nmaybe because there are no comments in\nthe code there is no documentation or\nthe person who has written the code is\nnot available or has left the company or\nthis is some open source Library so in\nall these cases you will have to read\nand understand code so read it and and\nthen describe insertion sort the\nalgorithm in plain English then look it\nup online and see if it matches what\nyou've\nwritten and then second is to also\ndetermine the time and space complexity\nof insertion sord and see if it is any\nbetter than bubble\nsord and explain why or why not so these\nare a couple of exercises for\nyou so that's bubble sword and insertion\nsord now before we\ncontinue I just want to recall you that\nthis is a Jupiter notebook running on an\nonline platform hub. binder. jan. ML and\nsince this is free uh it will shut down\nafter some time so you want to capture\nsnapshot of your work at regular\nintervals and that's where you can use\nthe Jovian Library so you install the\nJovian Library using p install Jovian\nimport Jovian and then run jan. commit\nnow when you run jan. commit it captures\na snapshot of this jupyter notebook and\nputs it on your Jovian profile so now\nthis will be your profile when you run\njan.com it and you will be able to\nresume your work by clicking the Run\nbutton on this page anytime and this\nnotebook will go to your profile so you\ncan just click on your Jovian profile or\njust click home here and if you check\neither the overview or the notebooks tab\nyou should be able to find your notebook\nhere like here you go okay coming back\nnow we're at step six where we want to\napply the right technique to overcome\nthe inefficiency in the algorithm now to\nperform slorting more efficiently we\nwill apply a strategy called divide and\nconquer and divide and conquer is a very\ncommon strategy used across the board\nfor many different kinds of algorithms\nand it has this General steps that is\napplied in different different ways\nacross different problems so step one is\nto divide the inputs into two roughly\nequal parts okay they don't have to be\nexactly equal but two roughly equal\nparts and the idea here is that those\ntwo Parts can themselves be used as\ninputs as sub problems so then we use\nrecursion so we recursively solve the\nproblem individually for each of the two\nparts so here you have a problem you've\ncreated two sub problems out of it and\nthen you call recursion so the recursive\nsolution itself will use divide and\nconquer and then keep going and so on\nbut once it gives you the solution\ncombine the results to solve the problem\nfor the in for the original\ninputs okay so you have now results of\nthe sub problems and you combine them\nand you get back the final\nresult and then the only last thing you\nneed to know is because you're going to\nkeep calling this keep doing this\ndivision recursively so if you have an\ninput of size 100 you will call the same\nfunction on inputs of size 50 and 50\nthen you will call the same function for\neach of those 50 you will call the same\nfunction on inputs of size 25 and 25 so\neach half and as you keep going you will\neventually end up with small or\nindivisible ible inputs and that is\nwhere you can solve the problem directly\nand include terminating conditions so\nthat's where the recursion stops okay so\nyou include terminating conditions for\nsmall or indivisible\ninputs so that's divide and conquer you\ntake the problem divided into two sub\nproblems recursively solve the sub\nproblems get the solutions of the sub\nproblems and then combine them so you\ncan also call it divide conquer combine\nin some\nsense and merge sort is the algorithm\nthat is the classic application of\ndivide and conquer to the Sorting\nproblem so let's take a look at merge\nsort by looking at an example visually\nso here we have a list that needs to be\nsorted in increasing\norder so remember step one divide the\nproblem into two sub problems so here we\nhave half the list a little more than\nhalf here we have another half so we\nhave split it into four elements and\nthree\nelements then we take we call cursively\nwe call the same sorting problem the\nsame algorithm on these two so we split\n38 and 27 into 1 12 and 43 and 3 into\nanother here 982 becomes 1/2 and 10\nbecomes the\nother again we can split 38 and 27 we\ncan split 43 and 3 982 10 so now we've\nended up with single elements so with\nrecursion We've Ended up at this\nterminating condition we can no longer\nsplit the list so now we start combining\nthe problems now if you're looking to\nsort a list with just one element 38\nwell that list is already sorted so you\ncan return that and 27 is already sorted\nthe single element so you return that\nnow we have these two sub lists and we\nneed to combine them each has one\nelement so we can simply compare these\ntwo elements and we can tell that 27\ncomes first and 38 comes second so\nthat's how you combine these two results\nto get\n2738 then similarly with 433 you combine\nthem to get 343 and you get 982 and\n10 next you can combine these two\nresults so this is where now the\ncombination is important okay we need to\nlook through and we can probably tell\nthat three should come first and then 27\nand then 38 and then 43 so we've\ncombined them here and similarly here\nwe've combined 9 10 and 82 and then we\ntake the final results these two final\nlist and then we combine them back to\nget the fully sorted list okay and we'll\ntalk about this combination or what is\ncalled the merge operation in a lot more\ndetail soon but this is roughly the idea\nhere you keep splitting it into half and\nthen you combine the\nhalves so let's now state it in plain\nEnglish so first the terminating\ncondition if the input list is empty or\ncontains just one element then it is\nalready sorted return it if it is not\ndivide the list of numbers into two\nroughly equal\nparts then sort each part recursively\nusing the merge sort\nalgorithm and by the power of recursion\nyou will get back two sorted\nlists then merge the two sorted lists to\nget a single sorted list and this is the\nkey operation here and this is why it's\ncalled a merge sort because we are\nalways merging sorted list and making\nbigger and bigger sorted lists out of\nthem and the merge operation is\nsomething that you may be asked to write\nin an interview or a coding challenge\napart from the whole merge sort\noperation itself\nso this is something that you can try to\nexplain yourself so try to think about\nhow the merge operation might work and\nexplain it in your own words here is\nsome space for you but let's jump into\nthe implementation of merge sort\nthen now we will Implement merge sort\nassuming that we already have a helper\nfunction called\nmerge and this is a very useful\ntrick where your program may need some\ncomplicated piece of logic or some logic\nwhich you have not figured out yet so\nall you do is assume that you already\nhave the function and write use it first\nand then implement it later so here's a\nmerge sort\nalgorithm so now we have the merge sort\nalgorithm and we have numbers here given\nas an input to merge sort now here's the\nterminating condition if the length of\nnumbers is less than equal to one which\nmeans if the list is empty or has just\none element return the\nnumbers then if not then get the\nmidpoint so return length of numbers\ndivided by two and remember we using the\ndouble slash here because a single slash\nwould return a decimal and we cannot use\na decimal as an index or a position in\nthe list so that's why we're using the\ndouble slash here so we take the length\nof numbers divided by two so if the size\nof the list is 10 so we get back five\nhere then we split the list into two\nhalves and here here's some interesting\nSyntax for you and let's look into what\nthe syntax actually means so let's say\nyou have a\nlist so this is the list we have and\nlet's say\nmid has the value well we can check it\nhere 1 2 3 4 5 6 so six elements by two\nmid has a value\nthree now let's check X of mid what does\nthat give us well that gives us 1 35\nwell actually X of colon mid means X of\n0 to Mid and X of 0 to Mid means all the\nelements from position\nzero till before the position mid so\nthat's very important once again it's\nlike a range so you get the indexes at\nposition 0 1 and two not at position\nthree okay so that gives us these three\nelements then let's check the other\nthing X of mid\ncolon now what this gives you is this\ngives you the elements starting from the\nposition mid all the way to the end so\nwe can also write here minus one or we\ncan also write here Len of x - one but\nor we can just skip it and python will\nautomatically interpret that you want\nall the elements starting from mid to\nthe end that is 12 5 and 1 so positions\n3 4 and 5 and hence to split the list\nall we need is to invoke this 135 and\n1251 we get back two parts of the\nlist so this is a nice thing about\nJupiter whenever you don't understand a\nline of code just create a cell above or\nbelow and try out a simple example so\nnow we have the left half nums zero to\nMid and then the right half so nums mid\ncolon now here's where the magic happens\nwe call the function recursively so we\ncall the merge sort function itself so\nwe call we call merge sort on left and\nthat gives us back a list a sorted list\nfor the left half called Left sorted and\nthen we call merge sort function right\nand that will give us back a sorted list\ncalled right\nsorted and then we combine the results\nof the two halves by calling the merge\noperation so we now we now saying that\nwe want to merge left sorted and right\nsorted to get back the final sorted\nnumbers and then we return the sorted\nnumbers so that's merge sort so yeah\nit's almost seem seems like magic but\nit's pretty small pretty straightforward\nonly about four or five lines of code if\nyou combine some of these\nlines so then let's come to the merge\noperation because that seems to be the\nmeat here right this is the only missing\npiece so to merge two sorted arrays what\nwe can do is we can repeatedly compare\nthe two least elements of each array and\ncopy over the smaller one into a new\narray so here's what that process might\nlook like let's say you have these two\nparts 147 and 023 three and we want to\nget the sorted list and notice that\nthese are both already sorted because\nthese are the results of the recursive\ncall to merge sort so we keep a pointer\non the left on each one so here we have\nthe pointer at one here we have the\npointer at zero We compare the two we\ntake the smaller one and put it in the\nlist how do we know we can put it\nbecause if this is smaller than this all\nthese numbers are also greater than zero\nand then since one is greater than Z and\nall these numbers are greater than zero\ngreater than one so that follows that\nall the other numbers to the right of\none and to the right of 0 are greater\nthan Z and hence 0o should come in the\nfirst position so we put it there and\nAdvance the pointer now you can see here\nnow we can compare one and two and this\ntime one is smaller and you know that\nall the numbers here are greater than\ntwo so they're also greater than one and\nthen all the numbers here are also\ngreater than one hence we know that one\nis now the next largest number so we can\nnow put in one and Advance the pointer\nand keep going this time now you compare\ntwo and four so now you can put in two\nand advanc the pointer now you put in\nthree and then Advance the pointer and\nat some point you will exhaust one of\nthe lists and when you exhaust one of\nthe list then you can stop comparing and\nyou can simply copy over the remaining\nelements so we can now copy over four\nand 7even and we've exhausted this list\nand we get back the sorted merged array\n0 1 2 3 4 7 so it's really simple it\ninvolves each step involves one\ncomparison and incrementing one pointer\nso you're either incrementing this\npointer or you're incrementing this\npointer okay so let's now Define the\nmerge operation and you can see the\nbenefit now of assuming that the\nfunction already existed now we do not\nhave to Def worry about the\nactual sorting and recursion Etc we\nsimply have to worry about merging two\nsorted\narrays so first we'll create a list to\nstore the results and we have nums one\nand nums two the two left and right list\nthat we are going to combine then we're\ngoing to set set up two indexes or two\nnumbers for iteration the two pointers\non the two lists and we set up each of\nthem at position\nzero so each of them are currently at\nposition zero here and we Loop over the\ntool list so we say while I less than\nLen of nums one and while J less than\nLen of nums 2 so if you have four\nelements in the left list then I can go\nfrom 0 to three all four positions and\nif you have five elements in the right\nlist J can grow from 0 to five 0 to four\nall five\npositions\nthen we check and and we remember we\nwant to make sure that both of these\nindices are valid if any of those have\nreached the end then you want to skip\nand we can simply copy over the\nremaining list right so as you see here\nas soon as we reach this point there's\nno more comparisons to be made so we can\nexit the loop so now we check which one\nis smaller so if we if nums 1 I so the\nleft list current element is smaller\nthan nums 2 J then we append to the\nmerged list nums one I as we did here\nand we increment I so this is exactly\nwhat we've done here so we put in well\nlet's say here so we put in one here and\nwe increment the left pointer on the\nother hand if that's not true we append\nthe element from the right so nums to J\nand we increment the right pointer so in\neach case in each y Loop we are\nincrementing one of the\npointers and then when the while loop\nends one of the lists would have been\nexhausted that's when the Y Loop ends so\nwe can get the remaining parts of both\nthe lists so we can get nums one I colon\nwill get the remaining elements from the\nfirst list the left list NS 2 J colon\nwill get the remaining elements from the\nright list but remember since one of\nthem is exhausted so one of these two is\ngoing to be empty right now we we can\ncheck which one is empty and simply add\nthe remaining one but here's a simpler\nsolution we just add both of them to the\nmerg\nso we append both the lists at the end\nand this automatically takes care of the\nempty case if the left side becomes\nempty then this adds nothing to the\nmerged array and this adds the remaining\nnumbers from the right side if the right\nside becomes empty then this adds the\nremaining numbers from the left left\nside and this adds nothing so that's a\nsmall\ntrick so that's the merge operation\nagain not very\ndifficult if you have any questions take\nthis out into specific cells and and try\nit out with examples and you should see\nit working so let's try out the merge\noperation now so here we have two sorted\nlists you can see\nhere and there you go you can see that\nthis is now arranged all these numbers\nare now arranged in a sorted\norder so now we have the merge operation\nand we have the merge sort operation so\nwe can now test out the merge sort\nfunction so we get the first set of\ninputs and outputs\nfrom test\nzero and you can see\nhere that this is the input and this was\nthe expected output and this was the\nactual output as\nwell now let's test all the cases using\nthe evaluate test cases function from\nJovian so here we're simply going to\ncall evaluate test cases on the entire\nlist of test cases and you can see all\nthe test cases seem to be passing\nnow if one of these test cases had\nfailed what you should go do is you\nshould go back and add some print\nstatements inside your merge function or\nadd some print statements inside your\nmerge sort function the right places to\nadd the print statements is right after\nthe function definition uh right after\nin the body of the function it can be\nthe first statement and then inside each\nLoop so inside each Loop whatever are\nthe changing parameters you should print\nthem inside a loop and then finally you\ncan also print the return value of the\nfunction so in this way you can build a\nfull picture of what the\nwhat your function is doing and that\nmakes it much easier to solve\nissues so test cases and print functions\nmake it easy to fix errors in code and\ndon't worry if there are errors there\nare always errors in code what's\nimportant is you should be able to find\na way to fix them easily and without\ntest cases or without printing you may\nget stuck and you may just keep staring\nat the code and trying to figure out\nwhat exactly went wrong so please do\nthat now one last thing I want you to\nnotice is here the execution took only\nabout 50\nmilliseconds on the other hand remember\nbubble sort took about 15\nseconds to sort 10,000 numbers so that M\nsort is much much faster right a\nmillisecond is\n.001 10 ^ minus 3 seconds so in a second\nyou can probably sort 200 of 200 list of\nsize 10,000 and that's what makes merge\nsort so much more powerful and because\nit is so much more efficient and as we\nanalyze the complexity you will learn\nthat M sort is in fact more efficient in\nterms of the biger notation as well so\nlet's analyze the algorithm's complexity\nand identify if there are any\ninefficiencies now analyzing recursive\nalgorithms can get tricky and that's\nwhere it helps to track and follow the\nchain of recursive calls so what we'll\ndo is we will add some print statements\nto our merge sort function and a merge\nfunction so we'll simply see what the\nmerge sort function was invoked with\nokay so we'll add a print statement\ninside merge and we'll add a print\nstatement inside merge sort both of them\nand we are also tracking something\ncalled a depth to track the chain or the\ndepth of each recursive call and you'll\nsee what I mean in just a second okay so\nthis is what it looks like we called\nmerge sort on this big list of elements\nunsorted and that merge sort internally\nled to two calls of merge sort so you\ncan see this one here and this one here\nso you have two calls to merge sort one\nwith the left half of the list and one\nwith the right half of the list and\nthey're\nunequal and these two merge sorts\nfinally returned merg lists and we\nfinally called a merge operation on the\ntwo of them you can see that this is the\nmerge operation the final merge\noperation called\nhere on the two merge sort lists and\nthis merge operation is working with\nthese two sorted lists okay so we can\nsee that each merge sort invokes the\nitself invokes merge sort twice but this\ntime with an array of half the size you\ncan see merge sort was invoked with\narrays of or lists of half the\nsize and it also invokes the merge\nfunction once to merge the two resulting\narrays the two sorted arrays now the two\ncalls to merge sort If You observe\nclosely they themselves make two more\ncalls to merge sort and one more call to\nmerge and then those internal calls make\ntwo more calls to merge sort and one\nmore call to merge and so on till we end\nup with single elements at which point\nmerge sort simply returns that single\nelement\nso the mer algorithm ultimately points\ndown to a series of merge operations you\ncan see here that each merge sort all\nit's doing is calling merge sort\ninternally and then calling a merge\noperation so ultimately what we doing is\nwe are first merging 5 and -2 and then\nwe merging 2 and\n6 and then we're merging -25 and 2A 6\nand then we're merging 123 and we're\nmerging 7 - 12 and then we're merging 7\n- 12 7 and finally we're\nmerging 123 - 1277 and then finally we\nare merging the big list right so it's\nultimately just a whole bunch of merge\noperations and if you look inside the\nmerge operation this is where a\ncomparison is happening and this is\nwhere this append end step is happening\nso we are comparing and appending so\nthose are the two key operations here\nand with every comparison there is\nappend so if you simply count the\ncomparisons once again that's happening\nthat should be enough to get the time\ncomplexity and what is the number of\ncomparisons that's happening well that's\nstraightforward too if you have two\nlists nums one and nums two each and the\ntotal length of the two lists is n so\nbecause the size the number of\niterations is equal to\nin the in the worst case it would be\nequal to the lengths of the two lists\ncombined so you may have to first maybe\nincrement I by one then increment J by\none then once again increment I by 1\nthen J by 1 so the total number of\niterations here is len of nums 1 plus\nLen of NS 2 right but remember the merge\nwas called if merge sort was called with\na list of size n then merge was called\nwith the list of size n by2 and n by2\nroughly so the total list the total\nlength of NS one plus nums 2 is actually\nthe overall length n so that's the real\ntrick here that merge the merge\noperation is an order n operation where\nn is the number of elements the total\nnumber of elements okay so this merge\noperation takes 4 + 5 9 comparisons and\nthis merge operation takes five\ncomparisons and this merge operation\ntakes three comparisons and so\non now this way now if you visualize a\nproblem now as a tree where we calling\nmerge sort with n with n elements and\nthat ends up calling merge sort with n\nby2 elements and that ends up calling\nmer s with n by4 elements all the way\ndown and then we start merging so here\nwhen we get to individual elements we\nare calling merge with literally single\nelements and as we come up here we are\ncalling\nmerge at this point we are calling merge\nwith elements of size n by 8 and N by 8\nbut we calling merge eight times so now\neach of these sub problems makes a call\nto merge and each of these sub problems\nhas the list size n by 8 so you have\neight calls to merge of size n by 8 so\nthe total number of comparisons done is\nn and at every stage you can check this\nat the top level uh you are calling\nmerge with n total elements so the total\nnumber of comparisons is n at the second\nlevel you're calling merge here once\nwith n by2 elements and you're calling\nmerge here once with n by2 elements so\nthe total number of comparisons is 2 * n\nby2 that's n and here you're calling\nmerge with n by4 elements four times so\nthat's\nn so if the height of the tree is H then\nthe total number of comparisons is n * H\nright\nso on each level you'll require n\ncomparisons for the merge and you call\nmerges at every level for each of these\nsub problems so the height of the tree\nis so the total number of comparisons is\nn *\nH now how do we get the height of the\ntree if the height of the tree is H and\nyou can see here that as we go down this\nis level zero and it has one element\nthis is level one and it has two\nelements this is level two and it has\nfour sub problems and this is level\nthree and it has eight sub problems so\nlevel K has 2 to the^ K sub problems so\nif you keep going down this is level hus\none so level H -1 should have 2 to the\nh-1 sub problems but remember at the\nlast level we simp we simply have sub\nproblems or merge merge calls with\nsingle elements so that means we have a\ntotal of\nn elements here or n Leaf nodes here so\nit follows that 2 ^ of H -1 is n okay so\nI'll I'll let you think about that and\nreason with that this is something that\nyou may have to work out on pen and\npaper to get correctly that if the\nheight of the tree is H then 2 ^ H - 1\nis equal to n because at the bottommost\nlayer you have n leaves in the tree so\nit follows that H is log n + 1 so since\nwe said that there are n * H comparisons\nand H is log n + 1 so it follows that\nthe complexity of merge sort is n log\nn and that's a big improvement from n\nSquare it may not seem like much but it\nit is so n sare for 10,000 is 10,000 *\n10,000 but n login for 10,000 is 10,000\n* 12 or 13 log to the base 2 so that's\nabout a few hundred times faster now\neven for an array of a million elements\nit will only take a few seconds to be\nsorted and you can verify this by\nactually creating a list of a million\nelements okay so the complexity of Mer\nsort is n log n and you get it by\ndrawing this sub problem tree and\nrealizing that there are you get a sub\nproblem tree of height log n or log n\nplus one and at each step you perform a\nmerge\noperation or multiple merge operations\ntotaling to n comparison so so n * login\nis the complexity of merge sort now\nhere's also a discussion about space\ncomplexity and this is something that I\nwill leave as an exercise for you so do\nread through this and see if you can\nreason why the space complexity of Mer\nsort is order n okay so time complexity\nis order n log n and the space\ncomplexity is order n but here's a hint\nwhy it's order n you can see that inside\nthe merge operation we are creating a\nnew list and then we are copying over\nelements from each of the two lists into\nthe new\nlists so we are allocating a new list\ninside\nmerge and now it's so now that's no\nlonger constant that list will have the\nsame size as the size of the problem\nitself and hence roughly that's why the\nspace complexity is order\nn\nokay so with that we conclude our\ndiscussion of merge sort it's a divide\nand conquer algorithm you split the list\ninto half recursively sort both of them\nthen merge the two sorted lists and the\ninitial condition is one or zero\nelements now there are several\nextensions and variations of merge sort\ncalled the kway merge sort where we\nsplit not into two parts but into K\nparts then we have the counting\ninversions problem\nwhere we modify mer sort a little bit to\nalso find some other in information\nabout the list and finally we have\nhybrid algorithms which combine merge\nsort and insertion sort so what they do\nis for smaller list they use insertion\nsort because that's more efficient and\nthen for bigger list they use merge sort\nso as they're splitting the list when\nyou get to a small enough problem let's\nsay 10 or less elements they use\ninsertion\nsort and that brings us to our next\nquestion where we make one level of\noptimization and then we\nstop but here we'll go one step further\nwhat we'll do is we will apply another\ntechnique to overcome the inefficiency\nin merge sort now the time complexity is\npretty good you can actually sort\nmillions or even tens of millions of\nelements with merge sort quite reliably\nbut it's a space complexity that causes\na problem now because merge sort\nrequires allocating additional space and\nthat additional SPAC is as large as the\ninput itself that makes it somewhat slow\nin practice because memory allocation is\nmore expensive than computations so\ndoing a comparison is very easy you just\ntell the CPU to compare two things in\nthe memory or swapping them is also easy\nbecause you're still working with memory\nthat you already have but when you have\nto allocate new memory you often have to\nthen request the operating system uh to\nallocate the new memory and then you\nhave to get its address and do a whole\nbunch of operations so it's let's say an\norder of magnitude more expensive than\nsimply doing some computations so you\nshould try and avoid memory allocations\nas far as possible now one or two\nvariables is fine but if you're dealing\nwith a million elements so you're\nprobably going to need maybe a few MB of\nadditional space and that is what may\nslow\ndown your algorithm a little bit it\nwould still be n log n but the constant\nFactor now the cost of each operation\nwill be higher because it involves an\nallocation now to overcome the\ninefficiencies the space in efficien of\nMer sord we will study another divide\nand conquer based algorithm sorting\nalgorithm and this is called quick sort\nand quick\nsort sorts the array in place which\nmeans it does not create a copy of the\narray internally for sorting inside each\noperation is inside each combination\noperation so let's see how it works it's\na pretty interesting a pretty smart\ntrick so here's how it works if the list\nis empty or has just one element return\nit it's already sorted\nstraightforward then pick a random\nelement if not pick a random element\nfrom the\nlist now this element is called a pivot\nnow there are many strategies for\npicking a pivot one is to pick a random\nelement one is to maybe pick the first\nelement the last\nelement what we'll do is we will pick\nthe last element but you can easily\naugment our implementation to pick a\nrandom\nelement and then reorder the list and\nthis is the key operation here reorder\nthe list so that all the elements with\nvalues less than or equal to the pivot\ncome before the pivot element while all\nthe elements with values greater than\nthe pivot come after the pivot element\nand this element is called partitioning\nyou're partitioning the array around the\npivot so here's an example you let's say\nwe take three as the pivot element the\nfinal element now what we want to do is\nwe want to reorder the elements and the\nway we reorder is by doing swapping and\ncomparison in whatever way we can and\nthat's what we will really focus on the\npartitioning\nalgorithm and you reorder it in such a\nway that all the numbers to the left of\nthe pivot are smaller than it and all\nthe numbers to the right of the pivot\nare larger than\nit now here's the key key observation\nhere once you do\nthat you can tell that all these all\nthese numbers can now be sorted\nindependently and none of the numbers\nfrom here will move to the right of\npivot and similarly all these numbers\ncan also be sorted independently and\nnone of the numbers here will move to\nthe left of the pivot so the pivot is in\nthe correct position in the final sorted\narray so it's now in its correct final\nposition and you can simply call quick\nsort on this half or less than half this\nportion of the array and portion of the\narray and there's no real combination\nrequired anymore right so because we're\ndoing it all in place we simply call\nquick sort on each side of the array and\nonce this gets sorted and this gets\nsorted\nrecursively then you will end up with\nthe entire sorted list right and that's\nthat's how we then continue doing the\nprocess recursively now on the left half\nyou once again pick a pivot and then you\narrange the elements around the pivot on\nthe right half you once again Pi pick a\npivot and arrange the elements around\nthe pivot and so on and so on okay so as\nI said the key observation here is that\nafter the partition the pivot element is\nat its right place in the sorted array\nthe two parts of the array can be sorted\nindependently in place now maybe once\nagain take pen and paper and try to work\nit out yourself again all of this makes\na lot more sense when you actually put\nit down and solve a real problem as a\nreal\nexample so here's an implementation of\nquick sort and once again we will assume\nthat we already have a helper function\ncalled Partition which can pick a pivot\npartition the array and return the\nposition of the pivot element for the\nnext quick sort step okay so this entire\nprocess going from here to here this is\nwhere we'll assume that we have a\nfunction and write the quick sort\nalgorithm and then implement the\npartition function so here's what quick\nsort might look like now quick sort\ntakes a bunch of\nnumbers and apart from the numbers it\nalso takes a start index and an end\nindex now why are we doing this remember\nwe want to avoid creating copies of the\nlist that's the whole Pro that's the\nwhole thinking here the line of thinking\nso we will call quicksort not with a\nsublist which is which is a copy of a\nportion but we will call quicksort\nSimply by changing the by passing the\nsame original list but by changing the\nstart and end index\nokay now there is some code here if end\nis none then we are s setting end to the\nlength of of the list minus one and\nhere's one more thing that we're doing\nso the final invocation to quick sort\nthat we'll make will be something like\nthis we may call quick\nsort let's say there are a few numbers\nhere so we may call quick sort on a list\nsomething like this and in this case\nautomatically start will have the value\nzero and end will have the value none\nnow remember the quick sort is going to\nsort the array in place\nbut we also said that we don't want to\nmodify our test cases so here's one\nassumption we are making that if end is\nnone which means if quicksort is called\njust with the just with the list then\nwe'll create a copy of the list right so\nwe'll just create one copy at the very\nbeginning right when the list is passed\nfor the first time and then we'll not\ncreate any more copies and you can even\nskip this line\nentirely but the only trouble is that\nwe'll start changing our test case input\nso that's why let's keep it and let's\nkeep a copy\nbut this is only done at the very top\nlevel right so only when we start we\ncreate a copy so that we not modifying\nthe input list but never\nagain so that's what we're doing here\ncreating a copy if uh quick sort was was\ncalled with the list and setting end to\nLen nums minus one which is the final\nvalid index in the list anyway putting\nthis aside this is the real condition\nhere so if start is less than end which\nmeans let's say here you have start and\nhere you have end now if start is less\nthan end that means you have two or more\nelements right if start and end are\nequal that means you have just one\nelement and if start is greater than end\nthat means you have zero elements really\nso if start is less than end that means\nif you have at least two elements then\nwe call the partition function we call\nthe partition function on nums and we\nsay that we want to partition the region\nstart to end so let's say this is the\nregion start to end we want to partition\nit so we want to pick a pivot and then\npartition it in such a way that elements\nto the left of the pivot are smaller\nthan it and elements to the right of the\npivot are larger than it for example if\nyou want four to be the partition\nelement four to be the pivot element\nthen we will partition the array as\nthree comma 4 comma 5A\n23 so that three is smaller than four\nand 523 are bigger than four and we will\nreturn the position of the pivot element\nokay so now you partition the array and\nreturn the position of the pivot element\nso this is the position we get back and\nthen we can call quick sort on this\nregion and on this region so we can now\ncall quick sort on start to Pivot minus\none and we can call quick sort on pivot\n+ one to end okay so now we are passing\nactually explicitly passing in values\nfor start and end so this will not kick\nin the next time so no more copies of\nthe list will be created so all the\nrecursive calls will keep modifying in\nplace so all the recur even the\npartition\ncall will'll modify in place and we'll\nsee how partition Works in just a moment\nso partition gets the slice of the\noriginal list and it Returns the\nposition of the pivot element then we\ncall quick sort on the left slice which\nis before the partition the elements\nsmaller than the partition and then we\ncall quick sort on the right slice which\nis elements that come after the\npartition okay now here is how the\npartition operation works\nit's pretty straightforward too not that\ndifficult so what we'll do is we will\npick the final element as the pivot\nelement but if you don't want to pick\nthe final element you want to pick a\nrandomized element well just pick a\nrandom position and move that element to\nthe final position and that's as good as\npicking the final element now so Random\npivot simply involves picking an element\nmoving it to the final position but\nassuming the pivot is in the final\nposition we then keep two pointers left\nand right\nnow remember we want to create we want\nto push all the numbers smaller than the\npivot to the left and we want to push\nall the numbers larger than the pivot to\nthe right okay and what we'll do\nultimately is we will arrange them in\nsuch a way that some of these are\nsmaller than the pivot and some of these\nare larger than the pivot and then we'll\nmove the pivot between\nthem so we'll see how to do that so you\nhave the left pointer and the right\npointer now here's what we do inside\npartition\nwhile these two pointers are far away\nfrom each other first we check if the\nelement at the left pointer is smaller\nthan the pivot well if the element at\nthe left pointer is smaller than the\npivot which it is you simply Advance the\nleft pointer forward so this goes to\nfive and then we go back to the next\nLoop now this time once again we check\nif the element that the left pointer\npoints to is smaller than the pivot five\nis not smaller than three five is is\ngreater than three so if that is the\ncase then we check if the right pointer\nis greater than the pivot now if the\nright pointer is greater than the pivot\nthat means this number is in its right\nposition it's greater than the pivot so\nwe move the right pointer back one space\nokay so that's the operation we just did\nnow once again we check is the left\npointer smaller than the pivot no it's\nnot is the right pointer greater than\nthe pivot no it's not so that means\nthese two numbers are out of place right\nwe ideally would want this to be smaller\nthan the pivot and this to be larger\nthan the pivot so we swap these two\nelements so now 0er comes here and five\ncomes here now once again we can check\nis zero the left pointer smaller than\nthe pivot yes so move the left pointer\nforward then we is the left pointer\nsmaller than the pivot no six is now\ngreater than three so we check is the\nright pointer larger than the pivot yes\nso we move the right pointer forward\nbecause five is still in its correct\nposition it's know on the on the right\nEdge and everything is greater than\nthree so now once again we end up in\nthis position that the left element is\nsmaller than the is larger than the\npivot so we check the right element the\nright element is smaller than the pivot\nwe want it to be larger so we swap these\ntwo because these two are once again out\nof order and now you can see that one2\nare all smaller than the pivot and 651\nare all larger than the pivot so we do\none final check is two\nsmaller than the pivot yes so we advance\nthe left pointer and now both of the\npointers are at the same position so now\nwe can tell at this point\nthat\nhere all from this point position\nonwards all of these numbers are larger\nthan the pivot so we simply simply Swap\nthis element with the pivot so there you\ngo so you end up with 1 02 3 5 11 and 6\nokay so that's the partition operation\nso again to understand it yourself do it\non pen and paper write out write write\nout this\narray create the pivot create the left\npointer right pointer and keep creating\ncopies of the array for each step of the\nloop okay and that's how you understand\nthese things it's not that difficult\nit's just it involves two pointers so\nit's a little tricky now this is the\ncode for\npartition and I will let you follow this\ncode we'll go this briefly but at by the\nthis point since we are halfway into the\ncourse now you should be able to read\nthe code and then there are also\ncomments here and understand what we\nhave just discussed in plain\nEnglish understand that in terms of code\nokay so one exercise for you is to\nexplain this visual approach in plain\nEnglish step by step and then the second\nexercise for you is to read the code and\nunderstand it or maybe even try to write\nit from memory so just take the English\ndescription and try to write the part\npartition function from your memory not\nmemorize the code itself but convert the\nEnglish text into code okay uh so once\nagain here you know we have the nums the\nnumbers that need to be partitioned the\nstart and the end and if end is none we\nsimply set end to the last index which\nis len nums minus one then we initialize\nthe start and end pointers so we\ninitialize the left and right\npointers remember we want to use the end\nelement so this is the end element so we\nwant to use the end element as the pivot\nso the left point the left pointer is\nstart and the right pointer is end minus\none that's what we that's what we've set\nhere and then white while the right\npointer is greater than the left pointer\nwe increment the left pointer if the\nnumber at the left pointer is less or\nequal to the pivot we decrement\notherwise we decrement the right pointer\nif the number on the right pointer is\ngreater than the pivot otherwise the two\nof them are out of place and they can be\nswapped so we swap them here\nand finally we place the pivot in place\nbetween the two parts and that's it\nthat's exactly what's happening here so\nlet's see here let's see this partition\nwe are taking this list and we are\ncalling partition on it and three is the\nnumber that was used as the pivot so now\nthree ends up here in between so you\nhave 102 and\n516 and it the partition function\nReturns the position of the pivot so now\nyou can see how it is used in quick sort\nthe partition for function Returns the\nposition of the pivot and then we call\nquick sort on the left\npartition before the pivot and on the\nright partition after the\npivot so now we can test out quick sort\nokay and here's another exercise for you\nadd print statements inside the\npartition function so there are already\nsome print statements you can simply\nuncomment them uncomment the print\nstatements to display the list the left\npointer and the right pointer at the\nbeginning at end of every Loop to study\nhow partitioning works and similarly you\ncan also add print statements inside the\nquick sort function to study how the\nrecursive calls are going on so study\nwhat we've done in merge and merge sort\nand add the same print statements in\nquick and quick sort and look at these\nrecursive calls now what you want is to\nhave a completely clear and perfect idea\nof what your code is doing you don't\nwant to be lost about it and that's why\nadding print statements and looking at\nsmall examples and making sure that it's\nworking perfectly really\nhelps so let's look at quick sort in\naction so here's an input and here's the\nexpected output and here's the actual\noutput and they match great and we can\nnow evaluate all the test cases using\nthe evaluate test cases functions for\nfunction from Jovian so we import from\njan. python DSA evaluate test\ncases and call evaluate test cases here\nand you can see that it passes\nall the test\ncases and not only that you will also\nnotice that it is marginally faster than\nmer sort for sorted\nlists sometimes you may not see that but\nyeah you can see here that it's you will\nsee that in most cases quick sort is\nmarginally faster than merge sort for\nlarger list and that's because it is not\nallocating new space okay so now coming\nto the time complexity for quick sort\nnow assuming that we are able to have a\ngood partition each time so each time we\nare dividing the list into roughly equal\nhalves roughly equal parts like you\nstart with a list of size n and you\npartition\nit into n by2 and n by2 so this is what\nthe sub problem tree looks like so you\ncall quick sort with two lists of n by2\nn by2 then you call quick sort with four\nlists of size n by2 n by4 n by4 and so\non now what is the activity that we're\ndoing inside quick sort in each quick\nsort the core operation is partition\nright and that's what puts one element\nthe element into its right place and\nthen the element smaller than it to the\nleft of it the elements larger than it\nto the right of\nit so the partition is where the actual\nwork the comparison and swapping happens\nand how many comparisons do we perform\nin the\npartition I would say that the number of\ncomparisons is equal to the size of the\nactual list and you can see that here\nyou can see that we are going on\ncomparing numbers like this we comparing\neach number to the pivot so each number\ngets compared to the pivot exactly once\nroughly and that means that there are a\ntotal\nof n comparisons if n is the size of the\nlist\nokay so we have n comparison and\npartition so partition performs n\noperations or partition is an order n\nfunction and what is the height of the\ntree once again the height of the tree\nis log n because to go from n to\none It Takes login steps you keep going\nn by2 n by 4 n by 8 and so on N by 2\nthe^ log n becomes n by\nN1 and so the time complexity of quick\nsort is in login if you're able to\npartition the array into roughly equal\nparts and that is what happens on\naverage if you're picking random pivots\neach time then you do end up with\nroughly equal parts maybe 75 35 75 25\nbut that's still more or less in the\nsame\nrange so the quick sort complexity is\nabout n login and this is called the\naverage case complexity on the other\nhand if you have a really bad partition\nand a really bad partition is maybe you\npicked the smallest element as the pivot\nnow if you pick the smallest element as\nthe pivot then all the elements will go\nto the right of the pivot and you will\nend up calling quick sort on a problem\nof size n minus one and then maybe once\nagain if you pick the smallest element\nas pivot all the elements will go to the\nright of the pivot once again and you\nwill end up calling quick sort with a\nproblem size of n minus 2 now this is an\nunbalanced t or a skew tree and what\nhappens in a skew tree is that the\nheight this time is the same as n you\ncan see n n-1 n-2 n - 3 so going up to\none the height of three is n but the\namount of work involved in partitioning\nis the same because you have to run\nthrough the entire list to partition the\nlist right so that in this case the time\ncomplexity is\nis roughly n * N - 1 by\n2 so the time complexi is about order n\nsquare and that's bad because that's as\nbad as bubble\nsort but despite the quadratic worst\ncase time complexity quick sort is still\npreferred in many situations now it\nreally depends on what kind of algorithm\nyou need to use and what kind of memory\nconstraints you have because\nquick sorts complexity is closer to end\nlogin in practice especially with a good\nstrategy for picking a pivot and a good\nstrategy picking a random pivot but\nthere's another one called picking\nmedian of medians you can check that out\nas\nwell so that's n login is the average\ntime complexity of quick sort and then n\nsquare is the worst case time complexity\nof quick sort now here's an exercise for\nyou verify that quick sort requires\norder one additional space which means\nthat it does not really need to copy the\nAR we did create a copy because we did\nnot want to affect our test cases but we\ncould have removed that line and quick\nsort would work just fine so because you\ndo not need to create a copy of the list\nor the array it requires order one\nadditional space but because space\ncomplexity also includes often the size\nor the space required to store the input\nso you can say that quick sort has the\nspace complexity of order n okay so if\nyou get the question about space\ncomplexity you may want to ask are you\ntalking about the additional space or do\nyou also want to include the input in\nthe space\ncomplexity so that's quick\nsort and those are the two sorting\nalgorithms we've looked at so we've\nlooked at we've looked at bubble sort\nand we've looked at insertion sort and\nthen we optimized it using divide and\nconquer and got to merge sort which is\norder n log n but it also has a space\ncomplexity of or the additional space\nrequirement of order n which can be\navoided using quick\nsort which uses order one additional\nspace but can have order and\nsquare complexity in the worst case time\ncomplexity but with the right choice of\na pivot it is closer to n\nlogin so that's sorting and you can see\nthat python is such an expressive\nlanguage that all these sorting\nalgorithms which are often quite\nconfusing to implement in C++ or Java\nare actually pretty straightforward to\nimplement in Python all you need to do\nis follow the method which is to State\nit first in plain English have some test\ncases ready to test your function and\nthen write your code carefully checking\neach line for errors and create small\nfunctions wherever you need to so try\nnot to have too much logic in one\nfunction A good rule of thumb is about 7\nto 8 lines of code per function no\nbigger than that and that's not just for\ntoy problems but that's also even as a\nsoftware developer something that you\ncan try to follow just have seven eight\nlines of code in any function if you\nhave more than that try to split it into\ntwo functions okay and and this way it's\nvery difficult for you to go\nwrong so now let's return to our\noriginal problem statement and let's\nread it once again you're working on a\nnew feature on Jovian called top\nnotebook of the week or top notebooks of\nthe week and write a function to sort a\nlist of notebooks in decreasing order of\nlikes now keep in mind that up to\nmillions of notebooks can be created\nevery week you want to build this for\nscale so your function needs to be as\nefficient as possible so first we need\nto sort objects this time and not just\nnumbers and second we also want to sort\nthem in the decreasing order of likes\nfor each notebook okay so all we need to\ndo to use our merge sort or quick sort\ntechniques that we've\nalready discussed is to define a com\ncustom comparison function to compare\ntwo notebooks okay but before we do that\nwe let's create a class that can capture\nsome basic information about notebooks\nso here we have the class so we're still\nfollowing the method so to speak right\nthe step one was to come up with the\ninput and the output format so here is\nthe input format our input format would\nbe using this class so we create\ncreating a class notebook which is uh\ntitle username and\nlikes so we create the class and that\ngets stored as properties titles\nusername and likes and then we also have\na string represent ation here then\ncreate some test cases so now we are\ncreating some test cases here so we are\ncreating some test cases nb0 to\nnb9 and let's put them all into a list\nand you can see here that we now have a\nlist of\nnotebooks nb0 to nb9 and you can see\nthat because we have a string\nrepresentation we can see that the first\nnotebook is this aash /py basic and it\nhas 373 likes and the second one is this\nand it has 532 likes and these are\nclearly out of order in terms of likes\nnext we'll Define a custom comparison\nfunction for comparing the two notebooks\nwhat it will do is it will return the\nstrings lesser equal or greater to\nestablish the out order between the two\nobjects okay so it should return lesser\nwhen nb1 should come at a position or a\nindex lesser than the position of nb2 in\na\nsorted list\nokay so in in in case of our problem\nwhat that means is we want to sort\nthings in the decreasing order of likes\nso the first notebook should have the\nhighest number of likes and then maybe\nthe second notebook should have the\nsecond highest number of likes and the\nthird notebook will have a lower number\nof likes and so on so if you have two\nnotebooks nb1 and nb2 and if nb1 do\nlikes is greater than nb2 do likes so\nthen nb1 should come at a lesser index\nokay so we will return lesser because it\nshould come at a lower\nposition in the sorted list so we return\nlesser because we want a decreasing\norder and if nb1 do likes is equal to\nnb2 do likes then we return equal and if\nnb1 do likes is less than nb2 do likes\nso that means this is not uh is nb2 is\nthe more like notebook nb1 is the less\nlike\nnotebook then nb1 should actually come\nat a greater position so we will return\ngreater okay so this is this comparison\nfunction should return whether the first\ninput to it should come up should show\nup at a lesser position in the sorted\nlist compared to the second input now in\nlanguages like C++ and Java normally the\nconvention is to return a negative\nnumber zero or positive number but I\nfind that python allows you to return\nstrings strings are first class citizens\nin Python and it's a lot clearer when\nyou are debugging things when you face\nissues to look at actual strings and\nit's also easier to write write\ncodee so I prefer using strings but you\ncan also use you can also use numbers\nlike negative 0 or positive that's\ntotally up to you so now here is an\nimplementation of merge sort which\naccepts a custom comparison function so\nlet's see the merge sort function so the\nmerge sort function\nuses it takes a list of objects this\ntime not a list of numbers and it also\ntakes a compare function which by\ndefault we also provide a default\ncomparison so that we can still use it\nwith numbers now with numbers and\ndefault assumption is if you want\nsorting you want sorting in increasing\norder so this is what the default\nsorting looks like for numbers so that's\npretty straightforward but you can also\npass a custom comparison function so\nhere we have the terminating condition\nif the length is less than two then we\nsimply return the list then we get the\nmid index and then we call merge sort on\nthe left half with the custom comparison\nfunction we call merge sort on the right\nhalf with the custom comparison function\nand we call merge with the custom\ncomparison\nfunction now what happens inside merge\ninside merge earlier know once again we\nhave these two halves left and right and\nthen we have a custom comparison\nfunction so we create pointers for the\ntwo of them and then we also create the\nfinal result list which is\nmerged and then we iterate over the left\nlist and the right list U so while we\nare going through these we compare the\nleft element and the right El element so\nnow we calling compare now we are not\ndoing the greater than less than\ncomparison we're calling compare and if\nthe result if the element on the left is\nlesser or equal to the element on the\nright then we append it to the result\narray and we increment the left counter\notherwise so lesser or equal means that\nthe element on the left the first\nelement on the left should show up at a\nlower position in the sorted final\nsorted list so that's why we append it\nfirst other we append the right child\nthe right element and we increment the\nright pointer and finally we attach any\nremaining elements here so this is\nsomething that you can review something\nwe've covered in a lot of detail so now\nlet's see let's call merge sort on our\nnotebooks and let's check if the\nnotebooks are sorted by likes and indeed\nthey are you can see that at position\nzero you have the notebook with the\nhighest number of likes and then you\nhave the next one and the next one and\nso on now since we have written a\ngeneric merch sort function that works\nwith with any compare function we can\nnow very quickly use it to sort the\nnotebooks by title as well or if we had\nmaybe the number of views per notebook\nor the number of versions in each\nnotebook or the number of comments on\neach notebook we could do that sorting\nas well so we could even use a hybrid of\nthose so here the example we're taking\nis comparing by titles so here we have\nnb1 and nb2 and simple comparison\nstrings can also be compared using the\ncomparison operators so if nb1 do title\nis less than nb2 do title then we return\nlesser\notherwise we return equal or\ngreater and with this we should be able\nto sort them in the ascending order of\ntitles you can see a n c i c i f e l i l\no py py okay py t h py t h py t o p\ntorch okay so this is now order sorted\nin the order of titles and exercise for\nyou is to sort in the order of username\n/ title which means you first compare\nthe username and if the usernames are\nare equal then compare the titles so you\ncan compare you can probably write\nanother comparison function compare\nusername and titles and use that to do\nthat two level comparison and use that\nfor\nsorting okay now another exercise for\nyou going forward is to implement and\ntest the generic versions of bubble sort\ninsertion sort and quick sort using\nthese empty cells that are given here\nright now at this point in the course\nyou should start writing code you should\nbe writing maybe solving one problem\nevery day to really practice the\nconcepts and internalize\nthem and while you're doing that you can\nalso any problem that you work on any\nnotebook that you create you can save\nit to jan. commit and I'll show you also\nhow to create new notebooks so one way\nto create new notebooks is to go to\nJovian jan. a click the new button and\nclick blank notebook and you can give it\na title let's say you are doing quick\nsort\ngeneric and you can set a privacy and\ncreate a notebook and that creates a\nnotebook for you and then you can click\nthe Run button and run it so that's one\nway to do it another way you can do\nit is we've given you a problem solving\ntemplate so if you come back to the\nlesson page you will find a problem\nsolving template here now you can click\non the problem solving template and\nclick duplicate to create a copy of this\nnotebook in your profile\nso let's do\nthat and now this is on your profile so\nyou can now click run and then run it on\nbinder or you can even run it locally on\nyour\ncomputer and make some changes to it and\ncome back and run jan. commit and you\nwill end up with\na link that you can share so now you can\nnow go on Twitter and you can just share\nthis link so write out a\ntweet and uh tag us and also use the #\n60 days of\npython okay and maybe say this is your\nquick\nsort\nalgorithm for generic\nobjects and tweet it out and we will\nretweet your Tweet so we want to support\neverybody who's taking part in this\ncourse on the course page you will find\na link to the course Community Forum\nwhich is where you can go and ask\nquestions where if you have questions\nabout any of these these and you can\neven discuss some of the ideas that are\ndiscussed here some of the exercises\nthat are shared so you can go\ninto lesson three for instance and\ncreate a new topic maybe you want to\ntalk about the generic implementation of\nquick sort so maybe you can create a new\ntopic and post a query there if you're\nnot able to make it work post your\nnotebook there and ask a question have a\ndiscussion and if you are helping other\npeople out if you are answering other\npeople's questions and you've written\nsome really great posts there are links\nto some more problems that have been\nshared here so you can check out these\nlinks on each of these links you can try\nout problems you can make submissions\nyou can solve these problems some of\nthese are interview questions as well\nyou can check if your results are\ncorrect and you can use this solving\nproblem solving template as a starting\npoint as we've just\nshared so there is a starter notebook\nwith each assignment and in the\nassignment all you need to do is run the\nnotebook so you can run it on binder for\ninstance and then there is a question\nmark in a bunch of places you will find\nlike question marks here in the text and\nyou will find question\nmarks here in the code so you simply\nneed to put in your code your answers\ninto the question marks so replace that\nwith your code you can see here there\nare some question marks here so you\nreplace that and step by step there\nthere are instructions to guide you\nthere is there are comments to guide you\nso step by step you can solve it and\nthen finally you can also make a\nsubmission so right at the very end when\nyou run the code you will also be able\nto submit directly and when you make a\nsubmission then the assignment will get\nautomated will get evaluated in an\nautomated fashion instantly and you will\nget a pass or a fail grade now if you\nget a pass grade that's great but if you\nget a fail grade then you will also get\nsome comments about what went wrong in\nyour\nsolution so you can use those comments\nto fix the issues so it's a great way to\nget quick feedback and keep fixing your\nissues uh especially watch out for edge\ncases so that's assignment one and then\nassignment two is called hash tables and\npython dictionaries a very interesting\nassignment where you are going to\nimplement hash tables which power python\ndictionaries from scratch in Python and\nyou will also replicate the interface of\npython dictionaries so do check it out a\nvery interesting\nassignment again very similar\nformat you will will find question marks\nin certain places you need to replace\nthem with appropriate values expressions\nor\nstatements and in this way by working\nthrough each of these step by step you\ncan see here by working through each of\nthese you will Implement hash functions\nand hash tables which again are very\ncommonly asked in interviews as well so\nthis is an important assignment for from\nan interview preparation or coding\nassessment preparation as well and it\nalso teaches you a lot of really good\npractices in Python Programming in\nparticular so do check out assignment 2\nas well and we will send you an email as\nsoon as assignment 3 is ready but you\ncan check back in a couple of days and\nyou should see it on the same page\npython\nds.com so what you do next review the\nlecture video and execute the Jupiter\nnotebook use the interactive nature of\nJupiter to experiment with the\ncode complete the assignment and attempt\nthe optional questions as well so each\nassignment has some required questions\nand you can make a submission as soon as\nyou're done with the required questions\nbut there are some optional questions\nwhich are slightly harder but I highly\nrecommend doing that because they will\nimprove your understanding give you more\npractice help you internalize the\nconcepts better and then participate in\nForum\ndiscussions and join or start a study\ngroup so this is a great way to learn\nget together with some friends maybe\nwatch the lecture together over a zoom\ncall pause the video have discussions\nwherever you have doubts discussion is a\ngreat way to solve the specific doubts\nthat you may have and it will also help\nyou to articulate your understanding\nbetter because you when you explain to\nothers you also answer a lot of your own\nquestions so please do\nthat this is data structures and\nalgorithms in\nPython thank you and good day or good\nnight hello and welcome to data\nstructures and algorithms in Python this\nis a live online certification course\nbeing organized\nby\nJovian today we are on Lesson Four\nrecursion memorization and dynamic\nprogramming my name is Akash and I'm\nyour instructor you can find me on\nTwitter on @ Akash\nNES if you follow along with this course\nand complete the weekly\nassignments you can also earn a\ncertificate of\naccomplishment which you can add to your\nLinkedIn profile and you will find\nhosted on your Jovian profile as\nwell so let's get\nstarted now to the data structures and\nalgorithms course this is python\ndsa.msc 1 and two today we are on Lesson\nFour so let's open up lesson 4 the topic\nis recursion and dynamic\nprogramming now you can find a recording\nof the lesson here and you can also\nwatch a version in Hindi if you would\nprefer that in this lecture we will\ncover recursion memorization and dynamic\nprogramming by looking at two common\nproblems in dynamic programming the\nlongest common subsequence problem and\nthen the napsack\nproblem and we'll do this by coding\nthese problems live using the problem\nsolving template that we\nhave been using one in one way or\nanother since lesson one so let's open\nup the problem solving\ntemplate this is a template that you can\nuse to solve any coding problem and we\nwill illustrate this by solving two\nproblems using this template\ntoday so the first thing we need to do\nis to run this template you can see that\nthere is some explanation and then there\nis some code here as well now to run\nthis code you have two options you can\nrun it using free online resources or\nyou can run it on your\ncomputer the simplest way to run it is\nclick the Run button here and select run\non\nbinder and with just one click this\nwill set up a machine on the cloud for\nyou start a Jupiter notebook\nserver and you will be able to\nthen execute the code and modify the\nnotebook and save a version of it to\nyour own profile so that you can\ncontinue working on it so there we have\nit now we have a running Jupiter Hub\nserver I'm just going to zoom in here a\nbit so that you can see things\nclearly okay so this is the problem\nsolving template and I said we're\nworking on two problems so I have some\nproblem statements listed out here you\ncan see the first problem longest common\nsub subsequence is listed here\nand this is a part of the lesson\nnotebook lesson page as well so you will\nfind link to this problem statement on\nthe lesson page two so let's first\nmodify the title of this notebook\nproblem solving template let's change\nthis title\nto dynamic\nprogramming longest\ncommon\nsubsequence let's get rid of this I\ndon't think we need\nthis then uh I'm going to keep the\nsection on how to run your code so that\nif I share this notebook with somebody\nelse they have a way to run\nit and then before we start the\nassignment or the problem let's just\nsave this to our own profile so I'm just\ngoing to give it a\nname longest\ncommon subsequence\nthis is an appropriate name for it so\nI'm going to give this a project name\ninstall the Jovian python\nlibrary and just run jan. commit now\nwhat this will do is we started out with\na template and now we are editing the\ntemplate by running jan.com we've saved\na copy of the template to our own\nprofile you can see this is the link\nwhere you will be able to access this\nnotebook and you can run it and continue\nyour work if this jupyter notebook shuts\ndown if you want to continue tomorrow\nfor\ninstance okay so now let's look at the\nproblem\nstatement now I'll just copy over the\nproblem statement here as well so that\nwe can see it directly within the\nnotebook there we have\nit now you can paste the problem\nstatement and if you are getting this\nproblem statement from some other source\nthen it's always a good idea to include\nthe link to the original source as well\nokay now we have a problem statement in\nfront of us so the question is write a\nfunction to find the length of the\nlongest common subsequence so that's a\nnew term we'll unpack that between two\nsequences now let's first learn what we\nmean by a sequence now a sequence is a\ngroup of items with a deterministic\nordering for instance a list a tuple a\nrange or even a string these are some\ncommon sequence types and P\nso here I have the string serendipitous\nthis is a group of items and this also\ncontains an order you can see that e\ncomes after S and R comes after e and so\non so this is a sequence a list would\nalso be a sequence so that would be a\nlist of numbers so that's a sequence\nthen we're looking at subsequence what\nis the subsequence now a subsequence is\na sequence that is obtained by deleting\nor removing zero or more elements from\nanother sequence for instance if you\nlook at serend Deus and if we remove the\ncharacters s r e n\ni i o us s then you will be left with\nedpt so edpt is a subsequence of\nserendipitous now two things to note\nhere edpt does not have to occur\ncontinuously so these elements can occur\nanywhere within sequence but the order\nshould be the same so edpt occur in this\nparticular order here and edpt should\noccur in the same model here so D should\noccur after e and P should occur after d\nand T should occur after P so those are\nthe two requirements for edpt to be a\nsubsequence of serendipitous and\nVisually speaking what we can see is if\nyou take a sequence and then you draw\nboxes around some of these characters or\nsome of these elements of the sequence\nand if you just take the elements in the\nboxes then in the same order then you\nend up with a\nsubsequence so now we understand what a\nsequence is and subsequence is and once\nagain if this is this question is asked\nin an interview and you're not sure what\nyou mean by a longest common subsequence\nthen or even what a sequence is then you\nshould ask the interviewer what do you\nmean by a subsequence or what do you\nmean by a sequence and they'll be more\nthan happy to tell you it's very\nimportant to\ncommunicate whatever you're thinking\nwhatever questions you have contrary to\nwhat you might think asking questions is\nactually a good thing the more questions\nyou ask the more it is appreciated\nokay so now we've talked about a\nsequence and a subsequence now what's a\ncommon subsequence so look at these two\nstrings serendipitous and precipitation\nnow if we pick just these elements that\nare in the boxes r e i p i t\no now you can see that REI p is a\nsubsequence of\nserendipitous and re e i p i t o is also\na subsequence of\nprecipitation so a sub sub sequence a\nwhich is common which is a subsequence\nof both sequences is called a common\nsubsequence so re p is a common\nsubsequence between serendipitous and\nprecipitation now you can have many\ncommon subsequences for instance we\ncould just look at re and re here and re\nwould be a common subsequence too or you\ncould just look\nat it and it and that would be a common\nsubsequence as well\nor we've not picked n here but you could\nalso pick re n and re n and that would\nalso be a common subsequence between the\ntwo now the longest common subsequence\nas the name suggests is the subsequence\nwhich between the the common subsequence\nbetween the two sequences which has the\nmaximum possible length and you can\nverify this you can try different\nsubsequences and see that REI p t is the\nlongest common subsequence between these\ntwo strings\nthese two\nsequences and its length is\nseven 1 2 3 4 5 6 7 so you have to write\na function to find the length of the\nlongest common subsequence between two\nsequences so that's a question and this\nis an visual example that tells you the\nanswer okay so now that we have the\nquestion we've understood the\nquestion we can start applying the\nmethod that we have been learning\nthroughout so this is the systematic\nstrategy that we will apply and nothing\nabout this method has changed since the\nfirst lesson even though we've covered a\nwhole variety of topics like binary\nsearch and binary search trees and then\nsorting algorithms and divide and\nconquer this method has remained the\nsame the first step is to State the\nproblem clearly and identify the input\nand output formats then the second step\nis to come up with some example inputs\nand outputs and these will be used to\ntest our Solutions so we should try and\ncover all the edge cases and that will\nhelp us write code that is correct\nanticipating all the errors that we\nmight\nface then we come up with a correct\nsolution to the problem and stated in\nplain\nEnglish very important for you to State\nthe problem in plain English before you\nstart coding so that you communicate\nyour ideas and you also make it clear\nonce you express yourself then you\nimplement the solution and test it using\nexample inputs and you fix bugs if you\nfind any of them and you will be able to\nfind bugs if you have written good test\ncases then you analyze the algorithm's\ncomplexity and identify in efficiencies\nif you have any and most likely the\nfirst solution that you come up with it\ndoesn't have to be optimal it just has\nto be correct so there will be some\ninefficiency but it's important to go\nthrough that process of first finding a\nBrute Force solution and then finding\nthe inefficiency and then apply the\nright technique to overcome the\ninefficiency and repeat steps to 3 to\nsix so you identif what's the right\ntechnique and in this case we will learn\na couple of techniques called\nmemorization and dynamic programming and\nthen we go back and state the correct\nsolution again then we implement the\nsolution and test it and then we analyze\nit again and if there's further scope\nfor improvement we do that otherwise we\nsay that we've arrived at a optimal or\ngood enough optimal enough\nsolution okay I hope by this point this\nyou've started to memorize this process\nand that's why we keep repeating it over\nand over that it should become second\nnature every time you see a problem so\nthe first thing is to State the problem\nclearly and to identify the input and\noutput formats now the problem is\nalready stated clearly enough but let's\njust state it slightly more clearly so\nlet's\nsay we are given and just write it in\nyour own words that's more important\nwhat whatever is clear to you so we are\ngiven two\nsequences and we need to\nfind the length of the\nlongest\ncommon subsequence between\nthem simple enough then we have two\ninputs now we decide the input and\noutput\nformats we have sequence\none a\nsequence\nexample\nserendipitous sequence\n2 another\nsequence example\nprecipitation great and this these are\nthe only two inputs that we require and\nthe output would be\nthe length of the longest common\nsubsequence let's just abbreviate that\nas LCS\nwhich in this case is\ns and we know what that subsequence\nlooks like we've just seen it\nabove so now based on this we can now\ncreate and you can see the problem is\nnow created um and before I talk about\nthe next thing you if you double click\non a texell you can start editing it and\nhere we using a language called markdown\nso you can see this creates a block\nquote this creates a bold font and this\ncreates a Cod like font so let's see\nhere know and the way to go back into\nthe display mode is to press shift plus\nenter so now you can see here that now\nwe have the problem we have the block\ncode and then we have all the styling so\nmarkdown is a really useful and easy to\nlearn language for formatting your text\nespecially in jupyter notebooks so do\nlearn it but now based on this we can\nnow create a signature of our function\nso our function Len LCS will accept a\nsequence sequence one and sequence 2 and\nit will return something okay so that's\nthe basic signature of our function and\neven though it's not doing much just\nestablishing what the arguments are is\nthe first step towards solving a\nproblem and let's just save our work\nfrom time to time it's very important to\nkeep saving your work on Jovian because\nthis is running on a free online service\nso this will shut down after some\nminutes of inactivity so just run\njan.com it and that will save the\nnotebook to your profile and you can\nrerun it okay so now the next step is to\ncome up with some example inputs and\noutputs and here we need to try and\ncover all the edge\ncases so I have written out a few test\ncases here\nalready now the most common case is a\ngeneral case of a string like we had\nserendipitous and precipitation that's a\ncommon case there is one of them both of\nthem have have some common elements and\nthere's a subsequence common subsequence\nof length 7 but we may also want to test\nout another type of data and this is one\nof the nice things about python where\nyou can write functions that operate not\njust on a particular class and its sub\nclasses but on any kind of data as long\nas it satisfies certain criteria for\ninstance strings and list both allow\nindexing into them and picking out the I\nelement or the nth element from the\nsequence so they're both sequences so\nour function should be able to work with\nboth strings and with lists\nthen here is another case where we have\ntwo sequences and they have no common\nsubsequence a function should not throw\nan error here it should gracefully\nreturn the number zero because the empty\nsequence is a subsequence of every other\nsequence does that make sense think\nabout it so in that case if you if\nthere's no common subsequence then the\nempty sequence is a common subsequence\nso the answer is zero then here's one\nOther Extreme case where one is a\nsubsequence of the other here's another\ncase where one sequence is empty there's\nanother case where both sequences are\nempty so all of these are important\notherwise you might miss out certain\nspecial cases and you will face an error\nwhen you code Your solution finally you\nyou can also have this case where you\nhave multiple subsequences with the same\nlength for instance if you have a b c d\nEF and b a d CF e and a c e a c e is one\nlong subsequence of length three and\nthat's the longest you can verify and\nBDF is another subsequence which is\ncommon to the two and also has the same\nlength those are some test cases now\nlet's copy over these test cases here in\nan interview or a coding assessment what\nyou might want to do is just write these\nas comments if you have just a single\ncoding screen and try to list at least\nfour or five if but go as far as you can\nbecause this will also help you\nstreamline your own solution and it's\nalways something that is a appreciated\nby\ninterviewers let's do that let's\nget let's copy over these test cases\nhere and you can think of more\nso if you have some more ideas of things\nyou should test come up with them\nthere's no right number of\ntests whatever it takes for you to feel\nconfident is what you need to\ndo okay so now what we've done is we've\ntaken these test cases and converted\nthem into dictionaries so you can see\nhere we have this first sequence\nsequence one and remember that's why\nwe've written out that's why we've\nwritten out here the names of the inputs\nand the signature of the function now we\ncan create test cases as dictionary so\nthat we can test them all easily all at\nonce so we have the sequence one and\nsequence 2 in the input subd dictionary\ninside the main test case dictionary and\nthen we have the output which is the the\noutput of the function which should be\nseven and this you can verify so this is\na general case then we have another case\nin this case we have uh two sequences\nthese are both lists of numbers and in\nthis case the output that we expect is\nfive and we have another General case\nlongest and stone in this case you can\nverify that o n e is the common\nsubsequence it has the output three then\nhere we have two sequences which do not\nhave any common elements all these come\nfrom the left half of the keyboard all\nthese come from the right half of the\nkeyboard so that was a quick way to\ngenerate these two\nsequences then here we\nhave dense and condensed and you can see\nthat dense is actually a piece inside\ncondensed so this is a special case\nwhere dense is a continuous substring of\nthe string uh but it even if you had d\ns that would still be a subsequence\nbecause de occur in this order so that's\none example and in this case the\nsequence one is itself the longest\ncommon subsequence and it has length\nfive then we have this case where one of\nthe sequences is empty you can see in\nthat case the output should be zero and\nboth sequences are empty and here is the\ncase where you can have multiple longest\ncommon subsequences and even in this\ncase your function should be able to\nfigure out the answer correctly so let's\ntake this and let us copy over these\ntest cases here so we have\nt0 to t7 so that's eight test\ncases and you can add more test cases\nhere please feel\nfree coming up with good test cases is a\nskill that you should develop and what\nwe'll do is we'll also put all these\ntest\ncases into this function called LCS or\nlongest common subsequent tests\nso that we have all of them easily\navailable for testing at\nonce\nokay okay now next step is to come up\nwith a correct solution for the problem\nnow we've seen the problem we have\nidentified some\nscenarios now we need to come up with a\nsimple correct solution is stated in\nplain English it doesn't have to be\nefficient it just has to be correct so\nhere's one\nidea here's one idea here you can see we\nhave a couple of\nsequences let's create two counters idx1\nand idx 2 both starting at zero so idx1\nwill be a pointer which will start\ntracking elements on in the first\nsequence and ID X2 will be a pointer\nwhich will start tracking elements in\nthe second\nsequence and what we'll do is we will\nwrite a recursive function so we'll\nwrite a recursive function which will\ncompute the LCS of sequence one from idx\nto the idx1 to the end and sequence 2\nfrom ID X2 to the end so what does that\nmean uh let's say idx1 has the value\nthree and idx 2 has the value 1 so you\ncan see 0 1 2 3 so sequence one idx1\nonwards is L OG Y and sequence 2 idx uh\nidx 2 onwards is L CH m e m y so we are\nlooking at this portion of the problem\nand this portion of the problem and a\nrecursive function when invoked with\nidx1 and ID X2 should\nreturn the length of the longest common\nsubsequence between these two portions\nso L OG Y and lcem Y now why are we\ndoing this we need the longest common\nsubsequence for the entire string don't\nwe now here's the logic why why we\nwriting this recursive function which\ncan theoretically compute this\nsubsequence for from any position\nonwards so here's how we do\nthis if sequence one of idx1 so if idx1\nwas pointing to L and ID X2 was pointing\nto L here as well if sequence one of\nidx1 and sequence 2 of ID X2 are equal\nthen this character L belongs to the LCS\nof this portion and this portion okay\nwhy think about it it makes sense\nbecause these uh these elements are\nequal so if you pick the longest common\nsubsequence of this and you pick the\nlongest common subsequence of the\nremaining then you can always add L to\nboth to that subsequence and that will\nmake the subsequence longer right and\nthat way it follows that L will always\noccur in the longest common subsequence\nbetween l or G Y and lch EM\ny\nokay so we know now that this will occur\nL will occur in the longest common\nsubsequence further the length of this\nlongest the length of this uh longest\ncommon subsequence will be the length of\nthe longest common subsequence between\nogy and chem y + 1 okay and now you can\nsee why recursion is required because\nwhat we can now do is we can say that if\nsequence one of idx1 and sequence 2 of\nID X2 are equal then we simply call the\nrecursive function on sequence one of\nidx1 + 1 so OG Y and sequence 2 of ID X2\n+ 1 CH em Y and assume that recursion\nwill give us the solution there and\nsimply add one to it because this is\nequal okay so that's one case if\nsequence one of idx1 and sequence one of\nid2 are equal\ngreat but if they are not equal I so for\nin this case for instance you can see\nthat if idx1 and ID X2 are both zero so\nidx1 points to a and idx 2 points to B\nso if they are not equal then one of the\ntwo things should\nhold either a does not occur in the\nlongest common sub\nsequence between the two strings or B\ndoes not occur in the longest common\nsubsequence between the two strings now\nwe don't know which one but that's the\npower of recursion that we can just try\nboth so we can simply ignore a and we\ncan get the longest common subsequence\nbetween bent and B EST and check its\nlength and then we or we can simply\nignore B and we can get the longest\ncommon subsequence between a n t and EST\nEST and check the length now whichever\nis longer in length that becomes the\nsolution for the two strings\nokay so this is what it looks like we\nstart out with analogy and Alchemy We\ncompare a and a these two are equal so\nwe know that the longest common\nsubsequence is one the length is 1 plus\nLCS of analogy and lemi okay now we\ncompare n and L and now we see that they\nare not equal so either n does not come\nin the longest common subsequence or L\ndoes not come in the longest common\nsubsequence so we try both we remove n\nhere you see a l OG g y and we remove l\nhere we see CH\nEmy now once again A and L are unequal\nso either a does not occur in the LCS of\nthese two strings or L does not occur in\nthe LCS of these two strings so if a\ndoesn't occur in the LCS we can remove a\nand try again if L does not occur in the\nLCS we can remove L and try again and\nhere once again we get a\nmatch so in this case we know that L\noccurs in the longest common subsequence\nof these two elements\nso now we can get the LCS of ogy and\nchemy okay and then you know as these\nrecursive calls complete you can see\nthat this entire tree pans out you can\nsee that each time you either get one\nchild or you get two children and if you\ngo all the way down and then you go back\nup and simply count the number of\nmatches for each path you will keep and\nyou take keep taking the maximum so here\nyou get back an answer let's say you get\nback an answer of size two here you get\nback an answer of size one so the answer\nfor this is simply the maximum of 2 and\n1 which is two and then the answer for\nthis is simply the maximum of two and\nlet's say if this is three then three\nand the answer for this is simply 1 + 3\n4 okay so this is the way that we will\nbuild up the\nsolution so we've now looked at the\nrecursive solution\nexpressed in text and we've looked at\nthe recursive solution expressed as a\ntree now it's possible that it still may\nnot make sense to you how exactly this\nis working and that is where you should\nstart trying to create this tree\nyourself so pick up a pen and paper and\nthen start drawing on pen and paper take\nan example and try to read each step\nhere and try to work it out like a\ncomputer okay and just thinking about it\nthat way will help you understand this\nalgorithm now one last thing is that if\neither of the sequence one from idx\nonwards or sequence two from idx onwards\nis empty which means the index has\nreached the end point\nin after doing some recursion then their\nLCS is empty so the length is zero okay\nso that is the recursive solution here I\nwill just copy over this recursive\nsolution too along with the entire\ntree now obviously in an interview you\ndo not need to write all of this in um\nin a lot of detail or you do not need\nto so it to show a diagram sometimes but\nyou don't really need to do all of this\nall you need to do is Express Yourself\nclearly that we will create two counters\nand uh the condition to check is whether\nthese two elements at those counter\npositions are equal what do we do if\nthey are equal what do we do if they are\ninequal and why are we using recursion\nhere so we using recursion we can\nbecause we can use reuse some of the sub\nproblems to compute the final\nproblem okay and understanding recursion\nis really important for solving data\nstructures and algorithms problem is\nbecause it's like a super power pretty\nmuch pretty much every problem that you\nsee one way or another\ncan does boil down to recursion in one\nway okay so now let's save our work once\nagain and now we're ready to implement\nthe solution so we have the recursive\nsolution in front of us and if you\nremember the four steps let's go let's\ngo ahead and implement it so we see\nlet's just call it LCS recursive\nand this will accept a sequence one and\na sequence\n2 and let's also\ninitialize idx1 and ID X2 because we\nwill be calling this function\nrecursively so we'll\nsimply use these two counters idx1 and\nID X2 and set them to\nzero now the first thing we need is if\nidx1 is equal to the length of sequence\n1 or ID X2 is equal to the length of\nsequence\n2 then we return\nzero again this is a common thing that\nhappens that the base case or the end\nscenario is something when you're\ndescribing the algorithm you will\ndescribe at the very end as you're\ndrawing the tree you will notice what\nthe end case end scenario is but when\nyou're coding the algorithm the end\nscenario or the base case comes at the\nvery top because otherwise we'll try and\naccess idx1 from sequence one and that\nwill throw an error so that's why you\nneed to handle the base case at the very\nbeginning okay next moving\nahead if sequence one of\nidx1\nequals sequence 2 of ID\nX2 great we found a match so we simply\nreturn\n1+ now we can call LCS\nrecursive on sequence one 2 and we\nincrement idx 1 by\n1 and we also increment idx 2 by one\nboth of these need to be\nincremented\nbecause we are going to use this element\nthis common element as an element in the\nsubsequence okay so there's just one\nrecursive call here that was nice\notherwise we have to either ignore the\nfirst element of or the current element\nfrom sequence one or the current element\nfrom sequence 2 so we have two options\nso we have option one which is we ignore\nthe current element of sequence one so\nthis becomes LCS recursive sequence 1\nsequence\n2\nidx1 +\n1 and ID\nX2 and then we have option\ntwo this\nis LCS recursive\nonce again with sequence one and\nsequence 2 and this time we increment ID\nX2 okay so make sure you understand this\npiece because this is really the key\nhere and then the length of the longest\ncommon subsequence is simply the maximum\nof option one and option two okay and\nthat's it what may have seemed like a\nfairly tricky problem once you start\nthinking about it recursively okay\nwhat happens if we simply compare the\nfirst two and they are equal and they're\nunequal okay now we need to solve the\nproblem for the remaining um either we\nadd one or we take or we ignore one of\nthe elements right once you get that\nthought the recursive thought then the\nsolution and the code simply presents\nitself to you it's just about seven\nlines of code okay that's our LCS\nrecursive solution now let's test it out\nlet's look at a test case t0\nokay so here we have serendipitous and\nprecipitation as the inputs let's call\nLCS let's keep that around so that we\ncan view it\nlater let's C call LCS\nrecursive\non\nt0 but of course we need to fetch from\nt0 the input and uh get sequence one out\nof the input\nand similarly we need to get the input\nand get sequence 2 out of the\ninput you can see it it takes it Returns\nthe value 7 which is equal to the output\nby the way so if we simply check put in\nhere\nt0\noutput and I'm also going to put in this\nspecial command called percentage\npercentage time this is going to tell us\nhow long the cell takes to\nexecute yeah so now you can see here\nthat if we get back true and the cell\ntakes 495 seconds or half a second to\nexecute and that's it so now we have\ntested this test case one small thing I\ncan tell you how to improve this\nslightly is\nbecause in t0 of input is a dictionary\nand because the names of the elements of\nthe dictionary are sequence one and\nsequence 2 which also match the argument\nnames of LCS recursive you can see here\nwe have sequence one and sequence 2 what\nyou can do is you can simply say star\nstar t0\ninput and python will automatically grab\nthe each key so sequence one will be\npassed as the argument sequence one and\nsequence 2 will be passed as the\nargument sequence\n2 that's this is a small trick here that\nhelps us speed up the reduce the amount\nof code we need to write okay now we've\ntested one test case but that's not\nenough we should be testing all the test\ncases so to test all the cases we can\nwrite a for Loop for T in tests\nEtc but we can do something else too we\ncan use the\nevaluate test cases function from Jovian\nso from jan. python DSA the module we\nwill import evaluate test cases it's a\nhelper function that we created for you\nbut it's really simple to write you can\njust use a for loop as well and we call\nevaluate test\ncases on the function that we want to\ntest which is LCS\nrecursive and the test that we have\nwhich is LCS tests and when we do this\nit is going to try out each test case\nyou can see it tried test case Zero that\nwas a pass it tried test case one and\nit's also printing out the input the\nexpected output and the actual output\nthe test case one was\nlists and lists work too because all we\nhave used here is indexing and length\nand these are both things that are\navailable in both strings and lists and\nthis is something that's very nice about\npython the dynamic nature of the\nfunctions uh once again this worked\nperfectly fine then here we have another\none longest in stone the expected output\nwas three and the actual output was\nthree as well here we have ads f e w a\nand another string they have nothing in\ncommon so the expect expected and actual\noutput are both zero here's one where\none is\nthe is already a subsequence of another\nso the smaller one becomes the longest\ncommon subsequence and then we have an\nempty string and then we have two empty\nstrings and finally we have multiple\nlongest common subsequences we still get\nback the right output now if any of\nthese failed you would know exactly what\nwent wrong for instance if you had an\nissue in this case where the two of\nthese were empty then that would tell\nyou that you've probably not handled\nthat empty case properly and that is why\nhaving great test cases is very\nimportant okay and we can see the\ntimings for these as well each of these\ntook about uh well 480 milliseconds was\nthe highest now that's still a bit high\nI would say 480 milliseconds because we\nare just looking at sequences\nserendipitous and precipitation which\nare of very short length if you're\nlooking at a really long sequence for\ninstance this technique is used for DNA\nsequencing and we were looking at two\nDNA strand\nor two D two DNA strings and trying to\nget the common subsequence out of them\nand these can go into thousands or\nsometimes millions of elements that\nwould make it rather\nslow okay so we do want to improve this\nalgorithm\nfurther so let's do that and before that\nwe can just commit our work once again\nuh but the first thing before we improve\nthe algorithm is to analyze its\ncomplexity how long does it really take\nokay and identify any inefficient\nefficiencies now to analyze the\ncomplexity let's look at an example and\nlet's consider the worst case now when\ndoes the worst case occur here we've\nseen that if two elements match then we\nsimply have one sub problem or one\nrecursive call but if the two elements\nor two elements of the sequences don't\nmatch then we have two recursive\ncalls so if you have two completely\ndistinct\nsequences where none of the sequences\nnone of the elements match\nthen each time we will end up with two\nsub problems so that becomes the worst\ncase so the worst case occurs each time\nwe have two sub problems where the\nsequences have no common elements and\nhere's an example this is a sequence of\nlength six here's an sequence of length\n8 and this is what the tree will look\nlike so now we have no longer put the\nactual sequences we've simply put what\nis the length of the string that we\nstart out with so here we start out with\nstrings of length 6 and 8 and then we\nsay that we either ignore the first\ncharacter of the first string or the\nfirst sequence or we ignore the first\nelement of the second sequence and that\ngives us two sub problems and this time\nthis the sequences have length 5 and 8\nin this case and six and seven in this\ncase okay so we either reduce one from\nthe left or we reduce one from the right\nand once again here we either reduce one\nfrom the left or we reduce one from the\nright so this way we create a tree and\nyou can also see that a lot of common\ntrees get created and that really is\nwhat is the inefficiency and we'll talk\nabout that but what will happen here is\n57 will then call 47 and 56 and 57 here\nwill once again call 47 and 56 and 47\nand 47 will get repeated here and 56 and\n56 will get repeated three times here so\nthere's a lot of repeated calls that are\ngoing to occur and you can even see this\nhere at the top you can see that a l OG\ny the problem was called repeatedly um\nso that's really a source of\ninefficiency\nbut now the question becomes that we\nknow that all the leaf nodes will end at\n0 0 that's when the entire tree ends so\ncan you count the number of leaf nodes\nokay can you count the if you keep\nexpanding this tree completely expand\neach of these don't skip any of them can\nyou count the number of leaf nodes now\nif you count the number of Lea nodes we\nknow that in a binary\ntree the number of leaf nodes if the\nnumber of leaf nodes is L um then the\nheight of the tree\nis if the number of leaf nodes is n then\nheight of tre is log n and based on that\nwe can actually determine the actual\nsize of the tree as\nwell so we\nknow that to count the number of unique\npaths from root to Leaf will give us the\nnumber of leaves right so each time we\nhave two choices we either reduce from\nthe left or we reduce from the right so\nto get to 0 0 we would have to reduce\nall the elements from the left and we\nwould have to reduce all the elements\nfrom the right that means if you have\nstrings or if you have strings of length\nor sequences of length M and N then you\nwould have to make m+ n choices in total\nright and you so each time you have M\nyou have to make M plus n choices and\neach time you have to choose whether you\nwant to reduce from the left or from the\nright you have two choices and you have\nto make those two choices m + n times\nthat's the right way to put it really so\nthat means each time you comp you do two\nchoices so you have 2 * by 2 ultied by 2\nultied by 2 and you keep multiplying\nthat and you will end up with 2 ^ of m +\nn Leaf nodes okay so here is an exercise\nfor you draw this tree on a piece of\npaper Mark out how the number of leaf\nnodes how the length of each part is M\nplus n figure that out and based on that\ncan you conclude that it takes 2 the^ of\nm + n\nleaves to complete this tree and if 2\nThe Power M of M plus n is the number of\nleaves then the total number of elements\nis the in the tree simply double of that\nonce again this is something that is\nvery easy to verify you can check it\nhere for instance if you just consider\nthese two\nlevels the if you have two leaves then\nthe total number of elements in the tree\nis 2 + 1 3 actually it's double minus 1\nso 2 into 2 4 - 1 3 if you have three\nlevels you can see here that if you have\nfour leaves and the total number of\nelements in the tree is 4 into 2 8 - 1 7\nand you can see that here so it follows\nessentially that we have an exponential\nnumber of sub problems we are we are\ncalling the recursive function an\nexponential number of times and inside\nthe recursive function we are\ndoing inside the recursive function we\nare doing a constant time work so you\ncan see here that there's no there's no\nspecial work that we're doing all we\ndoing is some comparison and we doing an\naddition both of them are constant time\nso we make 2 the^ of n plus n recursive\ncalls inside each we do constant work so\nthe time complexity is order of 2 ^ of m\n+ n okay it's a rough explanation we've\nnot gone into a lot of depth because\nwe've covered this over and over in\nthree lessons but the exercise for you\nto is to verify how exactly it is 2^ of\nm+ n\nokay so that's our recursive solution\nand we know we now know that the time\ncomplexity is 2 ^ of m + n let's just\ncopy that over here\nand the inefficiency as we said in this\nalgorithm is that we are calling the\nsame problem we're calling the exact\nsame problem the LCS recursive function\nis called with idx equal idx1 = to 5 and\nID X2 equal to 7 and idx1 equal to 5 and\nID X2 equal to 7 the same time uh twice\nso each of these sub problems will be\ncalled twice and then each of the sub\nproblems within them will be called\ntwice and of course some of these sub\nproblems will once again get shared so\nthere's a lot of repetition now there's\na simple solution here which is simply\nto remember some of these results okay\nand this technique is called\nmemorization and you may also just call\nit memorization because you're just\nremembering some of these things but\nmemorization is a technical term for\nit and we remember these Solutions in\nour dictionary called memo so what we\ngoing to do is we going to follow the\nsame recursive strategy but this time we\nare going to maintain a dictionary\ncalled memo and we're going to track\nintermediate results within the\ndictionary and if we find an\nintermediate result already exists in\nthe dictionary then we will not compute\nit again okay so let's see so now we\nwrite LCS memorized or let's just say\nLCS memo for short it takes a sequence\none and it takes a sequence\ntwo and this time we create this\ndictionary called\nmemo and then we write a function inside\nit so we will write a helper function a\nrecursive help function inside the LCS\nmemo function so that it has access to\nsequence one and sequence 2 and we will\nsimply start it out with\nidx1 as zero and ID X2 as Zer as well\nidx1 will track the position in sequence\none ID X2 will track the position in\nsequence\n2 now the first thing we do is create\nusing the two indices create a key so we\nare going to create the key idx1 comma\nID\nX2 and if the key is present in the memo\nso this is the way to check if a key\nexists in a dictionary then we simply\nreturn memo of key simple the problem is\nsolved we don't have to solve this\nproblem because it's already it's\nalready something that we've solved if\nit isn't then we need to solve the\nproblem and save it in the memo now here\nwe know that we can now write our same\nthree recursive cases now if the base\ncase if\nidx1 is equal to the length of sequence\none or ID X2 is is equal to the length\nof sequence\n2 then we simply set memo of\nkey\nas zero because by this point we have\nreached the end of the strings there's\nnothing left for us to\ncompare LF idx sequence\none of\nidx1\nequals sequence 2\nof ID X2 so in this case this is the\ncase where the current characters are\nequal so this is if we go go up here and\nlook at the tree once again this is a\ncase like this where the current\ncharacters that we pointing at are equal\nso in that case we simply return We\nsimply get the result as 1 plus the\nresult for the remaining with the first\ncharacter\nremote so in this case we simply set\nmemo of key\nto\n1+ we call the recursive function again\nrecurse idx1 + 1 and ID X2 + 1 create\nelse so this is the case where the two\nelements are not equal and this is where\nwe have two options so I'm not going to\nwrite the two options separately let's\njust do a Max directly here Max and we\nsay recurse with idx1 + 1 comma ID\nX2 and recurse with idx1 comma ID\nX2 + one okay and finally from the\nrecurse function we return memo of key\nso we have whichever case it is we have\ncomputed the result and saved it in the\nmemo so this\ntime these computations will not get\nrepeated again and\nagain and let us now return recurse of\n0a 0 because 0 comma 0 is the entire\nstring and that's\nit and this is the common strategy that\nyou should\napply whenever you come up with a\nrecursive solution and you see the\ninefficiency coming because of the same\nproblem being called again and again and\nagain this is where you need to apply\nthis technique called memorization right\nand in this technique you will then be\nable to\nsimply store intermediate results so\nit's really simple you just create a\ndictionary and then you add one or two\nlines of code here and you make sure to\nsave the result in that dictionary\nwhenever you compute a result the next\ntime you don't have to compute it okay\nand we can test it out we can test it\nout with all the test\ncases evaluate the test cases so LCS\nmemo and LCS tests\nand you can see that all the test cases\npass now not only do all the test cases\npass you can see that the time taken is\nnow\nlower okay so that's nice the time taken\nis now lower now we went from 450\nmilliseconds if you just go up here you\ncan see that it took 480\nmilliseconds for the for finding the\nlongest common subsequence\nbetween precipitation and serendipitous\nbut in this case it only took about\n234 which is2 millisecond so it is 2,000\ntimes faster even for strings of length\n7 or 8 and that's a huge boost um let's\nanalyze the complexity\nhere let's uh look at the complexity now\na quick and easy way to find the\ncomplexity of the solution is to see\nwhere the computation how many times the\ncomputation can occur now this is where\nthe bulk of the computation is occurring\nin a recursive\ncall and this computation is avoided if\nwe already have something in the memo\nokay so that means that the only number\nof computations that we need to do is\nequal to the maximum number of elements\nthat can end up in the memo now what are\nthe keys in the memo look like the keys\nin the memo look like idx1 and idx\n2 great and what values can these take\nidx1 can\ntake 0 to M values if m is the length of\nsequence one let's say and ID X2 can\ntake 0 to n values if N is a sequence\nlength of sequence 2 so in total the\npossible number of keys is M *\nn the possible number of keys is M * n\nthe possible number of things that you\nneed to store in the memo is M * n and\nfor each of them you do constant work\nand then the next time you try to access\nthis you do not need to do the work you\ndo not need to call any recursion you\ncan simply access the memorization\nright so what that tells us is the\ncomplexity of this case and in any\nmemorization case in general is equal to\nthe number of keys which in this case is\nM * n so the time complexity here is\norder of M * n so we've gone from 2 to\nthe^ of m + n which if you if M plus n\nwas equal to 30 would be 1\nbillion\nto M time order of M * n so let's say\nboth strings were 15 and 15 so that\nwould just be 225 operations so we've\ngone from 1 billion operations\nto 225 operations simply by storing\nintermediate results it's a very\npowerful technique that we apply all the\ntime so now you can see here that the\nfirst time 57 is computed the next time\n57 does not need to be computed again\nand that's why this tree here is\nactually marked out so this is the tree\nfor memorization this the first time 47\nwas computed it never needs to be\ncomputed again so this entire tree of\ncomputation gets eliminated and\nsimilarly this entire tree of\ncomputation gets eliminated we are\neliminating from 1 billion computations\nalmost all except 225 computation so we\nleft with practically nothing and that\nspeeds up your algorithm by a huge huge\nFactor\nso that's\nmemorization and as he said it's really\neasy to compute\nthe time complexity of memorization just\nsimply count the number of keys and then\njust track how much work do you need to\ncompute each key assuming that you\nalready have the recursive solutions for\nthe remaining okay so how much work do\nyou need to compute each key using some\nother existing Solutions now in this\ncase that was constant because all we\nneeded to do was compare and add\nadd okay and I'll let you write here a\nsimple optimized a plain English\nexplanation of memorization it's worth a\nit's a good exercise to try out but what\nwe will also look at is another\ntechnique called dynamic programming now\nthe downside with memorization is that\nit requires recursive calls and while\nit's not a problem for small cases when\nyou have really\nproblems recursion has an overhead and\nthe overhead for recursion if you see it\nthis way is that for this function\nexecution to complete you need this\nfunction execution to complete and this\nto complete and for this to complete you\nneed this to complete and this to\ncomplete right so the idea here is that\nfor each new recursive\ncall takes more space in the memory and\nit also takes longer because now we have\nto allocate some memory and then set up\nthat function stack the function stack\nfor the ex ution of that function so if\nyou have a large tree then you're\ncreating hundreds thousands or possibly\nmillions of open functions all of which\nhave their own memory and that can eat\nup a lot of memory and sometimes that\ncan also take up uh take longer\ntime so the solution to replace\nrecursion is iteration and how do we do\nthat we do that using a technique called\ndynamic programming so we'll do almost\nthe same thing there are a few changes\nhere instead of using a dictionary to\ntrack intermediate results we will\ncreate a matrix because we know\nthat sequence one uh the idx1 can go\nfrom 0o to n where or 0 to N1 let's say\nwhere N1 is the length of sequence one\nand sequence idx 2 can go from 0 to N2\nwhere see N2 is the length of sequence 2\nand what we can do is we can use a for\nLoop or a couple of for Loops to fill\nout all these sub problems without\nhaving to require a recursion okay and\nthis is how we'll do it so let's say\nthese are the two strings that we\nworking with this is string one t a cgt\nand this is string two and these this is\nwhat DNA sequences look like so what\nwe'll do is we will create a table of\nsize n + 1 + 1 and N N1 + 1 and N2 + 1\nso you can see that there are N1 +1 rows\nso if if this is of length N1 these are\nN1 rows and then there's an additional\nrow and similarly there is there are N2\n+ one rows here so if this is of length\nN2 there are there are N2 + one columns\nso you can see these are N2 columns and\nthere is an additional column\nhere and table of I and J so let's say\ntable of uh if I and J are zero so I is\na pointer\nfor the first sequence and J is a\npointer for the second sequence so I\nselects a row and J selects a column so\ntable of I and J represents the longest\ncommon\nsubsequence of sequence one up to I\nwhich means sequence\none so here if let's say I was 1 and uh\nJ was\n1 so this represents the longest\nsubsequence of sequence one up to I so\nall the positions before one which means\nonly the zeroth position just T and\nsequence 2 up to J which means all the\npositions up to the first position or up\nto up to one so which means only the\nzeroth position so which means a okay so\ntable one and table I represents the\nlongest common subsequence\nof these two of just a and t which is\nzero on the other hand if we skip ahead\na little bit if we skip ahead to let's\nsay this position you can count here I\ngoes 0 1 2 3 4 5 6 so this is six\nhere and here we\nhave 0 1 uh 0 1 2 3 so this is so this\nis table of 6A 3 the table of 6A 3 takes\nthe\nfirst six\nelements which is T A\ngtca and the first three elements AG of\nsequence 2 and it stores the result of\nthe longest common subsequence between\nthese two okay so I'll just let you look\nat the table and maybe even draw the\ntable on a piece of paper and verify\nthat the length three is right you can\nsee here AG g a ag G A occurs here so AG\nG is a subsequence of t a g TCA so the\nlongest common subsequence between them\nis\nthree now what we'll do is we will now\ncompare the next elements of we'll now\ncompare sequence one of I and sequence 2\nof J so let's say we are looking\nat let's Pi an example let's say\nsequence let's say I has the value\nI has the value 0 1 2 3 4 I has the\nvalue 0 1 2 I has the value two and\nlet's say J has the value 1 so 0 1 so if\nwe compare sequence one of I so which is\nG and sequence 2\nof sequence 2 of J which is also G and\nif they're equal so if they are\nequal then able of I + 1 or J +1 which\nis this value right so remember I is 2\nand J is\n1 so table one of I + 1 so table one of\n3 is 0 1 2 3 and table uh and table one\nof I + 1 J + 1 is table one\nof 3 and table a table of I + 1 and J +\n1 I being 2 and J being one is table one\nof\nthree and two and table one of three and\ntwo is the value\ntwo so this value is obtained by adding\none to table one of I comma J so because\nthese two elements are\nequal we we can then say that if we take\nthe longest common subsequence of ta and\na and add one to it that will give us\nthe longest common subsequence\nof T A and AG so the exact same logic as\nrecursion we have simply\nnow reversed it so we now now we're\nlooking at the last element so that we\ncan keep filling out the last value\nusing some previous values okay so this\nis one case similarly here's another\ncase where a and a are equal so the\nlongest common sub subsequence between t\na gtca and the longest common\nsubsequence between AG G A is 1 plus the\nlongest common subsequence between t a\nGTC and AG okay 1 plus this\nvalue so that's one case the other case\nis if they're not equal so let's look at\nthis value for example over here so we\nhave t a GT on this side and then we\nhave okay let's let's look at this one\nuh we have t a GT on this side and we\nhave AG GAC on this side now T is the\nelement here and C is the element\nhere they are not equal so that means\nthe longest common sub sequence between\nthese two either does not contain t or\nit does not contain C it cannot contain\nboth obviously because one of the\nstrings has to\nend so if it does not contain T then it\nis this result and if it does not\ncontain T if it does not contain C then\nit is this result so we simply take the\nmaximum of these two maximum of these\ntwo to get the result for this if these\ntwo elements are not equal and that is\nhow you fill out the table you start\nfrom the top the first row is zeros\nbecause we we have empty strings and the\nFirst Column is also zeros because we\nhave empty strings to fill out an\nelement you compare if the two elements\nare equal and if they are equal we\nsimply add one to the diagonally left to\ntop left element if they're unequal then\nwe take the maximum of the element above\nit and the element to the left of it and\nthat way we fill out the entire table\nokay so that's the dynamic programming\nsolution and I know this can seem a\nlittle bit complicated uh honestly I\nstill\nget confused with dynamic programming a\nlot of times and that's why I like to\njust draw tables and write things out\ncarefully okay and and especially you\nhave to be specially careful with\nindexes because here we are saying that\nif sequence I 1 I and sequence 2 J are\nequal then table one of I + 1 and J + 1\nis 1 plus table IG so be just watch the\nindices carefully here but let's\nimplement the\nsolution let's implement the dynamic\nprogramming solution so let's\nsay LCS Dynamic program programming so\nwe'll just say DP\nhere and we have sequence one and we\nhave sequence\n2 and the first thing we need is we need\na table of results now this table for it\nlet's just grab N1 and N2 so length of\nsequence\none and length of sequence\n2 and now we need to create a table with\nall zeros how do you create a table with\nall zeros a way to do it a way to create\na list of zeros is this 04 underscore in\nlet's say N1 let's give N1 and N2 some\nvalues now if you want to create a list\nof zeros of length N1 you you simply\nsay 0 for underscore or 0 for X You're\nsimply ignoring whatever value you're\ngetting from a range rrange N1 and\nthat's going to give you a list of zeros\nbut we don't want a list of N1 zeros we\nwant these want these want to be rows so\nwe want each of these to itself be a\nlist of zeros of length\nN2 so 0 for X in range\nN2 and now we have you can see that we\nhave five rows 1 2 3 4 5 and we have\nseven columns 1 2 3 4 5 6 7 so this is\nthe table that we want to create\ninitially okay now this is the table\nthat we've created this is going to be\nthis exact same table\ntable and we're simply going to start\neach string from position one this time\nnot from position zero because we want\nto have this additional row where we\ndon't consider either of these that just\nmakes computations a little\neasier now we say for idx1 in Len Ed X1\nin range N1 that's that's going to\niterate over the rows and then for idx\n2 in range\nN2 and that's going to iterate over the\ncolumns and first we\ncompare if sequence\none of idx1 is equal\nto sequence\n2 of ID X2 if they're equal then we can\nfill out table of I +\n1 n j +\n1 as 1 + a of\nIG okay and we can see this we can see\nthis here suppose the first elements\nwere equal so suppose this was suppose\nidx1 was zero and ID X2 was also zero\nsuppose they were equal then this value\nshould be one so this value should be\none plus the diagonally top element and\nthat holds true anywhere within the list\nso wherever you have two elements equal\nlike G and G are equal here so this\nvalue is 1 plus this value\nelse we have\ntable I +\n1 and J +\n1 is Max\nof\ntable I comma J + 1 so you stay in the\nsame\nrow or you you go to the previous row or\nyou go to the previous column which is\ntable\nof I + 1 comma J and this is the\nprevious column okay so this is this\ncase where G and a are not equal so if G\nand a are not equal then we take the\nmaximum of these two\nvalues and that's it that is going to\nfill up the table for us and then we\nsimply say return table we simply want\nthe bottom right element we can simply\nsay return table minus one minus one so\nthis is going to get the last row last\ncolumn\nand that's our dynamic programming\nsolution let's do evaluate test cases\nhere okay it turns out there's no I okay\nlet's just call this I and\nJ turns out idx1 is not defined let's\njust make this IJ now that we're doing\nthis coding live you can see that even\nafter a decade of coding I still make\nall of these\nissues it says the list list index is\nout of range it seems like I + 1 and J +\n1 Ah that's because remember we need an\nadditional row and an additional column\nto track the case where either of the\nstrings is empty so we need to get range\nN2 + 1 here and we need to get range N1\n+ 1 here okay that's why it helps to\nhave test cases so that you can fix all\nof these issues now you have test case\nZero it passes and test case 1 2 3 all\nof them pass you can see that all test\ncases have passed and you can also\nverify that the amount of time it took\nis now lower than the amount of time it\ntook for\nmemorization okay and so that's the\ndynamic programming approach you simply\ncreate a table and you fill out the\ntable sometimes just\nworking with indices within the table\ncan get confusing so it helps to work\nwith it on paper and make it clear to\nyourself and then write it in English\nthat's why we we've written it in plain\nEnglish\nHere and Now an exercise for you is to\nverify that the complexity of this\ndynamic programming approach is order of\nN1 * N2 so which is the same as\nmemorization and it's actually more\nstraightforward to see here because you\nhave two for loops and then each of\nthese for loops\nyou simply doing a comparison and an\naddition and there's not even any\nrecursion to very very there's not even\nany recursion for you to worry worry\nabout so you just do a comparison and\nyou do an addition or you take a maximum\npretty straightforward so order of N1 *\nN2 and it does not\neven invoke another function so it does\nnot take up too much memory it does not\ntake up too much time it's very very\nefficient\nand this is how you solve pretty much\nevery Dynamic Pro dynamic programming\nproblem you write a recursive solution\nyou come up with a Brute Force solution\nand keep in mind that recursion\nis almost always the way to go about\ncreating a Brute Force solution so you\ncome up with a recursive\nsolution and then you identify you draw\nthe recursion tree and if you see that\nthe same sub problem is being called\nagain and again that is a point where\nyou can introduce memorization so you\nintroduce memorization and sometimes you\ncan just write the memoized solution and\nthat's enough because it's easy to\nreason about you just put in a memo and\nyou're done with it um even the\ninterviewer or the coding assessment\nwill accept that solution but in some\ncases you will be asked to then remove\nthe recursion and write it as a in an\niterative fashion and that is when then\nyou have to start drawing a table and\nthink about what are the rows and\ncolumns in that table uh need to\nrepresent so here the i j element of the\ntable represented the first the first I\nelements of sequence one and the first J\nelements of sequence 2 what is the\nlongest subsequence between them and we\nuse that to build the next row and the\nnext\ncolumn and we then filled out the entire\ntable and we simply use the last value\nokay now again this is not very\nstraightforward uh how to come up with\nthis and the way you do that is by\nsolving problem so if you solve 5 to 10\nDynamic Pro programming problems you\nwill get some intuition about how to\nbuild the table\nand it's always very helpful to solve it\non pen and paper first especially with\ndynamic programming so that it's clear\nto\nyou what each element of the table\nrepresents otherwise you may make a lot\nof off by one errors like missing the\nplus one here or missing the plus one\nhere and get confused just like I did\npretty\nmuch and that's the time the time\ncomplexity is pretty straightforward in\nmost cases it is simply the size of the\ntable but sometimes you may have to do\nmore than constant work here so keep\nthat in mind see what it is that you're\ndoing inside your Loop now inside of\ninside your Loop if you have to go back\nand check the entire length of the\nstring so that will introduce another\nfactor into the equation so keep that in\nmind but in most cases counting the\niteration should be good enough to give\nyou an idea of the time\ncomplexity okay so that's the first\nproblem and let us just commit\nthis and now save saved to my profile if\nI just open this up\nhere you can see that now I have this\nnotebook called longest common\nsubsequences and I can share it online\nwhenever you work on a notebook it's\nalways a good idea to make it public put\nit up on Jovian all you need to do is\nrun jan.com and share it online just\npress the share button and then you can\nshare it on Twitter LinkedIn Facebook or\nwherever you\nlike so that's the first problem that we\nlooked at now let's come back to Lesson\nFour\nand uh by the way the problems that we\ntalking about all the problem statements\nthe graphs the images you can see them\nin the second link here but we will once\nagain open up the problem solving\ntemplate and now we'll use it for the\nsecond problem let me run this once\nagain and we're going to look at the\nsecond problem which is the napack\nproblem so let's read the napsack\nproblem it's also called the 01 napsack\nproblem here there's there are many\nvariations of this problem but here's\none way to State it that you might come\nacross or something similar you are in\ncharge of selecting a football or a\nsoccer team from a large pool of\nplayers and each player has a cost and a\nrating so there's a selection going on\nyou have to come up with a team for this\nyear and you have a large pool of\nplayers each player has a cost and each\nplayer has a rating now you have a\nlimited budget so you need to build a\nteam within the budget so what is the\nhighest total rating of a team that you\ncan create which fits within your budget\nokay so this is the question here you\nhave to maximize the total rating but\nfit it fit the total cost within your\nbudget so you have two variables here\nrating and variables rating needs to be\nmaximized Cost needs to be simply\noptimized to the extent that it fits in\nthe budget and just a simplifying\nassumption here is that you can assume\nthat there is no minimum or maximum team\nsize this is simplification and later\nyou can introduce a criteria there as\nwell that you want to build a team of\nexactly 10 people and see if you can\nalso solve that problem in a\nway so that's the napsack problem let's\ncopy it\nover and here's a Jupiter notebook a\nfresh problem solving\ntemplate let's simply change the title\nhere\nand this is also called the 01 napsack\nproblem because each item can either be\nchosen or not\nchosen and let's give it a project name\nhere\ntoo let's commit it and let's paste the\nproblem statement here\nokay so that's a problem statement and\nthis is a specific or a special\nform of a more General problem statement\nand we look at the general problem\nstatement in a second we when we try to\nState the problem clearly but here's\nonce again the systematic strategy we'll\napply we will state the problem clearly\nidentify the input and output formats\ncome up with some example inputs and\noutputs and try to cover all the edge\ncases then we will will come up with a\ncorrect solution for the problem and\nstate the solution in plain English it\njust has to be simple correct solution\nnot too\ncomplex then we apply the right\ntechnique to overcome the inefficiency\nand then we uh so we analyze the\nalgorithm and identify any\ninefficiencies after implementing the\nsolution and finally we apply the right\ntechnique to overcome the inefficiency\nand then repeat the process of stating\nthe solution implementing it and\nanalyzing\nit so to State the problem\nclearly what we can do is we can\nabstract out the problem in more general\nterms and that is what is stated\nhere and let's just grab that and we'll\ntake a\nlook so here we have we are given n\nelements and Each of which has a weight\nand a profit so you have n elements and\nhere's the profit of each element and\nhere's the weight you can of each\nelement so you need to determine the\nmaximum profit that can be obtained by\nselecting a subset of the elements\nweighing no more than a given weight w\nso you have a capacity a maximum\ncapacity let's say the maximum capacity\nis\n15 and you have to select certain\nelements so that you fill\nout the total weight is no more than the\ncapacity and the total profit is\nmaximized that's and this is why it's\ncalled the napsack problem it's assuming\nhere you have a bag or a napsack with a\ncapacity of 15 kg and these are the\nweights of the items and these are the\nprofits now in this case you can see in\nthis example the optimal selection is\nthese four elements which have the\nweights 5 3 2 and 5 so that you fill out\nthe total capacity of 16 or 15 and the\nthe solution or the maximum profit that\nyou can obtain is 7 + 4 11 + 5 16 + 3 19\nnow you can try other combinations and\nverify that this is actually the best\nsolution\ndo give it a\nshot so what are the inputs here so we\nhave it's pretty clear we have an\ninput weights so these are the weights\nof\nthe this is a list of uh numbers\ncontaining\nweights and then you have\nprofits a list of numbers containing\nprofits and this should have the the\nsame length as\nweights and then finally you have a\ncapacity the\nmaximum weight\nallowed and there you go and now we have\noutputs so now the output would simply\nbe the max\nprofit so this is\nthe maximum profit\nthat can be\nobtained by selecting\nelements of total weight no more than W\nor no more than\ncapacity okay great so that gives us\na pretty good starting point now we can\nwrite a function signature here so we\nwrite Max let's say def Max\nprofit and we can give it weights and we\ncan give\nit profits and we can give it a\ncapacity and we\npass so now we have defined the problem\nwe have stated we have identified input\nand output formats now we need to come\nup with some example inputs and test\ncases once again we have listed out a\nfew test cases here so we will have a\nfew generic test\ncases where you have just a random set\nof weights and profits and you identify\nthe napsack the optimal solution then\nhere's one option where all of the\nelements can be included you can take\neverything here's another option where\nnone of the elements can be included you\nhave to think about all these scenarios\nhere's one where only one of the\nelements can be included then you may\nalso think about areas where you do not\nuse the complete capacity\nokay you you do not use the complete\ncapacity because the optimal solution is\nactually taking a lower capacity so\nthere may be a way to fill out to\ncapacity but that may have a lower\nprofit than another option which takes\nless than the complete capacity but has\na higher profit so think about some\ncases here think think about some good\ntest cases here\nand I will just copy over these for\nnow and then what we'll do is we will\nExpress these test cases once again as\ndictionaries you have test zero test one\ntest two all of these Express at\ndictionaries and these are covering all\nthe test cases that I mentioned here you\ncan see here are some weights and some\nprofits and the capacity is 165 and then\nthe optimal solution is 309 now we are\nsimply asking here for the optimal\nsolution the maximum profit that can be\nobtained but an extension of this\nproblem is to identify which are the\nelements that should be chosen and and\nit's a simple extension it's a good\nexercise for you to try out and you can\ndiscuss it in the\nforums we have test zero test one test 2\ntest three and four and five so we have\na total of six six test cases let's copy\nover these test cases\nhere and let's put them here into a\nsingle string and that gives us the test\ncases okay now coming up with the\nsolution so once again the first step is\nto try and come up with a recursive\nsolution and a recursive solution is\nagain quite straightforward we'll write\na recursive function Max profit that\ngiven an index so this time we have just\none sequence so given an index within\nthe sequence so let's say you have an\nindex\nidx it computes the maximum profit that\ncan be obtained using the elements from\nidx onwards so 31 5 47 using all of\nthese elements idx onwards\nthe maximum profit that can be obtained\nright and using a given capacity so it\nwill take uh an\nindex so it will take an index and a\ncapacity so if let's say the idx is one\nso it will then look at just these\nelements and if the capacity is 10 so it\nwill try to fill the capacity of\n10 and that's a recursive function and\nwhy are we creating a recursive function\nlike this\nthere's a simple reason now suppose idx\nhas the value one and the capacity is 10\nor let's say the capacity is 3 then the\nweight of this element is greater than\nthe capacity so that means it cannot\nshow\nup it cannot be selected because it\ncannot fit inside the bag the napag that\nwe have so then the solution for this\nsub problem with idx equal to 1 and\ncapacity equal to\n3 is same as the solution for this sub\nproblem with this element removed\nbecause you cannot include this element\nwithin the napsack right so if you\nremove this element and simply consider\nthese elements the remaining Elements\nwhich essentially means idx + 1 so max\nprofit of idx + 1 profit uh weights idx\nplus 1 profits idx plus 1 and\ncapacity is the answer for Max profit of\nweight idx profits idx and capacity\nbecause the current weight 5 is greater\nthan the capacity 3 which is which the\nrecursive function has been invoked with\nso that's one option but the more\nGeneral case is that you have enough\ncapacity so let's say you have a\ncapacity of 10 recursion was called with\na capacity of 10 and you are at idx1 so\nthen you have two\nchoices either you include this element\nin your napsack or you do not include\nthis element in in your because you\ndon't know whether the optimal solution\nwill have this element or not so you try\nboth\nso there are two possibilities we either\npick weights idx this element or we\ndon't and what we can do is we can\nsimply compute the result in both cases\nand pick the maximum so if we don't pick\nweights idx then once again if we don't\npick this element so the capacity\nRemains the Same let's say the capacity\nwas 10 so we simply try out to fill out\nthe capacity of 10 using the remaining\nelements so we simply call Max profit\nwith weights idx + 1 profits idx plus1\nonwards and the remaining capacity which\nis 10 but if we do pick the element if\nwe pick the element and we had a\ncapacity of 10 then the optimal then the\nsolution the best solution in this case\nwill have a profit three more than the\nsolution for this case and since we've\nalso used up some capacity so we need to\nadd three in the profit and we need to\nsubtract five from the capacity right so\nif we pick weights idx then the maximum\nprofit for this case is is profits of\nidx plus Max profit of Weights idx + 1\nonwards profits idx plus one onwards but\nbecause we've used up some capacity we\nreduce the capacity in the recursive\ncall okay and that is why a recursive\ncall takes both an index and a\ncapacity okay I hope that makes\nsense so here's a recursive tree that\ntells you the same thing we start at the\nfirst index and we we have the capacity\nand if we don't pick the first element\nthen we simp the answer is simply\nthe to the best solution for second\nindex onwards with the same capacity if\nwe do pick the first element then the\nanswer is the second solution\nonwards with the reduced capacity with\nthe profit added okay and then we simply\ntake the maximum of these two cases so\nwe call these two recursive calls and\nthen we simply take the maximum of these\ntwo cases to get\nback the final result or the final best\nanswer and the Final End case is that if\nwe've reached the end if weight's idx\nonwards is empty if the index that we're\ntracking has reached the very end then\nirrespective of what the capacity is the\nmaximum profit is in that case is\nzero so let's try and implement this\nnow let's copy this\nover as the explanation\nand let's try and implement the solution\nlet's say let's call it Max profit\nrecursive and this is going to take a\nset of Weights it is going to take a set\nof profits and it is going to take a\ncapacity and it's also going to take an\nindex which the index will start out at\nzero\nso now if the index is we start with the\nbase case so if\nidx equals the length of Weights in this\ncase there's nothing left to do we\nsimply return zero because we don't have\nany more elements then we\ncheck if the weights idx is so the\ncurrent element is greater in weight\nthan the\ncapacity then it's a pretty\nstraightforward solution we simply\nreturn\nMax\nprofit\nrecursive\nof Weights\nprofits capacity + one uh sorry capacity\nand idx + 1 so we simply ignore this\nelement because we cannot fit it in the\ncapacity that we have else we have two\noptions so we have option one option one\nis even though it can fit within the bag\nwe don't take it we we because the\noptimal solution may still not have it\njust because it fits does not mean we\nshould take it so we look at the option\none which is once again the same as this\nwhere we ignore this element and then we\nhave we look at option two in option two\nwe actually put this element into the\nbag so since we are putting this element\ninto the bag then we get we get profit\nfrom it so we get profits of idx and\nthen we call Max profits\nrecursive and this time we call it with\nweights\nand\nprofits and now the capacity has reduced\na little\nbit because we have taken this element\nso now we can now we need to fill the\nremaining we fill the need to fill the\nbag with the remaining elements from idx\nplus 1 onwards with a limited capacity\nof capacity minus weights of\nidx and then finally we just put in idx\n+ 1 so that we can start calculating the\nsolution from the next element onwards\nso that's Max profit\nrecursive again not very difficult it is\njust\nabout six seven lines of code and let's\ntry it out here's test\nzero let's try Max profit\nrecursive with test\nzero\ninput and uh we need to get weights\ncapacity and profit all of these out of\nit so simple way to do that is simply to\nput in star star and we'll get back all\nof these will get passed\nin capacity will get passed as a\ncapacity parameter in weights will get\npassed in as the weights parameter and\nprofits as the profits\nparameter Okay so we've encountered an\nerror and that's completely fine\ncompletely fine to encounter an\nerror I see so what we've done here is\nuh we have not really taken the maximum\nof these two we've just defined the two\noptions options so we do need to take\nMax of option one and option two okay\nonce again this is why helping test\nhaving test cases\nhelps and you can see that now we call\nMax profit and we can also add a timer\nhere so max profit it takes 210 micros\nseconds but it result it Returns the\nresult\n309 great we get back the result 309\nhere which is what we\nexpected so our function is working\ncorrectly we can even evaluate it on all\nthe test cases so from jan. python\nDSA we\nimport\nevaluate test\ncases and then we simply call evaluate\ntest\ncases on all the inputs so we pass in\nMax profit\nrecursive and then we pass in all the\ntest cases as tests now you can see that\nwe have these test cases and each test\ncase seems to be passing just fine all\nsix T Test cases have passed and these\nare the times they\ntook so that's your recursive solution\npretty straightforward once you reason\nit out once\nyou maybe just look at an example draw a\ntree of recursion yourself work it out\non paper the code is in fact in most\ncases fairly simple\nand this is what the recursion tree\nlooks like each time we make a choice to\neither include the element or not\ninclude the element and now you can\nreason the complexity very easily\nbecause now we have n elements for each\none we keep making this choice so that\nmeans we end up with 2 to the^ n leaves\nand from there it follows that the\ncomplexity of the recursive algorithm is\norder of 2 the^ N right so it could be 2\n* or C * 2 the^ N but uh and in the big\nor notation it's order of 2 the^ of n so\nit is exponential and complexity and why\nis it exponential and complexity once\nagain there are it's a possibility here\nthat we may be Computing a lot of things\nrepeatedly because we are creating so\nmany of these sub\nproblems so it's possible that we may be\ncreating we may be recomputing a lot of\ndata here so now\nthe task for you or the an exercise for\nyou is to write the memorized version of\nthis so what is it that you need to\nmemorize\nnow the trick here is to look at what is\nchanging within the recursive calls so\nnow in Max profit recursive you can see\nthat weights and profits Remains the\nSame but it's the capacity and the idx\nthat change so you can take the capacity\ncomma the index the idx as the key in\nyour memorization dictionary and each\ntime you compute so each time let's say\nyou compute this or you compute this or\nyou compute this store the result in the\ndictionary before returning it and then\nat the beginning of the recursive\nfunction check within the\ndictionary if this value is already\npresent okay so remember what we did for\nlongest common subsequence we defined a\nrecursive function internally we defined\na memo a dictionary internally and the\nrecursive function kept either checking\nthe dictionary or filling the dictionary\nif it could not find a value and that\ncould eliminate a lot of the repeated\nwork in your problem okay so that's the\nchallenge for you to try out implement\nthe memo\nsolution and what we'll do is we will go\nahead and we\nwill implement the dynamic programming\nsolution so let's just commit our work\nonce again and we've analyzed the\nalgorithm's complexity in recursion it's\norder 2 the^ of\nn in memorization now that's an exercise\nfor you what do you think the complexity\nwill be but let's apply dynamic\nprogramming so let's look at a dynamic\nprogramming solution now once again for\ndynamic programming you have to create a\ntable you always almost always have to\ncreate a table for dynamic programming\nand in this\ncase we can see that there are n\nelements so there are n rows within the\ntable because we have n elements to\nchoose from and we we have a number of\ncolumns going from 0 to capacity + 1 uh\ngoing from zero to capacity and that's\nwhy there are total of capacity Plus 1\ncolumns and in in fact what we can do is\nwe can also include another column at\nthe top here another row at the top here\nwhich we have not which is not shown\nhere but what n represents N is a number\nof elements so what n represents or what\nthe particular element in the table\nrepresents so table of I comma C what it\nrepresents\nis the maximum profit that can be\nobtained using the first I elements if\nthe maximum capacity is C\nokay so if your maximum capacity is C\nlet's say your maximum capacity is three\nwhat is the maximum profit that you can\nobtain using the first two elements so\num here let's say we are at this\nposition so using the first two\nelements of the\nlist within this capacity okay so the\nfirst two elements have weights one and\ntwo and the capacity is three so you can\nyou can actually pick so sorry the first\ntwo elements have weights two and three\nand the capacity is three so you either\npick this element or pick this element\nnow if you pick this element the profit\nis one and if if you pick this element\nthe profit is two so the solution is to\npick this element and you get uh you\nfill the capacity three and you get a\nprofit of two you cannot pick both\nbecause your capacity is three okay so\nthat's the logic here a very simple\nvisual representation now remember that\nthere will also be a zero throw here\nwhich we have not shown but this is\nsomething that should be here another\nzero throw so the zero throw represents\nthat you've not picked any of the\nelements and if you don't pick any of\nthe elements it is simply going to\ncontain all zeros and that's why it's\nnot shown here the first\nrow assumes that you have picked you can\npick only the first element so you can\nyou you can't pick the first element\ntill a capacity of two and then from a\ncapacity of two onwards you pick the\nfirst element and that has the maximum\ncapacity of\none uh the maximum profit of one the\nsecond row or the row number two with\nrow with index two represents the fact\nthat you can pick both of these\nelements and if you can pick both of\nthese elements once again at capacity\nzero none of them can be picked at\ncapacity one none of them can be picked\nat capacity two this element can be\npicked which has a weight two and it\ngives you a maximum profit of one at\ncapacity 3 this element can also be\npicked so now you have a choice to pick\nbetween the two of the\nso you might as well better pick this\none because this is going to give you\nhigher profit and then finally when the\ncapacity becomes five you can pick both\nof these elements and you can pick both\nof these elements and that is going to\ngive you a profit of 2 + 1 3 and so on\nso you keep filling out this table for\neach step here or for each set of first\nI elements you fill out the capacity\ntable and then you use the information\nto fill out the next row and the next\ncolumn and so on\nokay and finally what we need is using\nall the\nelements and using the maximum capacity\nthat we have what is the maximum profit\nthat we can obtain so the last element\nof the table will give you the result\nokay so what is the logic look like we\nwill fill the table row by row and\ncolumn by column now if table of I comma\nc table of I comma C let's say this is a\ncertain position here table of I comma C\ncan be filled using some values in the\nrow above it okay now if you look at the\ntable of I comma C you look\nat look at this element for example yeah\nlet's look at this element here so in\nhere C has the value three and then I\nhas the value zero which is a row that\nis not shown 1 2 3 4 so I has the value\n4 and C has the value\nthree so if\nyeah so if weights of I is greater than\nC so 0 1 2 3 4 um if if the if this if\nthis weight so this weight the weight of\nthis element is greater than the\ncapacity so the weight of this element\nis four it is greater than the capacity\nthen this element cannot show up in this\nmaximum\nprofit why because its weight is greater\nthan the capacity so obviously it cannot\nshow up in the maximum profit now if it\ncannot show up in the maximum profit\nthen the then this cell can be filled\nusing the value above it because in any\ncase you cannot put in this element so\nyou might as well get the result by\nusing the first three elements and in\nthat case the value of the cell is\nobtained from the value of the cell\nabove it that's one case now on the\nother hand let's come here you come to\nthis case to this cell in to fill this\ncell because you have a capacity of four\nyou have the option of I either choosing\nthis element or of not choosing this\nelement now if you do choose this\nelement let's say you choose this\nelement with a capacity of\nfour with a capacity of four you get\nback a profit of N9 and now you have no\nmore capacity left to create to fill\nmore elements on the other hand if you\ndo not choose this\nelement then that's the same as this\nvalue because if you do not choose this\nelement then you have to fill the\ncapacity of four using the value of\nusing the first three elements\nand that simply gives you the same\nhighest profit as the previous sell\nright so you just consider these two\ncases whether we choose the element or\nwe do not choose the element now if if\nyou do not choose the element the value\ncomes from above if you choose the\nelement then the value comes from where\nlet's see if you choose the element the\nprofit of nine comes and you fill out\nthe capacity 4 so you have no remaining\ncapacity but on the other hand if the\ncapacity was six and you choose the\nelement the then you have chosen the\nelement and you've used up the capacity\n4 so you can still use the previous\nthree elements to fill the remaining\ncapacity which is 6 - 4 so which is a\ncapacity of 2 so you can go back to the\nprevious row and check the capacity\n2 and see how much was the maximum\nprofit that you can obtain with capacity\n2 and it turns out that with capacity\ntwo using the first three elements you\ncan obtain a maximum profit of one so\nthe maximum profit here when you choose\nthe element is 99 + 1 10 similarly here\nthe maximum profit that can be obtained\nif you choose the element is\n9 plus 7 minus uh plus from the previous\nrow you pick the element with a capacity\n7 - 4 which is 3 so 9 + 5 14 okay so\nthat's the logic\nhere sometimes you choose the element\nsometimes you don't choose the element\nand in fact the Sol the result of this\ncell is simply the maximum of either not\nchoosing the elements the maximum of\nthis cell or choosing the element and\nsubtracting the weight which is 6 - 4 2\nso maximum of this and that okay so\nlet's implement this same dynamic\nprogramming\nsolution once again do work this out on\npaper it really helps to work it out on\npaper but let's\nsay we\nhave Max\nprofit DP the dynamic programming\nsolution solution we have weights we\nhave profits and we have a\ncapacity and then let's say n is len\nweights so we need to create um\ntable so this is our table our table\ncontains n rows so we have Len n and\nthen in for each of the rows we contain\nwe\nhave capacity + one oh we contain n\nplus1 rows remember so we also want to\nconsider the case where we don't\nconsider where we don't take any of the\nelements and it is filled with zeros and\nthe number of columns is capacity + 1 to\ncheck the values from 0 to capacity so\nthat's our table right\nnow you can check what this capacity\nlooks like let's say n has n and\ncapacity have the values here n in this\ncase is five and capacity is\n10 we don't need a len\nhere we don't need a len here as\nwell it's all Perfectly Natural to make\nthese\nmistakes this should be range not\nLen this should be a range\nand this should be a range to\nyeah now you can see that we have\ncreated n rows or n plus one rows so one\nfor each of these and then one more row\nabove containing all which will contain\nall zeros this is in the case where we\ndon't pick any of the elements and then\nwe've created 11 columns so this is for\ncapacity zero so again the First Column\nwill also contain all zeros and this is\nsomething that you will often see in\ndynamic programming you will have an\nadditional row at the beginning or at\nthe end containing all zeros and that is\nsimply to\nmake your calculations like computations\neasier but what that will lead to is off\nby one error so you need to be very\ncareful while doing\nthis and now we'll fill out this value\nusing either this value or by\nsubtracting the weight of the element\nthat's here and getting a value from the\nprevious row so now we start iterating\nso now we say\nfor I in range\nn and for for J in range\nC let's just say for C in range capacity\nthis should be\ncapacity table of I comma\nC and it's actually going to be I + 1\nand C+ 1 because we have these\nadditional rows and columns table of I I\n+ 1A C+ 1\nis there are two cases here\nif weights of of I is greater than C the\ncurrent\ncapacity then we can simply look at the\nprevious row so which is this case let's\nsay the weight three is greater than the\ncurrent capacity\n2 so then we simply copy over the value\nfrom the previous\nRow the same column so we just say table\nof I comma C + 1 we\nC so our capacity should go from the\nvalue of one because we don't want to\naffect the First Column so the our\ncapacity goes from the value of 1 to a\nvalue of 10 so capacity C goes from the\nrange of 1 to\ncapacity and if the weights I is greater\nthan the capacity then we cannot fill\nthe table on the other\nhand if it is if it fits within the\ncapacity then we have two options so\ntable of I + 1 comma C has two options\nso one is we don't use the current\nelement we don't use the current element\nand that gives a stable IC once again\nthe other option is we use the current\nelement so we get profit from the\ncurrent element so profits high but we\ndo not get profits but that reduces the\ncapacity so we then have to pick table\nof I but now we have to pick C minus\nweight weights of I\nokay and that should fill out the entire\ntable pretty much and that's the nice\nthing about dynamic programming you\nsimply just have to write this one\nsolution or this one recurrence and be\ncareful about it and everything else is\ntaken care of by this Loop here now we\nsimply return table of\nmin-1 and minus1 and let's see if that\nworks it's likely that there are some\nissues here but let's see we have test\ncases\nMax profit\nDP with the tests that we\nhave great so we are seeing an issue\nalready I see here\nthat this should be range and this\nshould be\nrange okay one thing that we haven't\ndone here is\nwell it seems like our solution is\nalways\nzero ah this should be capacity + 1 that\nwe this takes all the values from 0 to\ncapacity right so C the iterator should\ntake the values from 1 2 3 4 all the way\nup to the maximum capacity and the range\ndoes not end uh so the range does not\ninclude the end value so you need to put\ncapacity + one\nhere okay now with that out of the way\nyou see once again these off by one\nerrors are always going to bug you with\ndynamic programming I've probably solved\num 50 or 100 problems in dynamic\nprogramming but I still make these\nerrors um but with that out of the way\nyou can see now that each of the test\ncases seems to\npass now there may be other cases which\nyou have not accounted for but overall\nwe've covered all the test cases here\nand we've ended up with now a dynamic\nprogramming solution and I'll let you\nfigure out the complexity here but once\nagain it's pretty\nstraightforward because we are filling\nup this table and filling up this table\nsimply requires this constant amount of\nwork which is a comparison and then\npotentially another comparison and an\naddition and a subtraction so like four\nor five\noperations so you have this n * n uh you\nhave this n * Capac uh n * capacity\nwhere n is the length of weights and\nCapac or W is the total capacity so n *\nW is the number of iterations and that\nreally also is the complexity the time\ncomplexity of the\nalgorithm so that's the napsack problem\nand now what you can do is try and\nfigure out not just what is the maximum\nvalue but also figure out what are the\nactual elements that were chosen now you\ncan do this for the napsack problem and\nyou can do this for the longest\nsubsequence problem figure out the\nactual longest subsequence quence and it\nshould be possible to do that with just\na small modification now use the Forum\nif you have any\nquestions about the contents of this\nlecture go back to the lesson page and\nopen up the course Community Forum\nhere you can see here that U this is the\nlesson for recursion and dynamic\nprogramming lesson you can post your\nquestion here and you can also discuss\nideas on how to figure out what the\nlongest common subsequence is and what\nthe best selection for the napsack\nproblem is so what do you do next well\nyou can review the lecture video and\nexecute the jupyter notebook the next\nstep is also to complete the assignment\nnow we have released assignments one and\ntwo so far if you go back on the lesson\npage you will find lessons uh you will\nfind assignments one and two and you can\nwork on them there is sufficient\ntime and also work on optional questions\nand do participate in Forum discussions\nand if possible join or to study group\ntwo that's a great way to stay motivated\nthis was Lesson Four of data structures\nand algorithms in Python thanks and talk\nto you soon hello and welcome to data\nstructures and algorithms in Python this\nis an online certification course being\nconducted by Jovian today we are on\nlesson five graph algorithms like BFS\nDFS and shortest\nParts my name is Akash and I your\ninstructor you can find me on Twitter on\n@ aashan\nis if you follow along with this course\nand complete all the assignments and\nbuild a course project you can earn a\nverified certificate of accomplishment\nfor this\ncourse so with that let's get started\nthe first thing we'll do is go to the\ncourse website python\nds.com now you can point your browser to\npython ds.com to open up the course page\nand on the course page you can enroll\nfor the course and you can view all the\npre previous lessons and assignments so\ndo check it out and do check out the\ncourse project as well but for now we'll\nopen up lesson five graph\nalgorithms now on this page you can\nwatch a video for the lesson later the\nsame video that you're watching right\nnow and you can also catch a Hindi\nversion if you wish and here is the code\nthat we are going to use today the first\nnotebook Under The Heading notebooks\nso let's open it\nup and this is a jupyter notebook hosted\non Jovian you should be familiar with it\nby now but here you can see that there\nare some explanations and then there are\nsome code cells where we can write some\ncode you can see that there's some code\nhere now to actually execute and edit\nthis code we will need to run this\nnotebook and you can find the\ninstructions to run the notebook right\nhere but the simplest way to do it is to\nclick run and select run on\nbinder now this will take a second or\ntwo but this will take your jupyter\nnotebook and create a new machine in the\ncloud and send your jupyter notebook to\nthat machine for execution this is a\nfree\nservice that you can access via\nJovian you can also run this notebook on\nyour own computer directly if you wish\nso for that you can check the Run\nlocally option here\nokay so our jupyter notebook server is\nnow ready so we can now start editing\nand writing some\ncode let's just go full screen\nhere okay so the topic today is graph\nalgorithms BFS TFS and shortest paths\nusing\npython now before we talk about graph\nalgorithms let's just try to understand\nintuitively what graphs are now here's\nan example of a graph in the real world\nworld so this is the railway map of\nIndia you can see here all the train\nstations that you have in\nIndia they represented using these black\ndots points they're also labeled so each\ntrain station points to a city or a\nvillage so all these are also labeled\nand then you can see connections between\nthese stations so these are as you might\nguess railway lines and you see that\nthere are three or four colors involved\nso these colors could represent\ndifferent types of railway lines like\ndifferent gauge meter gauge broad gauge\nEtc or these could represent different\nzones so there's some information\ncontained in the connections as well now\nanother important thing is that each\nRailway line between two cities will\nalso have a certain\nlength so that's what a graph is roughly\nand the kind of questions that you may\nwant to ask here is for example is there\na path from from New Delhi to\nHyderabad so given this information\nfirst of all the question is how do you\neven represent all this information\nbecause you have so many railway lines\nconnections between different cities so\nmany hundreds of cities how do you even\nrepresent this so that you can start\nwriting algorithms to answer these\nquestions right so if you're building a\nsearch a train search website then you\nwould have to answer given New Delhi and\nHyderabad is there is there a way to get\nfrom New Delhi to Hyderabad okay that's\nthe first question that you might ask\nnow if there is a way then the next\nquestion might be that what is the\npath with the shortest number of\nstops so do you go this way for the\nshortest number of stops or do you go\nthis way or do you go this way another\nquestion could be what is the path with\nthe shortest distance right so sometimes\nif you measure the distance and if you\nmeasure the number of stations the\nnumber of stops they may be different\nalong different paths and one may be\ngreater than the other\nin in in certain\ncases so those are the kind of questions\nthat we want to ask and answer\ntoday another question could be what are\nall the Stations reachable from New\nDelhi within one stop or two stops or\nthree stops or 10 stops so those are the\nkind of questions we'll try and answer\nand for that we need a way to represent\ngraphs in a more abstract fashion\nbecause the same question can be asked\nin a different context for instance here\nwe're looking at flight routes\ninternational flight routes now once\nagain you can ask the exact same thing\nhere is there a way to get from New\nDelhi to Vancouver now if there is then\nhow many stops will that require what is\nthe minimum number of stops we can take\nto get from New Delhi to Vancouver or\nwhat is the minimum time it might take\nmaybe if you okay with taking multiple\nstops but you want to minimize the the\nthe time taken or the distance traveled\nbecause you're concerned with the miles\nfor for some\nreason another thing you could ask is\nwhat is the minimum cost if there is a\ncost along each route\nokay now here's one more example from a\nvery different domain this is hyperlinks\nor the internet essentially so you can\nsee here here you have a whole bunch of\nwebsites and you have links on websites\nnow links on websites point to other\nwebsites and in this case it is a one\nway connection you can see that from\nthis particular course website we have a\nlink to IBM but from IBM you may not\nhave a link to this course website now\nthat's an interesting thing that's a\nslight variation here and this is called\na directed graph because\neach connection here is has a particular\ndirection now this is again interesting\nto ask is there a way to navigate from\ncs. umass.edu to itaka weather\nif there is what is the shortest way\nwhat do what does that path look like so\nthose are the kind of questions that we\nwant to answer today and to do that we\nwill need a more abstract representation\nof graphs and we'll start with the\nsimplest possible representation where\nyou have certain points or what we will\ncall nodes or vertices so these are two\nterms that are used for these points so\nnodes or vertices so a graph has certain\nnodes or vertices and just to make\nthings easy these could be cities or\nthese could be web pages or these could\nbe something else but just to make\nthings easy what we'll do is we will\nnumber the nodes so in our graph if we\nhave 10 nodes then we will number the\nnodes from 0 to 9 okay this is and they\ncan be numbered completely arbitrarily\nthere's no reason to name name number\nthis zero or number this one what's more\nimportant is that we should use up all\nthe all the numbers from 0 to n minus1\nif we we dealing with n nodes now why do\nwe do that we'll see in a moment when we\ntry to represent graphs using certain\ndata structures like ad adjacency list\nEtc but we want to number our nodes from\n0 to n minus one and this number is\narbitrary this one doesn't represent\nanything in the sense that one being\ngreater than zero or so on okay so these\nnodes have labels and then you have\nedges between nodes so an edge is simply\na pair an edge is simply something like\n1A 2 so a pair 1A 2 tells you that there\nis an edge between the Node 1 and node 2\nokay now as we move forward we will also\nstore some information within an edge\nand we will call that weight of an edge\nand we will also later look at directed\nedges and those will get get us directed\ngraphs but let's start with this and\nlet's see how we can now represent with\nthis basic structure how we can\nrepresent uh a graph so we can represent\na graph using two variables so one is\ncalled a number of nodes and the number\nof nodes is in this case\nfive and then we can represent the edges\nusing a list of\npairs so in this case the pairs\nare 0a\n1 in this case the pairs are 0a 1 that's\nan edge then 0a 4 4 that's an H2 uh then\nwe\nhave 1A 2 so one is connected to two and\nthe edge in this case is bidirectional\nso when we saying 0 comma 1 we say it\nautomatically says that 1 and z are also\nconnected right so 1 comma 2 and then we\nhave 2A 3 and which order we write these\nin doesn't matter we could have just\nwritten 3A 2 here as\nwell or we also have 1 comma 3 and then\nwe have 1A 4\ngreat and then\nfinally we\nhave 3A 4 okay so this is how we\nrepresent this data structure what which\nwhat we've drawn here is now represented\nin code using these two variables and we\ncan check here if we simply print the\nnumber of\nnodes and the length of edges we can\nverify if this is roughly correct so you\nsee we have five nodes and we have 1 2 3\n4 5 6 7 edges okay seems right to me we\ncould there may be a mistake here but\nroughly we have set things up correctly\nokay now the question becomes is this\nquestion is this representation good\nenough now this representation is good\nenough if you want to convey the\nstructure of a graph to someone I could\ngive you these two variables and then\nwithout showing you this image and you\ncould use this information to draw the\ngraph on a piece of paper so this\nrepresentation is complete it provides\nall the information about the graph but\nit may not be efficient for example if\nyou want to find out which nodes the\nnode one is connected to we would have\nto iterate over the entire list of edges\nwe would have to go through this one and\nthen check if either of these is one and\ncheck if either of these is one and so\non so that makes it very tricky to\naccess any information efficiently\nrather it'll be much nicer to just look\nat a list of notes that one is connected\nto in some way and go from there now if\nyou want to find the shortest path we\nwould first have to find all the notes\nthat one is connected to and then for\neach of those we would have to find\ntheir neighbors and then for each of\nthose we would find have to find their\nneighbors and so on so it would get\npretty tedious to go through the list so\nmany times so that's why and by the way\nby a neighbor we represent we mean two\nnodes that are connected by an edge so\nzero and one are neighbors but 0 and 2\nare not neighbors so that's a very\nsimple nomenclature that we can use\nand what we can say is if we track the\npath we say 012 and there if there is an\nedge between both of them we say that\n012 is a path so 012 in this case is a\npath but 3 0 1 is not a path because\nthere is no path there's no Edge between\nthree and 0 okay and we'll see what what\nwe mean by paths and neighbors and so on\nin some time\nbut to work with graphs more efficiently\nwe will represent them using what's\ncalled an adjacency list now the name it\nexplains what it contains so the\nadjacency list contains a list for each\nnode and it contains a list of all the\nnodes that are adjacent to that node now\nagain adjacency is the same as adjacent\nis same as neighbor so if for each node\nso for example for the node 0 we we\nmaintain a list and that list contains\nthe numbers 1 and four indicating that 0\nis adjacent to or 0 is a neighbor of or\nzero is connected via a direct Edge to 1\nand four so that's why you have 1 and\nfour here and then 1 is connected to 0 2\n3 and 4 you can see that 1 is connected\nto 0 2 3 and\n4 similarly two is connected to 1 and 3\n3 is connected to 1 2 4 and 4 is\nconnected to 0 1 three now this is more\nconvenient for sure one because since\nthis is an uh this is a list if you want\nto\nfind let's say which nodes 2 is\nconnected to we can directly access the\nindex two within the list and this is\nwhy we number the vertices or the number\nthe nodes from 0 to n minus one so that\nwe can access them directly in an\nadjacency list right so we directly\naccess the number stored next to two and\nso we have 1 and three here so that's\nwhat makes it convenient and one\nimportant thing to notice here is that\nedges each Edge occurs twice so the edge\n01 shows up in the list for zero you can\nsee here in the list for zero we have\none and similarly in the list for one we\nhave zero so each Edge shows up in two\nadjacency\nlist of each of the nodes that it\nconnects okay so now the obvious next\nquestion might be to create a class to\nrepresent a Gra as an adjacency list in\nPython okay this is again a question\nthat you might get asked a step or this\nmight be part of another question that\nyou may get asked where you're asked to\nperform a breadth first search or depth\nfirst search or find the shortest path\nthe first step you'll have to do is\ndefine a class for a\ngraph to maintain the information about\nthe graph as the adjacency list okay so\nhere we're creating a class graph and\nthe first thing we'll need inside the\ngraph is a Constructor function\nso we need to put something inside the\nConstructor function and we know that\nthe first argument to any graph any\nclass method in Python is self which\nrepresents the object that will get\ncreated ultimately when we create an\nobject of the\nclass but apart from this what\ninformation do you need to create a\ngraph now it's pretty straightforward we\ncan simply work with this information\nbecause these two variables together\nspecify the graph completely so let's\nsimply accept accept num nodes and a\nlist of edges as the information the\nfirst thing we can do is simply store\nnum nodes in self. Nom nodes so that\nonce we create a graph we can access the\nnumber of notes very easily then we need\nto create the adjacency list so we need\nto create the adjacency list we'll call\nit self.\ndata and initially we will create a list\ncontaining empty lists because and then\nwe will fill out the empty list step by\nstep so what we need\nis something like this in this case\nbecause there\nare\nfive because there are five nodes so\nthis is what we need to create the five\nempty lists now in general the way to\ncreate repeated elements is this you can\nsay if you want to create a repeated\nelement like this 0 * you type 0 * 10\nand that gives you this list\n0 0 or containing all zeros on the other\nhand if you create empty list * 10 and\nlet's call this\nL1 and let's see what L1\nis it looks like you've gotten an empty\nlist or you've gotten a list containing\n10 empty lists but let's just go into\nthe first element so the first element\nis this first empty list and inside the\nfirst element let us add the value\none okay and then let's look at the\nlet's look at the list L1 once\nagain and you see what happen happens\nthis one gets inserted into all of these\nlists now what's the problem here now\nthe problem here is that when we do this\nwhen we create a list containing an\nempty list or containing any object then\nthe same object gets replicated 10 times\nbut python does not create copies now\nwhen you're working with numbers it's\nfine because when you're working with\nlet's say the number zero that's fine\nbecause\nuh there's no internal structure inside\nZ right so there's nothing you can\nchange inside the zero it's a fixed\nvalue fixed immutable value so what so\nyou can you can't really say L1 of 0 and\nchange its value internally what you can\ndo is you can set L1 of 0 to another\nvalue let's say you can set L1 of 0 to 1\nso instead of getting all zeros you get\nall ones but you cannot take this take\nthis zero and change something inside it\non the other hand when you have an empty\nlist here so this is the same list that\nis showing up in 10 different showing up\n10 different times each of the each of\nthe elements in the list outer list is\nsimply a pointer to this same empty list\nso what we can do is since we can go\ninside this empty list and append\nsomething to it so since this is the\nsame object that we are seeing over and\nover the one gets appended to the first\nlist and because the rest of them are\nthe same object we get back all ones\ninside here okay so this is a the reason\nwe spending time here is because there a\ncommon common bug that you may\nunintentionally execute whenever you\nwant to create an list of empty lists do\nnot use this method so what's the method\nyou should use\nthen so here's one method you can use\nlet's say you want to create a list of\nempty list of size 10 so you may be\nfamiliar with this object\nthis this object called range this\nfunction called range what this does is\nif you view it as a list you can see\nthat it contains all the elements from 0\nto 9\nokay now if you view the range itself it\nsimply shows you 0 to 10 but when you\nconvert it into a list you can see that\ninternally it contains the value 0 to 9\nokay so you can take this range and you\ncan do something like this put this\nrange or put anything which is iterable\ninside these brackets the list brackets\nand then say for X in range and simply\nput X so what did that do that did\npractically nothing we simply took X\nfrom the range of of 0 to 10 and\nreturned X itself so we created a new\nlist like this but suppose we multiplied\nit by two here x by two so for each\nelement in the range we are multiplying\nit by two and so we get back a new list\nwhich is 02 4 68 so this is each element\nis the double of the elements that we\nhave in the range now what we need is we\nneed just empty lists right so we can\nsimply put an empty list here and we can\nignore this value X that we get here so\nnow we get get back a whole bunch of\nempty lists so let's call this\nL2 and what we now doing is for each\nelement in the range we are creating a\nnew empty list so this is important so\nnow when you do\nl20 do append 1 and then check\nL2 you can see that one was only\ninserted inside the first list okay so\nkeep keep out watch out for this this is\nsomething that you will probably go\nwrong with that at some point I've gone\nwrong many\ntimes and one last change we can make\nhere is whenever you're not using a\nvariable in Python it's always a good\nidea to just call it underscore you can\nstill call it X but your sometimes\nsomebody reading your code may not\nunderstand why you have declared a\nvariable and not used it and assume that\nmaybe you've made a mistake so just to\nmake things very clear it's always a\ngood idea to make something underscore a\nit's also a variable name a valid name\nand Mark something as underscore if it\nis not being used\nokay so with that whole discussion about\nlists we now know how to create a list\nof empty\nlists so here you have a list of empty\nlists for underscore in range num nodes\nso now we have created a list of empty\nlists then for each\nEdge in\nedges we need to do something so we need\nto insert it into the right lists okay\nnow what does for Edge in edges look\nlike so let's see for Edge in\nedges print\nEdge okay each Edge is a pair we already\nknow that and when you have pairs or\ntupes here you can get them get the\nvalues out so let's say let's call them\nN1 and N2 node one and node two you can\nget the values N1 and N2 out like this\nso now we can say print N1 and print N2\nand you can see that we able to get\nvalues N1 and N2 out directly within the\nfor Loop so let's call this N1 and N2\nand now this is a much more pythonic way\nof writing code so one of the things\nthat we are also learning is how to\nwrite code which is more pythonic or\nwhich is idiomatic in Python and this is\nagain something that will impress people\nwhen you use it in an interview or a\ncoding\nchallenge so for N1 and N2 in edges what\nwe need to do\nis first we get self of data of N1 so\nthis gives us the adjacency list for N1\nthe first node and here we append the\nvalue N2 and similarly we do the same\nfor\nN2 and we append N1 to it and that's it\nnow we've set up the\ngraph so let's create a graph\nG1 let's call this graph one maybe and\nwe simply inv W the graph function and\nthen we give it a number of nodes and\nthe edges right so remember self will be\npassed in by python automatically as the\nobject that is getting\ncreated so the graph one object\nessentially so now the number of nodes\nis five and we have a list of\nedges and let's see what graph 1. data\nlooks like so there you go you can see\nthat 0 is connected to 1 and\n4 and 1 is connected to 0 2 3 4 and so\non\nnow while this is okay it would be nicer\nto print it like this so maybe let's see\nif we can print it like\nthis and the way to do that is to define\na repper function so we Define a\nfunction called underscore uncore\nrpr and it contains it simply takes self\nas the\ninput and what we are going to do\nis we are going\nto go over over we're going to\ncall enumerate on self. data now what\ndoes that give us let's just check what\nenumerate on self. data give us gives\nus well maybe before we do that let's\nsee what enumerate on a list gives\nus enumerate on a list gives us this\nobject but let's just get a value out of\nit in a for Loop because you can use an\nenumerator in a for Loop and then just\nprint X\nso what enumerate gives us is it gives\nus the values from the list but apart\nfrom those values it also gives us\nindexes okay so you can get an index I\nand a value V out of enumerator so then\nyou can see that you can print both I\nand V\nhere and you will get back the same\noutput okay so what we can say is we can\ndo enumerate self. data now because\nself. data contains these elements so\nwhat we'll get back is we'll get back\npair\nlet's see\nhere we'll get back pairs 0a 1 14 1\ncomma 023 4 2A 213 now this is starting\nto look a lot like what we want okay so\nwe'll just take enumerate self data and\nthese we'll take these pairs so the\npairs will be a node so node n and and\nits\nneighbors the so we have the node n so\nthe node n will first be zero and its\nneighbors will be 1 and four node n will\nbe one and its neighbor will be 1 and\ntwo and so on and\nthen so for n comma Neighbors in\nenumerate what we'll do is we'll simply\ncreate a simple\nstring and here we using string\nformatting we're simply creating this\nstring\nwhere we put this here we place a\nplaceholder where we put n and then here\nwe put a placeholder where we put\nneighbors again let's just see what that\nlooks like and this is the best thing\nabout Jupiter while you're writing code\nyou can test your code right then and\nthere simply by creating putting data\ninto a new into a new cell so let's see\ngraph 1.\ndata you can see here that now we have\nnow we have converted that enumerated\nlist into a list of strings so we have a\nstring here this is the string 0\npointing to 1A 4 this is the string one\nthis one pointing to 0 2 3 4 and so on\nbut this is still a list of strings what\nwe need to return from the repper\nfunction is a single string so the way\nto join them together whenever you have\na list of strings and you want to join\nthem together all you need to do is you\nsay what you want to join them with so\nwe want to join them with a new line and\nthen call the join function on that\nstring\nand return that right so that is our\nrepper function and we'll see it users\nin just a moment and similarly we have\nanother function called Str Str now\nrepper is used when we simply type graph\none so when we type graph one this is\nthe output of the default repper\nfunction now this will get replaced by\nthe repper function that we are defining\nbut when we do Str Str of graph 1 or\nwhen we do print of graph one or when we\ninsert graph one into a string that is\nwhen the Str Str function is used\nnow we will simply use the repper\nrepresentation so let's just put self\ndoore\nrpr and that's\nit okay so let's see now let's put let's\ntype graph one here and you can see that\nnow we have this representation printed\nusing this reper function that we've\ndefined so we have 0 1 4 1 0 2 3 4 2\nconnected to 13 3 connected to 1 12 4\nand four connected to 0 1 and 3\nokay so now we have a graph data\nstructure that we've implemented using a\nclass so the adjacency list and we have\na nice way to print it out and this is\njust good programming practice now you\ndon't have to do this in a coding\ncompetition or you don't have to do this\nit's good if you do it in an interview\nif let's say you're able to type this\nout quickly but when you are working\nwhen you are working on your own\nproblems or on your own code or on a\nproject always make sure that any\nclasses you define have a good string\nrepresentation so that when you type the\nname of a variable you understand what\nit represents and you don't have to\nspend time thinking about it make it\nclear to yourself okay so that's the\nadjacency list and we'll see how that is\nuseful in just a few\nmoments but here are a couple of\nquestions for you try writing a function\nto add an edge to a graph that is\nrepresented as an adjacency list okay so\nhere we've specified all the edges right\nin the beginning but can you write a\nfunction add edge which takes a couple\nof nodes and it inserts an edge between\nthose two nodes and here's a hint this\ncode might be useful so do try that out\nnow here's another one can you write a\nfunction to remove an edge from a graph\nwhich is represented as an adjacency\nlist so here you may have to use the\nlist remove functions to remove a\nparticular element from a list but these\nare two good exercises to complete here\nokay now before we continue let's just\nsave our work and we know that this\nnotebook is running on binder which is a\nfree service so we'll just save our work\nby running jan.com and what that will do\nis that will capture a snapshot of this\nnotebook all the changes that you've\nmade and put this on your Jovian profile\nnow this will go on your Jovian profile\nfrom where you can continue running it\ncontinue executing it from where you\nhave left off okay\nnow another common representation for\ngraphs is called The adjacency Matrix\nwhich is slightly different from\nadjacency lists in this case for example\nthe same graph here is represented using\nthis Matrix so what we do is we create a\nmatrix of size n by n if n is the number\nof if n is the number of nodes in the\ngraph and then for each node for\ninstance since we have zero and since we\nhave a edge between one and two so\nif you take the first row row number one\nand column number two you put a one\nthere otherwise if there's no Edge for\nexample there's no Edge between 0 and\ntwo you take the zero throw and column\nnumber\ntwo the you put a zero there okay so you\nput a one wherever there is an edge\nbetween the two nodes and you put a zero\nwherever there isn't and you can see\nthat there is this refle reflexive\nproperty here because 1 2 is 1 and 2 1\nis also one because these are un\ndirected edges now of course if this is\na directed graph this would be\ndifferent okay so an exercise for you\nonce again is to represent a graph as an\nadjacency Matrix in Python shouldn't be\ntoo hard all you have to do is instead\nof so in adjacency list we initialized a\nlist of empty lists here you may want to\ninitialize a list of zeros a list\ncontaining lists of zeros okay and then\nyou may simply just want to fill in the\nzero ones in the right place\nnow adjacency matrices have their own\nbenefits sometimes they are more useful\nfor example when you want to immediately\ncheck if there is an edge between two\nvertices or two nodes you can quickly\nlook up look it up in the adjacency\nMatrix but in the adjacency list you\nwill have to get the list for one of\nthem and then search through that list\nwhich is fine for most cases but in some\ncases you may just want an adjacency\nMatrix as\nwell so that's one other way you can\nrepresent a graph and that's an exercise\nfor\nyou okay so now we know we've\nrepresented graphs and now we can start\nlooking at some graph algorithms and\nprobably the most common graph algorithm\nsomething that you will ultimately get\nasked in one interview or the other if\nyou're interviewing with a bunch of\ncompanies is bread first\nsearch and bread for search well this is\nwhat it looks like so suppose you have\nthis this is the real world graph that\nwe're looking at so these are cities in\nGermany and you can see that there are\nroads between these cities and we have\nlength of each road now we can ignore\nthe length for now what's important is\nthat these cities are connected to each\nother but not all cities are connected\nto all of them all of the\nothers so starting from Frankfurt you\nmay want to find out which are the\ncities that are that you can reach from\nFrankfurt without stopping so\nwhich are the cities that are one Edge\naway from Frankfurt and if you look at\nit this way it turns out that Manheim\ncastle and\nwburg are the three cities that are one\nEdge away from frankfur right so if you\nstart drawing this tree of sorts so you\nwill find that Manheim verburg and\nCastle are one Edge away okay then you\nmight ask which are the cities which are\ntwo edges away from Frankfurt so now the\ncities that are Manheim is connected\nto cars through and wburg is connected\nto these two cities and then Castle is\nconnected to this city okay so here you\nhave these other cities and then you\nmight ask which are the cities that are\nthree steps away from the from Frankfurt\nand that would be the remaining two\ncities Augsburg and stur\nokay now I'll let you think about this\nbut what you will find in this way as\nyou go step by step by step like first\nyou're finding all the cities that are\none step away so all the nodes that are\none step away from a source node then\nyou're finding all the nodes that are\ntwo steps away from a source node what\nthis will give you is ultimately you\nwill end up for each node you will find\nout how far away it is from the\nsource and that will be the length of\nthe shortest path between the two okay\nand you can verify that I'll let you\nthink about it for instance if you see\nyou can go\nto Castle by by going this way from\nverburg to nberg to munin to\nCastle but that would not be the\nshortest path but binary search the this\nis called breadth first search bread\nfirst search will always discover the\nshortest path because we're first\nfinding all the nodes at distance one\nand then we're finding all the nodes at\ndistance 2 and then we're finding all\nthe nodes at distance three and if a\nnode at distance three has a shorter\npath then it would have been already\nfind found when we are finding nodes of\nlength one or two or distance one or two\nokay\nso that's Brad first\nsearch so here's one problem that you\nmight um face in an interview Implement\nbreadth first search given a source node\nin a graph using python okay and here is\nsome pseudo code this is so it's always\na good idea to write or explain your\napproach in plain\nEnglish before you implement it so that\nyou do not make mistakes while\ncoding so here for is a SoDo code so if\nyou have to write a function BFS which\ntakes a graph and a root or a source\nnode so first we say create a q so we\ncreating and this is taken by from\nWikipedia so first we create a Q and\nwhat's a q well a q is a very simple\ndata structure a q is simply a\nlist and it follows a first in first\nout uh policy so when you have a list\nand you want to add something into a q\nit's also called NQ the NQ of operation\nso when you want to add something into a\nqueue you add it at the end okay so you\nhave a list and then you simply keep\nadding things at the end you just append\nthings at the end of a list but when you\nwant to access something from a queue\nyou do not access any value directly no\nyou always access the first available\nvalue okay you access the first\navailable value in this case what what\nis called the value in\nfront and when you access a value it\ngets removed okay so so in this way you\ncan see that it implement ment the the\nfirst in first out policy like if first\nwe NQ 1 and then we NQ 3 and then we enq\n4 and then we want to DQ and when we\nwant to DQ we simply get the first value\nthat was inserted which is one then\nmaybe we NQ a few more numbers 5 2 7\nthen we DQ and then we get back the\nfirst value that we had inserted which\nis not yet DQ so then we get back four\nor whatever was the was the second value\ninserted initially right so that's a Q\nand we let's see how a queue is useful\nso we create a queue and then we Mark\nthe label we Mark root we label the root\nnode as discovered okay so we need to\nsomehow track which nodes have been\ndiscovered or\nvisited and first what we'll do is we\nwill Mark the root node so let's say we\nstarting from the node three we will\nMark three as discovered so three is now\ndiscovered and as soon as we Mark\nsomething as discovered we will Q it\nokay\nthen while the queue is not empty which\nis while we have not accessed all the\nelements in the que while we have not\ndced all the elements from the que we DQ\nan element so we DEQ the first element\nwhich has not yet been removed from the\nquebe and if we looking for a particular\ngoal node then we can simply end there\nlike we found that node but we are not\nlooking for a goal node so let's remove\nthis code\nyeah so we get we get the first element\nor the first node from the Q which is\nnot yet DQ and then so for example\ninitially we just have three in the que\nso then we get back three we get three\nback from the que then we check all the\nedges for three so we check that three\nis connected to 1 and three is connected\nto two and three is connected to four so\nwe see all the edges for\nthree and if the other end of the edge\nwe check for each node let's say the\nother end of this Edge is two we check\nif two is not yet discovered or not yet\nvisited then we NQ two into the Q\nsimilarly we check for one and if one is\nnot yet already discovered we NQ one\ninto the list similarly for four we NQ\nfour into the list okay so we have DQ\nthree so three is no longer in the Q or\nwe've moved forward we no longer going\nto get Q three out of the Q but but now\nwe've ened 2 1 and 4 and 2 1 and 4 We\nNow understand they are at distance one\nso when we pick the next element of the\nQ we DQ the next element the first in\nfirst in first out we get back two and\nthen we Mark two as visited great now we\nvisited\nto oh no we we Mark as soon as we are\nadding something to a que we also mark\nthem as visited because we've identified\nthat 2 1 and four are all at distance\none from three and we've added them to a\nq so we marked them as visited now when\nwe get two out of the Q in the next\niteration we check if there are any\nnodes which two is connected to those\nare not yet visited so two is connected\nto one but one is already visited so\nthere's no need to enq it again and then\ntwo is connected to three but three is\nalready visited so there's no need to\nenq it\nagain and so we just move forward then\nwe go to one and when we go to one we\nrealize that 0 is not yet visited so we\nenq\n0 four is visited so we don't nq4 okay\nand that's how we proceed so now what\nyou should do is you should draw this on\na piece of paper and work it out just\nwrite on a piece of paper what would be\nthe first element that gets inserted and\nwhat will be the elements that we will\ninsert into the queue etc\netc but this is the algorithm here exact\nwhat we what we just discovered so we DQ\nin a Vertex for all the\nedges that start from the vertex V or\nthe node\nV if the other end of the edge is not\nlabeled as discovered then Market is\ndiscovered and enq it into the Q okay so\nlet's implement this let's see if we can\nimplement this live so we are\nimplementing BFS where we will get a\ngraph and a source node the first thing\nwe need to set up is a\nq so the Q is empty then we set up\ndiscovered and discovered will be false\ninitially and it will have the length so\nwe want to mark it false for all the\nelements okay and remember now we can\nuse this notation here because false is\nan immutable value so it doesn't matter\nso so we don't really need to use the\nrange or the list comprehension notation\nhere\nthen here let's come here so we Mark the\nlabel root as\ndiscovered so discovered\nof source let's just call it root so\nthat we don't get confused with the\nterminology so we Mark discovered of\nroot as true great then we insert or we\nNQ the root so we we type q. append now\nNQ simply means adding something to the\nend and you know how to do that in a\nlist you simply call q. append\nso q. append\nroot\ngreat now python lists by default do not\nsupport a DQ operation so what we will\ndo is we will set up an index which will\ntrack the first available element in the\nqueue okay so whenever we DQ an element\nwe will increase the index so that we\nmove\nforward so here we have the index idx\nequal to zero so now while there are\nelements in the que which means while\nthe next available index is less than\nthe length of the\nque first we will get the current we\nwill DQ so deqing simply means getting\nthe getting the first in element the\nelement that was most recently inserted\nand has not been DED so we get\ncurrent is Q of idx and then we can also\nincrease idx so as soon as we DQ\nsomething we the index so you can\nimagine that the index starts out here\nand when we DQ this or delete this then\nwe get that value out and then we update\nthe index to the next position okay so\nnow we have the\ncurrent this is a DQ\noperation then what do we have next now\nwe want to check all the edges of\ncurrent right so we are going to say\nfor so remember we have the adjacency\nlist representation so we will get\nfor node in self.\ndata current so self. data current\ncontains a list of all the nodes that\nare connected with the current node so\nfor node in self. data current\nif\nnot discovered node so if you have not\nyet discovered the node then we first\nmark it at this as\ndiscovered and then we add it to the Q\nso we do q.\nappend\nnode okay so what you end up with this\nway is first you have the source that\ngot added to q and then we inserted all\nthe inserted all the nodes which were at\na distance one from source and then we\ninsert then if you follow the trajectory\nyou'll see that we we will insert all\nthe nodes that are at a distance two\nfrom q and so on right so ultimately\nwhen we end up with this entire process\nwe will have the Q and The Q will\ncontain the list of nodes as they would\nbe visited in a binary uh in a breadth\nfirst search okay so we can simply\nreturn the Q\nhere so let's try it out so we have\ngraph\none and let's call\nBFS and graph one is this graph so let's\ngrab this image as\nwell so let's simply copy the code for\nthe image and come down\nhere let's come down here and put the\nimage\nhere okay let's call BFS on graph one\nstarting at the Note\n3 okay of course this should be called\ngraph.\nData so because graph is the graph that\nwe're working with so we need to check\ngraph. data\nhere okay so we start out with the node\n3 and you you can see that three first\ncauses 1 2 and four to get inserted and\nthen one causes two to get inserted okay\nnow that's BFS for you it's pretty much\ndone at this point but what would also\nbe helpful is maybe to keep track of\nwhat is the distance of each node right\nso we can also track we can also keep\ntrack of a distance so let's say we have\na distance which we initially said To\nNone or yeah which we initially said to\nnone\nand we will track a distance for for\nfrom each for each node so we have the\ndistance\nhere and initially we are going to set\nthe distance\nfor the root to zero of course because\nthe root is at zero distance from itself\nand the distance here means the number\nof edges right then when something is\ndiscovered so when we are discovering a\nnode and that node was not already\npreviously discovered that means that\nthe distance for that\nnode is one more than the distance for\nthe current node which caused it to be\ndiscovered right so the distance\nfor so for example if you starting with\nthree the distance for one is 1 more\nthan three which caused one to be\ndiscovered and the distance for zero is\ngoing to be 1 more than 1 which caused\nzero to be discovered so that's the\ndistance great we've we we now also\ntracked the distance one other thing\nthat would be nice to have is what is\ncalled the parent if you see if you go\nback here you can see\nthat it would be nice to know what led\nto Carro being discovered was it Manheim\nverburg or Castle so that we can work\nour way backwards and find a path from\nFrankfurt to car's room okay so for that\nwhat we can do is we can keep track of a\ndictionary of a list called parent once\nagain we will have no parents by default\nso parent\nnone and whenever we find a node and\nthat node was not already discovered\nthen we can set the parent of that node\nto the current node which caused it to\nbe discovered okay and now we can return\nfrom the que the distance and the\nparent so let's see if that works okay\nso it seems like now we have\nthese are this is the this is the order\nin which the nodes are being visited you\ncan see that three is the first node to\nbe\nvisited\nand three has and if you want to check\nthe distance of three you can see that\nthe distance of three is zero so this is\ndistance is given in the order of the\nnodes in the order of the original\nnumbering of the node so you can see\nthat three is at a distance Zero from\nitself obviously then you have 1 2 and 4\nnow if you want to check the distance of\none just check the index number one here\nso one is at a distance one if you want\nto check the distance of two now that is\nat a distance of one as well you can\ncheck here and then you want to check\nthe distance of four four is also at a\ndistance of one right so all of these 1\n2 and four are at a distance of one from\nthe root node 3 and also you can see\nhere that the parent of\none remember these are 0 1 2 3 4 these\nare the indices of the nodes so the\nparent of one is three and the parent of\ntwo is three as well and the parent of\nfour is three three itself does not have\na parent that's why this is none and\nfinally the last node we visit is zero\nand it is at a distance two you can see\nit is the distance here is indeed the\nhighest and the parent for 0er is one\nright so because one was the first node\nthat caused Z to be visited it could\nhave been 42 but in this case just how\nwe implemented it one was the first node\nwhich caused it to be visited so one is\nthe parent of zero so if you now want to\nfind the path from 3 to 0 you can look\nat the parent of 0 that would be one and\nthen you can look at the parent of one\nthat would be three and we're done so we\ncan work backwards from the target we\ncan keep checking the parent after\nparent of the Target and that will give\nus the entire path so now we have the\npath we have the distance and we have\nthe order in which these nodes will be\nvisited so you may get asked Brett for\nsearch in all these different variations\nbut roughly this is what the code looks\nlike and you can see here that the code\nis not too long now we have created all\nthese additional additional lists but\nyou don't really need them so the code\nis about 15 lines of Code 10 to 15 12 to\n15 lines of code not more than\nthat so that's BFS again if you're\nworking on a BFS problem it always helps\nto First State it in simple words and\nwork it out with an example and then\nstart coding so that you do not make\nmistakes while coding\nnow one question that you can work on is\nto check if all the nodes in the graph\nare connected this may not always be the\ncase so for example here you can see\nthat all the nodes in the graph are\nconnected but sometimes you may have a\nsituation where some nodes are not\nconnected for instance if these edges\none 1 2 and 3 two weren't present then\ntwo would not be connected to zero and\nmaybe two is connected to five and six\nEtc so here is one graph where not all\nthe nodes are connected to each other\nyou can see that there are nine nodes\nbut there are only eight edges and if\nyou look carefully you will see that 0 1\n2 3 0 1 2 3 are connected but there is\nno connection from these nodes to four\nso four 5 six are then connected\nseparately and then seven8 are connected\nto each other but not to one another\nright so can you use breadth first\nsearch to determine if all the nodes in\na graph are connected I I would reckon\nyes a look at this Q now this Q gives\nyou all the nodes that starting from the\nsource node are connected to the source\nnode by 0 1 2 3 or so many steps if\nsomething is not connected it will not\nshow up in the queue so you can simply\ncheck the length of the queue and see if\nthat is less than the total number of\nnodes and then use that\nto determine if all the nodes are\nconnected or not now another related\nquestion question that you may get asked\nis to find the number of connected\ncomponents in the graph now what's a\nconnected component if you take a set of\nnotes that's connected that's one\ncomponent and if you remove that then\nyou look at the next set of notes that's\nconnected that's two components if you\nremove that then you take the next set\nof nodes that\nconnected that are\nconnected that and that gives you the uh\nthird connected component and so on so\nin this case for example you have this\nis one connected component you can check\nby drawing the graph and then this would\nbe one connected component and then\nthese would form one connected component\nso 0 1 2 3 would be one connected\ncomponent 4 56 would be another and 78\nwould be another can you find the number\nof connected components or even can you\nlist all the connected components of a\ngraph using\nBFS yes you can again a very simple way\nto do it is just pick the first node\nperform BFS from the first node that\ngives you the connected component that\ncontains the first node then find the\nfirst index which is the first node\nwhich is not yet visited start BFS from\nthat node now that will give you the\nconnected component for the second node\nand then find and then keep doing keep\nrepeating this till all the nodes have\nbeen\nvisited okay that's another question\nthat you might get find the number of\nconnected components or find a list all\nthe connected components in a graph the\nBFS is a very versatile algorithm that\ncan be applied to solve pretty much most\ngraph problems that you may get asked in\ninterview so do do work on a few BFS\nproblems and get some practice with it\nokay now another way to work through a\ngraph to look through a graph is what is\ncalled DFS and this is the way in which\nyou would normally explore a maze where\nyou start out in One Direction and then\nkeep going so for example we started out\nhere and then we kept going till we hit\nan end right so you can see here that we\nkept going until we hit an end and then\nwe turned back and then we tried the\nnext PATH and then we turned back and\ntried the next PATH and so on so we go\nlike this then we turn back we try five\ngo like this turn back we try eight then\nwe turn back try 9 10 okay that's\nanother way to go about it and it's some\ncases in some cases BFS makes more sense\nin some cases DFS makes more sense and\nyou can in most cases both of them work\njust fine for most problems so you can\nImplement either one when you are faced\nwith a graph problem so let's Implement\nDFS or depth first search okay now here\nis a depth first search it's pretty\nstraightforward you have you pick a node\nand then you pursue the the node and\nthen you next node then the next node\nand so\non among the edges you pick one node and\nthen once once youve exhausted the path\nalong one Edge you come back and try the\nnext Edge and then you come back and try\nthe next Edge so there are two ways to\nwrite it there is a way to write it\nrecursively and then there is a way to\nwrite it without recursion and I leave\nit as an exercise for you to write it\nrecursively but what we'll do is we will\nwrite it without\nrecursion and to write without recursion\nwe will use something called a stack we\nwill use a stack and a stack is another\ndata structure very simple list like\ndata structure but it's just like a q\nbut it's different instead of being\nfirst in first out which is what we do\nin a Que in a stack we\nperform last in first out so here's how\nit works you start with an empty stack\nso you can think of it like this\ncontainer or a cookie jar and you start\nputting in things into that jar you put\nin one and you put in two and you put in\nthree so now when you have to remove an\nelement from the stack or you want to\naccess an element from the stack the\nonly element that you can access is the\nelement that was inserted most\nrecently so last in first out that's a\nstack how is that going to be useful\nit's pretty straightforward if you think\nabout it because this node when you you\nstart from this as a source you will add\nall these three into the let's say you\nadd these three into the\nstack now if you add these three uh\nlet's add them in this order so you\nstart with this note then you add this\nthis and this so you add these three\ninto the stack then the last in value\nwas two okay so then what you do is you\nextract two out and then you insert\neverything that two is connected to into\nthe stack so you insert three into this\nstack and then you the last in value was\nthree so you insert you take out three\nand then you insert four into the stack\nthen the last in value was four then you\ntake out four and you have nothing left\nto insert so now this entire path has\nbeen exhausted so then you end up with\nthis five now when you end up with five\nyou can insert its neighbors 8 and six\ninto the stack and once six gets\ninserted into the stack uh then you take\nout six and you put seven into the stack\nand so on right so you can see how depth\nfor search is working using a stack and\nroughly this is what the procedure the\nprocess looks like you start a stack\nit's\nempty push push the current Source let's\nsay the root node what which we starting\nwith push the root into the stack now\nwhile the stack is not empty pop the\nstack so get the last in value from the\nstack and that gets removed as soon as\nwe call\nPop then if that node is not already\ndiscovered then we mark it as discovered\nand then for all the edges from V to W\nso for all of its\nneighbors we simply push them into the\nstack right so that's it that's all\nwe're doing all of its neighbors which\nare not already visited we can simply\npush push them into the stack okay so\nlet's do that let's Implement\nDFS and once again we will keep this\npicture in mind so let me just grab this\npicture here as well\nthis is one of the nice things about\nJupiter that you can take these images\nand simply include them within your\njupyter notebook while coding so that\nyou don't make any mistakes so let's say\nwe're writing Define\nDFS and once again let's assume that we\nare going to start from\nthree and this picture is graph\none so let's say we are starting from\nthree so Define DFS graph and we have an\nroot note that we want to start with and\nthe first thing we want to do is we want\nto create a stack and you can use a list\nas a\nstack adding you can simply add things\nto the end and then pop them from the\nend so we create the stack and then we\nfind discovered we Mark discovered as\nfalse for every\nnode L graph.\ndata then we say stack dot insert so\nstack. append so we simply add the\nnumber three to the end or the root\nnumber to the end so stack. aend root\nand then we don't mark it as discovered\nyet now this is the interesting thing in\nDFS\nbecause remember when you start out with\nthree you want you don't want to Mark 4\n1 and two all of them as discovered you\nwant to put them into the stack but only\nwhen they come out you want to mark it\nas discovered because you want to\ndiscover four and then you want to\ndiscover zero before you discover one so\nthat's why we put these into the stack\nbut we don't\nreally mark them as discovered just yet\nso that's why we're not marking the root\nas discovered then while lens stack is\ngreater than\nzero we get the current value so the\ncurrent value would be stack.\npopop so interestingly python list do\nsupport a pop operation so if you have a\nlist and then you do L1 do pop\nyou can see\nthat the value V that you get from L1\npop is the value two and L1 now has the\nvalue 5A 6 okay so you can use a\ndictionary you can use a python list\nlike a stack in fact we can even try\nappend here to see the entire process\nlet's say we are appending three and\nthen we are popping three so we get back\nthree and 562\nremains so we pop the current node and\nthen we mark it as\ndiscovered so we mark it as discovered\nhere my discovered of current is true\nand we may also just want to store that\nthis is the result that we have so we\nmay also just want to create a result\nlist where every time we pop something\nwe are also going to add it to the\nresult list so let's say\nresult do append\ncurrent and then we finally going to\nreturn the result\nokay but here's the main logic so\nfor all the nodes\nin graph. data\ncurrent we simply going to push those\nnotes into the stack\nso we simply going to\nsay stack. append node okay so what we\ndo is we start with three and we then\npop three and add it to the result and\nthen we put 1 2 and four into the stack\nwe don't mark them as discovered\nyet then we pop\none and then we put all of these 0 2 3 4\ninto the\nstack we don't mark them as discovered\nyet we mark one is discovered now then\nwe pop zero because sorry then we pop\nfour not one because we insert one to\nfour so four is the last inserted value\nso then we pop four we mark it as\ndiscovered and then we insert 0 1 and\nthree now you can see that that there is\nsome repetition here we're also\ninserting three once again so just to\navoid that what we can do is we can say\nif not discovered\nnode only then add it to the stack right\nthere's no point in adding something to\na stack if it is not if it is already\ndiscovered so now with that in mind\nlet's see we start with three and then\nwe insert one 2 and four great four is\nthe last value inserted so three is\ndiscovered now four is the last value\ninserted so we pop four and then we\ninsert 0 1 but we don't insert three\nbecause it's visited so now one is the\nlast value inserted then we pop one and\nthen we try to insert some of these\nother values it seems like everything is\nalready inserted so nothing will get\ninserted then the only thing that\nremains is zero so we pop\nzero then we pop once we have popped\nzero we going to pop four so the order\nin which we expect to see things is 3 4\n1\n02 I believe so let's\nsee\nDFS graph one starting with the node\nthree okay so it looks like we have 0 1\nso it looks like we made a mistake\nbecause we got some repeated values here\nand that's because we may want to just\ncheck if not\ndiscovered\ncurrent we may want to just add this\ncheck and put everything inside this\ncheck so that any older values that have\nbeen inserted into the stack which are\nalready visited later sometime through\nanother value in the stack that gets\nignored so we end up with 3 1 3 41 2 0\nright so it goes like this first we go\nfrom 3 to 4 to\n1 to two and then we go from 3 to 4 to\nzero so that's how it\ngoes now a challenge for you is to also\nImplement distance now in this case the\ndistance will not really make sense\nbecause this is not the shortest\ndistance anymore so when you want to get\nshortest distance from one note to\nanother then you want to use BFS not DFS\nbecause if you track distance here you\nmay end up going by DFS 3 to 4 to 1 to\n2 and that is going to give you a\ndistance of 4 distance of three to\ngetting to two although the shorter\ndistance is one so maybe distance\ndoesn't make sense here but what you may\nwant to put in is the parent you may\nwant to track the parent for each node\nshould be simple enough to do whenever\nyou\nare popping something you may just want\nto track its\nparent\nokay that's an exercise for you another\nexercise that you can try is to write a\nfunction to detect a cycle in a graph\nnow when you're performing DFS let's say\nyou you are going about performing DFS\nstarting at 1 and you do this and then\nyou end up here back at one right\nbecause you go to from 1 to two 2 to Zer\nand when you notice that 0 points to one\nwhich is already visited that gives you\nan indication that there is a cycle in\nthe graph a cycle is simply a path which\nleads from a node to itself so 1 2 0 1\nis a path and a path is something a path\nis a sequence of edges so 1 2 is a edge\ntwo 0 is a edge and 01 is The Edge so\nthis is a path but 1 2 and 2 4 is not an\nedge so 1 2 4 is not a valid path right\nso cycle is simply a path that leads a\nnode leads from a node to itself so the\nchallenge for you is to write a function\nto detect a cycle in a graph another\nchallenge for you is\nto detect maybe the number of Cycles in\na\ngraph okay so that's another thing that\nyou can try\nout but we'll move on to another problem\nnow we will talk about weighted graphs\nand get closer to that example of the\nRailway map that we looked at initially\nso here you have nodes so you have nodes\nnumbered from 0\nto 8 so you have a total of nine\nnodes and you have edges too now these\nedges also have weights and this could\nbe distances for example the railway\nline or this could represent any other\ninformation which is of value to you\nright so you decide what Edge weights\nare what they mean in the abstract\nrepresentation we simply call them\nweights so this is a weighted graph and\nhere is an example of how we can convey\nthe information about a weighted graph I\ncan give you the number of nodes and\nthen I can give you a list of edges so\nthe first two elements of each Edge tell\nyou which nodes are connected like the\nnodes zero and one are connected\nhere and then the last element of the\nlist or the third element of the list\ntells you if it is weighted if there is\na weight associated with the\nedge okay so you have 0 1 3 and then you\nhave 0 3 2 so 0 is connected to three\nand it has a weight two and so on and\nyou can verify that there are 10 edges\nhere and these are the 10 edges with the\n10 weights so that's one variation that\nwe see in graphs here is another\nvariation this is called a directed\ngraph in this\ncase edges have a certain direction so\nthis corresponds to the example of\nhyperlinks where we have Pages web pages\non the internet and one page can link to\nthe other but the other page may not\nnecessarily link back they may in which\ncase you may have a bidirectional edge\nbut in most cases there you would have a\nsingle unidirectional Edge so you have 0\n1 1 2 and 2\n3 now directed graphs can be represented\njust the same way as undirected graphs\nall we need to do is we need to provide\nsome information that this is a directed\ngraph right so you can simply say uh\ndirected equals\ntrue and that will simply and once you\nprovide all these all this information\nthat can then specify to the person who\nis going through this data that this is\na directed graph right uh so here's how\nit's exactly the same as a normal\nundirected graph but when we create the\nadjacency list we\ncan have a graph or we can have a node\nfrom 0 to 1 but we should not put 0o\ninto the adjacency list for one because\nthere's no way from to there's no direct\nEdge from 1 to zero there's only a\ndirect Edge from 0 to 1 so keep that in\nmind and similarly in the adjacency list\nnow you will not set both the values 0 1\nand 1 02 1 you will only set one of them\ncorresponding to the One Direction\nunless of course there is a bir\ndirectional Edge and what we can do is\nwe can even combine directed graphs and\nweighted graphs so here's the here's\nwhat we'll do we will define a class\nwhich can represent weighted and\ndirected graphs in Python so we'll use\nit to represent undirected graphs\ndirected graphs and weighted graphs all\nof these\nand we will take some information in the\nConstructor to capture this detail so\nlet's say let's create a class graph\nonce again we will create a Constructor\nnow this has the self which is the\nobject that gets created always the\nfirst argument to any method in a class\nin Python then we take the num nodes\nthen we take the edges and then we take\na couple more arguments we take a\nargument Direct\nwhich has a default value false and we\ntake the argument weighted which has a\ndefault value false okay and we're going\nto store the information self. directed\nlet's store self. num\nnodes as num nodes self. directed as\ndirected self do weighted is\nweighted okay so now we come to the\nedges so for\nEdge in\nedges what do we do now an edge can\neither have two values or three values\nif it is weighted if it is unweighted\nthen it'll have two values if it is\nweighted then it'll have three values so\nwe need an if condition here if self.\nweighted\nthen include\nweights\nelse work without weights\nokay now we may want to also because we\nneed to create an adjacency list so\nwe'll create self. data just as we have\nbeen doing so far and in self.\ndat we will create a list of empty lists\nas we have done for underscore\nin\nrange num\nedges now what we'll do along with self.\ndata we will also create something\ncalled self. weight and self. weight\nwill store for each corresponding value\nin the adjacency list it will store the\nweight of the edge between the two\nelements so for and you'll see how how\nit works in just a\nmoment num edges okay so we have self.\ndat and self. we and this will make it\neasier another way you can do it is\ninstead of storing single values you can\nstore tuples inside self. data which\nwill correspond to the node and which\nwill also contain the weight right so\nthere both these are both ways to do it\nI'm just doing it this\nway but you can do it the other way as\nwell where you can store tuples directly\ninside self.\ndata but suppose it is\nweighted then first we get the values\nout of the edge so node one node two and\nweight from The Edge remember the edge\nis a tuple if and\nthen first we set self. data no node one\nand upend to it node\ntwo and then we also set self. weight\nnode one so at the exact same location\nwhere we have node two at the exact same\nindex we store the weight between the of\nthe edge between node one and node two\nwhich is weight okay so now we've stored\nOne Direction which is node one to node\ntwo we may also need to store the second\nDirection so if not directed so if if\nthe graph is not directed only then we\nneed to store the second Direction so we\njust say self. data node 2 do append\nnode one and then self. data node 2.\nupend\nweight okay and that's the case when it\nis weighted if it is not weighted\nwell the code is actually\nsimpler so we simply get node one and\nnode two from The Edge and we say self.\ndata node one\ndo append node 2 and then if not\ndirected so there's no weight here so we\nsimply check if the graph is not\ndirected self. data node 2 do\nappend node one\nokay so there's a bit of code here but\nthe code is again fairly straightforward\nit's just a couple of things that we\nhave to take care of whether whether\nit's weighted or not whether it's\ndirected or not but now that we've done\nthis we have a fairly generic\nrepresentation for a graph right so now\nwe can take this graph and remember\ngraph one so graph one had this\ninformation so similarly we can take we\ncan create this graph we can use this\ngraph class to represent graph one but\nwe can also use it to represent one of\nthese which is a directed gra a graph\nwith weights or a graph with directed\nedges or a graph with both a graph with\nboth weights and directed edges which\nwe'll see in just a moment\nnow one thing that we'll also do here is\ncreate a nice representation so let's\njust create a representation\nhere now I'm not going to get into the\ncode of this but roughly what we want is\nwe want while showing the graph if there\nis a weight we also want to show the\nweight we'll show the weight alongside\nthe other\nnode so let's see we create a result the\nresult will\nbe this uh the empty string and then\nwe'll return that\nresult then we are going to say for I\ncomma nodes comma weights in\nenumerate self. data and self. weight so\nnow this is an exercise for you to\nfigure out what exactly this is doing\nand you can apply the exact same\ntechnique take create a\nnew create a new cell and put this data\ninto a cell put the zip into a cell and\nthen see what that represents if if\nyou're not able to if it doesn't show\nsomething then try converting it into a\nlist or using it in a for Loop and then\nput enumerate around it and see what\nthat represents so that you understand\nwhat I nodes and weights represent but I\nam simply going to write it here so that\nyou see the final result\nokay so let's take Nom nodes one once\nagain and edges one it was called Nom\nnodes and edges so this was the initial\ndata data that we were working with and\nlet's create graph one\nand of course we want to do this only if\nit is weighted so if self.\nweighted if it is not weighted then we\nhave a different case where for I comma\nnodes in\nenumerate self.\ndata\nresult plus equals\nokay let's see so graph one we are going\nto use the graph and we're going to pass\nnum nodes edges and by default weighted\nand directed are both false so we don't\nneed to specify them and let's say graph\none this should be n\nnodes so you can see with life coding we\nalways make mistakes and it's almost\nalways bound to happen that's where\njupyter notebooks are very helpful and\nit's always helpful to just test your\nfunction while you're writing it okay so\nnow we've created graph one and graph\none you can see is a undirected graph\nyou can see that 0 points to 1 and 1\npoints\nto0 then let's look at graph two so\nwe're going to grab this\ndata this contains let's call this num\nnodes 2 and edges 2 this is a graph with\nweights\nso now let's create a graph\nto graph and here we pass in\nNum nodes\n2 edges\ntwo and weighted equals\ntrue and let's say graph\ntwo okay there's a small change\nhere yeah so now you can see for graph\ntwo this was the graph we were looking\nat here this graph let's grab this image\nas\nwell yeah this is the graph that we were\nlooking at and you can see that Zer is\nconnected to 1 and\n3 and so Zer is connected to 1 3 and 8 1\n3 and 8 and there are also weights\nAssociated so 01 has the weight three uh\n03 has the weight 2 and 08 has the\nweight 4 and and so\non there seems to be something off here\nbecause Z one only seems to be connected\nto zero I think we may have made a\nmistake somewhere in the\ncode okay so we may just have to debug\nthis code it seems like we may have made\nmade a small mistake somewhere because 0\n1 one seems to be connected only to 0\nbut one should also be connected to 7 I\ndon't see why that did not show up\nhere this is The Curse Of Life coding\nand that's why I have\ncreated a working I have some working\ncode here so I'm simply going to grab\nthe working code right\nnow and we'll just replace that but see\nif you can detect the bug in the\ncode okay we don't the version I have\ndoes not require you to specify weighted\nso we can simply skip weighted here it\ndetects automatically if the graph is\nweighted still something wrong here\nlet's just quickly verify what's going\nwrong so we are going through the list\nof edges\nhere and we are\npending maybe let's just print graph 2\ndot graph two. data Maybe the issues in\nthe representation and not in the code\ngraph 2\ndot\nedges uh there seems to be some issue in\nthe weight here so we may not have\ninserted the weights correctly\nI see so this should be called\nweight this should be called\nweight and so should this be called\nweight oh there was a syntax error here\ne\nokay I think we fixed it finally let's\nsee this should be called\nweight so we have an Ed here we have too\nmany values to unpack ah we simply pass\nweighted equals true\nfinally and we need to make this a\nlist it's finally done\nsome good hardcore live debugging but we\nhave this finally and again you get to\nsee that when you're coding you will fa\nyou will make issues you just need to\nbut you if you have a clear idea of how\nyou've written the code it's easier to\nnarrow down the issues by looking at the\nerrors but let's see this graph here so\nwe have zero connected to 1 3 and 8 and\nthat's you can see that here 1 3 and 8 a\nzero connected to 1 38 with the weights\n3 2 and 4 then we have three connected\nto 0 2 and 4 so we have three connected\nto 0 2 and 4 and we have six connected\nto five and 8 you can see six connected\nto five with the value eight so great we\nhave now represented our graph properly\nand this is why a representation is\nreally useful because now we can check\nif our implementation is correct before\nwe go on and Implement any graph\nalgorithms we can check if our\nrepresentation is correct let's try one\nmore let us also try this directed graph\nso we're going to grab this code and put\nit here let's call this num nodes 3\nedges 3 and director\nthree let me grab this graph code here\nas as\nwell we are working with this\ngraph and let's create graph three so\nfor graph three we have graph and we\npass in Num nodes\n3 we pass in edges three and you can\nverify that the edges are set up\ncorrectly and we just specify directed\nequals true so we don't really need this\nat this point we can just say directed\ntrue and weighted by default is\nautomatically false so we have graph\nthree here you can see that zero is\nconnected to one and one is connected to\ntwo but not to zero so now we haven't\ninserted the opposite Edge and then two\nis connected to three and four then\nthree is connected to zero and four is\nconnected to two great so we've imple\nwe've Now set up another graph and now\nhere Sim similarly you can check that if\nyou have a weighted directed graph the\ncode is still going to work fine okay so\nthat's an exercise size for you and at\nthis point let us just save our notebook\nusing jin.\ncommit so the next question that we're\ngoing to look at is called the shortest\npath\nquestion and this is really what we\nstarted out with let's say you have a\nbunch of nodes and this is we have taken\na directed graph here but you need not\nhave a directed graph you can do this\nwith an undirected graph too and that\nwill be an exercise for you but you do\nneed weights here now whenever you're\ntalking about shortest paths in terms of\nWeights that is when this algorithm\nmakes sense now if you do not have\nweights in the graph then the shortest\npath can be found simply by performing\nbreadth first search okay so whenever\nyou're asked to find the shortest path\nthe first question you should be asking\nis is there a weight involved or are\nthere no weights now if there are no\nweights involved then we simply\nconcerned with the length of the path\nthe number of nodes in each path and in\nthat case you can simply perform a\nbreadth first a breadth first search\nbut if you have weights whether it's\ndirected or undirected then bread first\nsearch alone may not be enough right\nbecause it may turn out that certain\npaths for instance you go from 0 to\nthree so you you go if you go via 0 2 4\nand 3 the length of the path is 2 + 3 5\n+ 4 9 but if you sorry the yeah the\ntotal size the total size of the the\nlength of the path is 2 + 3 5 + 4 9 but\nthe number of nodes is 4 0 2 3 4 on the\nother hand if you go via 013 in this\ncase the number of nodes is smaller so\nthere's just one in between so 0 1 3\nthere just three nodes total but the\nlength of the path is 14 Which is far\nhigher right so this could represent\nthat you go to a far off Place via a\ntrain and then take a train to something\nthat was actually closer even though\nthere were more stops in a different\nroute okay this is what we're going to\nimplement now we're going to implement a\nan algorithm to identify the shortest\npath from a given node to a given Target\nokay so now this time we going to focus\nour search between a node and a Target\nso what is the shortest path in terms of\nthe total weight of the path not in\nterms of the number of nodes in the path\nkeep in mind what is the shortest path\nin terms of the total weight that\nwe can find\nfrom a starting node to end node and\nroughly the strategy goes like this and\nthe strategy is called the D algorithm\nroughly the strategy goes like this you\nhave the source node and the source node\nis at a distance Zero from itself so\nthere's nothing there\nreally\nbut the first thing that we know the\nfirst and the only thing that we know\nis\nthat for one of the siblings for one of\nthe neighbors of the source\nnode the direct Edge will be the\nshortest path\nso for example we have one and we have\ntwo now you have\ndirected you have direct edges from you\nhave direct edges from 0 to 2 and you\nhave a direct Edge from 0 to\n1 0 to2 has the weight two and 0 to 1\nhas the weight\nfour now in this case suppose we had an\nedge from 2 to 1 and that edge had the\nweight 1\nthen you could go from 0 to two with a\nweight two and then go from 0 2 to 1 by\na weight one and the total weight you\nwould incur to get to one would simply\nbe three and that would be smaller than\nthe short smaller than the direct Edge\nright so even if we looking at direct\nconnections of the root we can't say\nthat the direct Edge is the shortest\npath except or one of the nodes right so\nif we just look at the node where the\nedge weight is the smallest so you start\nat the root and you look at the edge\nwith the smallest\nweight then we can say for\nsure that the shortest path from the\nroot to the next node to the node two is\nthe direct Edge why because this direct\nEdge is smaller than or smaller than\nequal to any other direct Edge so any\nother path that comes to do\nindirectly will contain an another\ndirect Edge and and then some other\nedges right so it will have a length\ngreater than or equal to this direct\nEdge right so that's the key Insight\nhere that at every point you maintain a\ngroup of visited nodes so in this case\ninitially just two Z is visited and then\nyou find the first node which is at the\nclosest distance from any node within\nthe visited group okay so for example if\nwe start out at zero and then we look at\none and we look at two we see the\nsmallest Edge is two so we add two into\nour visited group because we we know\nthat this is the shortest path from 0 to\ntwo and at this point now we take all of\nthe siblings of all of the neighbors of\ntwo and update their weights now because\nwe know that 0 to two is a direct\nshortest path so we can update the\ndistance for four that four could be at\na potential distance\nof 2 + 3 5 or there could be a shorter\npath so we've not yet added it we'll\njust update four and similarly if the\nwas a edge to one we can update the\ndistance of one and we can say that the\ndistance of one is either four which was\nthe direct Edge or it can be 2 + 1 if\nthere was a direct Edge from one so now\nwe'll get to know that 1 is at a\ndistance of three which is smaller right\nin this case it's not but Suppose there\nwas a direct Edge from 2 to one of\nweight 1 we would get to know that one\nis at a distance three so each time you\nadd a new node as you mark a node as\nvisited you you update the weights of of\nupdate the distances of all its\nneighbors and then you simply find the\nnext node with the smallest distance\nright so you will find that the next\nnode with the smallest distance in this\ncase is four and then you update the\nneighbors of four there's only one\nneighbor the next node with the smallest\ndistance is three you update the weights\nof three and so on so that was shortest\npath in a directed graph but here let's\nsee a shortest path in an undirected\ngraph where we have more such\ncases so let's just watch this from the\nbeginning let's wait for the animation\nto start\nagain so we start at zero then we check\ntwo okay we Mark two as updated then we\ncheck nine then we Mark three as updated\nthen we update the distance of 14 but\nnow we can see here that we have another\npath to go to two or we go to three\nthat's why we track that and finally we\nget two we Mark two as visited now we\nare considering three and using three we\nare updating the weights of all the\nother graph all the other nodes and then\nwe are marking three as visited then we\nare using three to Mark six as visited\nand so on right so at each point you\nhave a group of visited nodes and you\nhave distances for all the nodes that\nare connected with the visited nodes and\nthen you pick the first unvisited node\nwith the smallest distance okay now\nlet's read the\nalgorithm you first Mark all nodes as\nunvisited and then you create a set of\nall the unvisited nodes and you call it\nthe universal set so a set of all the\nunvisited nodes is called the UN call it\nthe unvisited set assigned to every node\na tentative distance value Now set it to\nzero for the initial node because the\ninitial node is at a distance zero and\nset it to Infinity for all the other\nnodes so we now set the distance to\nInfinity because we've not yet visited\nthe nodes we don't know their\ndistance then you set the initial node\nas the current node so there's always a\ncurrent node that we looking at in this\ncase we'll start with the initial node\nnow for the current node consider all of\nits unvisited neighbors and then\ncalculate their tentative distances\nthrough the current node right so you\nhave the current node and the current\nnode is connected to a lot of unvisited\nnodes and if we look at each unvisited\nnode we know the distance up to the\ncurrent node because the current node is\nvisited and using that we can calculate\ndistances for or the unvisited nodes now\nif the unvisited nodes have distances\nset to Infinity then we know that the\ndistance from the current node distance\nwhy for going why the current node is\ngoing to small is going to be smaller\nthan the distance Infinity that has been\nset but on the other hand if the if a\ndistance has already been set for an\nunvisited node through some other node\nthen we can simply compare whether it is\nbetter to go through the current node or\nwhether it is better to retain the\nretain the distance that was obtained by\nsome other node and just maintain that\nright so in this way we simply update\nthe distances of all the unvisited nodes\nthat are neighbors of the current node\nokay so for example if the current node\nis a and it is marked with a distance of\nsix and then there is an edge connecting\nit with a\nneighbor B and then that edge has the\nweight or the length two then the\ndistance to go to B through a from The\nSource will be 6 + 2 8 right so from the\nsource to a is 6 A to B is 2 so the\ndistance if you want to go to B through\na will be 6 + 2 8 on the other hand if B\nwas already previously marked with the\ndistance right so it was not visited but\nit was just marked with a distance\ngreater than 8 then we know that we have\nfound a shorter path WIA a so we update\nits distance to 8 on the other hand if\nwe have a value let's say the value of\nfor visiting B bya another node D was\n7even so we keep the distance as 7 right\nso we simply updating the distance we\nare not yet\nmarking these new we not yet marking b\nas\nvisited now when we are done updating\nall the distances for the current\nnode then we Mark the current node as\nvisited and of course we remove it from\nthe unvisited set right so we Mark the\ncurrent node as visited then a visited\nnode will never be checked again because\nonce you have visited a node you have\nfound the shortest paths to it and you\nhave used it to update the distances of\nof all its neighbors so you never need\nto visit it\nagain so\nthen find the first unvisited\nnode find the first unvisited node that\nis marked with the smallest distance\nright so now we have a bunch of visited\nnodes and then we have a bunch of\nunvisited nodes many of those unvisited\nnodes have been marked with a distance\nso you simply get the first unvisited\nnode with the smallest distance and make\nit the current node and then repeat the\nprocess\nokay so you start out with zero you see\nthat you can mark two as you can mark\nthe distances of for 1 and two so one\ngets the distance four and two gets the\ndistance two now then you mark zero as\nvisited now you see that the node with\nthe least the unvisited node with the\nleast distance is two so you get two and\nthen you mark the mark the edges from\ntwo so you mark the distance for four as\n2 + 3 5 and suppose two had a Edge to\none then you would Mark the distance for\none as 2 + 1 if 1 was the weight of the\nedge let's say you would Mark the\ndistance for one as the minimum of 4 and\n2 + 1 so which will be three so you can\nmark the distance for 1 as\n3 and that's it and then you uh remove\ntwo from the unvisited set next you find\nthe next unvisited node the which has\nthe lowest distance so if this Edge\nexisted that would be one but if since\nthis if this Edge does not exist that\nwould be four so you get four and then\nyou mark the distances for the Neighbors\nof four and so on\nokay so what we'll do is we will create\nthis we'll create this graph here which\ncontains okay there should be a graph\nhere that we can look\nat yeah so we'll create this graph here\nwhich contains uh 0 to six which\ncontains six nodes 0 to\n5 this is the graph we\ncreating let's just put it here this\ngraph yeah so this is the graph that\nwe'll work with and let's start writing\nour shortest path algorithm so shortest\npath and we have a graph and that's it\nwe have a we have a start\nnode so let's call it source and then we\nhave a Target node the node that we want\nto get to so we want to go from 0 to 5\nand as soon as we have the as soon as we\nMark the target node as visited our\nalgorithm is done right so first we Mark\neverything as unvisited by setting\nvisited\nfalse time L graph. data so here we have\nmarked visited then we have distance so\nwe take we take the distance as Infinity\nso here's a way to create Infinity in\nPython you just say float\nINF and once again we set all distances\nto\nInfinity then we are going to maintain a\nq so because we we have this first in\nfirst out kind of structure so we're\ngoing to maintain a\nq the first thing we'll do is we\nwill\nMark the\ndistance\nfor the source node as\nzero then we can insert the source node\ninto Q so Q do insert or q.\nappend source and then we set an index\nto keep track of uh what is the next\nelement that we need to DQ so the first\nelement is what we need to DQ so while\nindex is less than\n0er\nand not visited Target so while the\nindex is less than the length of the Q\nand the target is not visited so what do\nwe need to do we get need to get the\ncurrent element from the Q so we simply\nget Q of idx and then we increment\nincrement idx by one so we increment idx\nby one\nhere then we need to take all the\nneighbors\nof Q all the neighbor we also need to\nfinally mark it as visited so let's just\nput in visited current equals true here\nbut in between what we need to do is we\nneed to update the\ndistances of all the neighbors\nand then we also need to find the next\nnode with\nthe find the first unvisited\nnode with the smallest distance okay so\nto update the distance of all the\nneighbors we have written a function\ncalled update\ndistance so we'll call this function\nupdate distance or update distances\nwhere we will pass in the graph and we\nwill pass in the current node and we\nwill pass in the distance Matrix or the\ndistance\narray and we pass it in this way and\nwhat update distances does let's look\nlet's look at it here and again it's\nalways a good idea to extract out\nspecific pieces of logic into separate\nfunctions so here you we calling update\ndistances where we have a current node\nand then we have the graph and then we\nhave the distance so we get the\nneighbors of the current node using\ngraph. data\ngraph. data current will give us the\nneighbors of the current nodes then we\nget the weights of of the neighbors of\nthe edges connecting the current node to\nits neighbors so we get the weights as\nwell now we go through each list of\nneighbors so for I common node in\nenumerate\nneighbors and then we check we get the\nweight so we now we have the node and we\nhave the weight so we have for each\nEdge the node that\nit is connected\nto and the weight of the edge and then\nwe check the distance for the node if\nthe distance for the node let's say\nhasn't already been said then it is\ninfinity so in that case distance to the\ncurrent node from The Source plus the\nweight of the Edge from the current node\nto the next node will be less than the\ndistance so if the distance FL of\ncurrent plus weight is less than the\ndistance we simply update the distance\nof the node on the other hand if the\ndistance of the node has already been\nset via some other node and that is less\nthan the distance via the current node\nthen we do not update the distance okay\nso that's all we are doing here and we\ncan ignore this for now we'll come back\nto it but this is performing exactly\nthat update distances function that we\ntalked about then next we want to find\nthe next unvisited node so here we have\na function called pick next node which\nhas a list of distances and it has\nvisited so we want to track the minimum\ndistance so we first set a variable\ncalled minimum distance to the value\ninfinity and then we set a variable Min\nnode so this is the node with the\nminimum distance to the value none then\nwe iterate over the all the list all the\nnodes in the that we have in the graph\nso from 0 to n minus1 and we check that\nif the node is not visited and the\ndistance of the node is less than the\nminimum distance we've obtained so far\nthen we set that node to the minimum\nnode and we set the minimum distance to\nthat value okay so we track the minimum\ndistance the a running minimum Distance\nby going over all the nodes in the graph\nand we keep track of which node has the\nminimum which unvisited node has the\nminimum distance so finally what pick\nnext node gives us is the first next\nunvisited\nnode okay so here we can get next\nnode\nis pick next\nnode and we give it the distance and we\ngive it\nvisited\nokay so now if there was a next node\nit's possible that there is no next node\nbecause we've probably already visited\neverything that we can visit so if there\nis a next node then we NQ it so we say\nq.\nappend next\nnode and that's\nit that's pretty much it so that is our\nshortest path\nalgorithm we create a visited list we\ncreate a distance list we create a que\nwhere we will add things so this this\nwill be all the all the nodes that we\nhave visited we go through it go through\nthis one by one and the Q in order will\ngive us a list of all the nodes in their\norder of distance from The Source node\nwhat we need to return here is we simply\nneed to return distance of the Target\nand since that was what was asked\nhere let's also Mark current as visited\ntrue here soon enough so that we don't\nend up visiting current again and\nagain all right so let's run the\nshortest path algorithm then here we\nhave a graph this is the same graph that\nwe see\nhere now we can create a graph graph\n7 and this is weighted and directed so\nwe will pass in graph we will pass num\nnodes 7 we will pass edges 7 and then we\nwill pass weighted equals true and\ndirected equals true\nand this is graph\n7 okay this seems like it was it worked\nout right 0er is connected to 1 and two\nwith the weights four and two\nrespectively and five is connected to\nnothing four is connected three is\nconnected to five four is connected to\nthree okay this looks\nfine so now we can\nsay shortest\npath in the graph\nfrom let's say from 0 to\n5 in graph 7 and it says that the length\nof the shortest path is 20 so you have 2\n3 4 11 so 2 + 3 5 5 + 4 9 9 + 11 20 so\nthat seems to be right what would also\nbe nice to get is just to see what that\npath is and for this we can introduce\nsomething called a parent so here we can\nsimply have another thing called a\nparent\nwhich is set to none for each\nelement so\nvisited let's call this parent and let's\nset it to none by default and all we\nneed to do is whenever we are enqing a\nnode we need to track why it got inced\nright so if a if a node is getting enced\nthen it is probably getting enced so\nsoorry not whenever we in queing\nwhenever we are updating the distance of\na node we need to track why why its\ndistance got updated so inside update\ndistances whenever we update the\ndistance of a\nnode we also set the node the parent of\nthe node to that current node from which\nthe distance got updated right and\nthat's all we need to do when we update\nthe distance of a node we need to track\nwhy did we update this Distance by which\nnode did we come to update this distance\nso this way we have now tracked the\nparent and let's return not just the\ndistance of the target but let's also\nreturn the Q\nand let's\nreturn let's just return the parent for\nnow I think this should be\nfine okay so now you have the parent for\neach one so if you look at the Fifth\nElement 0 1 2 3 4 5 you can see that the\nparent of five is three so it seemed\nlike we arrived at five from three and\nthen if you look at the parent of three\nso 0 1 to 3 the parent of three was four\nit seemed like we arrived at three from\nfour then you look at the parent of two\nit seems like we arrived at from at four\nfrom two then you look at the parent of\ntwo and it looks like we arrived there\nfrom zero and zero was our source so the\npath is if simply going reverse 0 2 4 3\n5 okay and that's how you get the\nshortest path and not just the shortest\npath distance now notice that zero\nitself does not have a parent because\nthat was the\nsource now you can repeat this with\nanother graph let's say we take this\nother graph that we had\nthis\nwas graph two so let's grab this image\nhere so let's get graph two and let's\nsay shortest\npath graph\ntwo and let's get the shortest path\nmaybe from 0 to 7 so it seems like there\nare two paths one goes via one and one\ngoes via six or 2 3 3 2 and 7 so let's\nget the shortest part from 0 to\n7 okay so we started out with zero and\nuh we end up at 7 so 0 1 2 3 4 5 6 7 it\nseems like the parent for 7 was\n1 and then the parent for 1 was 0 so\nit's clear that it picked the path 017\nand the total length of the path was 7\nsounds\ngood we can try another one we can\ntry 2 and 8 so there are a couple of\nways to go from 2 to 8 one is to go via\nthree so you can go to six to other\nthree ways actually but 6 2 uh 6 you can\ngo at 3 0 and 8 or you can go at 3 4 and\n8 let's see which one it\npicks okay so now 0 1 2 3 4 5 6 7 8 so\nthe parent for8 is\n5 oh sorry 0 1 2 3 4 5 6 7 8 so the\nparent for 8 is 4 so we came to 8 bya 4\nand then the parent for 4 0 1 2 3 4 the\nparent for four is three so we came to 4\nbya 3 and then the parent for three 0 1\n2 3 the parent for three is 2 so we came\nto 3 y 6 uh Y 2 so 2 3 4 is the path and\nthe length should be 8 + 1 9 + 6 15\ngreat it seems like we figured out the\nshortest path once again and this time\nthis was an undirected graph okay so as\nlong as you have weights you can apply\nthis algorithm and this algorithm is\ncalled the Dias\nalgorithm and that's it so that's all\nwe're going to cover today now one thing\nthat we have not looked at very closely\nis the running time complexities so\nlet's do a quick look at that let's do a\nquick look at let's say\nBFS and see if we can identify and or\nguess the running time complexity and\nthe full proof is left to you as an\nexercise but roughly it looks like this\nthis is the\nmain this is the main Loop here so where\nwe are going through the\nQ so the number of times this may happen\nis n or which is the number of n which\nis the number of nodes and the number of\ntimes this might happen now inside each\nfor each node inside BFS remember that\nwe check A full list of noes inside each\nnode for BFS so the number of times this\nmay happen is equal to the number of for\neach node we may perform an additional\nnumber of steps equal to the number of\nnodes it is connected to right so if we\nhave n nodes so we have n while loops\nand then if we have a total of M edges\nand let's say those M edges are split\nacross if I count the number of edges\nfor each node the number of edges is E1\nE2 E3 E4 and so on and then we so the\nthe the size of this Loop for the node\nN1 is E1 the size of this Loop for the\nnode N2 is E2 the size of this Loop for\nnode N3 is E3 so if you add up the list\nof all the edges E1 + E2 plus E3 plus E4\nso the total number of iterations inside\nthis for Loop turns out to\nbe you can see here the total number of\niterations inside the for Loop will turn\nout to be the total the sum of all the\nadjacency lists okay and the total sum\nof all the adjacency list is equal to\ntwice the number of edges you can see\nhere the number of edges is 1 2 3 4 5 6\n7 and you can verify that the number of\nelements of all the adjacency lists put\ntogether is 14 because each Edge is\nrepresented twice right so we end up if\nwe have\nn uh so if we have n Ed n vertices and M\nedges we end up with n + 2\nm operations right so each of the N\noperations to start the while loop and\nthen each of the 2 m operations those\nare to iterate over each adjacency list\nright and now when we are talking about\ncomplexities we can ignore the M if m is\nthe number of edges we can ignore the\nfactor two associated with it so what we\nend up with with is order of n +\nm so order of n + m is the complexity of\nbreadth first search and now by this by\nthis point you should be able to just\nwork it out by looking at the code so do\ntry it out and if you if it's not clear\ndo ask on the Forum but order of n+ M is\nthe complexity of bread first search and\nyou will find a similar complexity for\ndepth first search as well order of n +\nm for the shortest path algorithm\nhowever the complexity will be\ndifferent because in the shortest path\nalgorithm let's see it here\nin the shortest path algorithm what we\ndo is we go over all the vertices so\nthat's we insert each Vertex or each\nnode into the Q once and then we take it\nout once so this contributes a factor n\nthen when we saying update distances\nthen it also contributes the factor\nM but when we are picking the next node\nwe may we visit all the vertices once\nagain right so here we are performing n\noperations inside when we are picking\nthe next node so that gives\nus order of\nn + n\nm uh n sare +\nm yeah something like that so order of n\nsquare + m or n n plus M into n so\nthat's those are some complexities that\nyou will see reported for shortest\npath and a way to improve this a way to\nimprove the picking of the next node is\nto use what is called A Min Heap so that\nyou don't have to look through the\nentire list of nodes each time to pick\nthe next node but you can simply pick\nthe next node in a very short\ntime so there's a data structure called\nA Min Heap that you can look at the Min\nHeap\nallows is used to keep track of a bunch\nof numbers and easily track the minimum\nso you can keep a bunch of numbers\naround in a binary tree like this and\nthe root will always be the minimum and\nthe numbers on the left and right will\nalways be larger than the root and then\nthe same will be true for each sub tree\nas well and insertion into this Heap is\nof order login and deletion into this\nHeap is of order login as well and then\nthe min max in this case fetching the\nMin or the maximum value is of order one\nso instead of maint instead of looping\nthrough the entire list of nodes each\ntime what you can do is you can simply\ninsert nodes into this Min Heap and\ndelete nodes from the Min Heap when they\nbecome visited and getting the next node\nis as simple as fetching the minimum\nvalue okay okay so check this out this\nis not something that will generally get\nasked this is a more advanced Concept in\nfact even the D shortest path algorithm\nit's very unlikely that you will get\nasked but do review it and do try as an\nexercise if you want to go further try\nimplementing an improving the D\nalgorithm using a binary Heap so that\nwill take the complexity for from M plus\nn * n to n+ n * log n okay and that may\nbe better so do check that out that's\nobviously going to be better for larger\ngraphs so do try to implement it in fact\ninside python there is a buil-in heap\ncalled the Heap Q data structure and\nthat will that will optimize\nthe pick next\nnode\noperation in the Dias algorithm okay so\nthat concludes our discussion of graphs\nhere there's a lot more in graphs graph\ntheory is an entire course in itself but\nsince this course is particularly\nconcentrated on data structures and\nalgorithms from the perspective of\ncoding interviews and coding assessments\nthis is as far as we need to go so what\nyou should do is you should practice\nmore graph problems related to breadth\nfirst search and depth first search that\nis really something that you need to\nbecome very familiar with breadth first\nand depth first search and shortest path\nmaybe in Sometimes some some really hard\ninterviews you may get asked to shortest\npath as well so do familiarize your\nyourself with that but apart from that\nyou don't really need a lot more but\nthere are other algorithms you can look\nat minimum spanning trees you can look\nat topological sorting you can look at\nConnected components that's\nanother path you can look at detection\nof\ncycles and there's something called\ndisjoint sets so there's a huge huge\nnumber of topics that we can cover in\ngraphs but we'll stop our discussion\nhere so what you do next review the\nlecture video and execute the Jupiter\nnotebook complete the assignment and\nattempt the optional questions and\nfinally participate in Forum discussions\nvery important if you're stuck at any\npoint just go on the Forum ask a\nquestion you can also share your code as\nlong as it's not working to get help and\nyou can also join or start a study group\nto learn together with\nfriends and you can also find us on\nTwitter at chian ML and Akash\nNS and the next lesson is data\nstructures and\nalgorithms in in data structures and\nalgorithms is python interview tips\ntricks and practical advice thank you\nhello and welcome to data structures and\nalgorithms in Python this is an online\ncertification course being conducted by\nJovian today we're on lesson six python\ninterview tips tricks and practical\nadvice this is the final lesson of this\ncourse so I hope you're\nexcited my name is Akash and I'm your\ninstructor you can find me on @ Akash NS\nif you've been following along with this\ncourse and you have been working on the\nassignments and if you complete a course\nproject as well then you can earn a\ncertificate of accomplishment for the\ncourse which you can find on your Jovan\nprofile and also add to LinkedIn or\ndownload his\nPDF so let's get started first thing\nwe'll do is go to the course website\npython\nso this is the course website python\ndsa.msc 1 2 3 and you have the course\nproject as well let's open up lesson\nsix now on lesson 6 you will be able to\nfind a video recording of the video\nyou're watching right now\nand here is the code that we will look\nat today so today we'll do something\ndifferent we will simulate the\nexperience of being in an interview so\nwhile we have given you a problem\nsolving template and we recommend that\nyou follow this template for any project\nor any notebook that you work on any\ncoding problem that you work on and here\non the problem solving template we also\nhave a method something that we have\nbeen applying throughout this course to\ndifferent kinds of problems different\nkinds of data structures and algorithms\nbut in an interview obviously you will\nnot have this\ntemplate so we'll see how to apply this\nmethod during an interview and before we\ndo that let's revise the method so that\nwe can recall it from memory when we\nworking on the interview problem so here\nis the systematic strategy that we have\nbeen applying so far for solving\nproblems and do check out the previous\nlessons if you haven't seen them for\nexamples of how to apply it in detail\nso the step one is to State the problem\nclearly in your own words and identify\nthe input and output format and then the\nsecond step is to come up with some\nexample inputs and outputs and try to\ncover all the edge cases that you can\nthink of so you want to think of all the\npossible scenarios and that will help\nyou write your code properly then step\nthree is to come up with a correct\nsolution for the problem and state that\nsolution in plain English and then step\nfour is to implement the solution and\ntest it using some example input this is\nimportant while you're practicing but\ninitially when you come up with a\ncorrect solution it will be a Simple\nSolution what is often called a Brute\nForce solution and in an interview\nsetting you may not have the time to\nimplement it from scratch so you may\nskip if the Brute Force solution is too\nstraightforward then step five is to\nanalyze the algorithm's complexity and\nidentify any inefficiencies in the\nalgorithm so what you can do in an\ninterviewers come up with a correct\nsolution and describe it to the\ninterviewer and then analyze its\ncomplexity directly and start\nidentifying inefficiencies and then move\non to apply the right technique to\novercome the inefficiency so this is\nwhere you need to identify what which\none of the techniques that you've\nlearned in this course do you need to\napply is this a binary search problem is\nthis a divide and conquer problem is\nthis related to binary search trees is\nthis something that you can solve in a\nsimilar way you'd solve sorting is it\nimportant to look at the worst case or\naverage case complexity is this a graph\nproblem or is this a recursion\nor is this a dynamic programming or a\nmemorization problem so all of these\nthings are something that you have to\nthink about and as you practice more and\nmore problems so for each of the lessons\nif you try and practice about 5 to 10\nproblems then you will start to\nrecognize these patterns and when you're\non step six when you're trying to come\nup with the right technique to overcome\nthe inefficiency the ideas will\nautomatically come to you so practice is\nvery important to succeed in Step\nsix and once we have determined how to\novercome the inefficiency through the\nright data structure or algorithm then\nwe state that solution implement it\nanalyze the complexity right so this is\nhow your a coding assessment or an\ninterview should proceed for you and\nlet's see let's pick up a coding problem\nand let's go from there so here we have\na coding problem python subarray with\nthe given sum and we'll read the problem\nbut before that you can see that here\nthis notebook is fairly\nempty and we what we're trying to do is\nwe're trying to simulate the situation\nwhere you are on a call with somebody\nand they are interviewing you and\ntypically they would be using some\nplatform like a collab edit or maybe a\nplatform where you can also run the code\nor a platform\nwhere the question is somewhere let's\nsay on the right it's already printed\nit's from a pre-selected database on on\nthe right on the left and on the right\nyou can type your code and you can\nexperiment with it now we're not using\nany third platform here what we'll do is\nwe'll simply simulate that in our\nJupiter\nnotebook okay so now we have this\nnotebook running we've clicked the Run\nbutton on the Jovian notebook and here\nwe\nare now the question is and this is a\nquestion that was asked during a coding\ninterview for Amazon of course a lot of\nother companies may ask similar\nquestions too now you are given an array\nof numbers and these numbers are all\nnon-\nnegative you need to find a continuous\nsub array of the list which adds up to a\ngiven sum this is how interviewer might\nState the problem to\nyou and then they may also tell you an\nexample sometimes they don't and if they\ndon't it's always a good idea to ask for\nexample now you might sometimes feel\nthat maybe if you ask too many questions\nthe interviewer might think that that\nyou don't know this or you're dumb in\nsome way but that's not true it's\nactually the opposite the more questions\nyou ask the better the interview the\nbetter the interviewer is able to convey\nwhat they want right now they're busy\nthey're doing five interviews a day and\nthey have their entire day's work\nsometimes they may just fail to State\nthe question in its entirety and if you\ndon't ask for clarifications you may\nassume the wrong thing and go ahead and\nImplement something that's completely\nwrong and that completely derails your\ninterview and trust me it happens more\noften then you might\nthink okay so we here is one example so\nlet's say if the interviewer did not\nprovide an example you can ask them can\nyou please give me an example for this\nproblem and then they come back to you\nand they say suppose we have this array\n1 7 4 2 1 3 11 and 5 the these are all\nnumbers and they are all non- negative\nsome of these could be zero as well but\nsuppose we have this array and I give\nyou the number 10 that I want you to\nfind the large the I want you to find a\ncontinuous sub array of the list which\nadds up to the given sum which is 10 so\nthen they might also tell you that in\nthis case the solution is this subarray\nstarting from position four uh starting\nfrom the number 4 and going all the way\nup to three and you can check that there\nare no other ways to create 10 like if\nwe took 1 7 that would be 8 and 1 74\nwould be 12 on the other hand\n742 would be 12 again but 4 2 1 3 turns\nout to be 10\nand once again on the right you will not\nbe able to create the total of\n10 so this subarray is what you have to\nreturn now what does it mean to return a\nsubarray to return a subarray means to\nreturn the indexes which is the the\nindex of the starting term or and the\nindex of the ending term and sometimes\nwe know in Python when we working with\nranges typically the end index is\noutside of the actual data so you could\nreturn the index of four and the index\nof 11 so that we so the index of four is\n0 1 2 so 2 is the index of 4 3 4 5 6 the\nindex of 11 6 so if you return 2 and six\nand then I try to\naccess the 2 to six 2 colon 6 range of\nthe list then you will get get this list\n4 to13 and in fact that's something that\nwe can very quickly verify here let's\nsay L1 so you have 1 7 4 2 1 3 now if I\nsay that the start index is the start\nindex I and the end index J are 2 and 6\nrespectively and you can see L1 of 2 to\n6 is 4 2 1 3 right so although J is\noutside so that doesn't get included\nwhen we put it as a range and then we\nput in 42 13 and you can also verify\nthat the sum is 10\nokay all right so that's the problem now\nI've explained it to you in a lot more\ndetail than an interviewer would but\nthis is the process that you have to\napply in your own mind what and\nsometimes what you can also do is you\ncan repeat the problem back to the\ninterviewer that's a great idea you you\nthey've stated the problem to you theyve\nmay be given you an example now you\nstate the problem yourself in simple\nwords remember that was step one so in\nthe same way that I just have you can\nState the problem and then you have to\nfigure out what are the inputs and the\noutputs so the input you have an array\nor array is also a list in Python so\nlet's say ARR Zer let's create let's\nmake this the first an example first\ninput and that would be 1 7 4 2 1 3 and\nthen the target so your target sum is\n10 so that's the input here and then the\noutput that we want to want\nis so this is the output zero that would\nbe 2A 6 as we've just\nverified so this is the input and output\nformat always makes sense to just create\nsome variables for that before you start\nstart\ncoding the next step is to think of what\nare all the cases that a function should\nbe able to handle but actually before we\ndo that we should also write a function\nsignature because we know what the input\nlooks like we know what the output is\ngoing to look like and we know what so\nwe know what the function should look\nlike so we can just say\nDef and let's call this subarray\nsum and it's going to take an array it's\ngoing to take a Target and there's going\nto be some some logic inside it okay all\nright so that was step one sorry I\nforgot about the function signature but\nit always helps to just write the\nfunction signature because if you've\nmisunderstood the problem still the\ninterviewer can immediately correct you\nand tell you hey but you haven't taken a\ncertain input or you've assumed an input\nwhich I have not provided okay all right\nso now we have the function signature\nnow step two remember step two was come\nup with an exhaustive list of test cases\nto test the problem so you can do this\nin comments you can just create some\ncomments and you can say I'm thinking\nabout the problem and I'm just trying to\nthink what are all the cases we need to\nhandle and this is a great quality this\nis not something people do often but\nthey should because this indicates that\nyou're doing what is called test driven\ndevelopment which means you are thinking\nabout all the ways in which your code\nshould code might be used and accounting\nfor those before writing the code so\nkind of working backwards and it's a\nvery useful way to avoid errors so now\nthe first one could be a generic\narray where\nthe sub array is in the center somewhere\nin the center right so which is what we\nhave already seen here now the sub array\ncould be in the center or the sub array\ncould\nbe at the\nstart or the sub\narray could be at the\nend or it's possible that the the sub\narray there is no such subarray so\nthere's no sub array which adds up to\n10 you may also have the situation where\nyou have a few zeros so you\nhave a few zeros in the list that's one\noption here's one thing that can happen\nthis could be that\nthere are multiple sub arrays with the\nsame\nsum now this is where you might want to\njust clarify with the interviewer hey\nwhat happens if we get two sub arrays\nwhich add up to the same uh number the\nTarget and the inter interviewer might\nsay find the shortest one or find the\nfirst one or find any one but it's\nalways good to clarify\nthat next one option could be\nthat what you could also ask them what\nis what happens if there is no subarray\nthat adds up to 10 and then they may\ntell you you can return none none or you\ncan return minus one or whatever it is\nor assume that there is always a sub\narray so that will help you write your\ncode and then you can obviously you may\nhave to work with the empty array you\nmay also have to work with the sub array\nis a single\nelement and whenever we say aray we also\nmean List in Python there\npractically speaking the same thing for\nour\npurposes okay we've listed quite a few\ntest cases and in that process we've\ncome across a few more questions which\nwe've clarified so now we're ready to\nstart solving the problem now at this\npoint what you may want to do\nis maybe just ask for a couple of\nminutes and keep a pen and paper close\nto you so I'm going to use this\ntool instead\nyes so I'm going to use this tool\ninstead so keep a pen and paper close to\nyou so that you can work on this problem\nnow let's come up with the simplest\npossible solution right so we have about\n2 3 minutes to come up with the solution\nand often the simplest solution is\npretty obvious so in this case one\nsimple solution could be if I could\nsimply try every\nsubarray then I will find at least one\nif that adds up to 10 if there is one so\nall I need to do now each sub array is\ndefined by a start index that is where\nthe first element of the array is and\nthen and N index the end index is just\nnext the next index the first index\nwhich is not in the array right so\nthat's how we defined a sub array\nremember so all we need to do is try all\nsuch values so all such values I I comma\nJ where I goes from 0 to n minus one and\nwhere J goes from remember you could\nstart out with the empty sub array so\nwhich means J also has the value I so\nhere we are saying I and J both have the\nvalue two so L1 of 2 to two becomes the\nempty array so J grows from I\nto All the Way Beyond the last element\nwhich means if the last element's index\nis n minus one so J can go all the way\nup to n all right so I goes from 0 to n\nminus1 and J goes from I to n and each\ntime we start at an i and we check each\nJ so we check Jal 0 and J = 1 J = 2 J =\n3 4 5 and so on then we move I again and\nthen we start over again and then we say\nwe start with Jal to 0 Jal to 1 JAL 2 3\n4 okay and and we keep doing this till\nwe find an array and we' have exhaust\nthis way we'll test all the sub aray so\nthe problem is solved so that's the\nBrute Force solution and what you should\ndo first of all is explain that Brute\nForce solution it may seem that this is\nan obvious solution what's the point of\nexplaining it but do mention it because\nat this point the interviewer knows\nnothing about you so they don't know if\nyou can even come up with a solution to\nthe problem right they're trying to\nassess can you think about problems and\nthey're trying to assess can you write\ncode now if you don't tell them the\nBrute Force solution then they don't\neven know if you figured out the Brute\nForce solution so do tell them the Brute\nForce\nsolution and generally you do not have\nto code it you can do the analysis in\nyour memory uh in your mind and you can\nsort of write the the code in your mind\npicture the code and based on that come\nup with the complexity analysis and\ndirectly say that the Brute Force\nalgorithm will have such and such\ncomplexity okay now we will just write\nthe code right now just to be very clear\nabout it in case you've not you are not\nyet clear on how to write the code but\nin an interview this is the part which\nyou can skip in the interest of time so\nt\nsubarray i I think it was\ncalled subarray\nsum subarray sum and let's call the\nsubar Su one the first approach that\nwe're taking here we have array one and\nthat's it and we have array and then we\nhave our Target and we saying remember\nthat start I from so I goes from 0 to\nnus 1 that was the first thing so for I\nin range 0 to n minus1 and what's n well\nn is simply the Len of the array length\nof the array then J goes\nfrom I to\nn oops so I made a small error here this\nshould say 0 to n because even in a\nRange the last value is not taken so J\ngoes from 0 I to n so for J in the range\nI to this should be n + 1 then because\nwe want J to go all the way up to n\nokay and now we simply check if the sum\nof array I to J and and we've seen this\narray I to J is going to give us all the\nindexes starting at I but ending just\nbefore G so if the sum of array I to\nJ equals\nTarget then we found the answer return I\ncomma J that's it so check if subarray\nsum equals\nTarget and if not let's just return non\nnone maybe this is what we agreed but\nlet's return n none\nand that's it so that's\nyour that's your code it's about 1 2 3 4\nfive lines of code maybe\nsix but that's a Brute Force\nsolution if it's really short it doesn't\nhurt to write it because then it's going\nto sit there and at least as a reference\nyou have it but it's something you can\ndiscuss with the interviewer should I I\nmean if you if you are clear about the\nBrute Force solution and you can tell\nits complexity then you don't have to\nwrite one other tip is whenever you're\ncoding it's always helpful to Simply add\na small comment\nabove so that even if the interviewer is\nnot able to follow your code they can\njust follow your comments and they can\ntell if your general strategy is correct\nright once again reading code is hard\nand especially\nwhen you are not familiar with the\ncoding best practices in the industry\nthe code that you write is sometimes\ndifficult to read so while you learn how\nto write good code in the meantime it\nalways helps to just mention comments\nmakes it makes their job easier makes\nthem easier makes it easier for them to\nevaluate you otherwise you may spend 5\nto 10 minutes talking about something in\nyour code which either they\nmisunderstood or you made a typo\nEtc okay so we have here the subarray\nsum one we've implemented The Brute\nForce solution maybe let's also check\nout some cases\nin and see if this root Force solution\nworks\ncorrectly so in an interview if you have\nthe ability to run the code you can just\nrun a few samples so let's say I simply\ntake array Z and Target 0\nand you get the value 26 and remember\noutput 0 also has the value\n26 so great it seems like\nour our technique work let's test a few\nmore cases just to be sure subarray at\nthe end subarray at the start let's see\nif we can fix that so here is array\nzero now if I take this remember 4\nto13 oops I think I didn't completed let\nme also put in 11a 5\nhere yeah so remember 4 to 13 is the\nsolution now if we simply take 4\n21315 and call sub array\nsum and put\nin this number here and put in once\nagain the target zero was\n10 oh this should be S some one okay\nyeah so now you can see 4 to 13 is 01 1\n2 3 which is the range 0 to 4 so it\nseems to have worked correctly let's do\nthe same thing now let this time let's\nput this at the end so 1 7 4 2 1 3\n115 this works fine 2 2 six let's try\nanother one let's try\nmaybe 17 and that probably cannot be\nfound oh it can 1 2 let's see 1 0 1 2 3\n4 5 probably the sum of all of these 4 +\n2 6+ 4\n10 okay now maybe there's a problem here\nbecause it seems like 17 is not the\nright sum so you have 1 + 7\n8 and 8 + 4 12 12 + 2 14 14 + 4 18 okay\nso this seems like a mistake\nthen and we can even check this out\nso we have\nL1 that's that let's call that\nL2 L 2 oh it says 1 to six I think I\nmisread it so we are ignoring the zeroth\nelement so this does add up to 17 okay\nso 17 does show up let's try 18 which\ntakes up the entire array works fine\nlet's try maybe four which should just\ntake the single number so that works\nfine too let's try 19 that should be\nnone none okay we've tested this\nextensively and over overall our\nsolution seems correct this is the\nprocess whenever you write any code you\nshould also test it out and it also\ngives more confidence to the\ninterviewer but if you do not have the\noption to test it out if you if you're\nnot able to run the code right now then\nsimply walk them through an example\nyourself like look at this example and\nthen walk them through the example okay\nso now we have the The Brute Force\nsolution the next step is to analyze the\nBrute Force solution now let's analyze\nit so you have here one for Loop and we\nknow that counting for Loops helps us\ncount the number of operations then we\nhave another for Loop so one for Loop\ncan go from 0 to n so this may run end\ntimes then we have another for Loop\nwhich goes from I to n +1 let's\napproximate here and say that it can run\nat most n minus one times or n times so\nn and inside each of these up at most n\nand then inside the second for Loop you\nhave the sum so this is very important\nnow always carefully observe the\noperation inside your for Loop so you\nhave a sum which can be on an array of I\nto J now remember I can be zero and J\ncan have the value n that means in the\nthe largest array that you can work with\nwill have approximately the size n as\nwell right so you have n and inside each\nof those you do n other loops and inside\neach Loop you do work you do n additions\nright at most n additions so that\nroughly gives you that this is going to\nbe n * n * n so this is going to be an\norder and Cube solution okay so if you\nare able to arrive at the order and Cube\nsolution the order and Cube complexity\nwithout implementing the solution great\nyou have learned it but if you're not\nable to arrive um at the order n Cube\nSOL at the order n Cube complexity for\nThe Brute Force solution\nthen you probably need a little more\npractice because this should become\nsecond nature to you just looking at a\nproblem identifying the simplest\nsolution and then finding the complexity\nof the simplest solution\nokay all right so now we have\nimplemented it tested it and we've\nidentified the complexity remember the\nnext step find the inefficiency and\novercome that inefficiency by applying\nthe right\ntechnique so let's find the inefficiency\nthen\nhere we\nhave let's say we are at this position\nso let's say you are looking\nat 742 let's say I has the value 1 so\nyou start out with I equal to 1 and J\nequal to 1 in in the Inner Loop then\nwhat we do is we increment J by 1 and\nthen we calculate the sum and the sum is\n7 then what we do is we increment J by 1\nmore and we calculate this Loop and this\nsum and this sum is 7 + 4 11 then we\nincrement this window once again and\nthen we calculate this sum and that is 7\n+ 4 + 2 so 7 + 4 11 +\n2 13 and then we move this and then we\ncheck it again so we doing this over and\nover and over many many times right each\ntime we are doing 7 + 4 + 2 + 1 and 7 +\n4 4 + 2 + 1 + 3 that seems like a lot of\nadditional work maybe we can just avoid\nthat what we can do is we can when we\nstart out with a J we can keep a running\nsum and each time simply before\nincrementing J add this upcoming element\nwhich is the J element into that running\nsum right and that way we don't have to\ndo that entire sum inside each of the\ninner Loops so that's one optimization\nand this is how you should explain it\nthat's one optimization that I have come\nup with the second optimization that we\ncan come up with is that the moment the\nsum the running sum that that we're\ncalculating the moment the sum becomes\ngreater than the target\nvalue we can skip all of these right so\nwe know that 7 + 4 is greater than 10\nand we know that the array only contains\nnon- negative number so what that means\nis 7 + 4 plus any of these numbers is\nalways going to be greater than 10 right\nyou can obviously you can see this the\nnumber is not going to decrease if we\nkeep adding positive\nnumbers and so as soon as the running\nsum crosses this value we can break out\nof the inner loop we do not need to\ncontinue and look for higher values of\nG so two\noptimizations helps to just write them\ndown maintain a running sum so that you\ndon't forget it and Fin and second\noptimization\nis when\nsome exceeds\nTarget break inner loop\nokay so now we have applied an\noptimization simply by just looking at\nthe data in a lot of cases it's very\nstraightforward you don't even have to\napply any special\ntechnique and in this case we found\nthese couple of optimizations so let's\napply them so what we'll do is we'll\nDefine def\nsubarray sum\ntwo and here once again we have the\narray and we have the\nTarget and this time we get the length\nof the\narray and now once again I goes from the\nsame value so I goes from 0 to\nnus1 nothing changes\nhere so for\nI in range 0 to\nnus1 now here is where we want to start\na running sum so s equal 0 this is our\nrun\nsum then for\nJ in range remember we start out with I\nand we'll go all the way well this I\nkeep making these mistakes all the time\nand by the way these are called off by\none errors here what we did was I wanted\nto go to at the address n minus one but\nbecause ranges do not include the final\nvalue I put in what I put in nus one was\nwrong I should be putting in n and I\nmake these mistakes all the time even\neven after many years of coding so\nalways watch out for off by one errors\nanyway so J can J can take the range of\nzero of I to n so here we should put in\nn +\n1 and now first we want to check if the\nrunning\nsum is equal to the Target right so so\nassume that we've been calculating the\nrunning sum step by step and we'll write\nand and at this current point the sum\nhas become equal to Target now if the\nsum has become equal to Target then we\nsimply return I comma J because this sum\nincludes the sum from index I all the\nway up to just before J so initially the\nJ also has the value I so the sum is\nzero which makes\nsense but if that is not the case we\ncheck if it is greater than the target\nso is it possible that our sum has\nalready exceeded the Target in that case\nwe don't need to continue this inner\nloop we can break out of this Inner Loop\nand the way to do that is by simply\ntyping\nbreak and\nthen if neither of these held true if\nneither of these was true so which is\nthat the sum was not equal to the Target\nand it was not greater that means it is\nstill less than the\ntarget so that means we need to then add\narray of J into the sum so we can say\nsum plus equal to oops sum plus equals\narray of J which is the same as sum\nequal to sum plus array of\nJ in any case array of sum plus equal to\narray of\nJ so we have added the jth element now\nremember if this is the pointer J we\nadded the jth element and then we we\nwill set J to J + 1 that will happen\nautomatically when we come into the next\niteration and the next iteration we'll\nonce again check if the sum is equal to\nthe Target if it is equal we return I\ncomma J otherwise we check if it is\ngreater than the target if it is so we\nbreak break if it is still less we\nincrement we move j once again so we add\none and then we move j once again and\nthen we check again right so that's our\nrunning\nsum looks good now once again if we were\nif it was found it would have been\nreturned somewhere here since it seems\nlike it was probably not found\nso uh if we come to the very end so here\nwe return none none okay and once again\nlet's test it out so let's try subar sum\n2 it gives you 2 six subar sum 2 of\nnone okay seems like there is an issue\nhere yes so this is why you need test\ncases so it seems that arj took up an\ninvalid\nvalue so why is that well that was\nbecause J can go to the point of n so\nthe maximum value J can take is n so\nwhich means that you have already\narrived at this\nposition so now you can no longer\nincrease the sum further right so if\nyou've arrived at this position but\nyou've still not reached the total of 10\nthen that means you may need to increase\nit further but you can't increase\nfurther so there's no number here to add\nso what we should do is we should here\nadd a check if J less than n since J can\ngo all the way up to\nn and that's it so we had a small bug\nand we fixed\nit now again this is something that you\nshould work out for yourself on pen and\npaper so even while doing the\noptimization you can ask for a couple of\nminutes play around with it on pen and\npaper write a few\nexamples relax you can even take up to\nfour five minutes and if you if you're\nnot getting any ideas you can simply\ntalk to the interviewer you can speak\nout loud explain your thought process\nand in a lot of cases they will give you\na hint because they want to see you\nsucceeding\nokay so now this is the second\nimplementation let's see okay this time\nit worked none none 4 213 let's put in\n10 here this should give you the value\n2A 6 let's put in this so that's 0a\n3 Let's test this out to so that's 0a\n4 yeah 0a 4 so it's seems like it's\nworking just\nfine yeah so seems like this is working\npretty well so now we have the second\noptimized solution so let's look at the\noptimized solution and analyze it so we\nhave one Loop and then we have a second\nLoop these two are the same but inside\nthe second Loop we are simply doing a\nconstant operation we are just doing\nsome comparisons and one addition not up\nto n additions so the complexity goes\nfrom order of n Cub to order of n squ by\nmaintaining a running sum great\nnow this at this point when you have\ndescribed the solution to the\ninterviewer and maybe also coded it you\nmight ask them is this good enough and\nthey can see that you've you've thought\nabout it you've found the solution and\nyou've tested it and it tests well and\nat this point they may just say I'm\nhappy with the solution this is good\nenough or they may say can you do better\nnow when they say can you do better most\nof the time it suggests that there is a\nbetter solution so let's see let's think\nabout it a little more and let's see if\nthere is a better solution now to can to\ncan you do better we apply the exact\nsame Technique we have analy the\ncomplexity and now we need to look for\ninefficiency okay so now we have removed\nthe inefficiency on this side which is\nas we move j that is\nwhen we reuse the previous sum to\ncompute the next sum so we've removed\nthe inefficiency on this side and we've\nalso added\nthis also added this condition so that J\nonly goes up to a certain point now of\ncourse in the worst case J may always go\nup all the way to the end but at least\nin a lot of cases J will not ex J will\nnot not go beyond a point where the sum\nbecomes larger than the target so these\nare good optimizations but what about I\nwhat about the left window now look at\nthis here when you have 74\nor let's start out all the way at one so\nwe have one that's so first we start out\nwith the empty empty subar that has the\nsum zero then we increment J so now the\nsum becomes one then we increment J now\nthe sum becomes 8 then we increment J\nonce again and now the sum becomes\n12 okay the sum has become 12 now that's\na problem so what do we do what we are\nsaying is we will take I and set it to\nthe next value and then we'll bring J\nback to Z or back to the value I so that\nwe start with the empty subarray once\nagain so now when we do seven and when\nwe so that's that just has the value\nseven and when we do this we have to add\nup 7 + 4 now here's something that we\ncould have done instead now as soon as\nthe value became larger than the target\nvalue we could have simply moved this\nhere does that make\nsense let's think about it so\ntill this point this total was less than\n10 as soon as we added this number on\nthe right this total became more than 10\nnow we know that this total became more\nthan 10 that means\nthat if we slide this window if we Slide\nthe left window forward One Step then\nthe total may become less than 10 right\nit may still became stay larger in this\ncase it stays larger or it may become\nless than 10\nso if the total now becomes less than 10\nthen we can once again move\nthis but the total has not become less\nthan 10 so we will move this\ninstead so now the total again is less\nthan 10 so we can once again move\nthis and now the total is still less\nthan 10 so we move this now the total is\nstill less than 10 we move this and we\nencountered 10 here but suppose we had\nnot encountered 10 suppose this number\nwas four instead then what we would have\nto do is move this right and now the now\nthe number becomes less than 10 so we\nalways go we always try to maintain a\nwindow of size less than 10 the moment\nthe window becomes greater than 10 we\nkeep trying to reduce its sides further\nto less than 10 right or exactly 10 as\nwell it's possible that the size may\nbecome exactly 10 and then the problem\nis solved but we keep trying to reduce\nits size to a value till it becomes less\nthan 10 so to revise the algorithm we\nstart out with both I and J at Z\nZ then we increment J while the running\nnow we have a single running Loop and a\nsingle Loop essentially so we increment\nJ while the sum is less than\n10 the moment it becomes greater than 10\nwe start incrementing I the moment the\nsum becomes less than 10 or less than\nTarget we start incrementing\nJ and if we encounter the point where\nthe sum equals 10 we have found the\nanswer so that's the algorithm so let's\nwrite WR it sub array sum\nthree now this is the array\nTarget now we have a we have I we have J\nand we have sum all of them let's call\nit s because sum is a reserved word in\nPython an existing function so all of\nthese have the value zero then we say\nwhile I is less\nthan Len\narray let's call that n so let's create\nn equal to Len AR\nRR I is less than n and J is less than n\n+ 1 remember because J can take the\nvalue n as well it is the exclusive end\nindex now at this point you want\nto check first so if the sum s the\ncurrent sum running sum is equal to the\nTarget then we simply return I comma\nJ L if sum is less than the\ntarget then we simply increment\nJ okay so now we can move the window\nforward so we we are incrementing J if\nthe sum is less than the\ntarget so we increment J but before we\nincrement J we should add the J element\nto maintain the running sum so here we\nsay s plus equals\nJ or array of J and remember J can take\nthe value n as well so that's where we\ndo this only if J is less than n if\nthere is indeed an element for us to add\nthis is an error we faced last time and\nyou will discover this when you write\nthe test anyway and then we say l if s\nis greater than Target and we can also\njust say else here but just for clarity\nlet's say l if in this case what we want\nto do is we want to move I forward so\nsuppose we end up in a situation like\nthis then we want to move this forward\nfor that we need to subtract s array of\nI first so we s we say s minus equals\nwhich is equal to S\nminus which is the same as s = s minus\narray of\nI and then we increment I so we move the\nleft window forward as\nwell so we then repeat this so we first\nmove j to a point then we as soon as we\ncross the target we start increasing I\nand then we keep doing that till we\nmatch the Target and then finally we\nreturn none comma none if we have not\nfound it so that's our subarray sum\nthree this is seems like the most\noptimized solution and let's test it\nout so here we have subar sum\n3 and let's test subar some three here\nhere as well seems like it worked let's\nsee if you put in 10 here you get 2A\n6 let's say this is 4 213 0a\n4 let's put in 12 here that doesn't show\nup let's put in 17 here 0a\n5 13 1A 5\nlet's try 19 that's 3A 6 let's see 1 + 3\n+ 7 + 9 yeah that has the value 19 let's\nthrow in a zero there and see if it\nworks with zeros that's 3A 7 works\nfine and let's see if it doesn't work\nout yeah okay great so this solution is\ncorrect too again if you don't have the\noption to run the code you can simply\npick one example and walk through the\nworking of the example\nnow we have subarray\nsum three and once again we ready to\nanalyze the complexity and in this case\nthe complexity would be this somewhat\ntricky this is a little bit unusual\nbecause there is a while loop with two\nvariables but remember that in each\nwhile loop either we exit which is the\nbest case so we can ignore that or we\neither increment J or we increment I\nright so we increment J or we increment\nI\nand if we\nincrement uh so J can go from the value0\nto n and I can go from the values 0 to n\nminus one so the total number of\nincrements can we we can do is the sum\nof the number of possible values of I\nand the number of possible values of J\nright remember this is not a product\nthis time because this you do not have a\nnested Loop so for each value of I\nyou're not doing this rather you are\nincrementing each one and I only one of\nthem each time so the some of total\nnumber of values I can take is n the\ntotal number of values J can take is n +\n1 so the total\nbecomes the number of iterations becomes\n2 n + 1 now of course there's the you\ncan verify that a constant amount of\nwork is being done here so we finally\nend up with the conclusion that this is\nan order n algorithm okay so this is\nfinally an order n algorithm so this is\na good example of a problem where the\nstep\nby-step solution coming up with a simple\nsolution and then thinking about\nthe inefficiency in the problem and then\napplying in this case just common sense\nto solve the inefficiency step by\nstep leads to the perfect solution and a\nvery good solution in fact so you start\nout with a order n Cube solution order\nand cube is going to be pretty slow when\nyou start hitting let's say even a\nthousand even a, elements if you have\n10,000 elements it'll take forever it'll\ntake maybe an hour or so if you have a\nmillion elements it will take hundreds\nof years on the other\nhand order n can work fine all the way\nup to a billion element right so there's\na huge difference between the subar sum\n1 2 and three subar sum 3 can work\ninstantly for a billion elements sub\nsome one will take forever even for\n100,000\nelements and sub add it to is in between\nand you can do the\nmath and this technique where you can\nalmost certainly tell what the next what\nthe next step is so this was not really\nrelated to any of the algorithms or data\nstructures that we have talked about\nthis is what is called a greedy approach\nwhere you know some optimal strategy\nabout the problem in this case you know\nthat we can calculate the sums by\nmaintaining a running sum so we just do\nthat and then you also know that as soon\nas it becomes greater than a Target we\nneed to break out and then you know the\nnext thing that when becomes greater\nthan Target rather you can simply up\nupdate I so this is what what is called\na greedy approach where you somehow know\nthat just doing this will fix it right\nthere's no real technique to be applied\nand these problems are somewhat tricky\nbut you get the hang of these problems\nas well if you search for greedy\nproblems online you get the hang of\nthese by solving a few practice\nexercises okay so that's our first\ninterview\nproblem and we've solved it in about 45\nminutes and this is approximately how\nlong you will have for an interview in\ntypical 45 minute to 1 hour interview\nwe'll have about a couple of minutes of\nintroduction maybe a few minutes just\nyou talking about a project and the\ninterviewer asking you questions but\nthen the next 30 to 40 minutes will be\ndedicated towards solving a\nproblem and this is what roughly the\nprocess will look\nlike let's do one more example let's\npick another interview question and\nlet's see if we can solve this one so\nthis is slightly different so this gives\nus one more variation to study\nby the way to run these you simply click\nthe Run button and select run on\nbinder okay so this is an interview\nquestion that was asked during a coding\ninterview at\nGoogle and the question is given two\nstrings A and B find the minimum number\nof steps required to convert a into B so\nwhat you can do is you can perform\noperations and each operation is counted\nas one step and the operations you can\nperform on a word are these you can\neither insert a character into the word\nor you can delete a character from the\nword so for instance here you can see\nthat we are trying to convert intention\ninto execution so either you can insert\na character for example you could insert\nC here or you can delete a character for\nexample you can delete I here or you can\nreplace a character that is you can can\ntake n and replace it with e you can\ntake T and replace it with X and E does\nnot need to be replaced and here we've\ninserted C and then here we substituted\nn for you right so we've taken the word\nintention and by performing a few\nchanges character by character by either\ninserting deleting or replacing a\ncharacter we have converted it into the\nstring\nexecution so the number of steps\nrequired here is 1 2 3 4 5 now now\nhere's a challenge for you try and work\nthis out on paper and prove that this is\nthe best solution so because we need to\nfind the minimum number of steps\nrequired to convert a to\nB okay so that's the problem and this is\na moderately hard problem and variations\nof this show up as\nwell so let's start applying the method\nnow when you hear the problem a solution\nmay not strike you up front that's\nperfectly all right don't panic\nsometimes when you're not able to\nimmediately come up with the solution or\nidentify how to solve this problem you\nenter a sort of panic and then you're\nunable to think don't do that remember\nhave faith in the method and we will\napply the method and come up with a\nsolution step by\nstep so the first thing is to State the\nproblem in your own words so given two\nstrings we need to perform operations a\nseries of operations on the first string\nthe operations could be deletion of a\ncharacter substitution of a character\nwith another character or insertion of a\ncharacter and through these operations\nwe need to convert it into a second\nstring okay we have understood the\nproblem if the interviewer had not given\nan example either you can State the\nexample or you can just ask for an\nexample whatever makes works for\nyou so we've stated the problem now what\nare the inputs to the problem so the\ninputs are two strings so the inputs are\nstrings like intention and execution so\nlet's see maybe let's call them Str\nstr1 this is\nintention s\nstr2 this is execution now one thing you\nhave to be careful about here is you do\nnot want to capitalize because sometimes\nwhat might happen is this I may match up\nwith an i here in the in the proper\nsolution but python obviously treats\nsmall and capital letters differently\npython doesn't know what's that that the\nI which is lower case and the I which is\nuppercase is the same so you will not be\nable to compare them so just to keep\nthings simple either make everything\nuppercase or make everything\nlowercase but yeah this is what the\ninput looks\nlike and the output is going to be a\nsingle number so the output is simp\nsimply going to be the edit distance so\nlet's just call it output one and it is\ngoing to be the number\nfive and here is something that you can\nverify so that's the input that's the\noutput\nand function\nsignature so of course this term edit\ndistance is how this problem is\ndescribed but here there is no edit\nthere's no concept of edit distance\nthat's mentioned so you can give a\nfunction name that makes sense for this\nproblem so find the minimum number of\nsteps required to convert a to B okay\nso let's just call it Min steps for\nnow so the function definition would be\nMin steps and this would take an S str1\nand this would take an S str2 and it\nwould return an output for now we'll\njust put in pass\nhere all right so now we have already\nclarified the problem if you had any\nquestions this is this would have been a\ngood time to ask the interviewer and\nmake sure that you have a clear\nunderstanding now you have stated the\ninput output and function\nsignature the problem has been\ncommunicated back and forth properly the\nfirst step is done the next step is to\nlist out some test cases right once\nagain a very good quality listing out\nsome test cases so you can say that now\nI'm just going to list out a few cases\nthat I want my function to cover so that\nthey will help me it will help me while\nwriting the code now one is the general\ncase which is uh listed above so this\nwould be intention execution and we can\ntake a few more examples like this now\none example could be where\nwhere no change is required so you are\ngiven the same\nstrings one case could be that all\nthe\ncharacters need to be\nchanged so these are the two extreme\ncases one is no changes required and\nsecond is all characters need to be\nchanged maybe added removed deleted lots\nof such things then you can check both\nstrings of equal length so in this case\nthey are in fact of equal length unequal\nlength you can check both strings of\nunequal length one of the\nstrings is\nempty your function should be able to\nhandle that\ntoo then you may check things like it\nwill if something only requires deletion\nif something only requires addition or\nif something only\nrequires swapping right such\nthings I guess this is pretty good at\nthis point so now we can probably move\nforward so we have stated some test\ncases now you don't need to create all\nthe test cases right now in an interview\nit can take a take a bit of time so\nlet's just move ahead and the next step\nis to come up with the simplest solution\nto the problem which is also called The\nBrute Force solution so now we have a\nlot more information about the problem\nin this meantime probably it has sunk\ninto you and you may have been able to\nthink of a Brute Force solution but if\nnot don't worry there is a simple trick\nI'll tell you which you can apply\nwhenever you are stuck and you can't\nthink of a Brute Force solution so we\nlooking at you're looking at it\nintention execution what am I going to\ndo am I going to start from the left and\nright how do I check which one\nis how do I know if this is going\nsupposed to be inserted or executed or\nreplaced or substituted or\ndeleted so the simple trick is whenever\nyou're in doubt\nthink about recursion see if there is a\nway to solve this problem recursively\nand what do you mean by solving a\nproblem recursively can you reduce the\noverall problem\nto a combination of one or more sub\nproblem so if you take a portion of the\ninput and can you solve the same problem\non the portion of the input and then use\nthat to solve the overall problem okay\nso let's see let's see if there is a\nrecursive solution possible here\nso here I have the same thing intention\nand execution now with recursive\nSolutions normally you either start by\nlooking at the first character or the\nlast character so let's look at the\nfirst character character of each string\nright so we've given these two strings\nand we need to find the number of\noperations to change this string into\nthis string let's look at the first\ncharacter now suppose the First\ncharacters were in fact equal suppose\nthis was not intention but it this was\nintention and this was execution so now\nwe compare the First characters and we\nknow that the First characters are equal\nokay so if the First characters are\nequal then obviously neither of them\nneeds to be deleted\nor removed or obviously this character\ndoes not need to be deleted or removed\nor switched it's already matching so\nwhat we can do is we can just ignore the\nfirst\ncharacters and we can simply look at the\nremaining string okay so intention and\nexecution because the First characters\nare already equal let's write that down\nso that we don't forget\nit and this is the recursive solution\nnow this is where you can take a moment\nto work this out on pen and paper and\nthat's perfectly all right what helps us\nto just talk keep talking about what\nyou're doing but for recursion now first\nthing we know is if the first character\nis\nequal then ignore from both so you just\nignore the charact first character of\nboth strings and simply recursively\nsolve the problem for the sub list or\nthe sub string without the First\ncharacters in each of the strings right\nso you exclude e and exclude E from this\nand solve the problem for these two\nperfect now suppose the first character\nisn't equal so that's another case now\nright so that is the case where you have\nintention and\nexecution so if the sub if the first\ncharacter is not equal then\neither the first character has to be\ndeleted or the first character has to be\nswapped so you may you may have to swap\nI with e or the first charact or maybe\nsomething needs to be added before the\nfirst character okay now let's see one\nby\none so\nif the first character is not\nequal either it has to be deleted\nor\nswapped or a character inserted before\nit there are only three possibilities\nright of course it's possible that we\nmay do some other things insert\ncharacters after after it and so on but\nat that position after applying an\noperation either the first character\nwill get deleted or the first character\nwill get swapped and will be changed to\ne or the first character will now change\nto some something else and the first\noriginal first character will become the\nsecond character\nokay now let's look at each case the\nfirst case is it has if it is deleted\nnow the power the beauty of recursion is\nthat we don't need to guess which\nsolution it is we can try all three\nrecursively and then simply pick the\nbest one so suppose we choose to delete\nthe first character so suppose we say\nthat we are deleting the first\ncharacter now what that means is we've\nperformed one operation and we've\ndeleted the first character so now what\nwe left with is\nthis so now what we end up is the second\nthe string has remained the same only\nthe first string has changed where we\nhave lost the first character now what\nwe end up with is with the sub problem\nwhere we need to find the minimum number\nof steps to change n tension n t n t o n\ninto execution okay so in this case if\nit has to be deleted\nthen recursively find\nthen recursively solve after ignoring\nfirst character of Str str1\nokay that's one\npossibility and the you get the\nrecursive solution and you simply add\none to it that tells you the solution if\nyou delete the first character the next\noption is that we change the first\ncharacter I to e now if we change the\nfirst character I to e so one operation\nhas been performed and then now these\ntwo have become equal now that these two\nhave become equal we can move this\nforward and we can move this forward so\nnow we can simply recursively solve the\nproblem for end tension and execution\nfind the minimum edit distance between\nthe two and simply add one to it to get\nthe number of steps required to change\nintention to\nexecution\nby swapping the first character right\nfrom I to e so in this case you\nrecursively\nsolve After\nignoring the\nfirst character of each right so it is 1\nplus in both cases it is one plus the\nrecursive solution After ignoring the\nfirst character of\neach because the one operation is\nsomething that has been performed okay\nnow the final\ncase the final case is you have\nintention and exec ution now we decide\nthat we are going to shift the string\nforward and we are going to include we\nare going to introduce an e here so we\ngoing to introduce\ne here so now what happens is the E is\nmatching the E now I has gone on to the\nfirst position I has gone on to the next\nposition here so effectively what has\nhappened is that we need to recursively\nsolve the problem for the original\nstring intention and the second string\nwith the first character remove mod\nbecause we have inserted something\nbefore the first character in the first\nstring so that is going to match with\nthe first character of the second string\nand hence we simply need to recursively\nsolve the problem for these two in this\ncase what we are doing is the solution\nis 1\nplus\nrecursively solve After ignoring the\nfirst\ncharacter of St\nstr2 okay sounds good looks like we've\ndone that now what's the end solution\ngoing to look like the end case remember\nin recursion this is all well and good\nbut at some point we are going to hit\nsome kind of an end so let's see let's\nsee if we can Define such an end\nscenario so maybe let's say we have been\nperforming recursion and then we ended\nup at a situation like this\nwhere there is nothing left in the\nsecond string but you still have some\ncharacters left in the first string\nright so you're at this position now and\nhere this is gone there's nothing left\nuh in the second string\nso in this\ncase to change recursive to change TI\ninto the empty string all we need to do\nis delete all four so so if you have a\nfew character if you if the second\nstring becomes empty then you simply\nfind the number of remaining characters\nin the first string and delete them so\nthat is the number of operations four\nthe other possibility is that the second\nstring still has some characters but\nyou've run out of characters on the\nfirst string so if you run out of\ncharacters on the first string but the\nsecond string still has some characters\nthen in that case what you need to do\nobviously is you have the empty string\nand you need to take\nthis convert this empty string into t o\nn that is a recursive problem we solving\nso you that you can do by adding t i o n\ngreat so you add t i o n and that is\nagain going to be four steps which is\nthe number of characters remaining in\nthe second string okay so these are the\ntwo end cases now of course if both of\nthem are empty then the answer is zero\nbut if either of them is empty the\nanswer is the number of remaining\nelements in the other one so let's write\nthe solution now we figured out the\nsolution it took some time but again\nthis is not a very straightforward\nproblem so there are a few cases to\nfigure\nout and while you are doing this while\nyou're identifying each case either you\ncan say it out loud to the instructor or\nyou can write it as a comment whatever\nyou feel more convenient with\nbecause the interviewer cannot see the\nwork that you're doing on paper so it's\nvery important for you to be able to\nconvey it and that is why all this while\nin this course we have been saying that\nyou need to express the solution in\nsimple words because you need to tell\nthe other person that you know the\nsolution and they should be able to\nunderstand what you're saying without\nlooking at your work without looking at\nthe images that youve\ndrawn and a great way to do it is either\nby wrting writing or by\nspeaking let's define it then def what's\nit called M\nsteps and M steps is it takes Str str1\nand Str\nstr2 great now we are doing recursion\nand in recursion what we're tracking is\nthe the which character we are currently\nat so we could be at the zeroth\ncharacter or the first character or the\nsecond character in string one\nand we could be at the zeroo character\nsecond charact first character second\ncharacter in string two right so the the\nstarting point of this window determines\nthe sub string that we are solving the\nproblem for so\nideally we when we want to solve this\nproblem for these two substrings we can\nsimply pass those substrings but\ncreating sub subl list or substrings as\na cost because you have to copy those uh\ncharacters out and then allocate some\nmemory and put them into a new place so\nan easier way is to simply keep a\npointer so we will keep two pointers i1\nand\nI2 and these will\nsignify that we should be skipping while\nComputing M steps we should be skipping\nthe First i1 characters or we should be\nstarting from the i1 index and we should\nbe starting from the i2th index for S\nstr2 okay so in your window if the i1\nWindex if the starting if the starting\nindex is equal to the length of string\none so this is the the end case and\nremember the end case while coding is\nalways written first so if this is equal\nto length of s str1 then we have known\nwe have seen here that we need to\nperform these many\nadditions so we simply return in this\ncase Str Str Len of Str\nstr2\nminus I2 right and you can verify that\nthis is the amount number of additions\nrequired L if on the other hand I2 is\nequal to to Len of S strr 2 so which\nmeans that you have exhausted the second\nstring but the first string still has\nsome values left so in this case you\nneed to remove the delete the return\nremaining values in the first string so\nyou just type Len of s\nstr1 minus\ni1 great so these we have now solved the\ntrivial cases now let's see L\nif Str str1 of\ni1 and Str str2 of I2 which means the\nFirst characters of each substring that\nwe are working with right remember we\njust using arrays as a we just using\nindices as a optimization what we really\nwant to work with the substring so the\nfirst character of each substring s str1\nof i1 and S str2 of I2 is equal now if\nthe first character is equal e and I are\nequal then we simply ignore both and\nsolve the problem for the remaining\nstring so we simply say return main\nsteps and we pass pass in s str1 we pass\nin s str2 and then we simply pass in i1\n+ 1 here and we pass in I2 + 1 here so\nwhat this is saying is that now we want\nto recursively solve the\nproblem for a substring starting at i+\ni1 + 1 so we have ignored the first\nstring of the current substring and\nsimilarly we have ignored the first\ncharacter of the current substring for\nof the second string okay so we ignore\nthe first characters and that's it and\nthere are no steps required here no\noperations required here right now\nbecause the first characters are equal\nnow finally this is the final case\nelse here we want to return one so we\nhave to perform one operation either it\nis an insertion deletion or\nSwap and what we can do is we can\nrecursively check the cost or the number\nof minimum steps required for each case\nof insertion deletion and swapping and\nsimply pick the minimum one and if to to\nit we add one then we get the total\nminimum number of steps we need to\nperform for the entire list right so\nagain recursion is very useful because\nyou can simply assume that you have the\nfunction which solves the problem and\nyou simply need to take the result of\nthe sub problem and combine them so we\ntake the minimum of the first option is\nif the first character of s str1 has to\nbe\ndeleted so which is let's say we choose\nto delete I if we choose to delete I\nthen that means we have to solve the\nproblem for these two so we say 1 plus\nRec cursively solve the problem after\nignoring the first character of Str str1\nso we solve main steps for str str1 s\nstr2 now since we've deleted the first\ncharacter of s str1 we can skip ahead\ninto the next because we are solving the\nproblem now for the from starting from\nthe next index and I2 Remains the Same\nright so remember here we have not\naffected I2 so we need to solve this\nproblem\nrecursively so this was the case of\ndeletion\nnext we have the option\nwhere you have swapped the first\ncharacter so we have taken e and we have\nconverted that it in we have taken I\nconverted it into an e if we did that so\nthen we can say that okay now these two\ncharacters are matching so now we can\nsimply recursively solve the problem for\nthe next character onwards After\nignoring the current character so this\nbecomes S str1 Plus s str2 + i1 +\n+ 1 + I2 + 1 great so this\nis swap or\nreplace and you might notice that this\nis this turns out to be the same\nrecursive call as this except that we\nwill add one to it because we have done\nthe Swap and finally if you are adding\nso if you're add\ninserting so finally if you're inserting\nhere something so if you are inserting e\nhere let's\nsay so in this case what we'll do is now\nwe'll recursively solve the problem for\nintention and execution without the e in\nfront so we skip the first character of\nthe second string so we have main steps\nStr str1 Str str2 i1 and I2 +\n1 so this is rather nice and symmetric\nand that's it so this should be it let's\nrun this okay there is a syntax error\nhere that's perfectly\nfine there needs to be a comma here\nthat's fine\ntoo I make a lot of syntax errors all\nthe time and of course off by one errors\nI'm sure there are a few but yeah this\nis the minimum number of steps and this\nis the recursive function not too bad 2\n4 6 around eight lines of code and let's\ntest out some of the test cases\nhere I'm just going to copy the test\ncases out here\nbelow and let's test a general case\nwhich is intention and exception so\nlet's see M\nsteps\nintention and exception\nit says five\nfour okay why does it say\nfour maybe let's test\nuh let's test a more simpler case first\nwhich is one of the strings being empty\nlet's say we have intention and one of\nthe strings is empty so we will need to\ndelete let's just say int and one of the\nstrings is empty this looks fine we will\nneed to delete all three of these\nand that in some way tests out this case\nwhere or sorry tests out the second case\nwhere the second string is\nempty now we can test this\ncase in this case also the in this case\nalso the solution is three great looks\nfine let's test this case where S str1\ni1 and S str2 I2 are equal so if you\nhave integer and let's say you have\nIndia\nso i n i in would be the same so these\nwould get skipped and here is where the\nrecursion would kick in so T would have\nto be changed to D and then you would\nhave to add I and a okay that looks fine\ntoo then let's check intention and\nexception once again I don't know what's\nwrong\nhere let's see\nso POS is it possible to do it with four\nI don't know it's may be possible to do\nit with just four\nchanges if you change I you delete I and\nthen you delete n and then you delete t\ndelete I substitute these\ntwo I don't think it is possible with\njust four\nchanges so there's probably an\n[Music]\nissue I don't know what's wrong here\nit's possible I may have made a mistake\nhere let me try\nanother Saturday and Sunday\nokay so Saturday sat needs to be changed\nto Sunday s\nn now s is the same so a t Ur needs to\nbe changed to u n so U Remains the Same\nnow if we can what we can do is we can\nprobably delete a delete\nT and take replace r with n so this\nseems to be fine\nall right so we'll probably unless I'm\nnot seeing this so you have\nintention and you\nhave\nexception unless I'm not seeing\nsomething it seems like we may have made\na mistake one one thing we could do is\nwe can simply print out the strings that\nwe are checking so let's see s str1 is\ni1 onwards and S Str 2 is I2 onwards\nwe first checking intention and\nexception then we\ncheck let's also print the result\nhere okay so at this point I would\nprobably look through the loop here and\nsee if the see if it is correct coming\nproperly so you have intention and\nexception first we delete I then we\ndelete n then we delete n then we delete\nT then we delete okay then we compare e\nand e so then we come back to n and\nexception and so on I think we have this\nmight take some time to fix we'll come\nback to intention and exception but\nsupposing we've solved the\nyeah supposing we've written the\nrecursive solution correctly and I do\nhave the recursive solution here let me\njust grab that and put that in\nhere let's see what's\ndifferent okay probably the answer is\nfour because I'm still getting four but\nsupposing we have the recursive solution\nhere so we have Min edit distance this\nis the recursive\nsolution and now what you need to do is\nyou need to find out the complexity of\nthe recursive solution so now to find\nthe complexity of the recursive solution\nwhat we can do is simply look at the\nrecursive calls in the worst case so how\nyou start out is you start out with a\nstring of length N1 let's say and a\nstring of length N2 you have one string\nof length N1 and one string of length N2\nthen you call either you call this m\neded distance with i1 + 1 and I2 + 1 so\nStr str1 and Str str2 you call them with\ni1 + 1 and I2 + 1 so that's one\npossibility\nor you call three recursive calls now\none recursive call is the good case\nwhere these two match up so we want to\nlook at the worst case where where these\ntwo things don't match up so in that\ncase you make three recursive calls\nright so you make three recursive calls\nand in each recursive call you are then\ngoing to reduce the problem size by one\nso you either going to decrease I2 or\nyour either going to decrease the size\nof the first string or you're going to\ndecrease the size of the second string\nor you're going to decrease the sizes of\nboth strings right so just to keep\nthings simple let's assume that in all\nthree we are decreasing the size of\neither one of the strings by one so we\nare decreasing the total problem size\nwhich is N1 + N2\nby one right so the number of levels of\nrecursion is going to be the total\nnumber of total length of each of the\ntwo strings so let's maybe just draw\nthat graph here as\nwell so let's take this so here you have\nN1 comma N2 so let's assume these are\nthe lengths of the two strings\nnow N1 + N2 what happens to\nit is that\nthis N1 plus N2 calls three recursive\nfunctions so there are three recursive\nfunctions so let's just draw those three\nrecursive functions\nso we have those three recursive\nfunctions here let's take this\ntwo and then those in those three\nrecursive\nfunctions what we have\nis either you reduce either you reduce\nthe size of the first string or you\nreduce the size of the second string or\nyou reduce the size of both\nstrings so either you end up\nwith N1 -1 and\nns2 and let's reduce the size of\nthat or we end up\nwith\nN1 and N2\nminus1 or we end up with\nN1\n-1 and N2\nminus1 okay so these are the three\nrecursive calls that we're doing and\nthen each of these will once again make\nthree more recursive\ncalls and so on now what is the depth\noverall depth of this recursive call now\nbecause we can see that each time the\nsize of the problem reduces by one so if\nthe size of the problem is N1 by plus N2\nin this case it reduces by one in this\ncase it reduces by one and in this case\nit reduces by two but for simplification\nlet's say it reduces by one here so the\ntotal size of the problem the total\nnumber of levels in this tree is going\nto\nbe N1 +\nN2 so you have three problems in the\nfirst layer the second layer will have\nthree Square problems the third layer\nwill have three Cube problems so 3 * 3 *\n3 and similarly you can go ahead and you\nwill find that at the last layer you'll\nhave 3 to the^ NL Plus N2 minus one\nlayers right and if you then add\ntogether all the layers what you end up\nwith is that total total number of sub\nproblems is 3 to the^ N1 + N2 right so\nyou have a total of 3 to the^ N1 + N2\nsub problems that you end up\ncreating and because of\nthat you have the complexity 3 to the^\nof N1 + N2 in this case okay so that's\nthat's the complexity so here we have a\nrecursive solution and then we have the\ncomplexity of the recursive solution\nwhich is exponential 3 3 to the^ of N1 +\nN2 now at this point it will make sense\nto add memorization so whenever you see\nrecursive Solutions and you see repeated\nproblems for example here itself you can\nsee a repeated\nproblem and then you can see that this\nproblem will get repeated inside this\nproblem and inside this problem too so\nthere are a lot of repetitions and all\nwe need to do is remove some of those\nrepetitions and to remove those\nrepetitions we can use\nmemorization so what happens in the\nmemorized solution it is exactly the\nsame as the recursive solution but\nbefore doing any computation we check a\nmemo we check a dictionary if we already\nhave the solution for the changing\nvariables which is i1 and\nI2 and if we have\nthose if we have those Solutions what we\nneed to do is just return them directly\nif we do not have those Solutions we\nneed to compute the solutions put them\nin the memo and then return the value\nfrom the memo so let's write the\nmemoized version so we have Min edit\ndistance with st str1 and Str\nstr2 and this we're calling memo\nokay this we're calling memo so now we\nhave a memo the memo is going to be a\ndictionary and the dictionary is\nempty and then we Define a function\nrecurse so in say in memorization\nnormally you have to write a recursive\nhelper function now you can either write\nthis outside or\ninside I like writing this inside\nbecause well it will have access to S\nstr2 and they do not need to be passed\nin so here we have i1 and I2 and first\nthing we do is we create a key so the\nkey is i1a I2 now if key in memo which\nmeans if we have already computed the\nsolution then we simply return memo of\nkey if not then we have all the other\ncases so now we have\nLF now we can check if i1 equals Len of\ns\nstr1 in that case don't return set the\nmemo of key\nto Len of s str2 minus\nI2 LF I2 equals Len of\nsdr2 then we return\nmemo of key is len of s\nstr1 minus\ni1 LF okay in this case then we check if\nthe first elements are equal so we have\nthe exact same logic you can see the\nsame Cas is coming up here so if you\nhave S str1 of i1 equals s str2 of\nI2 in this case we have mem of E equals\nwe simply ignore the first character so\nwe increment i1 and I2 so exactly what\nwe have done here so we simply call\nrecurse this time with i1 + 1 and I2 + 1\nright so we always call the recursive\nfunction but inside the recursive\nfunction if it if it has already been\ncomputed it will return from the\nmemo and finally if we\nhave and this is the final case which is\nwhere they are not equal so here memo of\nkey\nbecomes 1\n+ Min of\nlet's see here so we have recurse so the\ninsertion\ncases we will ignore the first element\nsorry the deletion cases we will ignore\nthe first element of the current range\nfrom the first string so we call recurse\nwith I i1 + 1 and I2 otherwise we call\nrecurse with i1 + 1 and i1 I2 + 1 this\nis the case where we swap the first\nelement of the first string so we can\njust recursively check after ignoring\nthe first element of each and then we\nhave recurse with\ni1 comma I2 +\n1 I2 + 1 and there we go and that's it\nso now we have stored it in the memo and\nthen we simply return memo of key at the\nvery end and finally we call\nrecurse 0 0 and that is our solution\nokay and there is there's a syntax error\nyou can fix fix these syntax errors\nthey're easy to fix and I've just\nrealized that the solution in this case\nmight actually be four because what we\ncan do is we can change n to P so that's\none step we can replace I and T with EXC\nso we replace I and T with EXC that's\nthree changes we don't change e and we\nreplace n with P the solution is four so\nour solution was correct\nthere was no issue\nthere in fact this is not the best\nsolution this is a suboptimal solution\nso this output should be\nfour and that's okay this is something\nthat happens all the time where you miss\nsomething and you just assume that you\njust say that you're going to come back\nto it at the end and then you move\nforward assuming that that code was\nright and then you realize that either\nyou were correct or what your mistake\nwas\nit's probably going to happen in one of\nfive interviews anyway okay so now we've\nwritten a memo solution great and we can\nstart checking the memo solution now so\nminimum edit distance memo so let's call\nMain edit distance memo and we get back\nthe value four looks fine let's try\nSaturday and Sunday as we have\nso that's three so what you will do is\nyou will leave a as it is change a to un\nn by removing at and changing R to n\nthat seems fine let's test out some\ncases like this okay this is 3 68\ncharacters so that seems right we simply\ndelete all the\ncharacters let's check out\nthis here also eight characters we have\nto add eight character ctors let's say\nwe have AB C and XYZ so this should be\nthree if it is XY z k then maybe that\nwill be four what if it's XY z a in this\ncase also it's\nfour so this seems to be working\nfine we have now taken the recursive\nsolution identified the inefficiency\ncalculated the complexity which was\nexponential identified the inefficiency\nand which was repeated sub problems\nand then fix the inefficiency by calling\nmain edit by by using\nmemorization and now how do you compute\nthe time complexity of memorization well\nthe argument is if you only need to\ncompute the solution for a key once and\nthe computation apart from the recursive\ncalls simply involves some comparison\nand a a fixed number of comparison and\nan addition so the time required to\ncompute assuming you have the recursive\nSolutions is constant constant so that\nmeans if you simply count the number of\nmemorizationscripture\nit N1 *\nN2 that's a number of keys and that\nbecause there's a constant amount of of\ntime additional time required to compute\nthe solution for a key that is also the\ncomplexity so the complexity is order N1\n+ N2 so we've gone from 3 to the power\nof N1 + N2 which grows very quickly even\nfor 3 to the power\nof 3 to the power\nof 10 is pretty high we can check it out\nhere 3 to^ of 10 is something like\n59,000 3 ^ of 100 so if you have N1 + N2\nthen that's e to the 47 that's going to\nbe a lot of operations on the other hand\nif for in with memorization it is only\ngoing to take let's say the 100 is split\nas two strings of length 50 and\n50 only going to take 2,500 operations\nso where it was taking 10 to the 47\noperations now it takes\nonly 2,500 operations which is pretty\nsmall so you can still work with lists\nof size up to 10,000 or 100,000 very\neasily using the memoized\nsolution so that covers this problem and\nkeep talking through your solution even\nas you're stuck even as you're confused\njust as I was it's helpful to just keep\nspend maybe 2 or 3 minutes trying to\nsolve the issue and if you're not able\nto solve the issue just say that this is\nsomething I'll fix later and then move\non assuming that you've fixed it and\nthen keep talking and keep continue keep\nworking on the solution and at some\npoint later it's possible that the\nsolution might strike you\nokay now at this\npoint you may be asked sometimes to\nimplement a dynamic Pro programming or\nan iterative solution like the when you\ntalk to the interviewer and you're\ntelling them that this is how I'm\nthinking I'm doing I'll do a recursive\nsolution first and I can see that maybe\nthere are going to be some sub problems\nthere then I'm going to then uh apply\ndynamic programming\nso you can just check with them and in\nmost cases they will accept a\nmemorization solution because the\ndynamic programming Solutions can take a\nlittle bit of time to solve to implement\nand they're always off by off by one\nerrors and it's also difficult to\nexplain the solution so you can most\nmost cases get away with memorization\nbut if they do ask you to do it with\niteratively with dynamic programming\nthen you'll have to go ahead and\nimplement the dynamic programming\nsolution so once again take a couple of\nminutes now and work it out on a piece\nof paper and then go back to them now\nfor dynamic programming remember you\nhave to create a table essentially so\nwhat the table will look like in this\ncase is let's see if we can simulate a\ntable so what the table will look like\nis let's create a new\nsheet and in this sheet let us put the\ntwo words which is\nintention okay and let's put the word\nexception as well\nmove this down to and let's also put in\nthe\nindexes ultimately this is what a\ndynamic programming looks like\nprogramming problem looks\nlike you are ultimately going to create\na table here\nand how we'll start filling the table is\nthe I element so let's say this\nelement in in t i in t e ex C so this\nelement represents the eded distance or\nthe number of operations required to\nconvert I and te into ex ex\nC and how do you check what the solution\nis now you know that e and e\nare equal so the final elements are\nequal so what that means is we look at\nthis value then this value should tell\nus what is the minimum edit distance\nbetween exe and exe now since we can\nsimply add e to each string and get this\nsolution that means this solution is\nequal this value should is equal to this\nvalue all right so in the case where the\ncorresponding elements are equal we\nsimply copy over the value diagonally\nleft top left value onto the current\ncell the other option is if they are not\nequal so let's say if we are here where\nhere you have n and here you have P now\nthere are three possibilities you you\nwant to\nfind the minimum Ed distance between I\nand t n and E ex c\np now n is not equal to p and this is\nthe original string so either we delete\nn now if we delete n then we need to\nfind the solution for I and te and ex C\nso if we delete n then this value will\nbecome 1 plus this value that's one\npossibility or another possibility is\nthat we swap n so we swap n for p so now\nyou get this becomes p and this becomes\nP so this value becomes will become one\nplus this value because now we can\nignore the p and simply get this\nprevious solution for e exce and I and\nte so this value becomes one plus this\nvalue or the final option is that you\ncan insert something just before n so if\nyou insert something just before\nn which is going to be P so if you\ninsert P just before\nn sorry you insert P just after n not\nbefore if you insert P just after n then\nyou have P after it already so you can\njust look at this value and this value\nis going to be one more than this value\nin the case that you insert something\ninsert P after n right so there are\nthree ways to come to this value either\nby deleting n or by inserting P or\nby changing n to p and what you can do\nis you can take the minimum of three\nvalues or these three values and add one\nto obtain this value so that's the logic\nroughly speaking and you start from the\nleft so you see okay e and i they are\nunequal so you need one operation to\nchange them and there's nothing else to\nconsider so that's done then e and n n\nthey are unequal now you need what you\ncan do\nis you can either delete\nn if you delete n then you simply need\nto check e and\nI and you know that the solution for e\nand I is one so this would be two\nanother another option is that you could\npossibly insert something but if you\ninsert something the length of I in is\ngoing to increase so that's going to\ncause a problem so you can't insert\nanything another is you change n with e\nbut if you change n with e then you will\nno longer be able\nto uh if you change n with\ne then you'll no longer be able to use\nthis\nsolution right because now you will have\nto match I with the empty list so that's\ngoing to be one as well so overall you\nend up with two and this is how you\nstart filling the list so you start\nfilling up from left to right and left\nto right and keep going top to bottom\nand as you fill out the list finally you\nwill fill out this final value exception\nand intention and that will be your\nsolution so that's a dynamic programming\nsolution and you can see that it's\ngetting tricky to to convey the entire\nsolution because there are so many cases\ninvolved here so typically you will not\nfind dynamic programming solutions to\nrequested in interviews and it will help\nyou to just stick to the memorization\nSolutions all right so with that we have\ncovered two common interview questions\nand you can keep going so the idea here\nis to just apply the method remember the\nremember the method the problem solving\ntemplate that we've covered State the\nproblem identify input and output\nformats write a function signature come\nup with some example inputs and outputs\nor at least the scenarios come up with a\ncorrect solution stated in plain English\nimplement the solution test it using\nexample inputs and fix bugs if you face\nany then analyze the algorithm's\ncomplexity and identify inefficiencies\nand finally apply the right technique to\novercome the inefficiency and you repeat\nthe process going back and stating the\nsolution implementing analyzing and\nrepeating now you in some cases you do\nnot need to implement the root Force\nsolution if you don't have the time but\nwhen you're working with recursive\nSolutions it always helps to implement\nBrute Force first before you do\nmemorization or dynamic\nprogramming and some tips ask questions\nas many questions as you can as many as\nyou need to clarify the problem Show an\nexample follow the method Don't\nPanic if you get stuck at a certain\npoint give it a couple of minutes\nsometimes you can even ask the\ninterviewer and they may be able to tell\nyou that maybe what your error is or\nmaybe you're not stuck at all what\nyou're you're simply assuming something\nincorrectly but beyond a few minutes\nwhat you want to say is that let I'll\nfix this later assuming this is correct\nlet's move on and then talk about\ncomplexity and and optimization and and\nsuch and such\nokay very important is to State The\nBrute Force solution to the interviewer\nand if you are unable to figure out a\nmore optimal solution then the best\nthing you can do is to uh offer to\nimplement the Brute Force solution so\nthat you can at least demonstrate that\nyou are able to write code and it's all\nright in a lot of cases you will not be\nable to figure out the optimal solution\nand in some cases there may not be an\noptimal way so there are some there are\ncertain problems where there is just one\nway and that is the hard way or the\nBrute for way and this is typically very\ntrue with a family of problems called\nbacktracking something we've not really\ncovered in a lot of detail but it is\nalso another form of\nrecursion so what do you do next so the\nnext step for you is is to review this\nlecture video and solve these problems\nyourself or take more problems ideally\nwhat you want to do is you want to take\nall the five different techniques that\nwe've covered and let's quickly review\nwhat those five techniques\nwere the first one was binary search so\nwe looked at linear search and binary\nsearch which is a form of divide and\nconquer and along with that we also\nunderstood the complexity and Big O\nnotation and then you had some homework\non link list and python classes but\nbinary search is something that comes up\noften and the hint to detect binary\nsearch\nis simply to look for order whenever you\nsee something being something being\nmetion mentioned as sorted now that is\nan indication for you that this may be\nbinary search sometimes what you may\nhave to do is you may have\nto get things into a sorted form Maybe\nby\ntaking replacing Elements by sum of\nvalues till that element or so on and\nonce you get things into a sorted form\nmaybe then you can do binary search\nthat's one way to go about it and once\nagain just do five to 10 problems on\nbinary search and you will be able to\nidentify pretty much any binary search\nquestion in an interview\nthen the next topic that we looked at\nwas binary search trees\ntraversals and here is\nsomething that is uh generally asked\nvery directly so you will be given a\nquestion like binary search tree do\nsomething with a binary search tree and\nyou can answer that question directly\nwe've covered a lot of different things\nhere so do check out lesson two for all\nthe different things you can do with\nbinary search trees traversals balancing\nand most of these are recursive\nSolutions so it's also good exercise on\nrecursion and we've also looked at B\nbinary trees and how can we optimize\nthem further then you had an assignment\non hash tables so hashing is a again a\ncommon question that is often asked so\nwe built hash tables from scratch in\nPython and we also handled collisions\nusing a technique called linear probing\nand so this is something you can check\nout in assignment to so you may get\nasked just to implement a hash table in\npython or\nImplement\nCollision resolution in a hash table in\nwhich case you can use linear probing\nthen you have the Sorting algorithms\nwhere we looked at bubble sort and\ninsertion sort merge sort using divide\nand conquer and quick sort where we had\na quadratic worst case complexity but a\nlogarithmic average complexity and\nthat's a good thing because merge sort\nalthough it is logarithmic in the worst\ncase it still takes up a lot of space\nand space allocation is slow and you may\nalso not have the\nmemory so that's why we sometimes use\nprefer quick sort over merge sort when\nwe are constraint for\nspace then assignment three is pretty\ninteresting where you will Implement an\noptimal algorithm for polinomial\nmultiplication using divide and conquer\nso do check out assignment 3 as well\nthen we looked at dynamic programming we\nlooked at recursion memorization\nsubsequence and aback problems and then\nwe finally also didn't cover\nbacktracking and pruning but we'll there\nare some questions there in the lesson\nnotebook which you can try out which use\nbacktracking and pruning as well then we\nlooked at graph algorithms the last time\nwhich was graphs and adjacency list and\nadjacency matrices we looked at the\ndepth first and bread first search and\nhow to implement them and we also looked\nat shortest paths and directed and\nweighted\ngraphs this is a very important topic\nbread first and depth first search you\nwill get many questions related to these\nso do solve maybe five questions on each\nof these topics and you should be good\nwith most graph problems asked in\ninterviews now this project for you the\ncourse project if you haven't seen seen\nit already is to pick a coding problem\nso you can pick a coding problem from an\nonline Source like lead code hacker rank\nGeeks for geeks Etc and then use the\nproblem solving template that we've\nshared with\nyou this problem solving template as a\nstarting point so just give it a name\nand then write the problem statement and\nimplement the solution step by step so\nuse the problem solving template to\nsolve the problem using the method\nyou've learned in the course then\ndocument Your solution add explanations\nwherever required perform the complexity\nanalysis\nall of this you should add in the\njupyter notebook and then publish your\nnotebook to your Jovian profile and\nfinally you can submit the link to your\nJovan notebook here do submit the link\nto your Jovan notebook\nhere and you can check\nout the discussion where you\ncan change uh where you can post what\nyou what you're working on so to post\nyour notebook as well and finally today\nwe have looked at a couple of real\ninterview questions from Amazon and\nGoogle and how to go about solving\nthem and we\nalso addressed a few issues that we\nfaced along the way so that was a\nhelpful\nexercise and that's it so now you can\nreview the lecture video execute the\nJupiter notebooks complete the\nassignments and attempt the optional\nquestions so that the topics that we've\ncovered they get Consolidated and you do\nnot ever have to look at this lecture\nagain right so practice is what really\nreinforces and consolidates your\nlearning complete the assignments and\nattempt the optional questions to\npractice and participate in Forum\ndiscussions also very useful when you\nparticipate in Forum discussions Why by\nanswering questions a lot of your own\ndoubts get cleared so do participate in\nForum discussions and then join or start\na study group if possible getting\ntogether with a group of four or five\npeople is great it really helps\nyou focus and uh improve your\nunderstanding by\ndiscussion so that's data structures and\nalgorithms in Python so with that thank\nyou very much for joining us on this\njourney as we learn data structures and\nalgorithms in Python a very useful topic\nto improve your coding skills and also\nsomething that you will almost certainly\nencounter in one of your interviews no\nmatter which company you're applying to\nso I hope this is helpful to you do let\nus know on the Forum how this course\nhelped you if it did you can let us know\nin the YouTube comments as well if you\nhave questions if something was not\nclear do post that too and we'll make\nsure to come up with clearer\nexplanations and clearer examples the\nnext time if you have any feedback for\nus do post it in the comments or send us\nan email at support\njan. with that I will take leave and I\nwill see you in the forums this is not\nthe end of our journey with you so do\nstay active on Jo there's a lot of great\nactivity happening do check out the\nforums the newsletter and stay tuned for\nour next course thank you and goodbye\n",
  "words": [
    "introduction",
    "common",
    "data",
    "structures",
    "algorithms",
    "python",
    "course",
    "taught",
    "akash",
    "ns",
    "ceo",
    "jovian",
    "data",
    "structures",
    "algorithms",
    "python",
    "practical",
    "coding",
    "focused",
    "online",
    "course",
    "help",
    "improve",
    "programming",
    "skills",
    "solve",
    "coding",
    "challenges",
    "ace",
    "technical",
    "interviews",
    "also",
    "earn",
    "verified",
    "certificate",
    "accomplishment",
    "completing",
    "course",
    "learn",
    "register",
    "python",
    "coding",
    "using",
    "python",
    "programming",
    "language",
    "get",
    "chance",
    "practice",
    "improve",
    "coding",
    "skills",
    "weekly",
    "programming",
    "assignments",
    "consisting",
    "real",
    "interview",
    "questions",
    "also",
    "build",
    "course",
    "project",
    "showcase",
    "resume",
    "linkedin",
    "profile",
    "beginner",
    "friendly",
    "course",
    "basic",
    "programming",
    "knowledge",
    "help",
    "follow",
    "along",
    "course",
    "worry",
    "new",
    "programming",
    "learn",
    "work",
    "course",
    "little",
    "extra",
    "effort",
    "also",
    "get",
    "access",
    "course",
    "community",
    "forum",
    "ask",
    "questions",
    "participate",
    "discussions",
    "share",
    "working",
    "course",
    "course",
    "created",
    "jovian",
    "platform",
    "learning",
    "data",
    "science",
    "machine",
    "learning",
    "global",
    "community",
    "tens",
    "thousands",
    "learners",
    "150",
    "countries",
    "instructor",
    "akash",
    "ceo",
    "jovian",
    "really",
    "excited",
    "kick",
    "course",
    "register",
    "invite",
    "friends",
    "join",
    "course",
    "python",
    "orith",
    "python",
    "online",
    "certification",
    "course",
    "brought",
    "jovian",
    "today",
    "lesson",
    "one",
    "binary",
    "search",
    "link",
    "lists",
    "complexity",
    "analysis",
    "name",
    "akash",
    "ceo",
    "jovian",
    "instructor",
    "find",
    "twitter",
    "aashis",
    "course",
    "runs",
    "6",
    "weeks",
    "6",
    "weeks",
    "enroll",
    "course",
    "work",
    "four",
    "programming",
    "assignments",
    "build",
    "course",
    "project",
    "earn",
    "certificate",
    "accomplishment",
    "along",
    "process",
    "also",
    "learn",
    "common",
    "data",
    "structures",
    "algorithms",
    "python",
    "use",
    "skills",
    "ace",
    "coding",
    "interviews",
    "technical",
    "assessments",
    "let",
    "get",
    "started",
    "begin",
    "need",
    "go",
    "course",
    "website",
    "python",
    "open",
    "python",
    "browser",
    "bring",
    "page",
    "course",
    "page",
    "watch",
    "introductory",
    "video",
    "course",
    "enroll",
    "course",
    "free",
    "need",
    "sign",
    "jovian",
    "use",
    "google",
    "g",
    "github",
    "email",
    "sign",
    "jovian",
    "enrolled",
    "course",
    "also",
    "invite",
    "friends",
    "join",
    "course",
    "course",
    "still",
    "open",
    "enrollments",
    "please",
    "invite",
    "friends",
    "colleagues",
    "course",
    "beginner",
    "friendly",
    "introduction",
    "common",
    "data",
    "structures",
    "algorithms",
    "python",
    "course",
    "help",
    "prepare",
    "coding",
    "interviews",
    "coding",
    "focused",
    "video",
    "tutorials",
    "every",
    "week",
    "either",
    "follow",
    "along",
    "video",
    "pause",
    "run",
    "code",
    "speak",
    "practice",
    "coding",
    "cloud",
    "watch",
    "video",
    "right",
    "practice",
    "later",
    "course",
    "solve",
    "questions",
    "real",
    "programming",
    "interviews",
    "earn",
    "verified",
    "certificate",
    "accomplishment",
    "let",
    "go",
    "lesson",
    "one",
    "binary",
    "search",
    "link",
    "list",
    "complexity",
    "lesson",
    "one",
    "page",
    "see",
    "recording",
    "lesson",
    "completed",
    "also",
    "able",
    "see",
    "hindi",
    "version",
    "code",
    "used",
    "lesson",
    "linked",
    "first",
    "set",
    "code",
    "look",
    "today",
    "called",
    "linear",
    "binary",
    "search",
    "let",
    "open",
    "first",
    "tutorial",
    "work",
    "lesson",
    "able",
    "work",
    "well",
    "part",
    "one",
    "total",
    "12",
    "notebooks",
    "12",
    "tutorials",
    "go",
    "course",
    "assume",
    "little",
    "background",
    "programming",
    "mathematics",
    "still",
    "need",
    "know",
    "little",
    "bit",
    "instance",
    "need",
    "know",
    "basic",
    "programming",
    "python",
    "things",
    "like",
    "variables",
    "data",
    "types",
    "loops",
    "functions",
    "worry",
    "know",
    "already",
    "click",
    "follow",
    "links",
    "separate",
    "tutorial",
    "tutorial",
    "take",
    "half",
    "hour",
    "learn",
    "basic",
    "programming",
    "python",
    "couple",
    "hours",
    "also",
    "need",
    "know",
    "high",
    "school",
    "mathematics",
    "want",
    "brush",
    "things",
    "like",
    "polinomial",
    "vectors",
    "matrices",
    "probabilities",
    "click",
    "read",
    "prior",
    "knowledge",
    "data",
    "structures",
    "algorithms",
    "required",
    "need",
    "extensive",
    "coding",
    "background",
    "cover",
    "additional",
    "mathematical",
    "theoretical",
    "concepts",
    "need",
    "go",
    "along",
    "run",
    "code",
    "see",
    "explanations",
    "also",
    "see",
    "code",
    "see",
    "code",
    "written",
    "fun",
    "library",
    "imported",
    "function",
    "library",
    "used",
    "run",
    "code",
    "two",
    "options",
    "either",
    "run",
    "code",
    "using",
    "free",
    "online",
    "resources",
    "recommend",
    "run",
    "computer",
    "locally",
    "read",
    "instructions",
    "going",
    "use",
    "free",
    "online",
    "resources",
    "provided",
    "jovian",
    "scroll",
    "top",
    "page",
    "click",
    "run",
    "click",
    "run",
    "binder",
    "take",
    "second",
    "two",
    "essentially",
    "setting",
    "machine",
    "cloud",
    "using",
    "software",
    "called",
    "binder",
    "open",
    "source",
    "software",
    "looking",
    "actually",
    "blog",
    "post",
    "actually",
    "something",
    "called",
    "jupiter",
    "notebook",
    "jupiter",
    "notebook",
    "something",
    "contain",
    "explanations",
    "also",
    "contain",
    "code",
    "look",
    "code",
    "outputs",
    "right",
    "interactive",
    "fashion",
    "scroll",
    "see",
    "content",
    "looking",
    "except",
    "time",
    "actually",
    "run",
    "code",
    "click",
    "run",
    "button",
    "run",
    "button",
    "run",
    "code",
    "click",
    "second",
    "run",
    "button",
    "going",
    "run",
    "second",
    "line",
    "code",
    "using",
    "jupyter",
    "notebooks",
    "extensively",
    "throughout",
    "course",
    "jupyter",
    "notebooks",
    "great",
    "way",
    "interactive",
    "programming",
    "change",
    "code",
    "example",
    "inside",
    "matt",
    "matt",
    "square",
    "root",
    "use",
    "matt",
    "seal",
    "change",
    "value",
    "jupyter",
    "notebooks",
    "great",
    "experimenting",
    "code",
    "couple",
    "tips",
    "want",
    "soon",
    "run",
    "jupyter",
    "notebook",
    "click",
    "kernel",
    "click",
    "restart",
    "clear",
    "output",
    "remove",
    "gone",
    "see",
    "numbers",
    "go",
    "away",
    "execute",
    "code",
    "line",
    "line",
    "see",
    "output",
    "discover",
    "output",
    "one",
    "thing",
    "want",
    "hide",
    "ui",
    "little",
    "bit",
    "toggle",
    "header",
    "also",
    "toggle",
    "toolbar",
    "might",
    "need",
    "toolbar",
    "run",
    "button",
    "tip",
    "instead",
    "pressing",
    "run",
    "button",
    "use",
    "shift",
    "plus",
    "enter",
    "press",
    "shift",
    "plus",
    "enter",
    "execute",
    "cell",
    "pretty",
    "handy",
    "shortcut",
    "go",
    "lesson",
    "page",
    "lesson",
    "page",
    "find",
    "link",
    "notebook",
    "called",
    "linear",
    "binary",
    "search",
    "linear",
    "binary",
    "search",
    "read",
    "explanations",
    "ca",
    "run",
    "run",
    "code",
    "need",
    "click",
    "run",
    "select",
    "run",
    "binder",
    "clicking",
    "run",
    "binder",
    "set",
    "cloud",
    "machine",
    "code",
    "see",
    "get",
    "executed",
    "cloud",
    "need",
    "set",
    "anything",
    "computer",
    "need",
    "download",
    "anything",
    "done",
    "let",
    "get",
    "started",
    "course",
    "takes",
    "coding",
    "focused",
    "approach",
    "towards",
    "learning",
    "notebook",
    "tutorial",
    "focus",
    "solving",
    "one",
    "problem",
    "learn",
    "techniques",
    "algorithms",
    "data",
    "structures",
    "device",
    "efficient",
    "solution",
    "specific",
    "problem",
    "generalize",
    "technique",
    "apply",
    "problems",
    "specific",
    "tutorial",
    "focus",
    "solving",
    "problem",
    "problem",
    "solving",
    "typical",
    "problem",
    "come",
    "across",
    "coding",
    "challenge",
    "coding",
    "interview",
    "problem",
    "goes",
    "alice",
    "cards",
    "numbers",
    "written",
    "arranges",
    "cards",
    "decreasing",
    "order",
    "lays",
    "face",
    "sequence",
    "table",
    "looks",
    "like",
    "cards",
    "cards",
    "number",
    "numbers",
    "decreasing",
    "order",
    "challenges",
    "bob",
    "pick",
    "card",
    "containing",
    "given",
    "number",
    "example",
    "could",
    "say",
    "bob",
    "want",
    "pick",
    "number",
    "seven",
    "turning",
    "cards",
    "possible",
    "puzzle",
    "given",
    "us",
    "told",
    "many",
    "cards",
    "alice",
    "need",
    "write",
    "function",
    "help",
    "bob",
    "locate",
    "card",
    "alice",
    "put",
    "number",
    "cards",
    "target",
    "number",
    "bob",
    "pi",
    "pick",
    "could",
    "anything",
    "tell",
    "bob",
    "spec",
    "solution",
    "specific",
    "problem",
    "general",
    "strategy",
    "use",
    "turn",
    "cards",
    "possible",
    "instance",
    "look",
    "seven",
    "cards",
    "maybe",
    "put",
    "imaginary",
    "imaginary",
    "numbers",
    "try",
    "figure",
    "strategy",
    "try",
    "start",
    "thinking",
    "problem",
    "may",
    "seem",
    "like",
    "simple",
    "problem",
    "especially",
    "familiar",
    "concept",
    "binary",
    "search",
    "strategy",
    "technique",
    "learning",
    "widely",
    "applicable",
    "soon",
    "use",
    "solve",
    "harder",
    "problems",
    "think",
    "problem",
    "start",
    "solving",
    "uh",
    "want",
    "talk",
    "learn",
    "data",
    "structures",
    "algorithms",
    "whether",
    "pursuing",
    "career",
    "software",
    "development",
    "data",
    "science",
    "almost",
    "certain",
    "asked",
    "programming",
    "problems",
    "like",
    "reversing",
    "leg",
    "list",
    "balancing",
    "binary",
    "tre",
    "technical",
    "interview",
    "coding",
    "assessment",
    "well",
    "known",
    "never",
    "face",
    "problems",
    "job",
    "software",
    "developer",
    "okay",
    "wonder",
    "problems",
    "asked",
    "interviews",
    "asked",
    "demonstrate",
    "following",
    "traits",
    "important",
    "traits",
    "programmer",
    "number",
    "one",
    "think",
    "problem",
    "systematically",
    "solve",
    "systematically",
    "step",
    "step",
    "number",
    "two",
    "envision",
    "different",
    "inputs",
    "outputs",
    "edge",
    "cases",
    "problem",
    "programs",
    "put",
    "wild",
    "part",
    "software",
    "encounter",
    "kind",
    "inputs",
    "thousands",
    "millions",
    "users",
    "encounter",
    "every",
    "possible",
    "input",
    "often",
    "many",
    "security",
    "implications",
    "take",
    "server",
    "take",
    "application",
    "loss",
    "data",
    "loss",
    "property",
    "communicate",
    "ideas",
    "clearly",
    "important",
    "part",
    "problem",
    "solving",
    "importantly",
    "convert",
    "thoughts",
    "ideas",
    "working",
    "code",
    "code",
    "also",
    "readable",
    "people",
    "really",
    "knowledge",
    "specific",
    "data",
    "structures",
    "algorithms",
    "tested",
    "interview",
    "approach",
    "towards",
    "problem",
    "may",
    "fail",
    "solve",
    "problem",
    "may",
    "still",
    "clear",
    "interview",
    "vice",
    "versa",
    "may",
    "solve",
    "problem",
    "still",
    "clear",
    "interview",
    "course",
    "focus",
    "skills",
    "solve",
    "problem",
    "clear",
    "interview",
    "successfully",
    "need",
    "learn",
    "data",
    "structures",
    "algorithms",
    "coming",
    "back",
    "problem",
    "hand",
    "read",
    "problem",
    "may",
    "thinking",
    "maybe",
    "ideas",
    "solve",
    "first",
    "instinct",
    "might",
    "start",
    "writing",
    "code",
    "optimal",
    "strategy",
    "may",
    "actually",
    "end",
    "spending",
    "longer",
    "time",
    "solve",
    "problem",
    "due",
    "coding",
    "errors",
    "may",
    "able",
    "solve",
    "problem",
    "going",
    "cover",
    "systematic",
    "strategy",
    "apply",
    "interviews",
    "coding",
    "problems",
    "coding",
    "assessments",
    "general",
    "whenever",
    "faced",
    "problem",
    "like",
    "strategy",
    "apply",
    "step",
    "one",
    "state",
    "problem",
    "clearly",
    "identify",
    "input",
    "output",
    "formats",
    "step",
    "two",
    "come",
    "example",
    "inputs",
    "outputs",
    "try",
    "cover",
    "edge",
    "cases",
    "step",
    "three",
    "come",
    "correct",
    "solution",
    "problem",
    "simple",
    "possible",
    "state",
    "plain",
    "english",
    "step",
    "four",
    "step",
    "optional",
    "sometimes",
    "implement",
    "solution",
    "test",
    "using",
    "example",
    "inputs",
    "fix",
    "bugs",
    "first",
    "solution",
    "step",
    "five",
    "analyze",
    "algorithm",
    "complexity",
    "identify",
    "inefficiencies",
    "finally",
    "step",
    "step",
    "six",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "go",
    "back",
    "step",
    "three",
    "come",
    "new",
    "correct",
    "solution",
    "also",
    "efficient",
    "implement",
    "solution",
    "analyze",
    "algorithm",
    "complexity",
    "technique",
    "apply",
    "course",
    "6",
    "weeks",
    "many",
    "different",
    "problems",
    "applying",
    "right",
    "technique",
    "knowledge",
    "common",
    "data",
    "structures",
    "algorithms",
    "comes",
    "handy",
    "method",
    "using",
    "let",
    "jump",
    "solution",
    "step",
    "one",
    "state",
    "problem",
    "clearly",
    "often",
    "encounter",
    "detailed",
    "word",
    "problems",
    "coding",
    "challenges",
    "interviews",
    "go",
    "paragraphs",
    "paragraphs",
    "instance",
    "talking",
    "alice",
    "deck",
    "cards",
    "shuffling",
    "putting",
    "table",
    "talking",
    "bob",
    "etc",
    "etc",
    "etc",
    "first",
    "step",
    "state",
    "problem",
    "clearly",
    "precisely",
    "abstract",
    "terms",
    "computers",
    "understand",
    "people",
    "computers",
    "understand",
    "cards",
    "computers",
    "understand",
    "numbers",
    "case",
    "represent",
    "sequence",
    "cards",
    "list",
    "numbers",
    "list",
    "basic",
    "data",
    "structure",
    "python",
    "turning",
    "specific",
    "card",
    "equivalent",
    "accessing",
    "value",
    "number",
    "certain",
    "position",
    "list",
    "instance",
    "think",
    "set",
    "cards",
    "represented",
    "list",
    "see",
    "list",
    "sorted",
    "decreasing",
    "order",
    "turning",
    "certain",
    "card",
    "equivalent",
    "accessing",
    "specific",
    "element",
    "list",
    "turning",
    "card",
    "number",
    "two",
    "say",
    "computer",
    "science",
    "card",
    "number",
    "one",
    "card",
    "number",
    "zero",
    "one",
    "thing",
    "might",
    "want",
    "get",
    "head",
    "well",
    "whenever",
    "counting",
    "always",
    "start",
    "counting",
    "zero",
    "otherwise",
    "may",
    "run",
    "many",
    "one",
    "errors",
    "position",
    "zero",
    "position",
    "one",
    "turn",
    "card",
    "position",
    "one",
    "good",
    "accessing",
    "element",
    "given",
    "list",
    "case",
    "turn",
    "11",
    "positions",
    "list",
    "starting",
    "zero",
    "figure",
    "many",
    "elements",
    "need",
    "access",
    "need",
    "access",
    "minimum",
    "number",
    "elements",
    "get",
    "particular",
    "element",
    "right",
    "problem",
    "stated",
    "follows",
    "need",
    "write",
    "program",
    "find",
    "position",
    "given",
    "number",
    "list",
    "arranged",
    "decreasing",
    "order",
    "also",
    "need",
    "minimize",
    "number",
    "times",
    "access",
    "elements",
    "list",
    "finding",
    "position",
    "given",
    "number",
    "seven",
    "position",
    "case",
    "three",
    "want",
    "minimize",
    "number",
    "times",
    "access",
    "elements",
    "list",
    "go",
    "direction",
    "example",
    "would",
    "need",
    "access",
    "13",
    "11",
    "12",
    "finally",
    "discover",
    "seven",
    "come",
    "end",
    "may",
    "discover",
    "7",
    "6",
    "5",
    "4",
    "finally",
    "may",
    "discover",
    "7even",
    "definitely",
    "coming",
    "left",
    "better",
    "coming",
    "right",
    "best",
    "solving",
    "defined",
    "problem",
    "try",
    "write",
    "problem",
    "words",
    "primarily",
    "make",
    "clear",
    "uh",
    "either",
    "speak",
    "loud",
    "interviewer",
    "write",
    "words",
    "short",
    "make",
    "short",
    "long",
    "possible",
    "clearly",
    "understand",
    "come",
    "inputs",
    "outputs",
    "two",
    "inputs",
    "input",
    "cards",
    "list",
    "numbers",
    "sorted",
    "decreasing",
    "order",
    "second",
    "input",
    "query",
    "number",
    "whose",
    "position",
    "array",
    "determined",
    "one",
    "output",
    "position",
    "position",
    "simply",
    "position",
    "query",
    "list",
    "cards",
    "example",
    "7",
    "position",
    "three",
    "counting",
    "zero",
    "course",
    "soon",
    "written",
    "input",
    "output",
    "write",
    "called",
    "signature",
    "function",
    "structure",
    "function",
    "without",
    "actual",
    "code",
    "inside",
    "call",
    "def",
    "locate",
    "card",
    "cards",
    "query",
    "single",
    "statement",
    "inside",
    "called",
    "pass",
    "function",
    "python",
    "empty",
    "body",
    "need",
    "put",
    "least",
    "one",
    "statement",
    "always",
    "put",
    "past",
    "statement",
    "first",
    "anything",
    "anything",
    "go",
    "framed",
    "problem",
    "abstract",
    "terms",
    "function",
    "signature",
    "work",
    "couple",
    "tips",
    "something",
    "interviewers",
    "specifically",
    "look",
    "also",
    "coding",
    "assessments",
    "code",
    "also",
    "shared",
    "company",
    "may",
    "want",
    "name",
    "functions",
    "properly",
    "think",
    "carefully",
    "signature",
    "example",
    "call",
    "function",
    "f1",
    "funk",
    "one",
    "f",
    "something",
    "like",
    "better",
    "call",
    "locate",
    "card",
    "similar",
    "thing",
    "true",
    "variable",
    "names",
    "well",
    "use",
    "descriptive",
    "variable",
    "names",
    "one",
    "good",
    "coding",
    "practice",
    "second",
    "work",
    "problem",
    "may",
    "lose",
    "track",
    "variable",
    "represents",
    "example",
    "call",
    "call",
    "b",
    "20",
    "minutes",
    "line",
    "talking",
    "problem",
    "writing",
    "different",
    "lines",
    "code",
    "may",
    "forget",
    "b",
    "represent",
    "please",
    "call",
    "represent",
    "even",
    "even",
    "get",
    "little",
    "long",
    "finally",
    "unable",
    "come",
    "function",
    "signature",
    "unable",
    "come",
    "simple",
    "description",
    "discuss",
    "problem",
    "interviewer",
    "unsure",
    "frame",
    "abstract",
    "terms",
    "keep",
    "mind",
    "really",
    "first",
    "important",
    "step",
    "stating",
    "clarifying",
    "problem",
    "statement",
    "stating",
    "clearly",
    "start",
    "coding",
    "done",
    "otherwise",
    "may",
    "get",
    "halfway",
    "code",
    "realize",
    "understood",
    "problem",
    "step",
    "two",
    "come",
    "examples",
    "example",
    "inputs",
    "outputs",
    "goal",
    "cover",
    "edge",
    "cases",
    "start",
    "implementing",
    "function",
    "want",
    "examples",
    "implement",
    "first",
    "thing",
    "want",
    "know",
    "correct",
    "general",
    "answer",
    "coding",
    "especially",
    "get",
    "getting",
    "started",
    "hard",
    "think",
    "many",
    "different",
    "scenarios",
    "especially",
    "especially",
    "interviews",
    "coding",
    "assessments",
    "also",
    "stressful",
    "situations",
    "may",
    "able",
    "focus",
    "think",
    "different",
    "things",
    "need",
    "keep",
    "mind",
    "simplest",
    "way",
    "reduce",
    "risk",
    "going",
    "wrong",
    "use",
    "uh",
    "test",
    "cases",
    "one",
    "test",
    "case",
    "came",
    "done",
    "taken",
    "information",
    "listed",
    "inputs",
    "outputs",
    "written",
    "code",
    "variable",
    "called",
    "cards",
    "list",
    "cards",
    "list",
    "numbers",
    "query",
    "value",
    "seven",
    "output",
    "value",
    "three",
    "expected",
    "output",
    "function",
    "three",
    "test",
    "case",
    "test",
    "function",
    "point",
    "anything",
    "want",
    "test",
    "simply",
    "pass",
    "input",
    "example",
    "cards",
    "query",
    "locate",
    "card",
    "function",
    "get",
    "back",
    "result",
    "see",
    "right",
    "nothing",
    "inside",
    "function",
    "result",
    "get",
    "back",
    "none",
    "later",
    "start",
    "getting",
    "back",
    "proper",
    "result",
    "function",
    "compare",
    "result",
    "output",
    "test",
    "case",
    "case",
    "compare",
    "obviously",
    "output",
    "three",
    "result",
    "none",
    "get",
    "back",
    "false",
    "one",
    "thing",
    "course",
    "make",
    "testing",
    "easier",
    "testing",
    "algorithms",
    "keep",
    "improving",
    "represent",
    "test",
    "cases",
    "dictionaries",
    "example",
    "test",
    "case",
    "represented",
    "every",
    "test",
    "case",
    "represented",
    "dictionary",
    "containing",
    "two",
    "keys",
    "input",
    "output",
    "input",
    "contain",
    "one",
    "key",
    "argument",
    "function",
    "function",
    "arguments",
    "called",
    "cards",
    "query",
    "function",
    "signature",
    "wrote",
    "function",
    "signature",
    "first",
    "get",
    "confused",
    "function",
    "arguments",
    "called",
    "cards",
    "query",
    "take",
    "one",
    "ar",
    "one",
    "key",
    "called",
    "cards",
    "put",
    "value",
    "cards",
    "one",
    "key",
    "called",
    "query",
    "put",
    "value",
    "query",
    "output",
    "simply",
    "contain",
    "simply",
    "put",
    "output",
    "expect",
    "function",
    "test",
    "function",
    "like",
    "might",
    "want",
    "test",
    "first",
    "maybe",
    "actually",
    "passing",
    "values",
    "like",
    "test",
    "input",
    "cards",
    "test",
    "input",
    "query",
    "trick",
    "whenever",
    "dictionary",
    "dictionary",
    "two",
    "keys",
    "want",
    "pass",
    "two",
    "keys",
    "two",
    "arguments",
    "function",
    "want",
    "pass",
    "cards",
    "card",
    "argument",
    "function",
    "locate",
    "card",
    "query",
    "query",
    "argument",
    "locate",
    "cards",
    "simply",
    "put",
    "dictionary",
    "write",
    "star",
    "star",
    "write",
    "star",
    "star",
    "python",
    "takes",
    "keys",
    "dictionary",
    "values",
    "used",
    "arguments",
    "parameters",
    "names",
    "calling",
    "locate",
    "card",
    "test",
    "input",
    "compare",
    "test",
    "output",
    "see",
    "get",
    "back",
    "false",
    "one",
    "test",
    "case",
    "us",
    "enough",
    "enough",
    "start",
    "writing",
    "code",
    "probably",
    "wild",
    "function",
    "able",
    "handle",
    "number",
    "set",
    "valid",
    "inputs",
    "pass",
    "possible",
    "variations",
    "might",
    "encounter",
    "really",
    "helps",
    "list",
    "fact",
    "writing",
    "variations",
    "realized",
    "many",
    "cases",
    "thought",
    "even",
    "coding",
    "12",
    "15",
    "years",
    "almost",
    "uh",
    "still",
    "find",
    "really",
    "useful",
    "list",
    "scenarios",
    "find",
    "input",
    "simplest",
    "scenario",
    "query",
    "occurs",
    "somewhere",
    "middle",
    "list",
    "cards",
    "imagine",
    "read",
    "question",
    "called",
    "general",
    "case",
    "special",
    "scenarios",
    "well",
    "query",
    "first",
    "element",
    "cards",
    "query",
    "last",
    "element",
    "cards",
    "list",
    "cards",
    "contains",
    "one",
    "element",
    "query",
    "something",
    "thought",
    "list",
    "cards",
    "even",
    "contain",
    "number",
    "query",
    "alice",
    "bluffing",
    "bob",
    "strategy",
    "figure",
    "number",
    "exist",
    "list",
    "cards",
    "empty",
    "list",
    "contains",
    "repeating",
    "numbers",
    "another",
    "interesting",
    "thing",
    "may",
    "come",
    "mind",
    "said",
    "list",
    "numbers",
    "specify",
    "numbers",
    "unique",
    "list",
    "contain",
    "repeating",
    "numbers",
    "finally",
    "number",
    "query",
    "occurs",
    "one",
    "position",
    "cards",
    "eight",
    "cases",
    "could",
    "think",
    "see",
    "think",
    "variations",
    "likely",
    "first",
    "heard",
    "problem",
    "think",
    "cases",
    "often",
    "tend",
    "focus",
    "one",
    "generic",
    "case",
    "hard",
    "hold",
    "many",
    "cases",
    "mind",
    "helps",
    "list",
    "actually",
    "write",
    "coding",
    "interview",
    "coding",
    "assessment",
    "interview",
    "may",
    "want",
    "put",
    "comments",
    "page",
    "coding",
    "page",
    "create",
    "comments",
    "list",
    "test",
    "cases",
    "especially",
    "things",
    "like",
    "empty",
    "array",
    "query",
    "occurring",
    "cards",
    "called",
    "edge",
    "cases",
    "represent",
    "rare",
    "extreme",
    "examples",
    "edge",
    "cases",
    "may",
    "occur",
    "frequently",
    "program",
    "able",
    "handle",
    "edge",
    "cases",
    "otherwise",
    "may",
    "fail",
    "unexpected",
    "ways",
    "somebody",
    "malintentions",
    "use",
    "edge",
    "cases",
    "hack",
    "software",
    "let",
    "create",
    "test",
    "cases",
    "variations",
    "listed",
    "store",
    "test",
    "cases",
    "list",
    "easier",
    "testing",
    "creating",
    "list",
    "called",
    "tests",
    "time",
    "create",
    "test",
    "cases",
    "format",
    "discuss",
    "dictionary",
    "format",
    "keep",
    "appending",
    "list",
    "understand",
    "understand",
    "lists",
    "dictionaries",
    "appending",
    "go",
    "back",
    "review",
    "basic",
    "material",
    "python",
    "linked",
    "top",
    "notebook",
    "first",
    "take",
    "one",
    "test",
    "case",
    "already",
    "put",
    "take",
    "maybe",
    "one",
    "example",
    "query",
    "occurring",
    "somewhere",
    "middle",
    "see",
    "cards",
    "list",
    "query",
    "one",
    "occurs",
    "somewhere",
    "middle",
    "although",
    "closer",
    "one",
    "end",
    "one",
    "case",
    "query",
    "first",
    "element",
    "four",
    "output",
    "obviously",
    "output",
    "expected",
    "zero",
    "one",
    "case",
    "query",
    "last",
    "element",
    "minus",
    "127",
    "another",
    "thing",
    "numbers",
    "could",
    "negative",
    "well",
    "something",
    "may",
    "want",
    "keep",
    "mind",
    "another",
    "one",
    "card",
    "contains",
    "cards",
    "contains",
    "one",
    "element",
    "query",
    "problem",
    "state",
    "list",
    "cards",
    "contain",
    "number",
    "query",
    "may",
    "often",
    "face",
    "questions",
    "may",
    "clear",
    "certain",
    "situation",
    "certain",
    "situation",
    "occur",
    "questions",
    "like",
    "process",
    "follow",
    "step",
    "one",
    "read",
    "problem",
    "statement",
    "carefully",
    "ask",
    "interviewer",
    "repeat",
    "question",
    "read",
    "problem",
    "statement",
    "carefully",
    "often",
    "find",
    "hints",
    "sometimes",
    "hints",
    "single",
    "number",
    "single",
    "words",
    "somewhere",
    "often",
    "also",
    "find",
    "examples",
    "provided",
    "problem",
    "also",
    "find",
    "scroll",
    "bottom",
    "find",
    "conditions",
    "find",
    "limits",
    "numbers",
    "whether",
    "integers",
    "decimal",
    "whether",
    "negative",
    "positive",
    "important",
    "read",
    "problem",
    "carefully",
    "start",
    "coding",
    "look",
    "examples",
    "ask",
    "interviewer",
    "maybe",
    "post",
    "question",
    "platform",
    "clarification",
    "often",
    "happens",
    "interviewers",
    "take",
    "many",
    "interviews",
    "may",
    "forget",
    "specify",
    "certain",
    "detail",
    "might",
    "expect",
    "ask",
    "question",
    "coding",
    "insufficient",
    "requirement",
    "clarify",
    "specifications",
    "problem",
    "important",
    "ask",
    "interviewer",
    "even",
    "somewhat",
    "sure",
    "want",
    "verify",
    "good",
    "idea",
    "ask",
    "finally",
    "done",
    "still",
    "solution",
    "make",
    "reasonable",
    "assumption",
    "state",
    "move",
    "forward",
    "assume",
    "function",
    "return",
    "minus",
    "one",
    "case",
    "cards",
    "contain",
    "query",
    "cards",
    "contain",
    "query",
    "return",
    "expect",
    "function",
    "return",
    "minus",
    "one",
    "one",
    "case",
    "card",
    "array",
    "empty",
    "obviously",
    "contain",
    "query",
    "well",
    "finally",
    "one",
    "last",
    "case",
    "number",
    "repeat",
    "cards",
    "numbers",
    "repeat",
    "cards",
    "query",
    "repeat",
    "cards",
    "query",
    "repeat",
    "three",
    "repeat",
    "numbers",
    "cards",
    "areay",
    "repeat",
    "last",
    "case",
    "query",
    "repeats",
    "see",
    "cards",
    "query",
    "occurs",
    "many",
    "times",
    "specified",
    "sometimes",
    "may",
    "okay",
    "sometimes",
    "problem",
    "statement",
    "may",
    "say",
    "return",
    "one",
    "position",
    "likely",
    "want",
    "may",
    "want",
    "make",
    "deterministic",
    "also",
    "make",
    "easy",
    "test",
    "function",
    "say",
    "impose",
    "additional",
    "restriction",
    "expect",
    "function",
    "return",
    "first",
    "occurrence",
    "query",
    "make",
    "easier",
    "us",
    "test",
    "testing",
    "problem",
    "know",
    "getting",
    "failure",
    "multiple",
    "possible",
    "answers",
    "issue",
    "code",
    "right",
    "want",
    "get",
    "good",
    "feedback",
    "failures",
    "want",
    "tests",
    "deterministic",
    "final",
    "test",
    "see",
    "full",
    "list",
    "test",
    "cases",
    "see",
    "list",
    "test",
    "cases",
    "eight",
    "10",
    "test",
    "cases",
    "may",
    "need",
    "create",
    "many",
    "test",
    "cases",
    "interview",
    "coding",
    "assessment",
    "depending",
    "much",
    "time",
    "create",
    "least",
    "least",
    "cover",
    "three",
    "four",
    "edge",
    "cases",
    "good",
    "number",
    "aim",
    "would",
    "five",
    "help",
    "coding",
    "interview",
    "help",
    "solve",
    "problem",
    "also",
    "appreciated",
    "interviewer",
    "shows",
    "thinking",
    "problem",
    "definitely",
    "take",
    "minute",
    "two",
    "spent",
    "10",
    "15",
    "minutes",
    "talking",
    "start",
    "applying",
    "technique",
    "see",
    "start",
    "creating",
    "test",
    "cases",
    "seconds",
    "soon",
    "read",
    "problem",
    "state",
    "problem",
    "find",
    "um",
    "find",
    "input",
    "format",
    "find",
    "output",
    "format",
    "write",
    "function",
    "uh",
    "signature",
    "write",
    "test",
    "uh",
    "start",
    "working",
    "test",
    "ideas",
    "automatically",
    "start",
    "coming",
    "within",
    "maybe",
    "2",
    "3",
    "minutes",
    "done",
    "two",
    "steps",
    "great",
    "fairly",
    "exhaustive",
    "set",
    "test",
    "cases",
    "creating",
    "test",
    "cases",
    "beforehand",
    "allows",
    "identify",
    "different",
    "variations",
    "edge",
    "cases",
    "sometimes",
    "may",
    "happen",
    "may",
    "clue",
    "work",
    "problem",
    "may",
    "feel",
    "completely",
    "confused",
    "simply",
    "start",
    "writing",
    "multiple",
    "test",
    "cases",
    "start",
    "looking",
    "like",
    "literally",
    "staring",
    "test",
    "cases",
    "question",
    "answer",
    "solution",
    "reveal",
    "underestimate",
    "power",
    "writing",
    "things",
    "stress",
    "stress",
    "ca",
    "come",
    "exhaustive",
    "list",
    "test",
    "cases",
    "takes",
    "time",
    "skill",
    "cultivate",
    "time",
    "list",
    "maybe",
    "test",
    "cases",
    "come",
    "mind",
    "right",
    "put",
    "single",
    "place",
    "keep",
    "coming",
    "back",
    "whenever",
    "new",
    "test",
    "case",
    "comes",
    "mind",
    "coding",
    "discussing",
    "analyzing",
    "come",
    "back",
    "place",
    "write",
    "test",
    "case",
    "important",
    "thing",
    "single",
    "place",
    "listing",
    "test",
    "cases",
    "written",
    "test",
    "cases",
    "come",
    "correct",
    "solution",
    "come",
    "correct",
    "solution",
    "writing",
    "code",
    "first",
    "stating",
    "plain",
    "english",
    "first",
    "goal",
    "correct",
    "mean",
    "best",
    "efficient",
    "solution",
    "first",
    "want",
    "solve",
    "problem",
    "want",
    "figure",
    "particular",
    "number",
    "lies",
    "list",
    "minimize",
    "solving",
    "two",
    "problems",
    "sometimes",
    "get",
    "tricky",
    "first",
    "aim",
    "correctness",
    "aim",
    "efficiency",
    "simplest",
    "obvious",
    "solution",
    "almost",
    "always",
    "exists",
    "almost",
    "always",
    "easy",
    "see",
    "involves",
    "checking",
    "poss",
    "possible",
    "answers",
    "also",
    "called",
    "brute",
    "force",
    "solution",
    "problem",
    "coming",
    "brute",
    "force",
    "solution",
    "quite",
    "easy",
    "bob",
    "simply",
    "turn",
    "cards",
    "order",
    "one",
    "one",
    "till",
    "finds",
    "card",
    "given",
    "number",
    "might",
    "work",
    "want",
    "implement",
    "code",
    "writing",
    "words",
    "becomes",
    "important",
    "create",
    "variable",
    "called",
    "position",
    "inside",
    "function",
    "value",
    "zero",
    "check",
    "number",
    "index",
    "position",
    "card",
    "list",
    "equals",
    "query",
    "since",
    "starting",
    "beginning",
    "position",
    "answer",
    "return",
    "function",
    "simply",
    "increment",
    "ment",
    "value",
    "position",
    "one",
    "repeat",
    "steps",
    "go",
    "back",
    "step",
    "two",
    "check",
    "whether",
    "number",
    "index",
    "position",
    "cards",
    "equals",
    "query",
    "return",
    "position",
    "increment",
    "position",
    "repeat",
    "repeat",
    "till",
    "reach",
    "last",
    "position",
    "number",
    "found",
    "return",
    "minus",
    "one",
    "simple",
    "four",
    "five",
    "step",
    "description",
    "take",
    "long",
    "either",
    "say",
    "loud",
    "interviewer",
    "also",
    "appreciate",
    "know",
    "know",
    "may",
    "know",
    "know",
    "brute",
    "force",
    "solution",
    "may",
    "say",
    "seems",
    "simple",
    "obvious",
    "interview",
    "interviewer",
    "know",
    "important",
    "state",
    "brute",
    "force",
    "solution",
    "may",
    "say",
    "brute",
    "force",
    "solution",
    "fairly",
    "straightforward",
    "goes",
    "like",
    "steps",
    "1",
    "2",
    "3",
    "4",
    "take",
    "30",
    "seconds",
    "least",
    "informs",
    "interviewer",
    "able",
    "think",
    "solution",
    "happens",
    "often",
    "seen",
    "interviews",
    "30",
    "40",
    "minutes",
    "passed",
    "45",
    "minutes",
    "single",
    "solution",
    "proposed",
    "far",
    "even",
    "though",
    "many",
    "lines",
    "code",
    "written",
    "important",
    "state",
    "solution",
    "state",
    "solution",
    "interviewer",
    "also",
    "help",
    "correct",
    "go",
    "forward",
    "right",
    "collaborative",
    "experience",
    "discussion",
    "use",
    "coding",
    "assessment",
    "may",
    "want",
    "write",
    "comments",
    "imple",
    "implemented",
    "congratulations",
    "first",
    "algorithm",
    "algorithm",
    "simply",
    "list",
    "statements",
    "list",
    "steps",
    "converted",
    "code",
    "executed",
    "computer",
    "different",
    "sets",
    "inputs",
    "particular",
    "algorithm",
    "called",
    "linear",
    "search",
    "involves",
    "searching",
    "list",
    "linear",
    "fashion",
    "element",
    "element",
    "ready",
    "implement",
    "solution",
    "quick",
    "tip",
    "already",
    "said",
    "always",
    "try",
    "express",
    "algorithm",
    "words",
    "brief",
    "detailed",
    "like",
    "underestimate",
    "power",
    "writing",
    "writing",
    "great",
    "tool",
    "thinking",
    "likely",
    "find",
    "part",
    "solution",
    "difficult",
    "express",
    "simply",
    "suggests",
    "probably",
    "unable",
    "think",
    "part",
    "clearly",
    "clearly",
    "able",
    "express",
    "thoughts",
    "easier",
    "turn",
    "code",
    "come",
    "strategy",
    "writing",
    "code",
    "focus",
    "coding",
    "focus",
    "avoiding",
    "errors",
    "brings",
    "us",
    "next",
    "step",
    "implement",
    "solution",
    "test",
    "using",
    "example",
    "input",
    "see",
    "everything",
    "comes",
    "together",
    "already",
    "know",
    "function",
    "signature",
    "looks",
    "like",
    "inputs",
    "look",
    "like",
    "already",
    "test",
    "cases",
    "test",
    "cases",
    "also",
    "identified",
    "different",
    "edge",
    "cases",
    "need",
    "handle",
    "already",
    "written",
    "descript",
    "description",
    "aough",
    "description",
    "algorithm",
    "looks",
    "like",
    "fact",
    "simply",
    "write",
    "comments",
    "within",
    "function",
    "english",
    "description",
    "simply",
    "need",
    "fill",
    "code",
    "comments",
    "instance",
    "five",
    "steps",
    "written",
    "create",
    "variable",
    "position",
    "value",
    "zero",
    "set",
    "loop",
    "check",
    "element",
    "matches",
    "query",
    "yes",
    "answer",
    "found",
    "increment",
    "position",
    "go",
    "back",
    "check",
    "reached",
    "end",
    "array",
    "return",
    "minus",
    "one",
    "code",
    "pretty",
    "straightforward",
    "create",
    "position",
    "variable",
    "zero",
    "set",
    "true",
    "true",
    "kicks",
    "loop",
    "want",
    "first",
    "set",
    "loop",
    "break",
    "need",
    "check",
    "element",
    "value",
    "position",
    "matches",
    "query",
    "return",
    "position",
    "come",
    "part",
    "simp",
    "function",
    "exits",
    "none",
    "code",
    "gets",
    "executed",
    "increment",
    "position",
    "check",
    "reached",
    "end",
    "reached",
    "end",
    "obviously",
    "want",
    "continue",
    "simply",
    "return",
    "minus",
    "one",
    "exit",
    "loop",
    "exit",
    "function",
    "reach",
    "end",
    "go",
    "back",
    "top",
    "loop",
    "position",
    "starts",
    "value",
    "one",
    "check",
    "value",
    "0",
    "1",
    "2",
    "3",
    "end",
    "array",
    "simple",
    "enough",
    "great",
    "first",
    "function",
    "let",
    "test",
    "fun",
    "function",
    "first",
    "test",
    "case",
    "test",
    "case",
    "simply",
    "call",
    "locate",
    "card",
    "test",
    "input",
    "test",
    "cards",
    "query",
    "result",
    "get",
    "already",
    "see",
    "result",
    "matches",
    "output",
    "compare",
    "get",
    "value",
    "true",
    "yeah",
    "results",
    "match",
    "output",
    "something",
    "often",
    "course",
    "put",
    "together",
    "small",
    "function",
    "within",
    "jovian",
    "python",
    "library",
    "jovian",
    "platform",
    "also",
    "offers",
    "python",
    "helper",
    "library",
    "contains",
    "utility",
    "functions",
    "put",
    "together",
    "small",
    "function",
    "called",
    "evaluate",
    "test",
    "case",
    "write",
    "well",
    "use",
    "library",
    "version",
    "let",
    "install",
    "library",
    "install",
    "jovian",
    "library",
    "using",
    "pip",
    "install",
    "jovian",
    "minus",
    "minus",
    "upgrade",
    "python",
    "dsa",
    "jovian",
    "name",
    "library",
    "inside",
    "jovian",
    "library",
    "since",
    "many",
    "courses",
    "python",
    "dsa",
    "utilities",
    "course",
    "present",
    "inside",
    "python",
    "dsa",
    "module",
    "module",
    "import",
    "function",
    "evaluate",
    "test",
    "case",
    "finally",
    "call",
    "evaluate",
    "test",
    "case",
    "give",
    "function",
    "want",
    "test",
    "want",
    "test",
    "locate",
    "card",
    "function",
    "test",
    "case",
    "test",
    "case",
    "needs",
    "defined",
    "format",
    "going",
    "going",
    "pick",
    "input",
    "pass",
    "function",
    "get",
    "output",
    "compare",
    "output",
    "uh",
    "expected",
    "output",
    "also",
    "print",
    "information",
    "see",
    "prints",
    "input",
    "prints",
    "expected",
    "output",
    "prints",
    "actual",
    "output",
    "prints",
    "execution",
    "time",
    "um",
    "something",
    "become",
    "important",
    "later",
    "tells",
    "whether",
    "test",
    "passed",
    "nice",
    "know",
    "look",
    "output",
    "input",
    "compare",
    "especially",
    "situation",
    "need",
    "think",
    "fast",
    "helpful",
    "create",
    "small",
    "function",
    "print",
    "pass",
    "fail",
    "test",
    "case",
    "may",
    "seem",
    "like",
    "working",
    "solution",
    "test",
    "case",
    "passed",
    "ca",
    "sure",
    "test",
    "function",
    "test",
    "cases",
    "use",
    "evaluate",
    "test",
    "cases",
    "function",
    "evaluate",
    "test",
    "case",
    "evaluate",
    "test",
    "cases",
    "also",
    "part",
    "jovian",
    "library",
    "call",
    "evaluate",
    "test",
    "cases",
    "function",
    "locate",
    "card",
    "time",
    "pass",
    "set",
    "list",
    "test",
    "cases",
    "test",
    "cases",
    "dictionary",
    "use",
    "function",
    "simply",
    "put",
    "things",
    "loop",
    "always",
    "test",
    "tests",
    "simply",
    "call",
    "evaluate",
    "test",
    "locate",
    "card",
    "test",
    "even",
    "directly",
    "call",
    "locate",
    "card",
    "test",
    "inputs",
    "test",
    "compare",
    "output",
    "test",
    "output",
    "right",
    "well",
    "simply",
    "print",
    "simple",
    "way",
    "use",
    "evaluate",
    "test",
    "cases",
    "function",
    "prints",
    "lot",
    "useful",
    "information",
    "us",
    "see",
    "prints",
    "case",
    "case",
    "case",
    "test",
    "case",
    "zero",
    "input",
    "expected",
    "output",
    "actual",
    "output",
    "case",
    "test",
    "case",
    "pass",
    "saw",
    "fact",
    "test",
    "test",
    "case",
    "one",
    "passes",
    "well",
    "test",
    "case",
    "2",
    "passes",
    "test",
    "case",
    "3",
    "4",
    "5",
    "six",
    "okay",
    "fine",
    "okay",
    "test",
    "case",
    "six",
    "seems",
    "caused",
    "error",
    "error",
    "says",
    "list",
    "index",
    "range",
    "okay",
    "perfectly",
    "right",
    "functions",
    "encounter",
    "error",
    "first",
    "thing",
    "important",
    "thing",
    "panic",
    "fact",
    "good",
    "thing",
    "know",
    "exactly",
    "function",
    "failing",
    "look",
    "back",
    "see",
    "issue",
    "see",
    "fix",
    "error",
    "one",
    "one",
    "good",
    "strategy",
    "approach",
    "keep",
    "mind",
    "always",
    "bugs",
    "code",
    "approach",
    "writing",
    "code",
    "assumption",
    "code",
    "correct",
    "go",
    "default",
    "assumption",
    "code",
    "wrong",
    "issues",
    "lets",
    "one",
    "feel",
    "demotivated",
    "panic",
    "see",
    "error",
    "second",
    "tend",
    "tend",
    "little",
    "careful",
    "actually",
    "writing",
    "code",
    "way",
    "writing",
    "code",
    "every",
    "time",
    "write",
    "line",
    "code",
    "asking",
    "line",
    "code",
    "go",
    "wrong",
    "particular",
    "case",
    "cards",
    "position",
    "equals",
    "equals",
    "square",
    "statement",
    "go",
    "wrong",
    "throw",
    "error",
    "let",
    "look",
    "one",
    "easy",
    "way",
    "check",
    "add",
    "called",
    "logging",
    "called",
    "printing",
    "information",
    "inside",
    "function",
    "rewrite",
    "function",
    "locate",
    "card",
    "function",
    "put",
    "cards",
    "put",
    "query",
    "exact",
    "function",
    "set",
    "position",
    "create",
    "value",
    "simply",
    "print",
    "cards",
    "query",
    "information",
    "see",
    "function",
    "working",
    "get",
    "visibility",
    "function",
    "print",
    "cards",
    "query",
    "true",
    "loop",
    "beginning",
    "loop",
    "print",
    "position",
    "tracking",
    "okay",
    "let",
    "simply",
    "added",
    "print",
    "statements",
    "print",
    "statement",
    "give",
    "us",
    "insight",
    "inner",
    "working",
    "function",
    "put",
    "print",
    "statement",
    "work",
    "reading",
    "code",
    "executing",
    "head",
    "always",
    "easier",
    "print",
    "information",
    "print",
    "nicely",
    "say",
    "cards",
    "query",
    "know",
    "could",
    "also",
    "done",
    "without",
    "saying",
    "cards",
    "would",
    "make",
    "make",
    "little",
    "harder",
    "read",
    "would",
    "cognitive",
    "overload",
    "apart",
    "already",
    "dealing",
    "stress",
    "solving",
    "error",
    "right",
    "add",
    "nice",
    "pretty",
    "print",
    "statements",
    "make",
    "obvious",
    "printing",
    "let",
    "see",
    "let",
    "us",
    "get",
    "test",
    "case",
    "let",
    "get",
    "test",
    "six",
    "get",
    "input",
    "get",
    "cards",
    "get",
    "query",
    "well",
    "pass",
    "locate",
    "card",
    "see",
    "initially",
    "cards",
    "array",
    "empty",
    "query",
    "seven",
    "position",
    "zero",
    "encounter",
    "error",
    "encounter",
    "error",
    "list",
    "index",
    "range",
    "line",
    "cards",
    "position",
    "equals",
    "equal",
    "query",
    "point",
    "fairly",
    "obvious",
    "issue",
    "issue",
    "obviously",
    "empty",
    "list",
    "empty",
    "list",
    "elements",
    "trying",
    "access",
    "position",
    "zero",
    "normal",
    "human",
    "conversation",
    "first",
    "element",
    "list",
    "first",
    "element",
    "access",
    "get",
    "error",
    "list",
    "index",
    "range",
    "important",
    "whenever",
    "get",
    "error",
    "try",
    "start",
    "looking",
    "code",
    "first",
    "try",
    "understand",
    "error",
    "first",
    "unable",
    "understand",
    "error",
    "add",
    "print",
    "statements",
    "tools",
    "like",
    "debuggers",
    "people",
    "use",
    "personally",
    "15",
    "years",
    "used",
    "debugger",
    "maybe",
    "used",
    "couple",
    "times",
    "know",
    "use",
    "print",
    "statements",
    "really",
    "simple",
    "put",
    "chuck",
    "function",
    "wherever",
    "need",
    "many",
    "print",
    "statements",
    "need",
    "nice",
    "clear",
    "messages",
    "make",
    "obvious",
    "almost",
    "certainly",
    "solve",
    "issue",
    "cards",
    "array",
    "empty",
    "access",
    "position",
    "zero",
    "solution",
    "solution",
    "obviously",
    "access",
    "anything",
    "list",
    "need",
    "make",
    "sure",
    "access",
    "list",
    "way",
    "rewritten",
    "function",
    "slightly",
    "start",
    "position",
    "zero",
    "time",
    "instead",
    "putting",
    "true",
    "instead",
    "assuming",
    "access",
    "zeroth",
    "element",
    "list",
    "say",
    "position",
    "less",
    "length",
    "cards",
    "cards",
    "list",
    "n",
    "elements",
    "indexes",
    "go",
    "0",
    "n",
    "minus",
    "one",
    "case",
    "zero",
    "elements",
    "indexes",
    "ais",
    "position",
    "less",
    "length",
    "cards",
    "able",
    "access",
    "case",
    "length",
    "cards",
    "zero",
    "0er",
    "less",
    "zero",
    "loop",
    "run",
    "directly",
    "return",
    "minus",
    "one",
    "card",
    "elements",
    "check",
    "element",
    "value",
    "position",
    "compare",
    "query",
    "return",
    "position",
    "match",
    "query",
    "increment",
    "position",
    "fairly",
    "straightforward",
    "fix",
    "easy",
    "save",
    "let",
    "test",
    "failing",
    "case",
    "great",
    "looks",
    "like",
    "failing",
    "case",
    "passing",
    "output",
    "minus",
    "one",
    "expected",
    "output",
    "matches",
    "actual",
    "output",
    "function",
    "minus",
    "one",
    "query",
    "exist",
    "array",
    "empty",
    "course",
    "enough",
    "every",
    "time",
    "make",
    "change",
    "code",
    "want",
    "go",
    "back",
    "test",
    "test",
    "cases",
    "h",
    "may",
    "happen",
    "fixing",
    "one",
    "error",
    "may",
    "introduce",
    "another",
    "error",
    "good",
    "set",
    "test",
    "cases",
    "important",
    "let",
    "run",
    "evaluate",
    "test",
    "cases",
    "see",
    "time",
    "test",
    "cases",
    "passing",
    "nice",
    "makes",
    "feel",
    "good",
    "well",
    "makes",
    "feel",
    "motivated",
    "well",
    "see",
    "bunch",
    "test",
    "cases",
    "passing",
    "real",
    "coding",
    "assessment",
    "real",
    "interview",
    "probably",
    "skip",
    "step",
    "implementing",
    "testing",
    "brute",
    "force",
    "solution",
    "interest",
    "time",
    "may",
    "take",
    "5",
    "10",
    "minutes",
    "implement",
    "solution",
    "errors",
    "solution",
    "may",
    "take",
    "time",
    "fix",
    "errors",
    "generally",
    "quite",
    "easy",
    "figure",
    "complexity",
    "talk",
    "second",
    "brute",
    "force",
    "solution",
    "plain",
    "english",
    "description",
    "first",
    "state",
    "plain",
    "english",
    "takes",
    "around",
    "20",
    "seconds",
    "computer",
    "throw",
    "errors",
    "speaking",
    "state",
    "plain",
    "english",
    "description",
    "move",
    "talk",
    "complexity",
    "start",
    "optimizing",
    "practicing",
    "always",
    "always",
    "implement",
    "brute",
    "force",
    "solution",
    "important",
    "reason",
    "know",
    "implement",
    "brute",
    "force",
    "solution",
    "case",
    "able",
    "figure",
    "optimal",
    "solution",
    "problem",
    "still",
    "go",
    "back",
    "implement",
    "brute",
    "force",
    "solution",
    "lot",
    "cases",
    "okay",
    "sometimes",
    "interviewers",
    "ask",
    "hard",
    "questions",
    "push",
    "boundaries",
    "little",
    "bit",
    "unable",
    "figure",
    "optimal",
    "solution",
    "allow",
    "implement",
    "brute",
    "force",
    "solution",
    "state",
    "know",
    "implement",
    "okay",
    "done",
    "done",
    "implementation",
    "brute",
    "force",
    "simplest",
    "solution",
    "need",
    "analyze",
    "learn",
    "called",
    "complexity",
    "algorithm",
    "mean",
    "recall",
    "statement",
    "original",
    "question",
    "alice",
    "challenges",
    "bob",
    "pick",
    "card",
    "containing",
    "given",
    "number",
    "turning",
    "cards",
    "possible",
    "right",
    "simply",
    "turning",
    "cards",
    "one",
    "one",
    "talk",
    "mean",
    "minimize",
    "number",
    "times",
    "turnover",
    "cards",
    "number",
    "times",
    "access",
    "elements",
    "need",
    "way",
    "measure",
    "let",
    "think",
    "know",
    "simple",
    "thinking",
    "since",
    "access",
    "list",
    "element",
    "every",
    "iteration",
    "code",
    "code",
    "pretty",
    "straightforward",
    "accessing",
    "element",
    "list",
    "since",
    "access",
    "element",
    "since",
    "access",
    "element",
    "every",
    "iteration",
    "list",
    "size",
    "n",
    "access",
    "elements",
    "list",
    "end",
    "times",
    "may",
    "access",
    "element",
    "el",
    "element",
    "element",
    "bob",
    "may",
    "need",
    "overturn",
    "end",
    "cards",
    "worst",
    "case",
    "find",
    "required",
    "card",
    "let",
    "introduce",
    "additional",
    "condition",
    "suppose",
    "bob",
    "allowed",
    "overturn",
    "one",
    "card",
    "per",
    "minute",
    "means",
    "may",
    "take",
    "30",
    "minutes",
    "find",
    "required",
    "card",
    "worst",
    "case",
    "30",
    "cards",
    "laid",
    "table",
    "really",
    "best",
    "way",
    "bob",
    "arrive",
    "answer",
    "turning",
    "five",
    "cards",
    "save",
    "25",
    "minutes",
    "instead",
    "turning",
    "30",
    "field",
    "study",
    "way",
    "bob",
    "case",
    "representative",
    "computer",
    "computer",
    "takes",
    "amount",
    "finite",
    "time",
    "perform",
    "instruction",
    "array",
    "ais",
    "actually",
    "takes",
    "time",
    "although",
    "fast",
    "see",
    "especially",
    "small",
    "inputs",
    "something",
    "become",
    "increasingly",
    "important",
    "go",
    "week",
    "week",
    "see",
    "start",
    "see",
    "limits",
    "long",
    "takes",
    "computers",
    "solve",
    "certain",
    "problems",
    "field",
    "study",
    "concerned",
    "finding",
    "amount",
    "time",
    "amount",
    "space",
    "amount",
    "resources",
    "required",
    "complete",
    "execution",
    "program",
    "called",
    "analysis",
    "algorithms",
    "process",
    "figuring",
    "best",
    "algorithm",
    "solve",
    "problem",
    "called",
    "algorithm",
    "design",
    "actually",
    "analysis",
    "algorithms",
    "right",
    "algorithm",
    "design",
    "next",
    "couple",
    "terms",
    "need",
    "understand",
    "go",
    "back",
    "writing",
    "code",
    "uh",
    "first",
    "thing",
    "complexity",
    "second",
    "thing",
    "big",
    "notation",
    "terms",
    "hear",
    "frequently",
    "talking",
    "data",
    "structures",
    "algorithms",
    "talking",
    "coding",
    "uh",
    "interviews",
    "assessments",
    "terms",
    "need",
    "understand",
    "fairly",
    "simple",
    "terms",
    "although",
    "term",
    "complexity",
    "means",
    "complexity",
    "algorithm",
    "simply",
    "measure",
    "measure",
    "amount",
    "time",
    "space",
    "required",
    "algorithm",
    "process",
    "input",
    "given",
    "size",
    "example",
    "list",
    "size",
    "n",
    "complexity",
    "amount",
    "time",
    "required",
    "amount",
    "space",
    "required",
    "ram",
    "process",
    "input",
    "size",
    "unless",
    "otherwise",
    "stated",
    "term",
    "complexity",
    "always",
    "refers",
    "worst",
    "case",
    "complexity",
    "possible",
    "bob",
    "turns",
    "first",
    "card",
    "answer",
    "always",
    "talk",
    "longest",
    "highest",
    "possible",
    "time",
    "space",
    "may",
    "taken",
    "program",
    "process",
    "input",
    "right",
    "need",
    "design",
    "programs",
    "keeping",
    "worst",
    "case",
    "mind",
    "case",
    "linear",
    "search",
    "implemented",
    "time",
    "complexity",
    "algorithm",
    "constant",
    "c",
    "n",
    "assuming",
    "n",
    "size",
    "list",
    "uh",
    "n",
    "number",
    "cards",
    "right",
    "constant",
    "c",
    "obviously",
    "depends",
    "number",
    "operations",
    "perform",
    "iteration",
    "loop",
    "example",
    "four",
    "five",
    "statements",
    "time",
    "taken",
    "execute",
    "statement",
    "specific",
    "hardware",
    "2",
    "ghz",
    "computer",
    "may",
    "twice",
    "fast",
    "1",
    "ghz",
    "computer",
    "running",
    "phone",
    "may",
    "different",
    "c",
    "captures",
    "things",
    "information",
    "number",
    "specific",
    "operations",
    "perform",
    "iteration",
    "information",
    "actual",
    "hardware",
    "running",
    "cn",
    "time",
    "complexity",
    "n",
    "size",
    "input",
    "sense",
    "understand",
    "time",
    "complexity",
    "proportional",
    "size",
    "input",
    "important",
    "part",
    "constant",
    "know",
    "change",
    "change",
    "input",
    "constant",
    "really",
    "change",
    "similarly",
    "space",
    "complexity",
    "since",
    "already",
    "given",
    "array",
    "additional",
    "space",
    "linear",
    "search",
    "requires",
    "simply",
    "single",
    "constant",
    "calling",
    "c",
    "prime",
    "independent",
    "n",
    "matter",
    "many",
    "matter",
    "large",
    "list",
    "given",
    "list",
    "already",
    "present",
    "memory",
    "need",
    "allocate",
    "one",
    "new",
    "variable",
    "called",
    "position",
    "variable",
    "used",
    "iterate",
    "array",
    "occupies",
    "constant",
    "space",
    "computer",
    "memory",
    "keep",
    "go",
    "updating",
    "variable",
    "right",
    "space",
    "complexity",
    "c",
    "constant",
    "independent",
    "n",
    "normally",
    "represent",
    "worst",
    "case",
    "complexity",
    "often",
    "use",
    "big",
    "notation",
    "big",
    "notation",
    "drop",
    "fixed",
    "constants",
    "lower",
    "powers",
    "uh",
    "drop",
    "fixed",
    "constants",
    "drop",
    "lower",
    "powers",
    "variables",
    "idea",
    "capture",
    "trend",
    "trend",
    "relationship",
    "size",
    "input",
    "complexity",
    "algorithm",
    "example",
    "time",
    "complexity",
    "algorithm",
    "constant",
    "time",
    "n",
    "cub",
    "plus",
    "constant",
    "time",
    "n",
    "plus",
    "constant",
    "time",
    "n",
    "plus",
    "constant",
    "n",
    "size",
    "input",
    "big",
    "notation",
    "simply",
    "say",
    "order",
    "n",
    "cube",
    "know",
    "long",
    "run",
    "study",
    "trend",
    "trend",
    "something",
    "looks",
    "little",
    "bit",
    "like",
    "n",
    "cube",
    "function",
    "may",
    "offset",
    "constant",
    "putting",
    "way",
    "time",
    "complexity",
    "linear",
    "search",
    "order",
    "n",
    "dropped",
    "constant",
    "c",
    "space",
    "complexity",
    "order",
    "1",
    "drop",
    "constant",
    "c",
    "prime",
    "see",
    "okay",
    "drop",
    "constant",
    "sometimes",
    "may",
    "find",
    "okay",
    "exactly",
    "n",
    "iterations",
    "n",
    "minus",
    "one",
    "iterations",
    "drop",
    "minus",
    "one",
    "sometimes",
    "find",
    "n",
    "two",
    "iterations",
    "simply",
    "half",
    "n",
    "dro",
    "half",
    "might",
    "wonder",
    "okay",
    "might",
    "take",
    "twice",
    "three",
    "times",
    "amount",
    "time",
    "dropping",
    "constant",
    "probably",
    "important",
    "thing",
    "keep",
    "mind",
    "see",
    "see",
    "soon",
    "implement",
    "efficient",
    "solution",
    "problem",
    "move",
    "forward",
    "optimize",
    "algorithm",
    "going",
    "save",
    "work",
    "notebook",
    "mentioned",
    "running",
    "online",
    "platform",
    "set",
    "everything",
    "install",
    "anything",
    "thousands",
    "people",
    "using",
    "using",
    "platform",
    "shut",
    "keep",
    "running",
    "forever",
    "need",
    "need",
    "save",
    "work",
    "time",
    "time",
    "save",
    "work",
    "pick",
    "everything",
    "happens",
    "jovian",
    "platform",
    "need",
    "download",
    "anything",
    "although",
    "could",
    "download",
    "want",
    "need",
    "download",
    "anything",
    "need",
    "use",
    "jovian",
    "library",
    "got",
    "another",
    "helpful",
    "function",
    "say",
    "import",
    "jovian",
    "run",
    "jovian",
    "commit",
    "run",
    "jovian",
    "doc",
    "commit",
    "give",
    "project",
    "name",
    "project",
    "name",
    "want",
    "identify",
    "specific",
    "notebook",
    "arguments",
    "important",
    "even",
    "skip",
    "perfectly",
    "fine",
    "run",
    "commit",
    "capture",
    "snapshot",
    "notebook",
    "online",
    "platform",
    "wherever",
    "running",
    "even",
    "running",
    "computer",
    "capture",
    "snapshot",
    "notebook",
    "computer",
    "wherever",
    "running",
    "upload",
    "give",
    "link",
    "access",
    "let",
    "open",
    "link",
    "able",
    "see",
    "page",
    "called",
    "python",
    "binary",
    "search",
    "profile",
    "see",
    "scroll",
    "see",
    "contains",
    "explanations",
    "contains",
    "code",
    "readon",
    "version",
    "jupyter",
    "notebook",
    "read",
    "version",
    "jupyter",
    "notebook",
    "obviously",
    "require",
    "us",
    "keep",
    "servers",
    "running",
    "run",
    "code",
    "need",
    "run",
    "know",
    "work",
    "saved",
    "whatever",
    "extent",
    "executed",
    "things",
    "need",
    "run",
    "simply",
    "click",
    "run",
    "click",
    "run",
    "binder",
    "okay",
    "resume",
    "work",
    "set",
    "new",
    "machine",
    "new",
    "machine",
    "post",
    "jupyter",
    "notebook",
    "uh",
    "start",
    "machine",
    "open",
    "jupyter",
    "notebook",
    "able",
    "start",
    "running",
    "code",
    "make",
    "notebooks",
    "public",
    "keep",
    "private",
    "multiple",
    "viewership",
    "options",
    "public",
    "private",
    "anybody",
    "else",
    "take",
    "link",
    "tweet",
    "interesting",
    "problem",
    "worked",
    "want",
    "tweet",
    "share",
    "link",
    "online",
    "anybody",
    "able",
    "read",
    "solution",
    "run",
    "well",
    "right",
    "fact",
    "notebook",
    "shared",
    "hosted",
    "profile",
    "jovin",
    "platform",
    "learn",
    "also",
    "platform",
    "build",
    "repository",
    "projects",
    "go",
    "back",
    "profile",
    "click",
    "profile",
    "click",
    "jovian",
    "logo",
    "see",
    "find",
    "notebooks",
    "tab",
    "notebooks",
    "tab",
    "find",
    "notebooks",
    "worked",
    "past",
    "okay",
    "anything",
    "committed",
    "using",
    "jin",
    "comit",
    "able",
    "resume",
    "working",
    "uh",
    "save",
    "work",
    "keep",
    "saving",
    "work",
    "time",
    "time",
    "need",
    "run",
    "comit",
    "even",
    "need",
    "put",
    "project",
    "argument",
    "something",
    "want",
    "actually",
    "give",
    "project",
    "name",
    "otherwise",
    "name",
    "picked",
    "automatically",
    "keep",
    "running",
    "jovian",
    "docit",
    "time",
    "time",
    "especially",
    "leaving",
    "computer",
    "half",
    "hour",
    "uh",
    "computer",
    "get",
    "goes",
    "sleep",
    "server",
    "shut",
    "may",
    "lose",
    "work",
    "coming",
    "back",
    "problem",
    "implemented",
    "linear",
    "search",
    "understood",
    "complexity",
    "order",
    "n",
    "called",
    "linear",
    "runs",
    "linear",
    "time",
    "another",
    "expression",
    "used",
    "also",
    "called",
    "linear",
    "going",
    "array",
    "step",
    "step",
    "next",
    "step",
    "apply",
    "right",
    "technique",
    "overcome",
    "efficiency",
    "course",
    "learned",
    "techniques",
    "yet",
    "probably",
    "figure",
    "think",
    "maybe",
    "something",
    "occurred",
    "right",
    "beginning",
    "idea",
    "occurred",
    "something",
    "implement",
    "moment",
    "simply",
    "going",
    "cards",
    "one",
    "one",
    "even",
    "utilizing",
    "fact",
    "sorted",
    "approach",
    "pretty",
    "poor",
    "basically",
    "checking",
    "everything",
    "great",
    "solution",
    "would",
    "great",
    "somehow",
    "would",
    "would",
    "best",
    "case",
    "somehow",
    "bob",
    "realized",
    "somehow",
    "bob",
    "could",
    "guess",
    "card",
    "first",
    "attempt",
    "would",
    "perfect",
    "would",
    "order",
    "one",
    "would",
    "constant",
    "time",
    "solution",
    "cards",
    "turned",
    "simply",
    "impossible",
    "guess",
    "right",
    "card",
    "next",
    "best",
    "idea",
    "maybe",
    "pick",
    "random",
    "card",
    "maybe",
    "let",
    "say",
    "bob",
    "picks",
    "card",
    "card",
    "turns",
    "nine",
    "bob",
    "use",
    "fact",
    "cards",
    "sorted",
    "order",
    "card",
    "turns",
    "nine",
    "means",
    "cards",
    "numbers",
    "greater",
    "nine",
    "target",
    "card",
    "target",
    "card",
    "lie",
    "region",
    "target",
    "card",
    "lie",
    "region",
    "picking",
    "random",
    "card",
    "rather",
    "picking",
    "first",
    "card",
    "bob",
    "eliminated",
    "four",
    "seven",
    "cards",
    "checked",
    "right",
    "one",
    "check",
    "bob",
    "eliminated",
    "total",
    "five",
    "cards",
    "1",
    "2",
    "3",
    "4",
    "5",
    "course",
    "number",
    "turns",
    "seven",
    "perfect",
    "great",
    "guess",
    "even",
    "still",
    "eliminated",
    "quite",
    "number",
    "turns",
    "less",
    "seven",
    "still",
    "eliminated",
    "three",
    "cards",
    "basic",
    "idea",
    "pick",
    "something",
    "edges",
    "somewhere",
    "middle",
    "best",
    "place",
    "pick",
    "something",
    "middle",
    "obviously",
    "picking",
    "card",
    "know",
    "whether",
    "going",
    "less",
    "greater",
    "number",
    "want",
    "especially",
    "everything",
    "closed",
    "best",
    "pick",
    "middle",
    "card",
    "whichever",
    "case",
    "turns",
    "turns",
    "still",
    "left",
    "three",
    "car",
    "cards",
    "process",
    "right",
    "pick",
    "card",
    "turn",
    "seven",
    "either",
    "need",
    "look",
    "three",
    "need",
    "look",
    "three",
    "strategy",
    "follow",
    "technique",
    "called",
    "binary",
    "search",
    "keep",
    "repeating",
    "time",
    "pick",
    "middle",
    "card",
    "eliminate",
    "half",
    "array",
    "strategy",
    "looks",
    "like",
    "array",
    "array",
    "want",
    "figure",
    "number",
    "six",
    "slightly",
    "different",
    "problem",
    "still",
    "decreasing",
    "order",
    "want",
    "figure",
    "number",
    "six",
    "access",
    "middle",
    "element",
    "okay",
    "compare",
    "six",
    "six",
    "okay",
    "bad",
    "guess",
    "problem",
    "know",
    "four",
    "less",
    "six",
    "means",
    "six",
    "lies",
    "left",
    "four",
    "suddenly",
    "eliminated",
    "half",
    "array",
    "done",
    "one",
    "axis",
    "eliminated",
    "half",
    "left",
    "three",
    "numbers",
    "pick",
    "middle",
    "number",
    "get",
    "seven",
    "7",
    "greater",
    "six",
    "means",
    "number",
    "number",
    "lies",
    "right",
    "left",
    "one",
    "card",
    "overturn",
    "last",
    "card",
    "check",
    "last",
    "number",
    "okay",
    "equal",
    "six",
    "great",
    "well",
    "nothing",
    "left",
    "check",
    "numbers",
    "greater",
    "less",
    "six",
    "numbers",
    "greater",
    "six",
    "number",
    "six",
    "six",
    "like",
    "array",
    "seven",
    "elements",
    "done",
    "three",
    "checks",
    "arrived",
    "answer",
    "worst",
    "case",
    "right",
    "mean",
    "never",
    "take",
    "verify",
    "never",
    "take",
    "three",
    "checks",
    "six",
    "comes",
    "position",
    "guess",
    "immediately",
    "six",
    "comes",
    "position",
    "position",
    "guess",
    "two",
    "checks",
    "six",
    "comes",
    "positions",
    "guess",
    "three",
    "checks",
    "pretty",
    "good",
    "idea",
    "read",
    "part",
    "says",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "repeat",
    "steps",
    "3",
    "six",
    "going",
    "go",
    "back",
    "step",
    "three",
    "come",
    "correct",
    "solution",
    "problem",
    "state",
    "plain",
    "english",
    "come",
    "solution",
    "already",
    "need",
    "state",
    "technique",
    "called",
    "binary",
    "search",
    "applied",
    "problem",
    "called",
    "binary",
    "well",
    "take",
    "left",
    "right",
    "decision",
    "first",
    "find",
    "middle",
    "element",
    "list",
    "matches",
    "queried",
    "number",
    "return",
    "middle",
    "position",
    "answer",
    "less",
    "queried",
    "number",
    "search",
    "first",
    "half",
    "list",
    "greater",
    "queried",
    "number",
    "search",
    "second",
    "half",
    "list",
    "exact",
    "thing",
    "saw",
    "apply",
    "finally",
    "elements",
    "remain",
    "simply",
    "return",
    "minus",
    "one",
    "let",
    "save",
    "work",
    "let",
    "point",
    "keep",
    "saving",
    "work",
    "time",
    "time",
    "using",
    "jovian",
    "doc",
    "commit",
    "uh",
    "come",
    "algorithm",
    "important",
    "write",
    "words",
    "whether",
    "want",
    "write",
    "short",
    "description",
    "paragraph",
    "guide",
    "write",
    "words",
    "assignment",
    "let",
    "implement",
    "solution",
    "test",
    "using",
    "example",
    "inputs",
    "implementation",
    "look",
    "let",
    "go",
    "back",
    "visual",
    "representation",
    "keep",
    "track",
    "search",
    "space",
    "current",
    "initially",
    "search",
    "space",
    "entire",
    "array",
    "means",
    "array",
    "seven",
    "numbers",
    "search",
    "space",
    "goes",
    "position",
    "0",
    "position",
    "six",
    "slowly",
    "keep",
    "reducing",
    "sear",
    "search",
    "space",
    "time",
    "keep",
    "track",
    "search",
    "space",
    "create",
    "two",
    "variables",
    "low",
    "high",
    "low",
    "value",
    "zero",
    "point",
    "first",
    "position",
    "array",
    "high",
    "value",
    "pointing",
    "last",
    "position",
    "last",
    "valid",
    "position",
    "array",
    "len",
    "cards",
    "minus",
    "one",
    "low",
    "loop",
    "becomes",
    "simple",
    "long",
    "least",
    "one",
    "element",
    "search",
    "space",
    "go",
    "ahead",
    "least",
    "one",
    "element",
    "search",
    "space",
    "low",
    "value",
    "starting",
    "index",
    "less",
    "equal",
    "end",
    "value",
    "right",
    "low",
    "less",
    "equal",
    "high",
    "starting",
    "index",
    "higher",
    "end",
    "index",
    "basically",
    "exhausted",
    "covered",
    "entire",
    "list",
    "nothing",
    "search",
    "exit",
    "point",
    "okay",
    "uh",
    "uh",
    "condition",
    "satisfied",
    "initially",
    "let",
    "say",
    "seven",
    "cards",
    "low",
    "zero",
    "cards",
    "uh",
    "len",
    "cards",
    "minus",
    "one",
    "six",
    "find",
    "middle",
    "position",
    "get",
    "middle",
    "position",
    "low",
    "plus",
    "high",
    "divided",
    "two",
    "let",
    "start",
    "applying",
    "strategy",
    "say",
    "every",
    "time",
    "write",
    "line",
    "code",
    "think",
    "go",
    "wrong",
    "write",
    "like",
    "low",
    "plus",
    "high",
    "divided",
    "2",
    "think",
    "go",
    "wrong",
    "okay",
    "low",
    "plus",
    "high",
    "may",
    "divisible",
    "two",
    "low",
    "plus",
    "high",
    "divisible",
    "two",
    "may",
    "end",
    "decimal",
    "number",
    "end",
    "decimal",
    "number",
    "fact",
    "division",
    "operator",
    "python",
    "always",
    "retains",
    "floating",
    "point",
    "number",
    "use",
    "array",
    "index",
    "want",
    "use",
    "position",
    "within",
    "array",
    "need",
    "double",
    "slash",
    "integer",
    "division",
    "simply",
    "returns",
    "quotient",
    "get",
    "middle",
    "position",
    "get",
    "number",
    "middle",
    "position",
    "also",
    "get",
    "cards",
    "made",
    "access",
    "element",
    "array",
    "makes",
    "easy",
    "us",
    "count",
    "number",
    "times",
    "access",
    "one",
    "access",
    "happening",
    "inside",
    "list",
    "accesses",
    "get",
    "mid",
    "number",
    "remember",
    "last",
    "time",
    "faced",
    "error",
    "add",
    "print",
    "statements",
    "might",
    "well",
    "add",
    "print",
    "statements",
    "right",
    "away",
    "print",
    "value",
    "low",
    "value",
    "high",
    "value",
    "mid",
    "value",
    "mid",
    "number",
    "help",
    "check",
    "whether",
    "number",
    "working",
    "expect",
    "whether",
    "function",
    "working",
    "working",
    "expected",
    "comes",
    "actual",
    "check",
    "meat",
    "problem",
    "middle",
    "number",
    "matches",
    "query",
    "return",
    "middle",
    "number",
    "great",
    "found",
    "well",
    "done",
    "middle",
    "number",
    "less",
    "query",
    "remember",
    "elements",
    "sorted",
    "array",
    "looking",
    "number",
    "query",
    "middle",
    "number",
    "less",
    "query",
    "means",
    "query",
    "probably",
    "lies",
    "left",
    "query",
    "elements",
    "decreasing",
    "order",
    "right",
    "query",
    "lies",
    "left",
    "need",
    "search",
    "decrease",
    "search",
    "space",
    "beginning",
    "position",
    "middle",
    "number",
    "right",
    "simply",
    "set",
    "high",
    "mid",
    "minus",
    "one",
    "hand",
    "mid",
    "number",
    "greater",
    "query",
    "means",
    "decreasing",
    "order",
    "array",
    "query",
    "lies",
    "right",
    "need",
    "move",
    "starting",
    "search",
    "space",
    "beyond",
    "middle",
    "number",
    "simply",
    "set",
    "low",
    "mid",
    "one",
    "see",
    "written",
    "used",
    "l",
    "l",
    "loop",
    "l",
    "stands",
    "lse",
    "python",
    "last",
    "condition",
    "could",
    "might",
    "well",
    "else",
    "three",
    "possibilities",
    "either",
    "equal",
    "mid",
    "number",
    "less",
    "greater",
    "sometimes",
    "nice",
    "list",
    "possibilities",
    "make",
    "super",
    "clear",
    "makes",
    "easy",
    "debugging",
    "fixing",
    "issues",
    "well",
    "okay",
    "okay",
    "binary",
    "search",
    "based",
    "algorithm",
    "finally",
    "exit",
    "loop",
    "uh",
    "returned",
    "middle",
    "number",
    "exited",
    "function",
    "yet",
    "return",
    "minus",
    "one",
    "number",
    "found",
    "let",
    "test",
    "using",
    "test",
    "cases",
    "handy",
    "evaluate",
    "test",
    "cases",
    "function",
    "also",
    "test",
    "manually",
    "want",
    "passing",
    "individual",
    "test",
    "cases",
    "great",
    "test",
    "case",
    "zero",
    "input",
    "query",
    "passed",
    "test",
    "case",
    "one",
    "input",
    "query",
    "passed",
    "print",
    "statements",
    "clearly",
    "look",
    "test",
    "cases",
    "actually",
    "tell",
    "tested",
    "correctly",
    "see",
    "started",
    "low",
    "0",
    "high",
    "7",
    "mid",
    "mid",
    "value",
    "three",
    "0",
    "1",
    "three",
    "found",
    "number",
    "seven",
    "query",
    "one",
    "need",
    "check",
    "half",
    "array",
    "exactly",
    "moved",
    "low",
    "four",
    "high",
    "remained",
    "seven",
    "mid",
    "number",
    "became",
    "three",
    "means",
    "need",
    "check",
    "half",
    "array",
    "check",
    "number",
    "found",
    "output",
    "see",
    "exactly",
    "algorithm",
    "works",
    "general",
    "want",
    "programmer",
    "want",
    "full",
    "understanding",
    "code",
    "written",
    "want",
    "code",
    "work",
    "incidentally",
    "want",
    "want",
    "position",
    "fixing",
    "things",
    "trying",
    "different",
    "things",
    "somehow",
    "code",
    "works",
    "want",
    "complete",
    "control",
    "want",
    "know",
    "exactly",
    "code",
    "failing",
    "failing",
    "go",
    "test",
    "case",
    "2",
    "3",
    "4",
    "5",
    "6",
    "uh",
    "looks",
    "good",
    "looks",
    "like",
    "may",
    "solved",
    "everything",
    "h",
    "probably",
    "test",
    "case",
    "8",
    "seems",
    "failed",
    "test",
    "case",
    "8",
    "number",
    "list",
    "list",
    "contains",
    "repeating",
    "numbers",
    "repeating",
    "numbers",
    "query",
    "occurs",
    "multiple",
    "times",
    "look",
    "maybe",
    "let",
    "go",
    "go",
    "evaluate",
    "test",
    "case",
    "separately",
    "using",
    "singular",
    "version",
    "evaluate",
    "function",
    "look",
    "see",
    "88",
    "66",
    "bunch",
    "sixes",
    "3",
    "22",
    "0",
    "query",
    "six",
    "start",
    "low",
    "zero",
    "high",
    "14",
    "total",
    "15",
    "elements",
    "gives",
    "middle",
    "position",
    "7",
    "mid",
    "number",
    "position",
    "let",
    "count",
    "1",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "okay",
    "mid",
    "number",
    "position",
    "six",
    "great",
    "uh",
    "six",
    "also",
    "query",
    "function",
    "returns",
    "seven",
    "remember",
    "decided",
    "function",
    "return",
    "first",
    "position",
    "number",
    "within",
    "array",
    "function",
    "failing",
    "condition",
    "happening",
    "unlike",
    "linear",
    "search",
    "start",
    "left",
    "always",
    "bump",
    "first",
    "position",
    "decreasing",
    "order",
    "elements",
    "hit",
    "encounter",
    "six",
    "encounter",
    "six",
    "binary",
    "search",
    "access",
    "elements",
    "order",
    "access",
    "elements",
    "sort",
    "randomly",
    "still",
    "strategy",
    "goes",
    "left",
    "right",
    "also",
    "depends",
    "values",
    "specific",
    "elements",
    "whether",
    "element",
    "accessed",
    "element",
    "depend",
    "value",
    "let",
    "say",
    "element",
    "right",
    "kind",
    "pseudo",
    "random",
    "kind",
    "order",
    "need",
    "additional",
    "condition",
    "keep",
    "track",
    "right",
    "fix",
    "way",
    "fix",
    "actually",
    "quite",
    "simple",
    "find",
    "middle",
    "position",
    "particular",
    "range",
    "equal",
    "query",
    "simply",
    "need",
    "check",
    "whether",
    "first",
    "occurrence",
    "query",
    "list",
    "whether",
    "number",
    "come",
    "comes",
    "equal",
    "query",
    "number",
    "comes",
    "middle",
    "element",
    "also",
    "equal",
    "query",
    "obviously",
    "middle",
    "element",
    "first",
    "occurrence",
    "simply",
    "means",
    "go",
    "back",
    "occur",
    "multiple",
    "times",
    "simply",
    "means",
    "go",
    "search",
    "left",
    "half",
    "hand",
    "middle",
    "element",
    "number",
    "middle",
    "element",
    "equal",
    "query",
    "obviously",
    "sorted",
    "list",
    "greater",
    "query",
    "numbers",
    "going",
    "greater",
    "query",
    "know",
    "must",
    "first",
    "position",
    "okay",
    "make",
    "sure",
    "understand",
    "must",
    "first",
    "position",
    "query",
    "occurs",
    "make",
    "easier",
    "logic",
    "involved",
    "define",
    "helper",
    "function",
    "called",
    "test",
    "location",
    "helpful",
    "thing",
    "every",
    "time",
    "find",
    "okay",
    "cover",
    "special",
    "cases",
    "function",
    "may",
    "start",
    "get",
    "slightly",
    "longer",
    "slightly",
    "complicated",
    "may",
    "want",
    "create",
    "helper",
    "function",
    "good",
    "rule",
    "thumb",
    "functions",
    "10",
    "lines",
    "code",
    "try",
    "keep",
    "functions",
    "seven",
    "lines",
    "code",
    "seven",
    "eight",
    "lines",
    "approximately",
    "amount",
    "information",
    "hold",
    "head",
    "function",
    "seven",
    "eight",
    "lines",
    "probably",
    "take",
    "quick",
    "glance",
    "tell",
    "identify",
    "issues",
    "anywhere",
    "beyond",
    "hard",
    "writing",
    "functions",
    "going",
    "hundreds",
    "lines",
    "please",
    "stop",
    "please",
    "start",
    "breaking",
    "code",
    "small",
    "functions",
    "quote",
    "forget",
    "creator",
    "think",
    "eric",
    "meyer",
    "created",
    "rx",
    "library",
    "reactive",
    "programming",
    "said",
    "great",
    "programmers",
    "write",
    "baby",
    "code",
    "really",
    "small",
    "bits",
    "code",
    "anybody",
    "understand",
    "single",
    "look",
    "writing",
    "many",
    "functions",
    "many",
    "small",
    "pieces",
    "code",
    "small",
    "pieces",
    "logic",
    "possible",
    "let",
    "see",
    "test",
    "location",
    "function",
    "purpose",
    "take",
    "query",
    "take",
    "specific",
    "position",
    "forget",
    "binary",
    "search",
    "take",
    "specific",
    "position",
    "tell",
    "position",
    "answer",
    "first",
    "get",
    "mid",
    "number",
    "cards",
    "get",
    "mid",
    "number",
    "cards",
    "print",
    "mid",
    "print",
    "mid",
    "number",
    "compare",
    "mid",
    "number",
    "query",
    "special",
    "case",
    "need",
    "handle",
    "error",
    "need",
    "check",
    "element",
    "midn",
    "number",
    "also",
    "equal",
    "query",
    "element",
    "mid",
    "number",
    "also",
    "equal",
    "query",
    "need",
    "go",
    "left",
    "make",
    "super",
    "clear",
    "instead",
    "setting",
    "high",
    "low",
    "etc",
    "simply",
    "say",
    "need",
    "go",
    "left",
    "return",
    "actual",
    "string",
    "left",
    "one",
    "thing",
    "keep",
    "mind",
    "whenever",
    "accessing",
    "array",
    "need",
    "make",
    "sure",
    "index",
    "valid",
    "simply",
    "check",
    "mid",
    "minus",
    "one",
    "greater",
    "equal",
    "zero",
    "mid",
    "position",
    "happen",
    "search",
    "space",
    "decreases",
    "example",
    "search",
    "space",
    "mid",
    "actually",
    "position",
    "equal",
    "number",
    "mid",
    "number",
    "equal",
    "query",
    "return",
    "left",
    "otherwise",
    "return",
    "found",
    "making",
    "obvious",
    "found",
    "number",
    "return",
    "found",
    "else",
    "case",
    "mid",
    "number",
    "less",
    "query",
    "means",
    "query",
    "lies",
    "left",
    "decreasing",
    "order",
    "list",
    "need",
    "search",
    "left",
    "else",
    "returns",
    "right",
    "test",
    "location",
    "simply",
    "tells",
    "us",
    "whether",
    "found",
    "solution",
    "need",
    "look",
    "left",
    "need",
    "look",
    "right",
    "sometimes",
    "see",
    "program",
    "especially",
    "java",
    "return",
    "something",
    "like",
    "minus",
    "one",
    "0",
    "1",
    "use",
    "represent",
    "whether",
    "go",
    "left",
    "right",
    "python",
    "high",
    "level",
    "language",
    "strings",
    "first",
    "class",
    "strings",
    "first",
    "class",
    "feature",
    "language",
    "use",
    "strings",
    "really",
    "descriptive",
    "make",
    "code",
    "readable",
    "somebody",
    "else",
    "reading",
    "code",
    "able",
    "understand",
    "looking",
    "minus",
    "one",
    "one",
    "etc",
    "going",
    "difficult",
    "people",
    "understand",
    "simplify",
    "locate",
    "card",
    "function",
    "low",
    "high",
    "len",
    "cards",
    "minus",
    "one",
    "uh",
    "zero",
    "l",
    "cards",
    "minus",
    "one",
    "loop",
    "print",
    "low",
    "high",
    "well",
    "printing",
    "low",
    "high",
    "inside",
    "locate",
    "card",
    "function",
    "printing",
    "mid",
    "mid",
    "number",
    "inside",
    "test",
    "location",
    "function",
    "wherever",
    "right",
    "place",
    "print",
    "something",
    "print",
    "get",
    "mid",
    "position",
    "simply",
    "call",
    "test",
    "location",
    "testing",
    "mid",
    "answer",
    "answer",
    "go",
    "left",
    "go",
    "right",
    "makes",
    "really",
    "simple",
    "get",
    "result",
    "check",
    "result",
    "says",
    "found",
    "return",
    "mid",
    "answer",
    "says",
    "left",
    "return",
    "midus",
    "one",
    "simply",
    "move",
    "high",
    "mid",
    "minus",
    "one",
    "returns",
    "right",
    "simply",
    "set",
    "low",
    "mid",
    "plus",
    "one",
    "simply",
    "changing",
    "start",
    "position",
    "search",
    "space",
    "middle",
    "element",
    "changing",
    "end",
    "position",
    "search",
    "space",
    "middle",
    "element",
    "right",
    "makes",
    "extremely",
    "obvious",
    "really",
    "hard",
    "go",
    "wrong",
    "write",
    "code",
    "like",
    "especially",
    "binary",
    "search",
    "problems",
    "especially",
    "tricky",
    "always",
    "certain",
    "special",
    "cases",
    "need",
    "handle",
    "start",
    "handling",
    "within",
    "loop",
    "loop",
    "inside",
    "loop",
    "inside",
    "another",
    "another",
    "statement",
    "get",
    "pretty",
    "tricky",
    "difficult",
    "debug",
    "let",
    "evaluate",
    "test",
    "case",
    "looks",
    "like",
    "test",
    "case",
    "passed",
    "time",
    "perfectly",
    "go",
    "logs",
    "verify",
    "let",
    "evaluate",
    "test",
    "case",
    "test",
    "cases",
    "well",
    "every",
    "time",
    "change",
    "function",
    "helpful",
    "function",
    "every",
    "time",
    "make",
    "change",
    "run",
    "test",
    "coding",
    "platform",
    "like",
    "lead",
    "code",
    "hacker",
    "rank",
    "given",
    "test",
    "cases",
    "although",
    "test",
    "cases",
    "visible",
    "submit",
    "solution",
    "may",
    "get",
    "actual",
    "result",
    "may",
    "get",
    "know",
    "test",
    "case",
    "answer",
    "wrong",
    "may",
    "want",
    "create",
    "test",
    "cases",
    "getting",
    "lot",
    "errors",
    "fact",
    "written",
    "algorithm",
    "may",
    "realize",
    "okay",
    "maybe",
    "need",
    "add",
    "test",
    "cases",
    "number",
    "lies",
    "first",
    "half",
    "array",
    "number",
    "lies",
    "second",
    "half",
    "important",
    "factor",
    "thinking",
    "binary",
    "search",
    "thinking",
    "direction",
    "splitting",
    "array",
    "half",
    "may",
    "want",
    "add",
    "test",
    "cases",
    "number",
    "lies",
    "exactly",
    "middle",
    "left",
    "right",
    "simplest",
    "way",
    "go",
    "back",
    "tests",
    "array",
    "open",
    "create",
    "new",
    "cell",
    "pressing",
    "character",
    "b",
    "click",
    "outside",
    "press",
    "character",
    "b",
    "create",
    "new",
    "cell",
    "simply",
    "tests",
    "append",
    "write",
    "test",
    "case",
    "final",
    "code",
    "algorithm",
    "without",
    "without",
    "print",
    "statements",
    "test",
    "location",
    "locate",
    "card",
    "try",
    "creating",
    "test",
    "cases",
    "test",
    "algorithm",
    "extensively",
    "every",
    "step",
    "going",
    "save",
    "work",
    "running",
    "jovin",
    "docit",
    "analyzing",
    "algorithm",
    "complexity",
    "identifying",
    "inefficiencies",
    "may",
    "read",
    "online",
    "actually",
    "look",
    "search",
    "complexity",
    "binary",
    "search",
    "read",
    "find",
    "answer",
    "may",
    "even",
    "say",
    "interviews",
    "always",
    "nice",
    "come",
    "answer",
    "first",
    "principles",
    "always",
    "nice",
    "especially",
    "interview",
    "talk",
    "talk",
    "order",
    "whatever",
    "see",
    "let",
    "try",
    "count",
    "number",
    "iterations",
    "algorithm",
    "need",
    "minimize",
    "number",
    "times",
    "access",
    "elements",
    "array",
    "know",
    "iteration",
    "accessing",
    "element",
    "comparing",
    "bunch",
    "operations",
    "iteration",
    "accessing",
    "one",
    "element",
    "need",
    "count",
    "number",
    "iterations",
    "number",
    "times",
    "loop",
    "executed",
    "start",
    "array",
    "n",
    "elements",
    "time",
    "time",
    "size",
    "array",
    "reduces",
    "half",
    "next",
    "iteration",
    "roughly",
    "true",
    "come",
    "check",
    "middle",
    "element",
    "decide",
    "whether",
    "go",
    "left",
    "right",
    "actually",
    "probably",
    "n",
    "2",
    "minus",
    "1",
    "n",
    "n",
    "even",
    "n",
    "odd",
    "floor",
    "n",
    "by2",
    "algorithms",
    "complexities",
    "generally",
    "want",
    "interested",
    "studying",
    "trend",
    "ignore",
    "small",
    "part",
    "calculation",
    "let",
    "say",
    "uh",
    "important",
    "part",
    "even",
    "okay",
    "overestimate",
    "little",
    "bit",
    "try",
    "underestimate",
    "first",
    "iteration",
    "may",
    "left",
    "search",
    "space",
    "size",
    "n",
    "by2",
    "may",
    "slightly",
    "less",
    "okay",
    "overestimate",
    "n",
    "n",
    "first",
    "iteration",
    "left",
    "search",
    "space",
    "n",
    "by2",
    "split",
    "half",
    "next",
    "time",
    "may",
    "left",
    "search",
    "space",
    "n",
    "4",
    "n",
    "2",
    "may",
    "left",
    "may",
    "left",
    "n",
    "8",
    "possible",
    "iterations",
    "may",
    "exit",
    "may",
    "found",
    "right",
    "number",
    "always",
    "try",
    "analyze",
    "worst",
    "case",
    "complexity",
    "algorithm",
    "longest",
    "possible",
    "amount",
    "time",
    "largest",
    "amount",
    "space",
    "take",
    "right",
    "talking",
    "time",
    "counting",
    "iterations",
    "iteration",
    "takes",
    "time",
    "n",
    "8",
    "iteration",
    "3",
    "2",
    "3",
    "think",
    "start",
    "see",
    "trend",
    "k",
    "iteration",
    "end",
    "n",
    "k",
    "elements",
    "iteration",
    "stop",
    "final",
    "iteration",
    "array",
    "length",
    "one",
    "access",
    "last",
    "element",
    "check",
    "whether",
    "checking",
    "last",
    "element",
    "equal",
    "index",
    "n",
    "k",
    "set",
    "one",
    "rearrange",
    "terms",
    "get",
    "back",
    "nal",
    "2",
    "k",
    "k",
    "iteration",
    "want",
    "left",
    "one",
    "element",
    "means",
    "n",
    "2",
    "k",
    "equal",
    "1",
    "n",
    "2",
    "k",
    "words",
    "k",
    "equal",
    "log",
    "log",
    "n",
    "remember",
    "logarithms",
    "obviously",
    "log",
    "refers",
    "log",
    "base",
    "2",
    "argue",
    "change",
    "base",
    "logarithm",
    "simply",
    "add",
    "constant",
    "simply",
    "taking",
    "natural",
    "log",
    "simply",
    "add",
    "constant",
    "remember",
    "talk",
    "time",
    "complexity",
    "ignore",
    "constants",
    "generally",
    "say",
    "algorithm",
    "binary",
    "search",
    "time",
    "complexity",
    "order",
    "log",
    "n",
    "means",
    "input",
    "grows",
    "amount",
    "time",
    "taken",
    "binary",
    "search",
    "proportional",
    "logarithm",
    "number",
    "elements",
    "list",
    "passed",
    "amount",
    "time",
    "taken",
    "logarithm",
    "size",
    "initial",
    "search",
    "space",
    "verify",
    "verify",
    "space",
    "complex",
    "check",
    "simply",
    "writing",
    "well",
    "take",
    "examples",
    "let",
    "say",
    "take",
    "card",
    "list",
    "size",
    "10",
    "work",
    "worst",
    "case",
    "count",
    "many",
    "iterations",
    "compare",
    "close",
    "login",
    "exercise",
    "verify",
    "space",
    "complexity",
    "binary",
    "search",
    "order",
    "one",
    "try",
    "posting",
    "youtube",
    "comments",
    "youtube",
    "live",
    "chat",
    "space",
    "complexity",
    "binary",
    "search",
    "order",
    "one",
    "let",
    "stay",
    "let",
    "compare",
    "linear",
    "search",
    "binary",
    "search",
    "two",
    "different",
    "create",
    "large",
    "test",
    "case",
    "start",
    "see",
    "benefits",
    "difference",
    "order",
    "n",
    "algorithm",
    "order",
    "log",
    "algorithm",
    "larger",
    "test",
    "cases",
    "small",
    "test",
    "cases",
    "everything",
    "runs",
    "instantly",
    "really",
    "much",
    "hassle",
    "locate",
    "card",
    "linear",
    "linear",
    "version",
    "algorithm",
    "simply",
    "go",
    "cards",
    "one",
    "one",
    "really",
    "large",
    "test",
    "case",
    "input",
    "cards",
    "goes",
    "range",
    "okay",
    "let",
    "see",
    "1",
    "2",
    "3",
    "th",
    "another",
    "three",
    "million",
    "10",
    "million",
    "elements",
    "10",
    "million",
    "elements",
    "looking",
    "actually",
    "creating",
    "range",
    "using",
    "function",
    "python",
    "creating",
    "list",
    "numbers",
    "going",
    "10",
    "million",
    "way",
    "1",
    "decreasing",
    "list",
    "going",
    "10",
    "million",
    "1",
    "create",
    "check",
    "list",
    "looking",
    "number",
    "two",
    "occurs",
    "end",
    "sort",
    "creating",
    "see",
    "want",
    "really",
    "analyze",
    "going",
    "worst",
    "case",
    "scenario",
    "linear",
    "search",
    "binary",
    "research",
    "approximately",
    "worst",
    "case",
    "query",
    "two",
    "output",
    "output",
    "expect",
    "obviously",
    "0",
    "9999999",
    "array",
    "indices",
    "last",
    "element",
    "one",
    "element",
    "two",
    "expected",
    "output",
    "great",
    "large",
    "test",
    "let",
    "us",
    "call",
    "evaluate",
    "test",
    "case",
    "let",
    "us",
    "pass",
    "check",
    "linear",
    "search",
    "pass",
    "last",
    "test",
    "huge",
    "list",
    "may",
    "want",
    "turn",
    "display",
    "output",
    "may",
    "want",
    "want",
    "actually",
    "see",
    "input",
    "displayed",
    "simply",
    "turn",
    "display",
    "passing",
    "display",
    "equals",
    "false",
    "get",
    "back",
    "result",
    "evaluate",
    "test",
    "case",
    "function",
    "result",
    "give",
    "output",
    "actual",
    "output",
    "function",
    "whether",
    "test",
    "passed",
    "running",
    "time",
    "algorithm",
    "takes",
    "second",
    "looks",
    "like",
    "test",
    "pass",
    "algorithm",
    "correct",
    "great",
    "took",
    "1",
    "122",
    "4",
    "291",
    "milliseconds",
    "seconds",
    "answer",
    "probably",
    "tell",
    "result",
    "probably",
    "took",
    "999",
    "9998",
    "iterations",
    "go",
    "elements",
    "get",
    "end",
    "hand",
    "talk",
    "binary",
    "search",
    "passing",
    "binary",
    "search",
    "version",
    "turning",
    "displayed",
    "false",
    "displaying",
    "output",
    "okay",
    "time",
    "result",
    "test",
    "pass",
    "execution",
    "time",
    "milliseconds",
    "times",
    "faster",
    "linear",
    "search",
    "version",
    "fact",
    "tell",
    "many",
    "elements",
    "actually",
    "access",
    "check",
    "log",
    "log",
    "number",
    "7",
    "maybe",
    "know",
    "checking",
    "log",
    "2",
    "maybe",
    "check",
    "something",
    "like",
    "20",
    "elements",
    "accessed",
    "linear",
    "search",
    "needed",
    "access",
    "10",
    "million",
    "elements",
    "binary",
    "search",
    "able",
    "get",
    "answer",
    "20",
    "checks",
    "lot",
    "time",
    "saved",
    "increase",
    "size",
    "array",
    "factor",
    "10",
    "increase",
    "factor",
    "10",
    "well",
    "see",
    "far",
    "bigger",
    "difference",
    "10",
    "times",
    "larger",
    "array",
    "linear",
    "search",
    "would",
    "run",
    "10",
    "times",
    "longer",
    "whereas",
    "binary",
    "search",
    "would",
    "require",
    "three",
    "additional",
    "operations",
    "linear",
    "search",
    "would",
    "go",
    "10",
    "million",
    "operations",
    "100",
    "million",
    "operations",
    "binary",
    "search",
    "would",
    "go",
    "20",
    "operations",
    "23",
    "real",
    "difference",
    "complexities",
    "order",
    "n",
    "order",
    "login",
    "size",
    "size",
    "arrays",
    "grows",
    "bigger",
    "another",
    "way",
    "look",
    "divide",
    "complexities",
    "binary",
    "search",
    "runs",
    "n",
    "login",
    "times",
    "faster",
    "linear",
    "search",
    "fixed",
    "constant",
    "always",
    "constants",
    "involved",
    "size",
    "input",
    "grows",
    "larger",
    "difference",
    "gets",
    "bigger",
    "difference",
    "performance",
    "algorithm",
    "analysis",
    "algorithms",
    "optimization",
    "algorithms",
    "overcoming",
    "limitations",
    "computers",
    "devising",
    "clever",
    "techniques",
    "solve",
    "problems",
    "something",
    "actually",
    "apply",
    "real",
    "life",
    "well",
    "lot",
    "cases",
    "lot",
    "things",
    "may",
    "see",
    "brute",
    "force",
    "solution",
    "apply",
    "mind",
    "may",
    "find",
    "optimal",
    "solution",
    "easy",
    "way",
    "lazy",
    "way",
    "less",
    "work",
    "think",
    "graph",
    "showing",
    "comp",
    "compare",
    "common",
    "functions",
    "running",
    "times",
    "common",
    "functions",
    "vary",
    "look",
    "kinds",
    "functions",
    "look",
    "constant",
    "time",
    "functions",
    "order",
    "one",
    "example",
    "accessing",
    "element",
    "array",
    "order",
    "one",
    "even",
    "element",
    "10",
    "list",
    "10",
    "million",
    "elements",
    "access",
    "last",
    "element",
    "constant",
    "time",
    "hand",
    "looked",
    "binary",
    "search",
    "order",
    "log",
    "n",
    "also",
    "looked",
    "linear",
    "search",
    "order",
    "n",
    "future",
    "look",
    "techniques",
    "complexities",
    "n",
    "n",
    "cub",
    "n",
    "n",
    "far",
    "far",
    "higher",
    "somewhere",
    "nice",
    "special",
    "type",
    "complexity",
    "called",
    "n",
    "login",
    "rather",
    "nice",
    "talk",
    "well",
    "login",
    "fact",
    "lot",
    "questions",
    "coding",
    "assessments",
    "coding",
    "interviews",
    "tend",
    "taking",
    "algorithms",
    "would",
    "would",
    "n",
    "square",
    "complexity",
    "brute",
    "force",
    "approach",
    "optimizing",
    "either",
    "order",
    "n",
    "order",
    "n",
    "login",
    "discuss",
    "worry",
    "make",
    "sense",
    "yet",
    "hope",
    "see",
    "ignore",
    "constants",
    "lower",
    "order",
    "terms",
    "expressing",
    "complexity",
    "big",
    "notation",
    "covered",
    "binary",
    "search",
    "seen",
    "context",
    "problem",
    "step",
    "away",
    "one",
    "step",
    "abstract",
    "identify",
    "general",
    "strategy",
    "behind",
    "binary",
    "search",
    "general",
    "strategy",
    "actually",
    "applicable",
    "wide",
    "variety",
    "problems",
    "want",
    "keep",
    "programmer",
    "need",
    "abstract",
    "away",
    "peel",
    "away",
    "layers",
    "specific",
    "problem",
    "specific",
    "details",
    "find",
    "general",
    "technique",
    "find",
    "general",
    "strategy",
    "encode",
    "using",
    "functions",
    "programs",
    "general",
    "strategy",
    "come",
    "condition",
    "determine",
    "whether",
    "answer",
    "lies",
    "given",
    "position",
    "assuming",
    "kind",
    "range",
    "identify",
    "position",
    "within",
    "range",
    "maybe",
    "element",
    "within",
    "range",
    "access",
    "elements",
    "using",
    "position",
    "come",
    "condition",
    "first",
    "tells",
    "whether",
    "given",
    "position",
    "answer",
    "lies",
    "position",
    "condition",
    "first",
    "retrieve",
    "midpoint",
    "middle",
    "element",
    "list",
    "middle",
    "element",
    "midpoint",
    "answer",
    "return",
    "middle",
    "position",
    "answer",
    "done",
    "answer",
    "lies",
    "repeat",
    "search",
    "repeat",
    "process",
    "first",
    "half",
    "list",
    "first",
    "half",
    "search",
    "space",
    "answer",
    "lies",
    "repeat",
    "search",
    "second",
    "half",
    "search",
    "space",
    "generic",
    "algorithm",
    "binary",
    "search",
    "implemented",
    "python",
    "see",
    "classic",
    "detail",
    "documentation",
    "binary",
    "search",
    "going",
    "take",
    "search",
    "space",
    "low",
    "high",
    "low",
    "going",
    "zero",
    "high",
    "going",
    "well",
    "pass",
    "maybe",
    "final",
    "pass",
    "maybe",
    "final",
    "position",
    "final",
    "index",
    "array",
    "writing",
    "way",
    "rather",
    "passing",
    "passing",
    "array",
    "also",
    "allows",
    "use",
    "binary",
    "search",
    "problems",
    "based",
    "array",
    "sometimes",
    "could",
    "numbers",
    "example",
    "ask",
    "find",
    "number",
    "1",
    "million",
    "10",
    "million",
    "perfect",
    "square",
    "use",
    "binary",
    "search",
    "takes",
    "condition",
    "uh",
    "starts",
    "loop",
    "low",
    "less",
    "equals",
    "high",
    "get",
    "midpoint",
    "low",
    "plus",
    "high",
    "divided",
    "two",
    "gives",
    "us",
    "midpoint",
    "remember",
    "uh",
    "earlier",
    "condition",
    "test",
    "location",
    "condition",
    "simply",
    "supposed",
    "take",
    "middle",
    "position",
    "identify",
    "middle",
    "position",
    "answer",
    "need",
    "go",
    "left",
    "right",
    "condition",
    "return",
    "either",
    "found",
    "left",
    "right",
    "condition",
    "returns",
    "f",
    "found",
    "return",
    "midpoint",
    "answer",
    "condition",
    "returns",
    "left",
    "return",
    "high",
    "move",
    "left",
    "side",
    "take",
    "end",
    "search",
    "space",
    "set",
    "midpoint",
    "set",
    "high",
    "equal",
    "mid",
    "minus",
    "1",
    "condition",
    "returns",
    "right",
    "else",
    "case",
    "set",
    "low",
    "mid",
    "plus",
    "one",
    "take",
    "start",
    "point",
    "search",
    "space",
    "move",
    "element",
    "return",
    "minus",
    "one",
    "binary",
    "generic",
    "binary",
    "search",
    "algorithm",
    "start",
    "using",
    "happen",
    "tested",
    "piece",
    "code",
    "fact",
    "see",
    "rewrite",
    "locate",
    "card",
    "locate",
    "card",
    "uh",
    "passing",
    "cards",
    "passing",
    "query",
    "need",
    "write",
    "condition",
    "using",
    "interesting",
    "feature",
    "python",
    "writing",
    "function",
    "inside",
    "function",
    "called",
    "function",
    "closure",
    "handy",
    "feature",
    "simply",
    "write",
    "condition",
    "inside",
    "locate",
    "card",
    "binary",
    "search",
    "going",
    "pass",
    "middle",
    "value",
    "middle",
    "position",
    "condition",
    "also",
    "access",
    "cards",
    "query",
    "lies",
    "inside",
    "locate",
    "inside",
    "condition",
    "okay",
    "check",
    "get",
    "middle",
    "element",
    "cards",
    "mid",
    "cards",
    "mid",
    "equal",
    "query",
    "check",
    "check",
    "whether",
    "first",
    "occurrence",
    "query",
    "query",
    "occur",
    "query",
    "occurs",
    "return",
    "left",
    "else",
    "return",
    "found",
    "original",
    "conditions",
    "already",
    "verify",
    "going",
    "back",
    "checking",
    "important",
    "part",
    "loop",
    "gone",
    "away",
    "simply",
    "call",
    "binary",
    "search",
    "zero",
    "l",
    "cards",
    "minus",
    "one",
    "start",
    "index",
    "end",
    "index",
    "condition",
    "evaluate",
    "test",
    "cases",
    "see",
    "test",
    "cases",
    "correct",
    "use",
    "binary",
    "search",
    "function",
    "tested",
    "one",
    "problem",
    "use",
    "exact",
    "function",
    "solve",
    "problems",
    "sense",
    "tested",
    "piece",
    "logic",
    "take",
    "quick",
    "question",
    "implement",
    "spent",
    "one",
    "half",
    "hour",
    "talking",
    "uh",
    "particular",
    "problem",
    "let",
    "spend",
    "maybe",
    "2",
    "minutes",
    "talking",
    "new",
    "problem",
    "solving",
    "slightly",
    "related",
    "question",
    "given",
    "array",
    "integers",
    "sorted",
    "increasing",
    "order",
    "find",
    "starting",
    "ending",
    "position",
    "given",
    "number",
    "sorted",
    "array",
    "time",
    "increasing",
    "difference",
    "apart",
    "fact",
    "sorted",
    "increasing",
    "order",
    "uh",
    "difference",
    "looking",
    "start",
    "index",
    "end",
    "index",
    "looking",
    "start",
    "index",
    "end",
    "index",
    "particular",
    "number",
    "number",
    "repeat",
    "like",
    "saw",
    "one",
    "example",
    "simple",
    "way",
    "sol",
    "solve",
    "simple",
    "strategy",
    "binary",
    "search",
    "find",
    "first",
    "position",
    "function",
    "let",
    "read",
    "changes",
    "variable",
    "changed",
    "order",
    "elements",
    "increasing",
    "order",
    "second",
    "change",
    "uh",
    "change",
    "one",
    "change",
    "another",
    "function",
    "called",
    "last",
    "position",
    "instead",
    "checking",
    "left",
    "checking",
    "right",
    "instead",
    "checking",
    "mid",
    "minus",
    "one",
    "checking",
    "mid",
    "1",
    "mid",
    "1",
    "equals",
    "target",
    "go",
    "right",
    "course",
    "change",
    "code",
    "instead",
    "decreasing",
    "increasing",
    "order",
    "right",
    "write",
    "two",
    "position",
    "write",
    "two",
    "functions",
    "first",
    "position",
    "last",
    "position",
    "first",
    "last",
    "position",
    "simply",
    "getting",
    "first",
    "position",
    "one",
    "binary",
    "search",
    "getting",
    "last",
    "position",
    "two",
    "binary",
    "searches",
    "bad",
    "know",
    "complexity",
    "still",
    "order",
    "login",
    "two",
    "login",
    "two",
    "times",
    "constant",
    "times",
    "login",
    "express",
    "big",
    "notation",
    "still",
    "login",
    "okay",
    "quick",
    "able",
    "reuse",
    "code",
    "written",
    "ben",
    "benefit",
    "uh",
    "making",
    "generic",
    "functions",
    "like",
    "binary",
    "search",
    "fact",
    "test",
    "solution",
    "making",
    "submission",
    "let",
    "go",
    "lead",
    "let",
    "us",
    "done",
    "already",
    "copied",
    "binary",
    "search",
    "function",
    "first",
    "first",
    "position",
    "function",
    "last",
    "position",
    "function",
    "way",
    "lead",
    "code",
    "great",
    "platform",
    "practicing",
    "go",
    "lead",
    "sign",
    "uh",
    "account",
    "find",
    "lot",
    "problems",
    "especially",
    "problems",
    "tab",
    "see",
    "exactly",
    "problem",
    "solving",
    "post",
    "code",
    "binary",
    "search",
    "first",
    "position",
    "last",
    "position",
    "first",
    "last",
    "position",
    "lead",
    "code",
    "requires",
    "write",
    "class",
    "called",
    "solution",
    "something",
    "give",
    "beforehand",
    "inside",
    "solution",
    "need",
    "define",
    "function",
    "called",
    "search",
    "range",
    "simply",
    "calling",
    "first",
    "last",
    "position",
    "let",
    "see",
    "simply",
    "test",
    "code",
    "uh",
    "test",
    "case",
    "pass",
    "test",
    "case",
    "test",
    "create",
    "simply",
    "submit",
    "see",
    "problem",
    "submitted",
    "successfully",
    "tells",
    "things",
    "like",
    "much",
    "runtime",
    "used",
    "memory",
    "used",
    "solution",
    "accepted",
    "right",
    "check",
    "lead",
    "go",
    "problem",
    "section",
    "see",
    "different",
    "problems",
    "also",
    "explore",
    "different",
    "problems",
    "come",
    "every",
    "day",
    "great",
    "place",
    "practice",
    "binary",
    "search",
    "want",
    "revisit",
    "method",
    "systematic",
    "strategy",
    "applied",
    "solving",
    "problem",
    "state",
    "problem",
    "clearly",
    "identify",
    "input",
    "output",
    "formats",
    "shows",
    "understood",
    "problem",
    "problem",
    "know",
    "solution",
    "look",
    "like",
    "come",
    "example",
    "inputs",
    "outputs",
    "try",
    "cover",
    "edge",
    "cases",
    "shows",
    "envisioning",
    "different",
    "inputs",
    "come",
    "write",
    "code",
    "come",
    "correct",
    "solution",
    "necessarily",
    "efficient",
    "one",
    "state",
    "plain",
    "english",
    "try",
    "state",
    "clarify",
    "help",
    "clarify",
    "thoughts",
    "analyze",
    "algorithm",
    "complexity",
    "uh",
    "implement",
    "solution",
    "test",
    "using",
    "example",
    "inputs",
    "basic",
    "solution",
    "interviews",
    "coding",
    "assessments",
    "maybe",
    "know",
    "time",
    "limit",
    "may",
    "want",
    "implement",
    "brute",
    "force",
    "sol",
    "brute",
    "force",
    "solution",
    "may",
    "get",
    "stuck",
    "fixing",
    "issues",
    "brute",
    "force",
    "directly",
    "jump",
    "ahead",
    "step",
    "five",
    "practicing",
    "always",
    "implement",
    "brute",
    "force",
    "step",
    "five",
    "analyze",
    "algorithm",
    "complexity",
    "time",
    "simply",
    "matter",
    "counting",
    "number",
    "iterations",
    "many",
    "times",
    "loop",
    "maybe",
    "loop",
    "within",
    "loop",
    "getting",
    "executed",
    "identify",
    "inefficiencies",
    "brute",
    "force",
    "solution",
    "generally",
    "quite",
    "easy",
    "see",
    "inefficiency",
    "example",
    "case",
    "inefficiency",
    "know",
    "array",
    "sorted",
    "anything",
    "better",
    "going",
    "line",
    "line",
    "right",
    "could",
    "pick",
    "random",
    "element",
    "would",
    "help",
    "us",
    "eliminate",
    "good",
    "chunk",
    "array",
    "inefficiency",
    "apply",
    "right",
    "technique",
    "learning",
    "techniques",
    "learned",
    "binary",
    "search",
    "today",
    "going",
    "learn",
    "lot",
    "techniques",
    "asked",
    "interviews",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "repeat",
    "steps",
    "3",
    "six",
    "go",
    "back",
    "come",
    "correct",
    "solution",
    "optimized",
    "technique",
    "implement",
    "solution",
    "test",
    "using",
    "example",
    "inputs",
    "analyze",
    "algorithm",
    "complexity",
    "identify",
    "inefficiencies",
    "done",
    "created",
    "template",
    "see",
    "python",
    "pro",
    "problem",
    "solving",
    "template",
    "use",
    "template",
    "simply",
    "run",
    "run",
    "code",
    "run",
    "template",
    "run",
    "template",
    "inside",
    "see",
    "question",
    "mark",
    "bunch",
    "places",
    "give",
    "nice",
    "project",
    "name",
    "commit",
    "profile",
    "one",
    "way",
    "save",
    "copy",
    "template",
    "profile",
    "clicking",
    "duplicate",
    "button",
    "click",
    "duplicate",
    "button",
    "copy",
    "profile",
    "look",
    "find",
    "jovian",
    "profile",
    "anyway",
    "copied",
    "click",
    "run",
    "button",
    "click",
    "run",
    "binder",
    "run",
    "run",
    "template",
    "go",
    "run",
    "copy",
    "problem",
    "statement",
    "copy",
    "link",
    "problem",
    "need",
    "make",
    "submission",
    "go",
    "back",
    "refer",
    "method",
    "summarized",
    "created",
    "sections",
    "simply",
    "start",
    "filling",
    "method",
    "say",
    "step",
    "one",
    "step",
    "two",
    "step",
    "three",
    "step",
    "four",
    "step",
    "five",
    "whenever",
    "fa",
    "based",
    "difficult",
    "problem",
    "use",
    "template",
    "guarantee",
    "one",
    "work",
    "course",
    "able",
    "solve",
    "majority",
    "problems",
    "come",
    "across",
    "specifically",
    "even",
    "able",
    "follow",
    "maybe",
    "30",
    "40",
    "course",
    "easily",
    "able",
    "solve",
    "questions",
    "asked",
    "interviews",
    "questions",
    "asked",
    "interviews",
    "fairly",
    "simple",
    "terms",
    "data",
    "structures",
    "algorithms",
    "test",
    "intention",
    "test",
    "approach",
    "look",
    "quality",
    "code",
    "see",
    "clearly",
    "expressing",
    "right",
    "exactly",
    "method",
    "teaches",
    "encourage",
    "encourage",
    "try",
    "take",
    "problems",
    "places",
    "like",
    "lead",
    "code",
    "um",
    "code",
    "chef",
    "code",
    "forces",
    "links",
    "listed",
    "see",
    "practice",
    "problems",
    "bunch",
    "links",
    "listed",
    "today",
    "lesson",
    "next",
    "lesson",
    "common",
    "data",
    "structures",
    "python",
    "data",
    "structures",
    "algorithms",
    "python",
    "online",
    "certification",
    "course",
    "brought",
    "jovian",
    "thank",
    "hello",
    "welcome",
    "data",
    "structures",
    "algorithms",
    "python",
    "online",
    "certification",
    "course",
    "offered",
    "jovian",
    "today",
    "looking",
    "assignment",
    "one",
    "binary",
    "search",
    "practice",
    "let",
    "get",
    "started",
    "first",
    "thing",
    "go",
    "course",
    "website",
    "python",
    "previous",
    "lectures",
    "assignments",
    "assignment",
    "one",
    "may",
    "want",
    "review",
    "video",
    "notebook",
    "lesson",
    "one",
    "let",
    "open",
    "assignment",
    "one",
    "called",
    "binary",
    "search",
    "practice",
    "assignment",
    "apply",
    "practice",
    "concepts",
    "covered",
    "first",
    "lesson",
    "understand",
    "solve",
    "system",
    "uh",
    "solve",
    "problem",
    "systematically",
    "implement",
    "linear",
    "search",
    "analyze",
    "optimize",
    "solution",
    "using",
    "binary",
    "search",
    "ask",
    "questions",
    "help",
    "others",
    "forum",
    "let",
    "open",
    "starter",
    "notebook",
    "assignment",
    "contains",
    "problem",
    "statement",
    "information",
    "notebook",
    "looking",
    "hosted",
    "jovian",
    "see",
    "description",
    "scroll",
    "also",
    "see",
    "code",
    "need",
    "execute",
    "notebook",
    "modify",
    "code",
    "within",
    "record",
    "new",
    "version",
    "submit",
    "see",
    "score",
    "let",
    "start",
    "reading",
    "go",
    "notebook",
    "find",
    "three",
    "question",
    "marks",
    "certain",
    "places",
    "complete",
    "assignment",
    "replace",
    "question",
    "marks",
    "appropriate",
    "values",
    "expressions",
    "statements",
    "ensure",
    "notebook",
    "runs",
    "properly",
    "end",
    "end",
    "keep",
    "mind",
    "need",
    "run",
    "cells",
    "otherwise",
    "may",
    "get",
    "errors",
    "like",
    "name",
    "error",
    "undefined",
    "variables",
    "changing",
    "variable",
    "names",
    "deleting",
    "cells",
    "disturb",
    "existing",
    "code",
    "add",
    "new",
    "code",
    "cells",
    "new",
    "statements",
    "redefine",
    "change",
    "existing",
    "variables",
    "using",
    "temporary",
    "online",
    "service",
    "code",
    "execution",
    "see",
    "use",
    "moment",
    "keep",
    "saving",
    "work",
    "running",
    "regular",
    "intervals",
    "question",
    "marks",
    "optional",
    "considered",
    "evaluation",
    "although",
    "recommend",
    "learning",
    "make",
    "submission",
    "solved",
    "optional",
    "questions",
    "make",
    "submission",
    "back",
    "assignment",
    "notebook",
    "page",
    "see",
    "stuck",
    "ask",
    "help",
    "community",
    "forum",
    "listed",
    "see",
    "well",
    "one",
    "final",
    "thing",
    "want",
    "mention",
    "get",
    "help",
    "errors",
    "ask",
    "hints",
    "even",
    "share",
    "code",
    "errors",
    "getting",
    "code",
    "please",
    "ask",
    "share",
    "full",
    "working",
    "answer",
    "code",
    "forum",
    "everybody",
    "opportunity",
    "work",
    "problem",
    "statement",
    "make",
    "mistakes",
    "learn",
    "mistakes",
    "arrive",
    "right",
    "solution",
    "run",
    "code",
    "recommended",
    "way",
    "run",
    "code",
    "clicking",
    "run",
    "button",
    "top",
    "page",
    "selecting",
    "run",
    "binder",
    "also",
    "run",
    "using",
    "options",
    "like",
    "google",
    "collab",
    "kagle",
    "run",
    "computer",
    "locally",
    "going",
    "use",
    "recommended",
    "method",
    "run",
    "binder",
    "notebook",
    "running",
    "front",
    "us",
    "first",
    "thing",
    "like",
    "go",
    "kernel",
    "click",
    "restart",
    "clear",
    "output",
    "see",
    "outputs",
    "notebook",
    "scratch",
    "also",
    "going",
    "toggle",
    "header",
    "toolbar",
    "zoom",
    "bit",
    "jupiter",
    "notebook",
    "running",
    "online",
    "platform",
    "called",
    "binder",
    "starting",
    "assignment",
    "let",
    "save",
    "snapshot",
    "assignment",
    "jovian",
    "profile",
    "access",
    "later",
    "continue",
    "work",
    "going",
    "run",
    "pip",
    "install",
    "jovian",
    "going",
    "install",
    "jovian",
    "library",
    "run",
    "import",
    "jovian",
    "import",
    "library",
    "set",
    "project",
    "name",
    "calling",
    "binary",
    "search",
    "assignment",
    "run",
    "jovian",
    "doc",
    "commit",
    "taken",
    "stter",
    "notebook",
    "hosted",
    "profile",
    "run",
    "binder",
    "soon",
    "run",
    "jovian",
    "docit",
    "copy",
    "starter",
    "notebook",
    "gets",
    "sav",
    "profile",
    "see",
    "link",
    "notebook",
    "hosted",
    "jovian",
    "profile",
    "let",
    "open",
    "see",
    "personal",
    "copy",
    "assignment",
    "notebook",
    "changes",
    "make",
    "run",
    "commit",
    "get",
    "added",
    "profile",
    "want",
    "come",
    "back",
    "continue",
    "work",
    "go",
    "back",
    "original",
    "starter",
    "notebook",
    "contains",
    "blanks",
    "rather",
    "come",
    "back",
    "profile",
    "come",
    "profile",
    "simply",
    "opening",
    "profile",
    "go",
    "notebooks",
    "tab",
    "notebooks",
    "tab",
    "able",
    "find",
    "see",
    "able",
    "find",
    "binary",
    "search",
    "assignment",
    "go",
    "binary",
    "search",
    "assignment",
    "created",
    "open",
    "run",
    "binder",
    "continue",
    "work",
    "moving",
    "along",
    "problem",
    "looking",
    "given",
    "list",
    "numbers",
    "obtained",
    "rotating",
    "ass",
    "sorted",
    "list",
    "unknown",
    "number",
    "times",
    "okay",
    "two",
    "new",
    "terms",
    "rotating",
    "ass",
    "sorted",
    "list",
    "worry",
    "know",
    "means",
    "normally",
    "see",
    "new",
    "terms",
    "problem",
    "explained",
    "within",
    "problem",
    "instance",
    "see",
    "definition",
    "define",
    "rotating",
    "list",
    "removing",
    "last",
    "element",
    "list",
    "adding",
    "first",
    "element",
    "instance",
    "rotating",
    "number",
    "list",
    "3",
    "2",
    "41",
    "leads",
    "removal",
    "last",
    "number",
    "placing",
    "beginning",
    "end",
    "list",
    "1",
    "3",
    "2",
    "4",
    "new",
    "operation",
    "defining",
    "something",
    "standard",
    "find",
    "lot",
    "problems",
    "define",
    "new",
    "terms",
    "new",
    "operations",
    "becomes",
    "easier",
    "understand",
    "problem",
    "rotating",
    "list",
    "rotating",
    "list",
    "produces",
    "1",
    "3",
    "2",
    "4",
    "rotate",
    "list",
    "resulting",
    "list",
    "one",
    "time",
    "end",
    "4",
    "1",
    "3",
    "2",
    "term",
    "sorted",
    "sorted",
    "refers",
    "list",
    "elements",
    "arranged",
    "increasing",
    "order",
    "case",
    "numbers",
    "numbers",
    "1357",
    "increased",
    "arranged",
    "increasing",
    "order",
    "sorted",
    "list",
    "3241",
    "well",
    "numbers",
    "arranged",
    "increasing",
    "order",
    "sorted",
    "list",
    "given",
    "list",
    "numbers",
    "obt",
    "obtained",
    "rotating",
    "sorted",
    "list",
    "unknown",
    "number",
    "times",
    "instance",
    "sorted",
    "list",
    "0",
    "2",
    "3",
    "4",
    "5",
    "6",
    "9",
    "rotated",
    "certain",
    "number",
    "times",
    "verify",
    "rotate",
    "three",
    "times",
    "end",
    "list",
    "569",
    "0",
    "2",
    "3",
    "4",
    "right",
    "see",
    "first",
    "9",
    "comes",
    "beginning",
    "six",
    "come",
    "comes",
    "beginning",
    "five",
    "comes",
    "beginning",
    "need",
    "write",
    "function",
    "given",
    "list",
    "given",
    "original",
    "sorted",
    "list",
    "given",
    "list",
    "obtained",
    "rotating",
    "sorted",
    "list",
    "unknown",
    "number",
    "times",
    "need",
    "write",
    "function",
    "determine",
    "minimum",
    "number",
    "times",
    "original",
    "sorted",
    "list",
    "rotated",
    "obtain",
    "given",
    "list",
    "function",
    "worst",
    "case",
    "complexity",
    "order",
    "log",
    "n",
    "n",
    "length",
    "list",
    "assume",
    "numbers",
    "list",
    "unique",
    "okay",
    "three",
    "parts",
    "write",
    "function",
    "determine",
    "minimum",
    "number",
    "times",
    "need",
    "rotate",
    "original",
    "sorted",
    "list",
    "case",
    "three",
    "function",
    "worst",
    "case",
    "complexity",
    "log",
    "n",
    "determines",
    "correctness",
    "determines",
    "efficiency",
    "additional",
    "information",
    "help",
    "assume",
    "numbers",
    "list",
    "unique",
    "mentioned",
    "would",
    "also",
    "handle",
    "case",
    "list",
    "contain",
    "unique",
    "numbers",
    "apply",
    "method",
    "applying",
    "throughout",
    "course",
    "solving",
    "problems",
    "number",
    "one",
    "state",
    "problem",
    "clearly",
    "identify",
    "input",
    "output",
    "formats",
    "number",
    "two",
    "come",
    "example",
    "inputs",
    "outputs",
    "try",
    "cover",
    "edge",
    "cases",
    "number",
    "three",
    "come",
    "correct",
    "solution",
    "problem",
    "state",
    "plain",
    "english",
    "number",
    "four",
    "implement",
    "solution",
    "test",
    "using",
    "example",
    "inputs",
    "test",
    "cases",
    "implementing",
    "solution",
    "allows",
    "test",
    "using",
    "example",
    "inputs",
    "fix",
    "bugs",
    "important",
    "test",
    "cases",
    "number",
    "five",
    "analyze",
    "algorithm",
    "complexity",
    "identify",
    "inefficiencies",
    "number",
    "six",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "go",
    "back",
    "repeat",
    "steps",
    "3",
    "six",
    "come",
    "correct",
    "solution",
    "implement",
    "solution",
    "test",
    "analyze",
    "algorithm",
    "complexity",
    "review",
    "lesson",
    "one",
    "detailed",
    "explanation",
    "method",
    "let",
    "apply",
    "step",
    "step",
    "first",
    "step",
    "state",
    "problem",
    "clearly",
    "identify",
    "input",
    "output",
    "formats",
    "stated",
    "clearly",
    "enough",
    "always",
    "helps",
    "express",
    "words",
    "way",
    "makes",
    "clear",
    "something",
    "keep",
    "returning",
    "rather",
    "original",
    "problem",
    "statement",
    "something",
    "understand",
    "better",
    "okay",
    "problem",
    "overlaps",
    "original",
    "problem",
    "statement",
    "try",
    "express",
    "words",
    "case",
    "done",
    "double",
    "clicked",
    "double",
    "click",
    "edit",
    "text",
    "cell",
    "start",
    "writing",
    "problem",
    "let",
    "say",
    "given",
    "rotated",
    "list",
    "need",
    "find",
    "number",
    "times",
    "rotated",
    "okay",
    "think",
    "probably",
    "missed",
    "sorted",
    "list",
    "given",
    "sorted",
    "list",
    "rotated",
    "unknown",
    "number",
    "times",
    "need",
    "find",
    "number",
    "times",
    "rotated",
    "right",
    "maybe",
    "going",
    "say",
    "given",
    "rotated",
    "sorted",
    "list",
    "technically",
    "input",
    "sorted",
    "list",
    "rotated",
    "sorted",
    "list",
    "given",
    "rotated",
    "sorted",
    "list",
    "rotated",
    "unknown",
    "number",
    "times",
    "need",
    "find",
    "number",
    "times",
    "rotated",
    "exercise",
    "helps",
    "determine",
    "understood",
    "problem",
    "correctly",
    "may",
    "often",
    "find",
    "okay",
    "certain",
    "detail",
    "problem",
    "missed",
    "okay",
    "point",
    "happy",
    "description",
    "see",
    "matching",
    "description",
    "large",
    "extent",
    "something",
    "understand",
    "better",
    "refer",
    "point",
    "assuming",
    "know",
    "rotation",
    "sorted",
    "means",
    "otherwise",
    "could",
    "also",
    "include",
    "question",
    "function",
    "write",
    "take",
    "one",
    "input",
    "called",
    "nums",
    "represent",
    "given",
    "example",
    "okay",
    "double",
    "click",
    "one",
    "input",
    "nums",
    "sorted",
    "rotated",
    "list",
    "let",
    "give",
    "example",
    "let",
    "say",
    "take",
    "sorted",
    "list",
    "3",
    "5",
    "6",
    "7",
    "9",
    "rotate",
    "times",
    "let",
    "say",
    "rotated",
    "couple",
    "times",
    "end",
    "sorted",
    "rotated",
    "list",
    "input",
    "answered",
    "question",
    "first",
    "question",
    "express",
    "problem",
    "word",
    "words",
    "solution",
    "second",
    "question",
    "input",
    "nums",
    "represent",
    "give",
    "example",
    "represents",
    "sorted",
    "rotated",
    "list",
    "79356",
    "third",
    "question",
    "function",
    "write",
    "return",
    "single",
    "output",
    "called",
    "rotations",
    "represent",
    "well",
    "write",
    "function",
    "identifies",
    "many",
    "times",
    "list",
    "rotated",
    "number",
    "times",
    "sorted",
    "list",
    "rotated",
    "okay",
    "case",
    "example",
    "sorted",
    "list",
    "rotated",
    "twice",
    "356",
    "79",
    "rotated",
    "two",
    "times",
    "mentioned",
    "two",
    "see",
    "back",
    "quotes",
    "using",
    "next",
    "number",
    "one",
    "keyboard",
    "escape",
    "key",
    "back",
    "quotes",
    "let",
    "let",
    "express",
    "text",
    "code",
    "within",
    "markdown",
    "see",
    "gray",
    "background",
    "different",
    "font",
    "looks",
    "lot",
    "like",
    "code",
    "true",
    "nums",
    "use",
    "markdown",
    "features",
    "advantage",
    "organize",
    "descriptions",
    "text",
    "better",
    "okay",
    "based",
    "create",
    "signature",
    "functions",
    "function",
    "called",
    "counts",
    "rotations",
    "takes",
    "num",
    "list",
    "numbers",
    "returns",
    "well",
    "right",
    "putting",
    "pass",
    "know",
    "going",
    "return",
    "single",
    "number",
    "rotations",
    "step",
    "remember",
    "save",
    "notebook",
    "going",
    "run",
    "jin",
    "commit",
    "leave",
    "computer",
    "worried",
    "work",
    "may",
    "lost",
    "go",
    "open",
    "notebook",
    "jovan",
    "profile",
    "r",
    "press",
    "run",
    "point",
    "run",
    "notebook",
    "step",
    "two",
    "come",
    "example",
    "inputs",
    "outputs",
    "try",
    "cover",
    "edge",
    "cases",
    "function",
    "able",
    "handle",
    "set",
    "valid",
    "inputs",
    "variations",
    "encounter",
    "list",
    "size",
    "10",
    "rotated",
    "three",
    "times",
    "list",
    "size",
    "eight",
    "rotated",
    "five",
    "times",
    "two",
    "generic",
    "examples",
    "list",
    "rotated",
    "list",
    "rotated",
    "list",
    "rotated",
    "n",
    "minus",
    "one",
    "times",
    "n",
    "size",
    "list",
    "list",
    "rotated",
    "end",
    "times",
    "mean",
    "rotating",
    "list",
    "end",
    "times",
    "well",
    "let",
    "see",
    "empty",
    "list",
    "list",
    "containing",
    "one",
    "element",
    "think",
    "test",
    "cases",
    "definitely",
    "add",
    "test",
    "cases",
    "express",
    "test",
    "cases",
    "dictionaries",
    "help",
    "us",
    "organize",
    "test",
    "cases",
    "test",
    "easily",
    "using",
    "helper",
    "functions",
    "see",
    "organized",
    "one",
    "test",
    "case",
    "expressed",
    "test",
    "case",
    "dictionary",
    "input",
    "test",
    "case",
    "input",
    "key",
    "output",
    "test",
    "case",
    "function",
    "take",
    "many",
    "arguments",
    "input",
    "going",
    "dictionary",
    "argument",
    "case",
    "one",
    "call",
    "nums",
    "input",
    "size",
    "output",
    "okay",
    "let",
    "create",
    "test",
    "case",
    "let",
    "us",
    "uh",
    "want",
    "fetch",
    "actual",
    "input",
    "output",
    "fetch",
    "test",
    "input",
    "nums",
    "going",
    "give",
    "us",
    "nums",
    "use",
    "test",
    "input",
    "output",
    "test",
    "outputs",
    "seems",
    "error",
    "result",
    "count",
    "rotations",
    "num",
    "zero",
    "okay",
    "actual",
    "result",
    "obtained",
    "passing",
    "test",
    "case",
    "count",
    "rotations",
    "see",
    "result",
    "get",
    "back",
    "none",
    "right",
    "code",
    "says",
    "pass",
    "inside",
    "result",
    "output",
    "equal",
    "output",
    "number",
    "three",
    "result",
    "none",
    "okay",
    "test",
    "case",
    "failing",
    "right",
    "yet",
    "implemented",
    "function",
    "soon",
    "implement",
    "expect",
    "see",
    "test",
    "case",
    "passing",
    "help",
    "aoid",
    "void",
    "work",
    "given",
    "function",
    "called",
    "evaluate",
    "test",
    "case",
    "python",
    "dsa",
    "import",
    "evaluate",
    "test",
    "case",
    "call",
    "evaluate",
    "test",
    "case",
    "function",
    "want",
    "test",
    "actual",
    "test",
    "case",
    "see",
    "prints",
    "input",
    "passed",
    "expected",
    "output",
    "actual",
    "output",
    "obtained",
    "test",
    "result",
    "case",
    "test",
    "result",
    "failed",
    "execution",
    "time",
    "also",
    "printed",
    "want",
    "evaluate",
    "certain",
    "implementation",
    "faster",
    "another",
    "job",
    "create",
    "test",
    "cases",
    "scenarios",
    "listed",
    "test",
    "zero",
    "original",
    "test",
    "case",
    "created",
    "test",
    "one",
    "size",
    "list",
    "size",
    "eight",
    "rotated",
    "five",
    "times",
    "let",
    "create",
    "look",
    "something",
    "like",
    "open",
    "replace",
    "three",
    "question",
    "marks",
    "let",
    "say",
    "list",
    "size",
    "eight",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "imagine",
    "rotated",
    "five",
    "times",
    "1",
    "2",
    "3",
    "4",
    "five",
    "four",
    "five",
    "numbers",
    "move",
    "first",
    "position",
    "get",
    "input",
    "numbers",
    "output",
    "well",
    "rotated",
    "five",
    "times",
    "think",
    "guess",
    "output",
    "five",
    "list",
    "rotated",
    "output",
    "sure",
    "guess",
    "output",
    "zero",
    "let",
    "fill",
    "list",
    "rotated",
    "let",
    "try",
    "let",
    "fill",
    "one",
    "list",
    "rotated",
    "would",
    "give",
    "us",
    "735",
    "go",
    "list",
    "rotated",
    "n",
    "minus",
    "one",
    "times",
    "n",
    "size",
    "list",
    "okay",
    "let",
    "list",
    "rotated",
    "n",
    "times",
    "n",
    "size",
    "list",
    "okay",
    "look",
    "like",
    "take",
    "list",
    "first",
    "put",
    "10",
    "first",
    "position",
    "put",
    "9",
    "first",
    "position",
    "9",
    "10",
    "comes",
    "beginning",
    "3578",
    "comes",
    "move",
    "eight",
    "first",
    "position",
    "move",
    "seven",
    "move",
    "five",
    "move",
    "three",
    "move",
    "back",
    "first",
    "position",
    "end",
    "list",
    "rotated",
    "end",
    "times",
    "output",
    "case",
    "six",
    "numbers",
    "output",
    "six",
    "know",
    "sure",
    "remember",
    "question",
    "original",
    "question",
    "says",
    "write",
    "function",
    "determine",
    "minimum",
    "number",
    "times",
    "original",
    "sorted",
    "list",
    "rotated",
    "obtain",
    "given",
    "list",
    "minimum",
    "number",
    "times",
    "may",
    "want",
    "go",
    "back",
    "change",
    "need",
    "find",
    "number",
    "times",
    "rotated",
    "minimum",
    "number",
    "times",
    "rotated",
    "needs",
    "rotated",
    "right",
    "coming",
    "back",
    "output",
    "six",
    "zero",
    "keep",
    "mind",
    "empty",
    "list",
    "let",
    "figure",
    "nums",
    "output",
    "list",
    "containing",
    "one",
    "element",
    "pretty",
    "straightforward",
    "rotate",
    "list",
    "one",
    "element",
    "let",
    "decide",
    "taking",
    "tests",
    "putting",
    "single",
    "list",
    "since",
    "defined",
    "tests",
    "going",
    "use",
    "definition",
    "contains",
    "tests",
    "going",
    "pick",
    "number",
    "tests",
    "defined",
    "defined",
    "test",
    "zero",
    "test",
    "one",
    "test",
    "three",
    "test",
    "five",
    "going",
    "put",
    "test",
    "zero",
    "test",
    "one",
    "test",
    "three",
    "test",
    "five",
    "full",
    "set",
    "tests",
    "definitely",
    "need",
    "fill",
    "test",
    "test",
    "cases",
    "think",
    "cases",
    "testing",
    "include",
    "test",
    "cases",
    "well",
    "okay",
    "evaluate",
    "function",
    "test",
    "cases",
    "together",
    "use",
    "evaluate",
    "test",
    "cases",
    "helper",
    "function",
    "jian",
    "two",
    "functions",
    "evaluate",
    "test",
    "case",
    "works",
    "single",
    "test",
    "case",
    "evaluate",
    "test",
    "cases",
    "works",
    "list",
    "test",
    "cases",
    "list",
    "test",
    "cases",
    "four",
    "eight",
    "least",
    "created",
    "import",
    "python",
    "dsa",
    "evaluate",
    "test",
    "cases",
    "invoke",
    "evaluate",
    "test",
    "cases",
    "count",
    "rotations",
    "function",
    "still",
    "logic",
    "function",
    "test",
    "cases",
    "pass",
    "list",
    "test",
    "cases",
    "created",
    "see",
    "test",
    "cases",
    "zero",
    "fails",
    "one",
    "fails",
    "two",
    "fails",
    "three",
    "fails",
    "four",
    "test",
    "cases",
    "none",
    "passed",
    "problem",
    "completed",
    "step",
    "two",
    "create",
    "test",
    "cases",
    "know",
    "defined",
    "function",
    "whether",
    "function",
    "definition",
    "correct",
    "next",
    "step",
    "come",
    "correct",
    "solution",
    "problem",
    "state",
    "plain",
    "english",
    "hint",
    "already",
    "coming",
    "correct",
    "solution",
    "quite",
    "easy",
    "based",
    "simple",
    "insight",
    "list",
    "sorted",
    "numbers",
    "rotated",
    "k",
    "times",
    "keep",
    "rotating",
    "step",
    "step",
    "moving",
    "last",
    "number",
    "first",
    "position",
    "smallest",
    "number",
    "list",
    "ends",
    "position",
    "k",
    "okay",
    "verify",
    "simple",
    "whenever",
    "doubt",
    "create",
    "new",
    "cell",
    "way",
    "create",
    "new",
    "cell",
    "clicking",
    "left",
    "side",
    "cell",
    "click",
    "insert",
    "cell",
    "code",
    "cell",
    "click",
    "near",
    "prompt",
    "press",
    "b",
    "character",
    "adds",
    "new",
    "cell",
    "let",
    "take",
    "list",
    "1",
    "3",
    "5",
    "7",
    "5",
    "67",
    "let",
    "rotate",
    "k",
    "times",
    "let",
    "try",
    "k",
    "equal",
    "2",
    "set",
    "k",
    "equal",
    "two",
    "going",
    "take",
    "two",
    "numbers",
    "end",
    "move",
    "beginning",
    "means",
    "0",
    "comes",
    "position",
    "six",
    "comes",
    "position",
    "0",
    "7",
    "comes",
    "position",
    "1",
    "starting",
    "element",
    "sorted",
    "list",
    "comes",
    "position",
    "two",
    "interesting",
    "let",
    "move",
    "third",
    "element",
    "well",
    "okay",
    "moved",
    "three",
    "elements",
    "rotated",
    "list",
    "three",
    "times",
    "smallest",
    "element",
    "ends",
    "position",
    "three",
    "seems",
    "hold",
    "true",
    "verify",
    "larger",
    "list",
    "smaller",
    "list",
    "empty",
    "list",
    "test",
    "cases",
    "list",
    "sorted",
    "k",
    "times",
    "sorted",
    "list",
    "rotated",
    "k",
    "times",
    "smallest",
    "number",
    "list",
    "ends",
    "position",
    "k",
    "counting",
    "zero",
    "number",
    "list",
    "smaller",
    "number",
    "see",
    "smallest",
    "number",
    "position",
    "three",
    "numbers",
    "higher",
    "numbers",
    "come",
    "except",
    "number",
    "one",
    "smaller",
    "seven",
    "simply",
    "need",
    "check",
    "number",
    "list",
    "whether",
    "smaller",
    "number",
    "comes",
    "number",
    "answer",
    "simply",
    "uh",
    "number",
    "rotations",
    "simply",
    "position",
    "number",
    "right",
    "find",
    "position",
    "number",
    "smaller",
    "number",
    "comes",
    "position",
    "number",
    "also",
    "equal",
    "number",
    "times",
    "sorted",
    "list",
    "rotated",
    "find",
    "number",
    "list",
    "rotated",
    "see",
    "list",
    "applying",
    "logic",
    "three",
    "number",
    "smallest",
    "number",
    "three",
    "number",
    "lower",
    "number",
    "precedes",
    "predecessor",
    "29",
    "since",
    "three",
    "occurs",
    "position",
    "4",
    "well",
    "actually",
    "three",
    "occurs",
    "position",
    "three",
    "0",
    "1",
    "2",
    "3",
    "list",
    "rotated",
    "exactly",
    "3",
    "times",
    "use",
    "linear",
    "search",
    "algorithm",
    "first",
    "attempt",
    "solve",
    "problem",
    "linear",
    "search",
    "simply",
    "involves",
    "working",
    "list",
    "walking",
    "list",
    "left",
    "right",
    "task",
    "used",
    "describe",
    "linear",
    "search",
    "solution",
    "words",
    "please",
    "write",
    "words",
    "going",
    "write",
    "let",
    "say",
    "create",
    "variable",
    "position",
    "value",
    "zero",
    "position",
    "tracking",
    "tracking",
    "position",
    "look",
    "number",
    "given",
    "position",
    "look",
    "compare",
    "number",
    "let",
    "say",
    "current",
    "position",
    "number",
    "starting",
    "position",
    "value",
    "zero",
    "maybe",
    "may",
    "number",
    "may",
    "able",
    "compare",
    "something",
    "may",
    "even",
    "start",
    "value",
    "one",
    "right",
    "number",
    "smaller",
    "read",
    "cessor",
    "return",
    "position",
    "position",
    "answer",
    "found",
    "number",
    "smaller",
    "predecessor",
    "one",
    "number",
    "otherwise",
    "increment",
    "position",
    "repeat",
    "till",
    "exhaust",
    "numbers",
    "okay",
    "simple",
    "add",
    "steps",
    "description",
    "algorithm",
    "requires",
    "steps",
    "perfectly",
    "right",
    "point",
    "clear",
    "description",
    "solution",
    "starting",
    "position",
    "one",
    "zero",
    "also",
    "want",
    "track",
    "previous",
    "position",
    "import",
    "jovian",
    "commit",
    "project",
    "keep",
    "saving",
    "work",
    "every",
    "step",
    "continue",
    "work",
    "talking",
    "implementing",
    "solution",
    "testing",
    "let",
    "implement",
    "solution",
    "said",
    "want",
    "start",
    "position",
    "want",
    "start",
    "position",
    "one",
    "loop",
    "terminated",
    "well",
    "position",
    "less",
    "len",
    "nums",
    "guess",
    "fair",
    "success",
    "criteria",
    "position",
    "greater",
    "zero",
    "nums",
    "position",
    "less",
    "nums",
    "position",
    "minus",
    "one",
    "okay",
    "success",
    "criteria",
    "see",
    "condition",
    "position",
    "greater",
    "zero",
    "really",
    "need",
    "start",
    "position",
    "zero",
    "start",
    "position",
    "really",
    "need",
    "start",
    "position",
    "one",
    "start",
    "position",
    "zero",
    "well",
    "happen",
    "condition",
    "get",
    "skipped",
    "position",
    "get",
    "incremented",
    "good",
    "practice",
    "whenever",
    "iterate",
    "list",
    "normally",
    "want",
    "start",
    "zero",
    "avoid",
    "confusion",
    "later",
    "reading",
    "code",
    "intend",
    "write",
    "zero",
    "one",
    "etc",
    "etc",
    "put",
    "position",
    "equals",
    "0",
    "simply",
    "skip",
    "check",
    "simply",
    "skip",
    "comparison",
    "position",
    "valid",
    "right",
    "whenever",
    "accessing",
    "element",
    "inside",
    "list",
    "inside",
    "dictionary",
    "always",
    "want",
    "make",
    "sure",
    "index",
    "key",
    "valid",
    "okay",
    "making",
    "sure",
    "key",
    "position",
    "minus",
    "one",
    "valid",
    "checking",
    "position",
    "greater",
    "zero",
    "case",
    "logic",
    "finally",
    "saying",
    "number",
    "position",
    "less",
    "number",
    "comes",
    "return",
    "going",
    "going",
    "increment",
    "position",
    "going",
    "check",
    "till",
    "run",
    "numbers",
    "ex",
    "exhausted",
    "entire",
    "list",
    "follows",
    "rotations",
    "n",
    "rotations",
    "exactly",
    "either",
    "case",
    "number",
    "return",
    "zero",
    "okay",
    "keep",
    "mind",
    "may",
    "doubt",
    "returning",
    "minus",
    "one",
    "returning",
    "zero",
    "well",
    "question",
    "specify",
    "clearly",
    "given",
    "sorted",
    "rotated",
    "list",
    "find",
    "number",
    "times",
    "rotated",
    "obviously",
    "minus1",
    "rotations",
    "possible",
    "minus1",
    "would",
    "val",
    "valid",
    "return",
    "value",
    "function",
    "reason",
    "write",
    "test",
    "cases",
    "let",
    "evaluate",
    "test",
    "case",
    "let",
    "call",
    "evaluate",
    "test",
    "case",
    "single",
    "test",
    "case",
    "count",
    "rotations",
    "linear",
    "let",
    "see",
    "test",
    "case",
    "test",
    "case",
    "output",
    "call",
    "evaluate",
    "test",
    "case",
    "count",
    "rotations",
    "linear",
    "test",
    "gives",
    "us",
    "linear",
    "search",
    "result",
    "see",
    "number",
    "list",
    "numbers",
    "expected",
    "output",
    "actual",
    "output",
    "great",
    "function",
    "seems",
    "passed",
    "test",
    "case",
    "evaluate",
    "test",
    "cases",
    "calling",
    "count",
    "rotations",
    "linear",
    "test",
    "cases",
    "together",
    "give",
    "gives",
    "us",
    "whole",
    "list",
    "test",
    "results",
    "test",
    "case",
    "0",
    "1",
    "two",
    "three",
    "passed",
    "put",
    "minus",
    "one",
    "would",
    "see",
    "one",
    "test",
    "cases",
    "would",
    "fail",
    "case",
    "list",
    "rotated",
    "rotated",
    "end",
    "times",
    "okay",
    "tell",
    "answer",
    "zero",
    "linear",
    "search",
    "algorithm",
    "point",
    "may",
    "face",
    "issues",
    "may",
    "feel",
    "stuck",
    "may",
    "able",
    "figure",
    "write",
    "code",
    "perfectly",
    "right",
    "part",
    "learning",
    "may",
    "face",
    "errors",
    "may",
    "face",
    "exceptions",
    "instance",
    "check",
    "position",
    "greater",
    "zero",
    "maybe",
    "condition",
    "like",
    "position",
    "less",
    "equals",
    "position",
    "1",
    "okay",
    "go",
    "forum",
    "post",
    "issue",
    "let",
    "open",
    "forum",
    "forum",
    "discussion",
    "assignment",
    "one",
    "go",
    "original",
    "topic",
    "longer",
    "discussion",
    "everybody",
    "posting",
    "small",
    "issues",
    "see",
    "321",
    "messages",
    "posted",
    "start",
    "looking",
    "forum",
    "start",
    "reading",
    "posts",
    "even",
    "search",
    "press",
    "crf",
    "even",
    "search",
    "questions",
    "want",
    "post",
    "question",
    "scroll",
    "end",
    "click",
    "button",
    "click",
    "reply",
    "okay",
    "mention",
    "question",
    "music",
    "issue",
    "return",
    "minus",
    "one",
    "zero",
    "case",
    "list",
    "rotated",
    "okay",
    "maybe",
    "want",
    "code",
    "working",
    "error",
    "also",
    "include",
    "screenshot",
    "code",
    "show",
    "another",
    "trick",
    "actually",
    "include",
    "let",
    "say",
    "commit",
    "notebook",
    "let",
    "come",
    "committed",
    "notebook",
    "particular",
    "line",
    "code",
    "want",
    "share",
    "actually",
    "click",
    "copy",
    "cell",
    "link",
    "paste",
    "give",
    "link",
    "entire",
    "cell",
    "somebody",
    "clicks",
    "link",
    "view",
    "specific",
    "cell",
    "notebook",
    "directly",
    "let",
    "see",
    "see",
    "brings",
    "us",
    "directly",
    "specific",
    "cell",
    "another",
    "option",
    "even",
    "click",
    "embed",
    "cell",
    "okay",
    "embed",
    "secret",
    "notebooks",
    "allow",
    "embedding",
    "copying",
    "cell",
    "link",
    "work",
    "click",
    "reply",
    "question",
    "posted",
    "somebody",
    "reply",
    "question",
    "come",
    "back",
    "forum",
    "hours",
    "maybe",
    "next",
    "day",
    "see",
    "answer",
    "also",
    "receive",
    "email",
    "discussion",
    "topic",
    "also",
    "go",
    "back",
    "topic",
    "category",
    "create",
    "new",
    "question",
    "see",
    "want",
    "start",
    "thread",
    "think",
    "question",
    "deserves",
    "deeper",
    "discussion",
    "multiple",
    "people",
    "reply",
    "also",
    "create",
    "new",
    "thread",
    "clicking",
    "new",
    "topic",
    "okay",
    "keep",
    "mind",
    "make",
    "use",
    "forum",
    "seen",
    "people",
    "active",
    "forum",
    "least",
    "four",
    "five",
    "times",
    "likely",
    "complete",
    "course",
    "earn",
    "certificate",
    "accomplishment",
    "continue",
    "working",
    "topics",
    "course",
    "well",
    "okay",
    "next",
    "step",
    "analyze",
    "algorithm",
    "complexity",
    "way",
    "seen",
    "lesson",
    "one",
    "simply",
    "count",
    "number",
    "iterations",
    "number",
    "executions",
    "loop",
    "list",
    "numbers",
    "size",
    "n",
    "see",
    "key",
    "loop",
    "position",
    "less",
    "length",
    "numbers",
    "n",
    "loops",
    "n",
    "iterations",
    "inside",
    "iteration",
    "performing",
    "certain",
    "comparisons",
    "returning",
    "things",
    "effect",
    "constant",
    "time",
    "based",
    "probably",
    "tell",
    "complexity",
    "linear",
    "search",
    "order",
    "n",
    "put",
    "big",
    "n",
    "big",
    "notation",
    "would",
    "order",
    "n",
    "first",
    "part",
    "assignment",
    "linear",
    "search",
    "next",
    "step",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "see",
    "read",
    "rest",
    "assignment",
    "idea",
    "binary",
    "search",
    "technique",
    "apply",
    "key",
    "question",
    "need",
    "answer",
    "binary",
    "search",
    "given",
    "middle",
    "element",
    "decide",
    "answer",
    "means",
    "let",
    "say",
    "smallest",
    "number",
    "list",
    "whether",
    "answer",
    "lies",
    "left",
    "right",
    "okay",
    "given",
    "middle",
    "given",
    "middle",
    "element",
    "smaller",
    "predecessor",
    "answer",
    "already",
    "know",
    "one",
    "number",
    "list",
    "smaller",
    "predecessor",
    "see",
    "example",
    "middle",
    "element",
    "one",
    "suppose",
    "middle",
    "element",
    "one",
    "see",
    "one",
    "smaller",
    "8",
    "know",
    "one",
    "answer",
    "position",
    "middle",
    "element",
    "answer",
    "however",
    "need",
    "way",
    "determine",
    "whether",
    "answer",
    "lies",
    "left",
    "left",
    "middle",
    "element",
    "right",
    "consider",
    "examples",
    "see",
    "middle",
    "element",
    "three",
    "answer",
    "position",
    "two",
    "uh",
    "case",
    "answer",
    "smallest",
    "element",
    "lies",
    "left",
    "hand",
    "case",
    "see",
    "middle",
    "element",
    "four",
    "smallest",
    "element",
    "minus",
    "one",
    "lies",
    "right",
    "need",
    "apply",
    "mind",
    "think",
    "check",
    "help",
    "determine",
    "middle",
    "element",
    "given",
    "middle",
    "element",
    "answer",
    "lies",
    "left",
    "right",
    "right",
    "looking",
    "smallest",
    "element",
    "remember",
    "logic",
    "spend",
    "couple",
    "minutes",
    "come",
    "quite",
    "easily",
    "middle",
    "element",
    "list",
    "smaller",
    "last",
    "last",
    "element",
    "list",
    "okay",
    "last",
    "element",
    "range",
    "currently",
    "looking",
    "means",
    "numbers",
    "increasing",
    "order",
    "answer",
    "lies",
    "left",
    "hand",
    "middle",
    "element",
    "list",
    "larger",
    "last",
    "element",
    "range",
    "means",
    "know",
    "list",
    "rotated",
    "sorted",
    "list",
    "means",
    "numbers",
    "increase",
    "point",
    "decrease",
    "continue",
    "increasing",
    "way",
    "final",
    "element",
    "smaller",
    "means",
    "answer",
    "lies",
    "right",
    "logic",
    "binary",
    "search",
    "describe",
    "binary",
    "search",
    "solution",
    "words",
    "four",
    "five",
    "lines",
    "important",
    "express",
    "coding",
    "also",
    "going",
    "difficult",
    "always",
    "exercise",
    "expressing",
    "solution",
    "words",
    "practicing",
    "solving",
    "coding",
    "challenge",
    "something",
    "even",
    "interview",
    "also",
    "important",
    "first",
    "thing",
    "need",
    "communicate",
    "interviewer",
    "thought",
    "process",
    "thinking",
    "problem",
    "first",
    "thing",
    "need",
    "describe",
    "simple",
    "solution",
    "simple",
    "words",
    "may",
    "may",
    "ask",
    "code",
    "solution",
    "next",
    "thing",
    "identify",
    "complexity",
    "identify",
    "inefficiency",
    "next",
    "step",
    "describe",
    "optimal",
    "solution",
    "binary",
    "search",
    "solution",
    "words",
    "okay",
    "describe",
    "solution",
    "words",
    "start",
    "writing",
    "code",
    "may",
    "able",
    "follow",
    "code",
    "even",
    "written",
    "mostly",
    "correct",
    "code",
    "maybe",
    "one",
    "two",
    "edge",
    "cases",
    "wrong",
    "may",
    "still",
    "feeling",
    "know",
    "writing",
    "explain",
    "solution",
    "clearly",
    "know",
    "understand",
    "solution",
    "able",
    "follow",
    "code",
    "write",
    "able",
    "pick",
    "mistakes",
    "errors",
    "help",
    "errors",
    "one",
    "secret",
    "interviews",
    "always",
    "open",
    "helping",
    "unless",
    "make",
    "really",
    "confused",
    "keep",
    "mind",
    "describe",
    "solution",
    "words",
    "commit",
    "next",
    "step",
    "implement",
    "solution",
    "implement",
    "binary",
    "search",
    "solution",
    "described",
    "previous",
    "step",
    "let",
    "run",
    "yeah",
    "run",
    "count",
    "rotations",
    "define",
    "function",
    "count",
    "rotations",
    "binary",
    "may",
    "want",
    "review",
    "lesson",
    "one",
    "start",
    "see",
    "low",
    "starts",
    "zero",
    "high",
    "starts",
    "len",
    "nums",
    "minus",
    "one",
    "solve",
    "rest",
    "certain",
    "condition",
    "low",
    "high",
    "binary",
    "search",
    "starting",
    "entire",
    "list",
    "range",
    "looking",
    "mid",
    "number",
    "getting",
    "first",
    "mid",
    "position",
    "look",
    "number",
    "mid",
    "position",
    "check",
    "middle",
    "position",
    "answer",
    "middle",
    "position",
    "answer",
    "return",
    "middle",
    "position",
    "check",
    "answer",
    "lies",
    "left",
    "half",
    "condition",
    "decide",
    "answer",
    "lies",
    "left",
    "half",
    "condition",
    "holds",
    "true",
    "change",
    "high",
    "change",
    "end",
    "point",
    "range",
    "midus",
    "one",
    "check",
    "answer",
    "lies",
    "right",
    "half",
    "case",
    "change",
    "starting",
    "point",
    "range",
    "mid",
    "1",
    "loop",
    "repeats",
    "okay",
    "general",
    "logic",
    "binary",
    "search",
    "one",
    "thing",
    "keep",
    "mind",
    "none",
    "elements",
    "satisfy",
    "criteria",
    "answer",
    "important",
    "condition",
    "easy",
    "go",
    "wrong",
    "also",
    "called",
    "edge",
    "case",
    "trivial",
    "case",
    "handle",
    "think",
    "carefully",
    "okay",
    "done",
    "evaluate",
    "test",
    "case",
    "single",
    "test",
    "case",
    "evaluate",
    "multiple",
    "test",
    "cases",
    "test",
    "cases",
    "failing",
    "may",
    "want",
    "enable",
    "print",
    "statement",
    "inside",
    "uncommenting",
    "make",
    "sure",
    "comment",
    "end",
    "print",
    "statement",
    "help",
    "see",
    "low",
    "high",
    "mid",
    "points",
    "may",
    "want",
    "take",
    "pen",
    "paper",
    "look",
    "example",
    "failing",
    "see",
    "printed",
    "numbers",
    "match",
    "expect",
    "see",
    "debugging",
    "function",
    "important",
    "skill",
    "keep",
    "mind",
    "use",
    "debugging",
    "technique",
    "like",
    "adding",
    "print",
    "statements",
    "working",
    "problem",
    "side",
    "side",
    "paper",
    "fix",
    "issues",
    "otherwise",
    "may",
    "feel",
    "lost",
    "able",
    "look",
    "internal",
    "workings",
    "function",
    "next",
    "analyze",
    "algorithm",
    "complexity",
    "identify",
    "inefficiencies",
    "straightforward",
    "enough",
    "already",
    "looked",
    "complexity",
    "binary",
    "search",
    "need",
    "make",
    "sure",
    "within",
    "algorithm",
    "matches",
    "analysis",
    "done",
    "earlier",
    "problem",
    "size",
    "reduces",
    "half",
    "time",
    "constant",
    "work",
    "step",
    "solving",
    "problem",
    "half",
    "size",
    "roughly",
    "give",
    "answer",
    "keep",
    "committing",
    "work",
    "finally",
    "make",
    "submission",
    "two",
    "options",
    "one",
    "option",
    "take",
    "link",
    "notebook",
    "committed",
    "come",
    "assignment",
    "page",
    "let",
    "open",
    "assignment",
    "page",
    "minary",
    "search",
    "practice",
    "come",
    "paste",
    "link",
    "click",
    "submit",
    "click",
    "submit",
    "assignment",
    "submitted",
    "go",
    "automated",
    "evaluation",
    "couple",
    "minutes",
    "maybe",
    "hour",
    "depending",
    "que",
    "submissions",
    "different",
    "participants",
    "receive",
    "grade",
    "email",
    "let",
    "refresh",
    "page",
    "seems",
    "like",
    "issue",
    "issue",
    "count",
    "rotations",
    "binary",
    "defined",
    "possible",
    "happened",
    "count",
    "additions",
    "binary",
    "get",
    "defined",
    "bunch",
    "question",
    "marks",
    "may",
    "need",
    "fix",
    "issue",
    "come",
    "back",
    "make",
    "submission",
    "okay",
    "received",
    "fail",
    "grade",
    "go",
    "back",
    "fix",
    "issue",
    "come",
    "back",
    "okay",
    "important",
    "good",
    "set",
    "good",
    "set",
    "test",
    "cases",
    "test",
    "function",
    "submit",
    "get",
    "error",
    "maybe",
    "look",
    "functions",
    "performance",
    "test",
    "cases",
    "fix",
    "anything",
    "needs",
    "fixed",
    "add",
    "new",
    "test",
    "cases",
    "need",
    "one",
    "way",
    "submit",
    "simply",
    "running",
    "code",
    "p",
    "submit",
    "assignment",
    "equals",
    "python",
    "dsa",
    "hyphen",
    "assignment",
    "1",
    "code",
    "mentioned",
    "see",
    "submission",
    "made",
    "verify",
    "submission",
    "page",
    "okay",
    "assignment",
    "one",
    "next",
    "review",
    "lecture",
    "video",
    "need",
    "execute",
    "jupyter",
    "notebook",
    "may",
    "need",
    "keep",
    "may",
    "want",
    "keep",
    "jupyter",
    "notebook",
    "running",
    "side",
    "side",
    "working",
    "assignment",
    "complete",
    "assignment",
    "even",
    "attempt",
    "optional",
    "questions",
    "scroll",
    "assignment",
    "notebook",
    "find",
    "optional",
    "questions",
    "one",
    "bonus",
    "question",
    "use",
    "generic",
    "binary",
    "search",
    "algorithm",
    "inside",
    "python",
    "dsa",
    "module",
    "jovian",
    "function",
    "called",
    "binary",
    "search",
    "use",
    "generic",
    "binary",
    "search",
    "example",
    "optional",
    "bonus",
    "question",
    "handle",
    "repeating",
    "numbers",
    "say",
    "assume",
    "repeating",
    "numbers",
    "list",
    "one",
    "list",
    "repeating",
    "numbers",
    "modify",
    "solution",
    "handle",
    "special",
    "case",
    "optional",
    "bonus",
    "question",
    "three",
    "searching",
    "rotated",
    "list",
    "given",
    "rotated",
    "list",
    "instead",
    "finding",
    "number",
    "times",
    "rot",
    "trying",
    "find",
    "position",
    "certain",
    "number",
    "instance",
    "position",
    "six",
    "apply",
    "binary",
    "search",
    "modify",
    "previous",
    "solution",
    "slightly",
    "search",
    "within",
    "rotated",
    "list",
    "find",
    "position",
    "given",
    "number",
    "okay",
    "hint",
    "simply",
    "identify",
    "two",
    "sorted",
    "sub",
    "arrays",
    "within",
    "given",
    "array",
    "perform",
    "binary",
    "search",
    "subarray",
    "using",
    "identify",
    "two",
    "sorted",
    "subarrays",
    "use",
    "count",
    "rotations",
    "binary",
    "function",
    "one",
    "potential",
    "solution",
    "another",
    "way",
    "modify",
    "count",
    "rotations",
    "binary",
    "function",
    "solve",
    "problem",
    "directly",
    "interesting",
    "problem",
    "solve",
    "found",
    "assignment",
    "easy",
    "definitely",
    "solve",
    "bonus",
    "questions",
    "solve",
    "question",
    "without",
    "taking",
    "additional",
    "help",
    "solve",
    "pretty",
    "much",
    "problem",
    "related",
    "binary",
    "search",
    "may",
    "asked",
    "interview",
    "questions",
    "variations",
    "something",
    "like",
    "pretty",
    "much",
    "hardest",
    "problem",
    "may",
    "get",
    "asked",
    "also",
    "test",
    "solution",
    "making",
    "submission",
    "lead",
    "code",
    "final",
    "optional",
    "question",
    "thread",
    "forum",
    "discuss",
    "bonus",
    "questions",
    "separately",
    "well",
    "make",
    "use",
    "forum",
    "thread",
    "two",
    "optional",
    "bonus",
    "questions",
    "discussion",
    "assignment",
    "one",
    "data",
    "structures",
    "algorithms",
    "called",
    "binary",
    "search",
    "practice",
    "hello",
    "welcome",
    "data",
    "structures",
    "algorithms",
    "python",
    "online",
    "certification",
    "course",
    "jovian",
    "name",
    "akash",
    "ceo",
    "jovian",
    "earn",
    "certificate",
    "accomplishment",
    "course",
    "completing",
    "four",
    "weekly",
    "assignments",
    "course",
    "project",
    "today",
    "lesson",
    "two",
    "six",
    "open",
    "python",
    "end",
    "course",
    "website",
    "able",
    "find",
    "information",
    "course",
    "view",
    "pr",
    "previous",
    "lessons",
    "lesson",
    "one",
    "uh",
    "also",
    "work",
    "previous",
    "assignment",
    "assignment",
    "one",
    "also",
    "check",
    "course",
    "community",
    "forum",
    "get",
    "help",
    "discussions",
    "let",
    "open",
    "lesson",
    "2",
    "lesson",
    "page",
    "able",
    "see",
    "video",
    "lesson",
    "watch",
    "live",
    "watch",
    "recording",
    "also",
    "see",
    "version",
    "video",
    "lecture",
    "hindi",
    "lesson",
    "explore",
    "use",
    "cases",
    "binary",
    "search",
    "trees",
    "develop",
    "implementation",
    "scratch",
    "solving",
    "many",
    "common",
    "interview",
    "questions",
    "along",
    "way",
    "code",
    "going",
    "use",
    "lesson",
    "different",
    "notebooks",
    "containing",
    "code",
    "list",
    "let",
    "open",
    "first",
    "one",
    "see",
    "explanations",
    "code",
    "lesson",
    "binary",
    "search",
    "trees",
    "traversals",
    "balancing",
    "python",
    "second",
    "notebook",
    "course",
    "check",
    "first",
    "notebook",
    "lesson",
    "one",
    "joining",
    "us",
    "beginner",
    "friendly",
    "course",
    "need",
    "lot",
    "background",
    "programming",
    "little",
    "bit",
    "understanding",
    "python",
    "little",
    "bit",
    "high",
    "school",
    "mathematics",
    "able",
    "follow",
    "along",
    "fine",
    "know",
    "follow",
    "tutorials",
    "learn",
    "prerequisites",
    "hour",
    "two",
    "best",
    "way",
    "learn",
    "material",
    "covering",
    "course",
    "actually",
    "run",
    "code",
    "experiment",
    "run",
    "code",
    "see",
    "scroll",
    "see",
    "code",
    "page",
    "well",
    "run",
    "code",
    "two",
    "options",
    "either",
    "run",
    "using",
    "online",
    "programming",
    "platform",
    "run",
    "computer",
    "locally",
    "run",
    "code",
    "scroll",
    "click",
    "run",
    "button",
    "click",
    "run",
    "binder",
    "going",
    "start",
    "executing",
    "code",
    "looking",
    "go",
    "course",
    "page",
    "python",
    "watch",
    "video",
    "lesson",
    "two",
    "open",
    "link",
    "code",
    "read",
    "code",
    "explanations",
    "want",
    "run",
    "code",
    "click",
    "run",
    "button",
    "execute",
    "code",
    "click",
    "run",
    "button",
    "binder",
    "able",
    "see",
    "interface",
    "like",
    "jupiter",
    "notebook",
    "interface",
    "explanations",
    "seeing",
    "lesson",
    "page",
    "see",
    "explan",
    "exps",
    "available",
    "difference",
    "edit",
    "explanations",
    "go",
    "actually",
    "run",
    "code",
    "tutorial",
    "see",
    "run",
    "button",
    "click",
    "run",
    "button",
    "going",
    "run",
    "code",
    "particular",
    "cell",
    "jupiter",
    "notebook",
    "made",
    "cells",
    "couple",
    "things",
    "first",
    "thing",
    "click",
    "kernel",
    "click",
    "restart",
    "clear",
    "output",
    "clear",
    "outputs",
    "code",
    "cell",
    "execute",
    "going",
    "zoom",
    "hide",
    "interface",
    "look",
    "explanations",
    "code",
    "finally",
    "running",
    "code",
    "notebook",
    "focus",
    "solving",
    "specific",
    "problem",
    "common",
    "question",
    "question",
    "sort",
    "asked",
    "interviews",
    "interview",
    "question",
    "along",
    "way",
    "also",
    "learn",
    "build",
    "build",
    "binary",
    "trees",
    "binary",
    "search",
    "trees",
    "apply",
    "several",
    "questions",
    "question",
    "senior",
    "backend",
    "engineer",
    "jovian",
    "tasked",
    "developing",
    "fast",
    "inmemory",
    "data",
    "structure",
    "manage",
    "profile",
    "information",
    "username",
    "name",
    "email",
    "100",
    "million",
    "users",
    "allow",
    "following",
    "operations",
    "performed",
    "efficiently",
    "able",
    "insert",
    "profile",
    "information",
    "new",
    "user",
    "find",
    "profile",
    "information",
    "user",
    "given",
    "username",
    "update",
    "profile",
    "information",
    "user",
    "given",
    "username",
    "list",
    "users",
    "platform",
    "sorted",
    "username",
    "assume",
    "usernames",
    "unique",
    "realistic",
    "problem",
    "might",
    "face",
    "working",
    "company",
    "lot",
    "users",
    "let",
    "see",
    "solve",
    "problem",
    "systematic",
    "strategy",
    "apply",
    "solving",
    "problems",
    "throughout",
    "course",
    "first",
    "step",
    "state",
    "problem",
    "clearly",
    "abstract",
    "terms",
    "identify",
    "input",
    "output",
    "formats",
    "come",
    "example",
    "inputs",
    "outputs",
    "test",
    "future",
    "implementations",
    "try",
    "cover",
    "edge",
    "cases",
    "come",
    "simple",
    "correct",
    "solution",
    "problem",
    "efficient",
    "correct",
    "state",
    "plain",
    "english",
    "implement",
    "solution",
    "test",
    "using",
    "example",
    "inputs",
    "fix",
    "bugs",
    "face",
    "finally",
    "analyze",
    "algorithm",
    "complexity",
    "identify",
    "inefficiencies",
    "identify",
    "inefficiencies",
    "apply",
    "right",
    "technique",
    "data",
    "structures",
    "algorithms",
    "comes",
    "picture",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "go",
    "back",
    "step",
    "three",
    "come",
    "new",
    "correct",
    "solution",
    "also",
    "efficient",
    "state",
    "plain",
    "english",
    "implement",
    "analyze",
    "complexity",
    "follow",
    "process",
    "able",
    "solve",
    "programming",
    "problem",
    "interview",
    "question",
    "step",
    "one",
    "state",
    "problem",
    "clearly",
    "identify",
    "input",
    "output",
    "formats",
    "reduce",
    "problem",
    "simple",
    "single",
    "line",
    "statement",
    "need",
    "create",
    "data",
    "structure",
    "efficiently",
    "store",
    "100",
    "million",
    "records",
    "able",
    "perform",
    "insertion",
    "search",
    "update",
    "list",
    "operations",
    "efficient",
    "possible",
    "input",
    "key",
    "input",
    "data",
    "structure",
    "solution",
    "building",
    "going",
    "user",
    "profiles",
    "contains",
    "username",
    "name",
    "email",
    "user",
    "come",
    "solution",
    "need",
    "way",
    "represent",
    "user",
    "profiles",
    "python",
    "class",
    "would",
    "great",
    "way",
    "represent",
    "information",
    "user",
    "may",
    "heard",
    "term",
    "objectoriented",
    "programming",
    "going",
    "look",
    "familiar",
    "class",
    "simple",
    "class",
    "simply",
    "blueprint",
    "creating",
    "object",
    "object",
    "well",
    "everything",
    "python",
    "object",
    "whether",
    "looking",
    "number",
    "dictionary",
    "list",
    "uh",
    "anything",
    "create",
    "custom",
    "objects",
    "custom",
    "properties",
    "custom",
    "methods",
    "creating",
    "custom",
    "classes",
    "simplest",
    "possible",
    "class",
    "python",
    "nothing",
    "inside",
    "creating",
    "class",
    "user",
    "declare",
    "class",
    "putting",
    "nothing",
    "inside",
    "whenever",
    "put",
    "nothing",
    "inside",
    "function",
    "class",
    "anything",
    "uh",
    "put",
    "need",
    "put",
    "past",
    "statement",
    "python",
    "accept",
    "empty",
    "blocks",
    "code",
    "creating",
    "class",
    "anything",
    "inside",
    "create",
    "object",
    "often",
    "called",
    "instantiation",
    "take",
    "creating",
    "instance",
    "class",
    "instantiate",
    "object",
    "class",
    "calling",
    "like",
    "function",
    "say",
    "user",
    "one",
    "user",
    "creates",
    "object",
    "variable",
    "user",
    "one",
    "points",
    "object",
    "verify",
    "object",
    "class",
    "user",
    "simply",
    "printing",
    "checking",
    "type",
    "user",
    "one",
    "type",
    "user",
    "one",
    "user",
    "object",
    "user",
    "one",
    "contain",
    "useful",
    "information",
    "let",
    "add",
    "called",
    "constructor",
    "method",
    "constructor",
    "method",
    "used",
    "construct",
    "object",
    "store",
    "attributes",
    "properties",
    "defining",
    "class",
    "user",
    "inside",
    "defining",
    "function",
    "see",
    "function",
    "inside",
    "class",
    "indentation",
    "define",
    "function",
    "underscore",
    "uncore",
    "init",
    "takes",
    "four",
    "arguments",
    "first",
    "argument",
    "special",
    "argument",
    "called",
    "self",
    "talk",
    "three",
    "arguments",
    "username",
    "name",
    "email",
    "inside",
    "setting",
    "self",
    "username",
    "setting",
    "property",
    "self",
    "username",
    "setting",
    "property",
    "self",
    "name",
    "setting",
    "property",
    "self",
    "email",
    "finally",
    "printing",
    "user",
    "created",
    "let",
    "see",
    "let",
    "create",
    "another",
    "user",
    "user",
    "2",
    "see",
    "user",
    "2",
    "also",
    "object",
    "class",
    "user",
    "happening",
    "conceptually",
    "first",
    "thing",
    "happens",
    "invoke",
    "function",
    "invoke",
    "user",
    "function",
    "python",
    "first",
    "creates",
    "empty",
    "object",
    "class",
    "user",
    "stores",
    "variable",
    "user",
    "python",
    "invokes",
    "init",
    "function",
    "init",
    "function",
    "passes",
    "user",
    "object",
    "created",
    "self",
    "arguments",
    "passed",
    "creating",
    "object",
    "rest",
    "arguments",
    "imagine",
    "basically",
    "basically",
    "calling",
    "user",
    "doore",
    "init",
    "function",
    "user",
    "two",
    "empty",
    "object",
    "arguments",
    "john",
    "jondo",
    "inside",
    "init",
    "function",
    "simply",
    "set",
    "properties",
    "user",
    "two",
    "get",
    "user",
    "two",
    "username",
    "john",
    "user",
    "two",
    "name",
    "john",
    "user",
    "two",
    "email",
    "john",
    "basically",
    "classes",
    "work",
    "python",
    "always",
    "additional",
    "extra",
    "argument",
    "class",
    "methods",
    "refer",
    "object",
    "finally",
    "gets",
    "created",
    "okay",
    "user",
    "2",
    "created",
    "values",
    "john",
    "joho",
    "john",
    "check",
    "user",
    "two",
    "name",
    "john",
    "user",
    "two",
    "email",
    "john",
    "user",
    "two",
    "username",
    "john",
    "also",
    "define",
    "custom",
    "methods",
    "inside",
    "class",
    "obviously",
    "init",
    "method",
    "also",
    "defining",
    "another",
    "method",
    "called",
    "introduce",
    "introduce",
    "uh",
    "takes",
    "two",
    "arguments",
    "first",
    "argument",
    "self",
    "def",
    "refer",
    "actual",
    "object",
    "gets",
    "created",
    "later",
    "guest",
    "name",
    "basically",
    "say",
    "hi",
    "guest",
    "name",
    "contact",
    "blanks",
    "filled",
    "using",
    "guest",
    "name",
    "self",
    "name",
    "self",
    "email",
    "okay",
    "define",
    "method",
    "class",
    "uh",
    "another",
    "user",
    "creating",
    "jane",
    "jano",
    "jane",
    "see",
    "call",
    "introduce",
    "david",
    "user",
    "three",
    "jane",
    "becomes",
    "self",
    "david",
    "becomes",
    "guest",
    "name",
    "get",
    "hi",
    "david",
    "jane",
    "contact",
    "jan",
    "quick",
    "refresher",
    "classes",
    "python",
    "lot",
    "classes",
    "simplest",
    "thing",
    "need",
    "know",
    "define",
    "class",
    "create",
    "constructor",
    "um",
    "underscore",
    "uncore",
    "set",
    "properties",
    "like",
    "said",
    "properties",
    "name",
    "email",
    "username",
    "finally",
    "define",
    "methods",
    "like",
    "defined",
    "method",
    "introduce",
    "need",
    "today",
    "wo",
    "need",
    "much",
    "one",
    "final",
    "thing",
    "class",
    "defining",
    "two",
    "special",
    "functions",
    "underscore",
    "uncore",
    "repper",
    "andore",
    "uncore",
    "strr",
    "two",
    "functions",
    "two",
    "functions",
    "used",
    "create",
    "string",
    "representation",
    "object",
    "see",
    "create",
    "object",
    "user",
    "4",
    "try",
    "print",
    "user",
    "4",
    "see",
    "user",
    "4",
    "printed",
    "like",
    "user",
    "3",
    "printed",
    "mean",
    "user",
    "3",
    "printed",
    "user",
    "user",
    "4",
    "information",
    "printed",
    "well",
    "exercise",
    "also",
    "brings",
    "us",
    "first",
    "quiz",
    "day",
    "going",
    "three",
    "quizzes",
    "video",
    "answer",
    "quizzes",
    "linkedin",
    "go",
    "linkedin",
    "profile",
    "see",
    "posts",
    "see",
    "new",
    "post",
    "give",
    "question",
    "question",
    "purpose",
    "defining",
    "functions",
    "str",
    "str",
    "repper",
    "within",
    "class",
    "two",
    "functions",
    "different",
    "leave",
    "comment",
    "answer",
    "pick",
    "right",
    "answer",
    "one",
    "right",
    "answer",
    "one",
    "lucky",
    "winner",
    "get",
    "swag",
    "back",
    "us",
    "input",
    "way",
    "represent",
    "users",
    "creating",
    "classes",
    "output",
    "want",
    "final",
    "output",
    "want",
    "create",
    "problem",
    "data",
    "structure",
    "data",
    "structure",
    "something",
    "define",
    "using",
    "class",
    "define",
    "expect",
    "final",
    "output",
    "class",
    "called",
    "user",
    "database",
    "four",
    "methods",
    "insert",
    "find",
    "update",
    "list",
    "insert",
    "takes",
    "user",
    "inserts",
    "database",
    "find",
    "takes",
    "username",
    "returns",
    "user",
    "update",
    "takes",
    "user",
    "updates",
    "data",
    "user",
    "finally",
    "list",
    "returns",
    "list",
    "users",
    "class",
    "look",
    "like",
    "implemented",
    "yet",
    "interface",
    "next",
    "step",
    "come",
    "example",
    "inputs",
    "outputs",
    "let",
    "create",
    "sample",
    "user",
    "profiles",
    "use",
    "test",
    "functions",
    "implement",
    "going",
    "create",
    "seven",
    "user",
    "profiles",
    "see",
    "creating",
    "seven",
    "user",
    "profiles",
    "username",
    "name",
    "email",
    "storing",
    "variables",
    "using",
    "user",
    "class",
    "defined",
    "earlier",
    "also",
    "going",
    "store",
    "list",
    "users",
    "variable",
    "called",
    "users",
    "see",
    "access",
    "different",
    "fields",
    "within",
    "user",
    "profile",
    "using",
    "dot",
    "notation",
    "check",
    "bar",
    "username",
    "barage",
    "bar",
    "email",
    "barage",
    "bar",
    "name",
    "barajas",
    "also",
    "view",
    "string",
    "representation",
    "user",
    "seen",
    "print",
    "user",
    "see",
    "information",
    "user",
    "full",
    "list",
    "users",
    "created",
    "always",
    "good",
    "idea",
    "set",
    "input",
    "data",
    "set",
    "test",
    "inputs",
    "use",
    "test",
    "implementation",
    "later",
    "since",
    "implemented",
    "data",
    "structure",
    "yet",
    "possible",
    "list",
    "sample",
    "outputs",
    "try",
    "come",
    "different",
    "scenarios",
    "test",
    "future",
    "implementations",
    "let",
    "let",
    "list",
    "scenarios",
    "testing",
    "methods",
    "user",
    "database",
    "class",
    "methods",
    "insert",
    "find",
    "update",
    "list",
    "install",
    "inserting",
    "may",
    "want",
    "test",
    "inserting",
    "user",
    "empty",
    "database",
    "users",
    "called",
    "edge",
    "case",
    "general",
    "case",
    "insert",
    "user",
    "database",
    "assuming",
    "user",
    "already",
    "exist",
    "another",
    "edge",
    "case",
    "trying",
    "insert",
    "user",
    "username",
    "already",
    "exists",
    "right",
    "different",
    "ways",
    "use",
    "insert",
    "function",
    "exercise",
    "try",
    "coming",
    "different",
    "scen",
    "scarios",
    "would",
    "like",
    "test",
    "different",
    "functions",
    "insert",
    "find",
    "update",
    "list",
    "completes",
    "step",
    "two",
    "sample",
    "inputs",
    "scenarios",
    "going",
    "finally",
    "test",
    "function",
    "next",
    "step",
    "come",
    "simple",
    "correct",
    "solution",
    "state",
    "plain",
    "english",
    "simple",
    "easy",
    "solution",
    "problem",
    "simply",
    "store",
    "user",
    "user",
    "objects",
    "list",
    "sorted",
    "usernames",
    "simple",
    "enough",
    "suppose",
    "inside",
    "data",
    "structure",
    "list",
    "simply",
    "contains",
    "bunch",
    "user",
    "objects",
    "various",
    "functions",
    "implemented",
    "like",
    "insert",
    "function",
    "insert",
    "function",
    "simply",
    "requires",
    "looping",
    "list",
    "adding",
    "new",
    "user",
    "position",
    "keeps",
    "list",
    "sorted",
    "instance",
    "users",
    "akash",
    "hant",
    "sidhant",
    "already",
    "inserting",
    "user",
    "barage",
    "tell",
    "barage",
    "go",
    "akash",
    "hon",
    "alphabetical",
    "order",
    "insert",
    "new",
    "user",
    "maintain",
    "sorted",
    "property",
    "list",
    "find",
    "user",
    "simply",
    "loop",
    "list",
    "find",
    "user",
    "object",
    "username",
    "matching",
    "query",
    "looking",
    "hon",
    "instance",
    "start",
    "beginning",
    "go",
    "akash",
    "paj",
    "finally",
    "hit",
    "hon",
    "retrieve",
    "user",
    "object",
    "associated",
    "hon",
    "update",
    "updating",
    "simple",
    "well",
    "similar",
    "find",
    "find",
    "user",
    "object",
    "matching",
    "query",
    "update",
    "details",
    "user",
    "object",
    "finally",
    "internal",
    "representation",
    "already",
    "list",
    "user",
    "objects",
    "sorted",
    "usernames",
    "simply",
    "return",
    "list",
    "want",
    "list",
    "users",
    "plain",
    "english",
    "description",
    "always",
    "good",
    "idea",
    "describe",
    "solution",
    "plain",
    "english",
    "clarify",
    "doubts",
    "even",
    "interviews",
    "good",
    "idea",
    "conversation",
    "interviewer",
    "actually",
    "implement",
    "solution",
    "one",
    "fact",
    "use",
    "usernames",
    "strings",
    "compared",
    "using",
    "less",
    "greater",
    "equal",
    "operators",
    "compare",
    "strings",
    "like",
    "numbers",
    "python",
    "make",
    "easy",
    "us",
    "implement",
    "functions",
    "brings",
    "us",
    "implementation",
    "code",
    "implementing",
    "also",
    "fairly",
    "straightforward",
    "user",
    "database",
    "class",
    "actually",
    "implementing",
    "class",
    "see",
    "constructor",
    "constructor",
    "take",
    "additional",
    "arguments",
    "apart",
    "self",
    "side",
    "self",
    "set",
    "property",
    "users",
    "property",
    "users",
    "set",
    "empty",
    "list",
    "come",
    "insertion",
    "assume",
    "already",
    "users",
    "user",
    "database",
    "start",
    "pointer",
    "set",
    "zero",
    "go",
    "valid",
    "positions",
    "users",
    "list",
    "0",
    "n",
    "minus",
    "one",
    "n",
    "users",
    "find",
    "first",
    "username",
    "greater",
    "new",
    "users",
    "username",
    "instance",
    "inserting",
    "hon",
    "go",
    "akash",
    "barage",
    "finally",
    "realize",
    "next",
    "value",
    "probably",
    "sidhant",
    "want",
    "insert",
    "h",
    "sidhant",
    "right",
    "want",
    "first",
    "username",
    "greater",
    "new",
    "users",
    "username",
    "check",
    "property",
    "soon",
    "find",
    "next",
    "next",
    "user",
    "greater",
    "user",
    "needs",
    "inserted",
    "break",
    "insert",
    "user",
    "position",
    "okay",
    "insertion",
    "four",
    "five",
    "lines",
    "code",
    "work",
    "code",
    "try",
    "read",
    "code",
    "line",
    "line",
    "see",
    "works",
    "similarly",
    "find",
    "function",
    "update",
    "function",
    "list",
    "function",
    "pretty",
    "straightforward",
    "really",
    "much",
    "exercise",
    "also",
    "brute",
    "force",
    "simple",
    "implementation",
    "exercise",
    "go",
    "functions",
    "try",
    "use",
    "interactive",
    "nature",
    "jupter",
    "experiment",
    "add",
    "print",
    "statements",
    "inside",
    "functions",
    "need",
    "inside",
    "loops",
    "need",
    "visibility",
    "happening",
    "okay",
    "uh",
    "try",
    "test",
    "implementation",
    "first",
    "thing",
    "instantiating",
    "new",
    "database",
    "users",
    "using",
    "user",
    "database",
    "class",
    "say",
    "user",
    "database",
    "gives",
    "us",
    "database",
    "users",
    "let",
    "insert",
    "entries",
    "database",
    "insert",
    "instance",
    "insert",
    "value",
    "hant",
    "akash",
    "sidhant",
    "inserted",
    "three",
    "values",
    "database",
    "retrieve",
    "data",
    "given",
    "user",
    "given",
    "username",
    "using",
    "find",
    "method",
    "say",
    "database",
    "find",
    "sidon",
    "returns",
    "user",
    "check",
    "value",
    "user",
    "see",
    "retrieved",
    "data",
    "sidhant",
    "username",
    "sidhant",
    "name",
    "sidhant",
    "sin",
    "email",
    "sidhant",
    "let",
    "try",
    "changing",
    "information",
    "user",
    "change",
    "information",
    "call",
    "database",
    "update",
    "simply",
    "pass",
    "new",
    "user",
    "object",
    "let",
    "say",
    "want",
    "change",
    "information",
    "sidhant",
    "sena",
    "sidhant",
    "u",
    "call",
    "database",
    "update",
    "find",
    "information",
    "find",
    "call",
    "database",
    "find",
    "get",
    "back",
    "user",
    "object",
    "time",
    "updated",
    "information",
    "created",
    "database",
    "inserted",
    "values",
    "retrieved",
    "values",
    "also",
    "updated",
    "finally",
    "retrieve",
    "list",
    "users",
    "alphabetical",
    "order",
    "listed",
    "see",
    "see",
    "username",
    "akash",
    "username",
    "hant",
    "sidhant",
    "three",
    "values",
    "inserted",
    "alphabetical",
    "order",
    "username",
    "insert",
    "new",
    "user",
    "let",
    "say",
    "let",
    "insert",
    "barage",
    "make",
    "sure",
    "barage",
    "inserted",
    "right",
    "position",
    "okay",
    "use",
    "data",
    "structure",
    "created",
    "use",
    "empty",
    "cells",
    "try",
    "various",
    "scenarios",
    "run",
    "notebook",
    "recap",
    "created",
    "simple",
    "class",
    "inside",
    "storing",
    "list",
    "users",
    "sorted",
    "order",
    "usernames",
    "insertion",
    "pretty",
    "easy",
    "simply",
    "loop",
    "find",
    "right",
    "position",
    "insert",
    "new",
    "values",
    "finding",
    "values",
    "easy",
    "well",
    "simply",
    "loop",
    "keep",
    "comparing",
    "updating",
    "values",
    "simply",
    "matter",
    "finding",
    "updating",
    "specific",
    "value",
    "listing",
    "simple",
    "simply",
    "return",
    "internal",
    "list",
    "representation",
    "already",
    "storing",
    "sorted",
    "order",
    "usernames",
    "simplest",
    "solution",
    "one",
    "simplest",
    "solutions",
    "even",
    "simple",
    "solutions",
    "maybe",
    "next",
    "step",
    "analyze",
    "algorithm",
    "complexity",
    "identify",
    "inefficiencies",
    "typically",
    "interview",
    "setting",
    "may",
    "want",
    "implement",
    "simplest",
    "solution",
    "actually",
    "skip",
    "step",
    "four",
    "know",
    "described",
    "simplest",
    "solution",
    "english",
    "plain",
    "english",
    "step",
    "three",
    "directly",
    "jump",
    "analyzing",
    "complexity",
    "move",
    "optimization",
    "implementing",
    "optimized",
    "version",
    "practicing",
    "learning",
    "always",
    "good",
    "idea",
    "implement",
    "even",
    "brute",
    "force",
    "solutions",
    "let",
    "analyze",
    "complexity",
    "operations",
    "insert",
    "find",
    "update",
    "involve",
    "iterating",
    "list",
    "users",
    "worst",
    "case",
    "may",
    "take",
    "n",
    "iteration",
    "return",
    "result",
    "n",
    "total",
    "number",
    "users",
    "list",
    "function",
    "uh",
    "slightly",
    "different",
    "simply",
    "returns",
    "existing",
    "list",
    "list",
    "function",
    "take",
    "linear",
    "time",
    "takes",
    "constant",
    "time",
    "based",
    "information",
    "easy",
    "check",
    "guess",
    "time",
    "complexities",
    "various",
    "operations",
    "insert",
    "find",
    "update",
    "order",
    "n",
    "worst",
    "case",
    "time",
    "complexity",
    "means",
    "take",
    "n",
    "iterations",
    "however",
    "list",
    "function",
    "order",
    "one",
    "complexity",
    "means",
    "irrespective",
    "many",
    "users",
    "database",
    "returns",
    "list",
    "amount",
    "time",
    "want",
    "display",
    "list",
    "want",
    "iterate",
    "list",
    "may",
    "take",
    "additional",
    "effort",
    "getting",
    "list",
    "constant",
    "time",
    "operation",
    "time",
    "complexity",
    "exercise",
    "verify",
    "space",
    "complexity",
    "operation",
    "order",
    "one",
    "wondering",
    "mean",
    "complexity",
    "go",
    "back",
    "watch",
    "lesson",
    "one",
    "talk",
    "analysis",
    "algorithms",
    "complexities",
    "big",
    "notation",
    "calling",
    "order",
    "n",
    "big",
    "notation",
    "explained",
    "lot",
    "detail",
    "go",
    "back",
    "lesson",
    "one",
    "check",
    "created",
    "simple",
    "solution",
    "first",
    "question",
    "might",
    "wonder",
    "good",
    "enough",
    "get",
    "sense",
    "long",
    "function",
    "might",
    "take",
    "100",
    "million",
    "number",
    "users",
    "platform",
    "let",
    "create",
    "loop",
    "let",
    "create",
    "loop",
    "let",
    "run",
    "let",
    "see",
    "many",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "let",
    "run",
    "10",
    "million",
    "100",
    "million",
    "numbers",
    "creating",
    "range",
    "100",
    "million",
    "numbers",
    "running",
    "loop",
    "iterates",
    "entire",
    "range",
    "simply",
    "performing",
    "simple",
    "operation",
    "really",
    "using",
    "multiplying",
    "number",
    "simulate",
    "might",
    "happen",
    "database",
    "100",
    "million",
    "users",
    "trying",
    "access",
    "find",
    "user",
    "worst",
    "case",
    "scenario",
    "let",
    "run",
    "already",
    "see",
    "taking",
    "100",
    "million",
    "users",
    "loop",
    "takes",
    "10",
    "seconds",
    "complete",
    "took",
    "delay",
    "fetching",
    "user",
    "profiles",
    "definitely",
    "lead",
    "suboptimal",
    "user",
    "experience",
    "may",
    "cause",
    "users",
    "stop",
    "using",
    "platform",
    "together",
    "imagine",
    "came",
    "jin",
    "took",
    "10",
    "15",
    "seconds",
    "load",
    "profile",
    "maybe",
    "even",
    "longer",
    "load",
    "information",
    "display",
    "would",
    "happy",
    "experience",
    "processing",
    "time",
    "user",
    "request",
    "profile",
    "request",
    "also",
    "significantly",
    "limit",
    "number",
    "users",
    "access",
    "platform",
    "time",
    "running",
    "backend",
    "server",
    "one",
    "computer",
    "eight",
    "cores",
    "core",
    "busy",
    "10",
    "seconds",
    "time",
    "user",
    "tries",
    "access",
    "platform",
    "serve",
    "eight",
    "users",
    "10",
    "seconds",
    "time",
    "pretty",
    "bad",
    "could",
    "significantly",
    "limit",
    "number",
    "users",
    "uh",
    "significant",
    "outage",
    "lot",
    "users",
    "come",
    "platform",
    "hand",
    "may",
    "increase",
    "cloud",
    "infrastructure",
    "add",
    "servers",
    "add",
    "bigger",
    "hardware",
    "ces",
    "ram",
    "could",
    "increase",
    "cloud",
    "infrastructure",
    "cost",
    "company",
    "millions",
    "dollars",
    "senior",
    "backend",
    "engineer",
    "must",
    "come",
    "efficient",
    "data",
    "structure",
    "choosing",
    "right",
    "data",
    "structure",
    "requirements",
    "hand",
    "important",
    "skill",
    "clearly",
    "see",
    "using",
    "sorted",
    "list",
    "users",
    "may",
    "best",
    "data",
    "structure",
    "organize",
    "profile",
    "information",
    "let",
    "see",
    "better",
    "let",
    "save",
    "work",
    "remember",
    "notebook",
    "running",
    "online",
    "platform",
    "called",
    "binder",
    "binder",
    "shut",
    "moment",
    "free",
    "service",
    "want",
    "run",
    "pip",
    "install",
    "jovian",
    "import",
    "jovian",
    "library",
    "run",
    "commit",
    "run",
    "commit",
    "captures",
    "snapshot",
    "jupyter",
    "notebook",
    "whether",
    "running",
    "binder",
    "running",
    "local",
    "computer",
    "saves",
    "snapshot",
    "jupiter",
    "notebook",
    "jovian",
    "profile",
    "see",
    "jovian",
    "profile",
    "notebook",
    "go",
    "back",
    "profile",
    "view",
    "notebooks",
    "created",
    "past",
    "jovian",
    "profile",
    "becomes",
    "collection",
    "jupyter",
    "notebooks",
    "working",
    "always",
    "takes",
    "couple",
    "lines",
    "import",
    "jovian",
    "run",
    "jin",
    "commit",
    "always",
    "run",
    "jin",
    "commit",
    "inside",
    "notebooks",
    "want",
    "resume",
    "work",
    "need",
    "click",
    "run",
    "button",
    "click",
    "run",
    "binder",
    "start",
    "executing",
    "code",
    "within",
    "jupyter",
    "notebook",
    "right",
    "remember",
    "binder",
    "free",
    "service",
    "shut",
    "10",
    "minutes",
    "inactivity",
    "computer",
    "goes",
    "sleep",
    "change",
    "tab",
    "keep",
    "running",
    "time",
    "time",
    "simple",
    "implementation",
    "analyzed",
    "determined",
    "efficient",
    "inefficient",
    "need",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "limit",
    "number",
    "iterations",
    "required",
    "common",
    "operations",
    "like",
    "find",
    "insert",
    "update",
    "ditching",
    "linear",
    "structure",
    "earlier",
    "organizing",
    "data",
    "tree",
    "like",
    "structure",
    "structure",
    "use",
    "data",
    "call",
    "binary",
    "tree",
    "called",
    "tree",
    "vaguely",
    "resembles",
    "inverted",
    "tree",
    "trunk",
    "branches",
    "think",
    "root",
    "root",
    "see",
    "like",
    "branches",
    "nodes",
    "branches",
    "split",
    "multiple",
    "branches",
    "called",
    "nodes",
    "finally",
    "end",
    "individual",
    "nodes",
    "branches",
    "called",
    "leaves",
    "terms",
    "used",
    "tree",
    "represents",
    "entire",
    "structure",
    "top",
    "node",
    "called",
    "root",
    "element",
    "tree",
    "called",
    "node",
    "top",
    "node",
    "called",
    "root",
    "bottommost",
    "nodes",
    "sub",
    "trees",
    "called",
    "children",
    "children",
    "called",
    "leaves",
    "right",
    "root",
    "node",
    "two",
    "children",
    "node",
    "zero",
    "one",
    "two",
    "children",
    "necessary",
    "exactly",
    "two",
    "children",
    "two",
    "children",
    "determines",
    "binary",
    "tree",
    "binary",
    "tree",
    "binary",
    "tree",
    "need",
    "additional",
    "properties",
    "make",
    "efficient",
    "purposes",
    "see",
    "one",
    "thing",
    "observe",
    "root",
    "node",
    "seems",
    "also",
    "seems",
    "central",
    "value",
    "sort",
    "keys",
    "increasing",
    "order",
    "notice",
    "left",
    "uh",
    "keys",
    "lie",
    "jades",
    "right",
    "keys",
    "lie",
    "jades",
    "one",
    "thing",
    "actually",
    "second",
    "property",
    "listed",
    "left",
    "subtree",
    "node",
    "consists",
    "nodes",
    "keys",
    "lexicographically",
    "smaller",
    "nod",
    "key",
    "right",
    "key",
    "node",
    "barage",
    "lexic",
    "graphically",
    "smaller",
    "jades",
    "similarly",
    "hant",
    "akash",
    "smaller",
    "jades",
    "property",
    "holds",
    "every",
    "node",
    "every",
    "node",
    "check",
    "sonak",
    "see",
    "sidhant",
    "less",
    "sonak",
    "vishal",
    "comes",
    "right",
    "sonak",
    "sonak",
    "sidhant",
    "vishal",
    "three",
    "greater",
    "jades",
    "right",
    "binary",
    "tree",
    "satisfies",
    "property",
    "called",
    "binary",
    "search",
    "tree",
    "looking",
    "binary",
    "search",
    "tree",
    "first",
    "property",
    "need",
    "second",
    "property",
    "nodes",
    "keys",
    "values",
    "sometimes",
    "create",
    "binary",
    "nodes",
    "binary",
    "trees",
    "keys",
    "node",
    "single",
    "number",
    "string",
    "inside",
    "call",
    "key",
    "value",
    "element",
    "whatever",
    "wish",
    "want",
    "want",
    "keys",
    "usernames",
    "compare",
    "keys",
    "easily",
    "along",
    "node",
    "also",
    "want",
    "associate",
    "value",
    "actual",
    "user",
    "object",
    "look",
    "looking",
    "hant",
    "let",
    "say",
    "start",
    "root",
    "node",
    "see",
    "jades",
    "root",
    "node",
    "since",
    "binary",
    "search",
    "tree",
    "know",
    "hon",
    "lies",
    "left",
    "reach",
    "barage",
    "know",
    "hon",
    "lie",
    "right",
    "barage",
    "go",
    "right",
    "reach",
    "hon",
    "access",
    "value",
    "stored",
    "hon",
    "user",
    "details",
    "hon",
    "right",
    "need",
    "keys",
    "values",
    "binary",
    "tree",
    "called",
    "tree",
    "map",
    "map",
    "many",
    "languages",
    "finally",
    "tree",
    "create",
    "data",
    "structure",
    "create",
    "balanced",
    "looking",
    "node",
    "two",
    "children",
    "left",
    "right",
    "also",
    "possible",
    "unbalanced",
    "tree",
    "one",
    "child",
    "maybe",
    "one",
    "sides",
    "require",
    "balanced",
    "means",
    "skew",
    "heavily",
    "one",
    "direction",
    "talk",
    "balancing",
    "means",
    "talk",
    "check",
    "tree",
    "balanced",
    "keep",
    "tree",
    "balanced",
    "okay",
    "go",
    "things",
    "step",
    "step",
    "properties",
    "want",
    "final",
    "data",
    "structure",
    "okay",
    "one",
    "important",
    "property",
    "tree",
    "binary",
    "tree",
    "height",
    "tree",
    "fact",
    "start",
    "counting",
    "say",
    "level",
    "zero",
    "one",
    "node",
    "level",
    "two",
    "level",
    "one",
    "two",
    "nodes",
    "left",
    "right",
    "left",
    "right",
    "child",
    "root",
    "node",
    "level",
    "three",
    "level",
    "two",
    "four",
    "nodes",
    "left",
    "right",
    "child",
    "first",
    "node",
    "level",
    "one",
    "left",
    "right",
    "child",
    "second",
    "node",
    "level",
    "one",
    "right",
    "see",
    "number",
    "nodes",
    "level",
    "balanced",
    "binary",
    "tree",
    "double",
    "number",
    "nodes",
    "previous",
    "level",
    "tree",
    "height",
    "k",
    "means",
    "tree",
    "exactly",
    "k",
    "levels",
    "list",
    "number",
    "nodes",
    "level",
    "level",
    "zero",
    "one",
    "node",
    "root",
    "node",
    "level",
    "one",
    "two",
    "nodes",
    "children",
    "level",
    "two",
    "four",
    "nodes",
    "children",
    "four",
    "nodes",
    "2",
    "2",
    "2",
    "two",
    "level",
    "three",
    "eight",
    "nodes",
    "two",
    "nodes",
    "four",
    "nodes",
    "2",
    "3",
    "similarly",
    "keep",
    "going",
    "level",
    "kus1",
    "final",
    "level",
    "2",
    "kus1",
    "nodes",
    "total",
    "number",
    "nodes",
    "tree",
    "n",
    "follows",
    "n",
    "1",
    "2",
    "2",
    "2",
    "cu",
    "plus",
    "2",
    "k",
    "minus",
    "1",
    "okay",
    "trying",
    "determine",
    "relationship",
    "height",
    "tree",
    "total",
    "number",
    "nodes",
    "tree",
    "relationship",
    "simplify",
    "bit",
    "add",
    "one",
    "side",
    "see",
    "side",
    "get",
    "n",
    "1",
    "side",
    "get",
    "1",
    "1",
    "gets",
    "simplified",
    "2",
    "2",
    "1",
    "add",
    "2",
    "1",
    "2",
    "1",
    "gets",
    "simplified",
    "2",
    "2",
    "add",
    "2",
    "2",
    "2",
    "two",
    "get",
    "simplified",
    "2",
    "3",
    "keep",
    "performing",
    "reduction",
    "keep",
    "adding",
    "together",
    "till",
    "finally",
    "end",
    "2",
    "k",
    "1",
    "2",
    "kus",
    "1",
    "simply",
    "2",
    "k",
    "gives",
    "us",
    "k",
    "height",
    "tree",
    "log",
    "n",
    "1",
    "approximately",
    "almost",
    "every",
    "case",
    "less",
    "log",
    "n",
    "1",
    "bit",
    "approximation",
    "height",
    "tree",
    "less",
    "log",
    "n",
    "1",
    "store",
    "n",
    "records",
    "require",
    "balanced",
    "binary",
    "search",
    "tree",
    "height",
    "larger",
    "log",
    "n",
    "1",
    "useful",
    "property",
    "combination",
    "fact",
    "nodes",
    "arranged",
    "way",
    "makes",
    "easy",
    "find",
    "specific",
    "key",
    "simply",
    "following",
    "path",
    "route",
    "binary",
    "search",
    "tree",
    "property",
    "see",
    "soon",
    "end",
    "lesson",
    "insert",
    "find",
    "update",
    "operations",
    "balanced",
    "binary",
    "search",
    "tre",
    "complexity",
    "order",
    "login",
    "original",
    "implementation",
    "brute",
    "force",
    "implementation",
    "order",
    "n",
    "time",
    "reduced",
    "complexity",
    "order",
    "login",
    "far",
    "better",
    "see",
    "happens",
    "okay",
    "quick",
    "introduction",
    "binary",
    "search",
    "trees",
    "enough",
    "theory",
    "let",
    "get",
    "implementation",
    "second",
    "question",
    "binary",
    "trees",
    "commonly",
    "used",
    "data",
    "structures",
    "variety",
    "different",
    "variety",
    "different",
    "languages",
    "instance",
    "java",
    "python",
    "java",
    "concept",
    "map",
    "represented",
    "using",
    "binary",
    "tree",
    "also",
    "used",
    "file",
    "systems",
    "binary",
    "trees",
    "also",
    "used",
    "file",
    "systems",
    "store",
    "indexes",
    "files",
    "browse",
    "file",
    "system",
    "search",
    "specific",
    "file",
    "binary",
    "tree",
    "used",
    "look",
    "file",
    "find",
    "location",
    "file",
    "brings",
    "us",
    "second",
    "question",
    "today",
    "find",
    "second",
    "question",
    "linkedin",
    "profile",
    "go",
    "jovan",
    "aai",
    "find",
    "second",
    "second",
    "question",
    "second",
    "question",
    "tree",
    "based",
    "data",
    "structure",
    "used",
    "store",
    "index",
    "windows",
    "file",
    "system",
    "invented",
    "data",
    "structure",
    "like",
    "question",
    "follow",
    "us",
    "comment",
    "answer",
    "stand",
    "chance",
    "win",
    "swag",
    "pack",
    "right",
    "repeat",
    "question",
    "tree",
    "based",
    "data",
    "structure",
    "used",
    "store",
    "index",
    "windows",
    "file",
    "system",
    "also",
    "known",
    "ntfs",
    "invented",
    "data",
    "structure",
    "okay",
    "let",
    "get",
    "implementation",
    "binary",
    "trees",
    "common",
    "interview",
    "question",
    "might",
    "get",
    "implement",
    "binary",
    "tree",
    "using",
    "python",
    "show",
    "usage",
    "examples",
    "implement",
    "binary",
    "trees",
    "binary",
    "search",
    "trees",
    "also",
    "cover",
    "many",
    "common",
    "interview",
    "questions",
    "fact",
    "cover",
    "exactly",
    "15",
    "quite",
    "first",
    "one",
    "implement",
    "binary",
    "tree",
    "begin",
    "create",
    "simple",
    "binary",
    "tree",
    "special",
    "properties",
    "like",
    "key",
    "value",
    "pairs",
    "binary",
    "search",
    "tree",
    "balancing",
    "rather",
    "also",
    "use",
    "key",
    "numbers",
    "keys",
    "within",
    "nodes",
    "simpler",
    "work",
    "example",
    "binary",
    "tree",
    "root",
    "node",
    "left",
    "child",
    "right",
    "child",
    "simple",
    "class",
    "representing",
    "representing",
    "single",
    "node",
    "within",
    "tree",
    "calling",
    "class",
    "tree",
    "node",
    "constructor",
    "function",
    "simply",
    "takes",
    "key",
    "sets",
    "self",
    "key",
    "key",
    "also",
    "couple",
    "properties",
    "self",
    "left",
    "self",
    "right",
    "initially",
    "set",
    "none",
    "node",
    "created",
    "exists",
    "independently",
    "nodes",
    "let",
    "create",
    "nodes",
    "representing",
    "nodes",
    "node",
    "zero",
    "calling",
    "calling",
    "tree",
    "node",
    "value",
    "three",
    "node",
    "one",
    "node",
    "two",
    "go",
    "created",
    "nodes",
    "verify",
    "type",
    "three",
    "node",
    "see",
    "check",
    "key",
    "node",
    "zero",
    "see",
    "value",
    "three",
    "connect",
    "nodes",
    "setting",
    "left",
    "right",
    "properties",
    "root",
    "node",
    "go",
    "node",
    "zero",
    "set",
    "left",
    "node",
    "one",
    "connected",
    "node",
    "0",
    "node",
    "one",
    "similarly",
    "set",
    "node",
    "right",
    "node",
    "two",
    "connected",
    "node",
    "zero",
    "node",
    "two",
    "done",
    "three",
    "nodes",
    "connected",
    "nodes",
    "may",
    "also",
    "want",
    "track",
    "root",
    "node",
    "create",
    "new",
    "variable",
    "called",
    "tree",
    "simply",
    "point",
    "node",
    "zero",
    "tree",
    "points",
    "root",
    "node",
    "tree",
    "root",
    "node",
    "connected",
    "children",
    "children",
    "connected",
    "children",
    "check",
    "check",
    "tree",
    "key",
    "get",
    "three",
    "check",
    "tree",
    "left",
    "key",
    "tree",
    "root",
    "node",
    "value",
    "three",
    "tree",
    "left",
    "node",
    "value",
    "four",
    "tree",
    "wr",
    "key",
    "value",
    "five",
    "okay",
    "pretty",
    "straightforward",
    "pretty",
    "much",
    "answer",
    "question",
    "implement",
    "binary",
    "tree",
    "python",
    "going",
    "forward",
    "use",
    "term",
    "tree",
    "refer",
    "root",
    "node",
    "refer",
    "root",
    "node",
    "term",
    "node",
    "used",
    "refer",
    "node",
    "tree",
    "necessarily",
    "root",
    "okay",
    "exercise",
    "try",
    "create",
    "binary",
    "tree",
    "root",
    "node",
    "left",
    "child",
    "right",
    "child",
    "left",
    "child",
    "another",
    "left",
    "child",
    "right",
    "child",
    "similarly",
    "another",
    "right",
    "child",
    "left",
    "child",
    "left",
    "child",
    "right",
    "child",
    "okay",
    "slightly",
    "complicated",
    "tree",
    "structure",
    "try",
    "use",
    "cells",
    "empty",
    "cells",
    "given",
    "replicate",
    "tree",
    "structure",
    "try",
    "view",
    "different",
    "levels",
    "tree",
    "manually",
    "okay",
    "please",
    "great",
    "exercise",
    "understanding",
    "structure",
    "works",
    "connect",
    "nodes",
    "bit",
    "inconvenient",
    "create",
    "tree",
    "manually",
    "connecting",
    "nodes",
    "fact",
    "may",
    "make",
    "total",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "nine",
    "connections",
    "right",
    "write",
    "helper",
    "function",
    "convert",
    "tuple",
    "tuple",
    "kind",
    "structure",
    "tuple",
    "simply",
    "kind",
    "like",
    "list",
    "except",
    "represented",
    "round",
    "brackets",
    "parenthesis",
    "tuple",
    "kind",
    "structure",
    "three",
    "elements",
    "middle",
    "element",
    "represent",
    "value",
    "key",
    "within",
    "root",
    "node",
    "first",
    "element",
    "also",
    "either",
    "tuple",
    "left",
    "child",
    "entire",
    "sub",
    "tree",
    "single",
    "number",
    "number",
    "right",
    "element",
    "represent",
    "right",
    "sub",
    "tree",
    "okay",
    "example",
    "one",
    "tree",
    "tuple",
    "see",
    "tree",
    "tuple",
    "three",
    "elements",
    "first",
    "element",
    "second",
    "element",
    "third",
    "element",
    "first",
    "element",
    "two",
    "represents",
    "root",
    "node",
    "second",
    "element",
    "two",
    "represents",
    "root",
    "node",
    "first",
    "element",
    "element",
    "position",
    "zero",
    "represents",
    "sub",
    "tree",
    "see",
    "sub",
    "tree",
    "look",
    "sub",
    "tree",
    "tree",
    "three",
    "root",
    "subtree",
    "one",
    "left",
    "child",
    "right",
    "child",
    "represent",
    "sub",
    "tree",
    "five",
    "root",
    "node",
    "two",
    "sub",
    "trees",
    "represented",
    "five",
    "root",
    "node",
    "sub",
    "tree",
    "subtree",
    "easy",
    "way",
    "convenient",
    "way",
    "us",
    "represent",
    "binary",
    "tree",
    "define",
    "function",
    "par",
    "tuple",
    "par",
    "tuple",
    "function",
    "take",
    "tuple",
    "like",
    "convert",
    "tree",
    "like",
    "structure",
    "linked",
    "nodes",
    "using",
    "tree",
    "node",
    "data",
    "stru",
    "using",
    "tree",
    "node",
    "class",
    "defined",
    "call",
    "past",
    "tuple",
    "function",
    "data",
    "instance",
    "tuple",
    "pass",
    "tuple",
    "first",
    "checks",
    "data",
    "type",
    "tuple",
    "length",
    "three",
    "two",
    "things",
    "hold",
    "true",
    "first",
    "create",
    "node",
    "create",
    "node",
    "data",
    "one",
    "case",
    "create",
    "node",
    "two",
    "key",
    "set",
    "left",
    "right",
    "sub",
    "trees",
    "node",
    "something",
    "interesting",
    "calling",
    "past",
    "tuple",
    "function",
    "call",
    "pass",
    "tuple",
    "time",
    "called",
    "recursion",
    "function",
    "calls",
    "inside",
    "called",
    "recursion",
    "call",
    "pass",
    "tuple",
    "first",
    "element",
    "tuple",
    "right",
    "calls",
    "another",
    "invocation",
    "pass",
    "tuple",
    "moment",
    "let",
    "assume",
    "returns",
    "proper",
    "subtree",
    "proper",
    "node",
    "set",
    "node",
    "got",
    "created",
    "node",
    "left",
    "similarly",
    "create",
    "right",
    "sub",
    "tree",
    "using",
    "values",
    "set",
    "node",
    "node",
    "right",
    "okay",
    "might",
    "wonder",
    "function",
    "calling",
    "stop",
    "ca",
    "go",
    "forever",
    "track",
    "actual",
    "function",
    "calls",
    "call",
    "pass",
    "tuple",
    "entire",
    "tuple",
    "first",
    "calls",
    "pass",
    "tuple",
    "call",
    "pass",
    "tuple",
    "uh",
    "see",
    "three",
    "used",
    "create",
    "node",
    "p",
    "tuple",
    "called",
    "one",
    "p",
    "tuple",
    "called",
    "one",
    "condition",
    "longer",
    "holds",
    "true",
    "also",
    "check",
    "next",
    "condition",
    "data",
    "one",
    "none",
    "one",
    "none",
    "condition",
    "hold",
    "true",
    "fall",
    "else",
    "condition",
    "simply",
    "create",
    "node",
    "right",
    "create",
    "node",
    "time",
    "calling",
    "past",
    "duple",
    "right",
    "called",
    "terminating",
    "condition",
    "recursive",
    "function",
    "similarly",
    "get",
    "back",
    "result",
    "one",
    "call",
    "p",
    "truple",
    "value",
    "none",
    "condition",
    "entered",
    "condition",
    "matches",
    "set",
    "node",
    "equal",
    "n",
    "return",
    "node",
    "okay",
    "reach",
    "either",
    "leaf",
    "node",
    "either",
    "single",
    "number",
    "reach",
    "value",
    "none",
    "stop",
    "invoking",
    "function",
    "recursively",
    "function",
    "returns",
    "entire",
    "tree",
    "gets",
    "con",
    "gets",
    "converted",
    "powerful",
    "idea",
    "programming",
    "idea",
    "recursion",
    "idea",
    "functions",
    "calling",
    "seem",
    "unintuitive",
    "confusing",
    "first",
    "one",
    "thing",
    "add",
    "print",
    "statement",
    "inside",
    "function",
    "see",
    "works",
    "see",
    "different",
    "calls",
    "going",
    "call",
    "past",
    "tuple",
    "entire",
    "tuple",
    "internal",
    "calls",
    "made",
    "uh",
    "study",
    "result",
    "comes",
    "maybe",
    "try",
    "pen",
    "paper",
    "important",
    "technique",
    "learn",
    "asked",
    "find",
    "applications",
    "recursions",
    "many",
    "places",
    "throughout",
    "programming",
    "data",
    "science",
    "career",
    "learn",
    "let",
    "call",
    "par",
    "stuple",
    "tuple",
    "input",
    "let",
    "see",
    "okay",
    "returned",
    "tree",
    "tree",
    "type",
    "tree",
    "node",
    "great",
    "let",
    "examine",
    "tree",
    "verify",
    "constructed",
    "expected",
    "check",
    "tree2",
    "key",
    "tree2",
    "key",
    "pointing",
    "root",
    "node",
    "key2",
    "let",
    "check",
    "level",
    "one",
    "level",
    "zero",
    "let",
    "check",
    "level",
    "one",
    "let",
    "check",
    "left",
    "key",
    "right",
    "key",
    "see",
    "get",
    "values",
    "three",
    "five",
    "let",
    "check",
    "next",
    "level",
    "level",
    "left",
    "left",
    "left",
    "right",
    "value",
    "ca",
    "really",
    "check",
    "key",
    "right",
    "left",
    "right",
    "right",
    "see",
    "left",
    "left",
    "key",
    "one",
    "left",
    "right",
    "none",
    "child",
    "right",
    "child",
    "left",
    "key",
    "right",
    "dot",
    "key",
    "gives",
    "three",
    "seven",
    "similarly",
    "check",
    "level",
    "four",
    "level",
    "three",
    "well",
    "levels",
    "tree",
    "looks",
    "like",
    "tree",
    "constructed",
    "properly",
    "see",
    "power",
    "recursion",
    "play",
    "recursive",
    "function",
    "construct",
    "trees",
    "levels",
    "create",
    "tles",
    "within",
    "tles",
    "within",
    "tles",
    "long",
    "right",
    "structure",
    "long",
    "three",
    "element",
    "structure",
    "left",
    "element",
    "represents",
    "left",
    "sub",
    "tree",
    "right",
    "element",
    "represents",
    "right",
    "right",
    "sub",
    "tree",
    "middle",
    "element",
    "represents",
    "current",
    "node",
    "construct",
    "tree",
    "size",
    "exercise",
    "defined",
    "function",
    "convert",
    "tuple",
    "tree",
    "define",
    "function",
    "convert",
    "tree",
    "back",
    "tuple",
    "binary",
    "tree",
    "con",
    "return",
    "tuple",
    "representing",
    "tree",
    "instance",
    "tree",
    "created",
    "tree",
    "2",
    "calling",
    "tree",
    "tle",
    "return",
    "original",
    "tupple",
    "used",
    "create",
    "tree",
    "hint",
    "use",
    "recursion",
    "fill",
    "see",
    "figure",
    "defined",
    "class",
    "binary",
    "tree",
    "also",
    "way",
    "creating",
    "binary",
    "tree",
    "tuple",
    "let",
    "create",
    "another",
    "helper",
    "function",
    "display",
    "keys",
    "tree",
    "tree",
    "like",
    "structure",
    "easier",
    "visualization",
    "use",
    "call",
    "function",
    "display",
    "keys",
    "uh",
    "get",
    "code",
    "pretty",
    "straightforward",
    "conditions",
    "need",
    "handle",
    "give",
    "us",
    "call",
    "display",
    "keys",
    "tree",
    "get",
    "kind",
    "representation",
    "tree",
    "see",
    "exactly",
    "representation",
    "take",
    "representation",
    "mentally",
    "rotate",
    "clockwise",
    "direction",
    "get",
    "representation",
    "like",
    "see",
    "roughly",
    "root",
    "node",
    "two",
    "left",
    "child",
    "three",
    "right",
    "child",
    "five",
    "three",
    "left",
    "child",
    "one",
    "right",
    "child",
    "five",
    "left",
    "child",
    "three",
    "uh",
    "three",
    "left",
    "child",
    "three",
    "right",
    "child",
    "four",
    "exact",
    "structure",
    "replicated",
    "us",
    "view",
    "visually",
    "useful",
    "thing",
    "spending",
    "time",
    "talking",
    "create",
    "trees",
    "visualize",
    "trees",
    "easier",
    "make",
    "create",
    "trees",
    "likely",
    "test",
    "easier",
    "test",
    "different",
    "scenarios",
    "always",
    "spend",
    "little",
    "bit",
    "time",
    "coming",
    "good",
    "string",
    "representations",
    "data",
    "structure",
    "create",
    "something",
    "helps",
    "visualize",
    "easy",
    "way",
    "create",
    "data",
    "structures",
    "okay",
    "way",
    "visualize",
    "tree",
    "well",
    "great",
    "exercise",
    "try",
    "create",
    "trees",
    "visualize",
    "using",
    "display",
    "keys",
    "use",
    "tool",
    "excal",
    "diagrams",
    "created",
    "digital",
    "whiteboard",
    "create",
    "trees",
    "create",
    "trees",
    "like",
    "try",
    "create",
    "come",
    "tuples",
    "trees",
    "try",
    "create",
    "trees",
    "using",
    "par",
    "stuple",
    "function",
    "finally",
    "try",
    "display",
    "okay",
    "experiment",
    "see",
    "explore",
    "different",
    "tree",
    "structures",
    "create",
    "next",
    "one",
    "frequently",
    "asked",
    "questions",
    "interviews",
    "traverse",
    "binary",
    "tree",
    "binary",
    "tree",
    "traversals",
    "common",
    "may",
    "face",
    "one",
    "three",
    "questions",
    "write",
    "function",
    "perform",
    "order",
    "traversal",
    "binary",
    "tree",
    "write",
    "function",
    "perform",
    "traversal",
    "binary",
    "tree",
    "write",
    "function",
    "perform",
    "traversal",
    "binary",
    "tree",
    "mean",
    "traversal",
    "traversal",
    "refers",
    "process",
    "visiting",
    "node",
    "tree",
    "exactly",
    "mean",
    "visiting",
    "visiting",
    "could",
    "mean",
    "operation",
    "generally",
    "refers",
    "either",
    "printing",
    "key",
    "value",
    "node",
    "adding",
    "nodes",
    "key",
    "list",
    "three",
    "ways",
    "traverse",
    "binary",
    "tree",
    "return",
    "list",
    "visited",
    "keys",
    "first",
    "one",
    "called",
    "inorder",
    "traversal",
    "order",
    "traversal",
    "traversal",
    "defined",
    "recursively",
    "binary",
    "trees",
    "recursive",
    "structure",
    "see",
    "almost",
    "function",
    "write",
    "sort",
    "recursive",
    "structure",
    "order",
    "traversal",
    "involves",
    "first",
    "traversing",
    "left",
    "subtree",
    "recursively",
    "order",
    "traversing",
    "current",
    "node",
    "traversing",
    "right",
    "subtree",
    "recursively",
    "order",
    "mean",
    "well",
    "start",
    "tree",
    "traversing",
    "ord",
    "reversal",
    "try",
    "look",
    "root",
    "node",
    "realize",
    "left",
    "ch",
    "left",
    "sube",
    "visit",
    "yet",
    "means",
    "print",
    "add",
    "list",
    "yet",
    "rather",
    "follow",
    "follow",
    "path",
    "left",
    "side",
    "come",
    "across",
    "three",
    "realize",
    "okay",
    "three",
    "also",
    "left",
    "child",
    "visit",
    "yet",
    "go",
    "one",
    "go",
    "one",
    "left",
    "child",
    "right",
    "child",
    "visit",
    "one",
    "go",
    "three",
    "visited",
    "left",
    "sub",
    "tree",
    "three",
    "visit",
    "three",
    "next",
    "step",
    "visit",
    "right",
    "sub",
    "tree",
    "three",
    "course",
    "three",
    "right",
    "child",
    "right",
    "subtree",
    "visit",
    "move",
    "back",
    "two",
    "visited",
    "left",
    "subtree",
    "two",
    "visit",
    "two",
    "print",
    "1",
    "3",
    "2",
    "visited",
    "two",
    "visit",
    "right",
    "sub",
    "tree",
    "two",
    "visit",
    "right",
    "subtree",
    "go",
    "five",
    "realize",
    "five",
    "left",
    "sub",
    "tree",
    "go",
    "three",
    "three",
    "left",
    "sub",
    "tree",
    "visit",
    "three",
    "visit",
    "four",
    "since",
    "visited",
    "left",
    "sub",
    "tree",
    "five",
    "visit",
    "five",
    "similarly",
    "visit",
    "6",
    "7",
    "8",
    "okay",
    "order",
    "traversal",
    "tree",
    "another",
    "traversal",
    "called",
    "traversal",
    "slightly",
    "different",
    "traverse",
    "current",
    "node",
    "first",
    "start",
    "two",
    "say",
    "okay",
    "going",
    "visit",
    "two",
    "first",
    "visit",
    "two",
    "print",
    "add",
    "list",
    "traverse",
    "left",
    "sub",
    "tree",
    "traverse",
    "right",
    "subtree",
    "go",
    "visit",
    "three",
    "one",
    "come",
    "right",
    "side",
    "visit",
    "five",
    "three",
    "compare",
    "two",
    "diagrams",
    "see",
    "order",
    "reversal",
    "different",
    "important",
    "understand",
    "great",
    "examples",
    "different",
    "functions",
    "similar",
    "implementations",
    "one",
    "two",
    "things",
    "need",
    "change",
    "uh",
    "recursive",
    "well",
    "understand",
    "cer",
    "difference",
    "second",
    "commonly",
    "asked",
    "interviews",
    "likely",
    "face",
    "coding",
    "assignment",
    "interview",
    "asked",
    "perform",
    "traversal",
    "binary",
    "tree",
    "finally",
    "another",
    "order",
    "called",
    "another",
    "traversal",
    "called",
    "post",
    "order",
    "traversal",
    "let",
    "guess",
    "works",
    "also",
    "look",
    "implementation",
    "ordit",
    "reversal",
    "may",
    "seem",
    "little",
    "complicated",
    "actually",
    "pretty",
    "straightforward",
    "let",
    "look",
    "look",
    "given",
    "node",
    "first",
    "traverse",
    "node",
    "left",
    "sub",
    "tree",
    "create",
    "return",
    "list",
    "list",
    "keys",
    "create",
    "list",
    "nodes",
    "key",
    "get",
    "list",
    "keys",
    "left",
    "sub",
    "tree",
    "order",
    "traversal",
    "get",
    "add",
    "current",
    "nodes",
    "key",
    "call",
    "traverse",
    "order",
    "right",
    "sub",
    "tree",
    "recursively",
    "keeps",
    "adding",
    "keys",
    "one",
    "end",
    "condition",
    "terminating",
    "condition",
    "recursion",
    "hit",
    "none",
    "hit",
    "node",
    "exist",
    "means",
    "come",
    "parent",
    "left",
    "right",
    "child",
    "return",
    "empty",
    "array",
    "okay",
    "let",
    "try",
    "tree",
    "tree",
    "saw",
    "traversal",
    "traverse",
    "tree",
    "order",
    "get",
    "values",
    "1",
    "3",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "verify",
    "1",
    "3",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "order",
    "traversal",
    "tree",
    "exercise",
    "print",
    "postorder",
    "traval",
    "binary",
    "tree",
    "test",
    "implementations",
    "making",
    "submissions",
    "problems",
    "lead",
    "okay",
    "discussion",
    "traversals",
    "another",
    "thing",
    "may",
    "get",
    "asked",
    "commonly",
    "writing",
    "functions",
    "calculate",
    "height",
    "depth",
    "binary",
    "tree",
    "writing",
    "function",
    "count",
    "number",
    "nodes",
    "binary",
    "tree",
    "expressed",
    "recursively",
    "well",
    "height",
    "tree",
    "given",
    "node",
    "simply",
    "1",
    "plus",
    "maximum",
    "height",
    "right",
    "sub",
    "tree",
    "left",
    "sub",
    "tree",
    "height",
    "tree",
    "def",
    "defined",
    "longest",
    "path",
    "root",
    "node",
    "leaf",
    "see",
    "longest",
    "path",
    "root",
    "node",
    "leaf",
    "length",
    "four",
    "2",
    "5",
    "3",
    "4",
    "way",
    "get",
    "longest",
    "length",
    "longest",
    "path",
    "checking",
    "max",
    "left",
    "height",
    "right",
    "height",
    "adding",
    "one",
    "course",
    "terminating",
    "condition",
    "also",
    "hit",
    "node",
    "exist",
    "return",
    "zero",
    "get",
    "height",
    "tree",
    "check",
    "height",
    "three",
    "four",
    "another",
    "uh",
    "function",
    "count",
    "number",
    "nodes",
    "tree",
    "really",
    "simple",
    "time",
    "instead",
    "checking",
    "maximum",
    "simply",
    "get",
    "size",
    "left",
    "subtree",
    "get",
    "size",
    "right",
    "sub",
    "tree",
    "add",
    "add",
    "one",
    "see",
    "nine",
    "elements",
    "tree",
    "3",
    "6",
    "nine",
    "get",
    "tree",
    "size",
    "tree",
    "nine",
    "questions",
    "relating",
    "path",
    "length",
    "binary",
    "tree",
    "check",
    "concept",
    "maximum",
    "depth",
    "minimum",
    "depth",
    "also",
    "concept",
    "diameter",
    "try",
    "final",
    "step",
    "compile",
    "functions",
    "written",
    "methods",
    "uh",
    "methods",
    "within",
    "tree",
    "node",
    "class",
    "technique",
    "called",
    "encapsulation",
    "encapsulating",
    "data",
    "well",
    "functionality",
    "related",
    "data",
    "data",
    "structure",
    "within",
    "class",
    "really",
    "really",
    "good",
    "programming",
    "practice",
    "write",
    "code",
    "try",
    "think",
    "create",
    "classes",
    "information",
    "inside",
    "also",
    "relevant",
    "methods",
    "inside",
    "okay",
    "added",
    "methods",
    "height",
    "size",
    "traverse",
    "order",
    "display",
    "keys",
    "two",
    "tuple",
    "also",
    "added",
    "methods",
    "str",
    "str",
    "repper",
    "remember",
    "quiz",
    "one",
    "go",
    "linkedin",
    "post",
    "answer",
    "functions",
    "finally",
    "par",
    "tuple",
    "well",
    "functions",
    "added",
    "within",
    "class",
    "try",
    "instance",
    "tree",
    "tuple",
    "call",
    "tree",
    "node",
    "pass",
    "tuple",
    "convert",
    "tree",
    "tuple",
    "tree",
    "see",
    "also",
    "representing",
    "binary",
    "tree",
    "using",
    "tuple",
    "like",
    "representation",
    "also",
    "display",
    "hierarchical",
    "structure",
    "using",
    "display",
    "keys",
    "check",
    "height",
    "using",
    "tree",
    "height",
    "check",
    "size",
    "using",
    "tree",
    "size",
    "traverse",
    "tree",
    "order",
    "using",
    "traverse",
    "order",
    "convert",
    "tree",
    "tuple",
    "using",
    "tuple",
    "create",
    "trees",
    "try",
    "operations",
    "defined",
    "try",
    "also",
    "try",
    "adding",
    "operations",
    "tree",
    "node",
    "class",
    "continuing",
    "save",
    "work",
    "going",
    "import",
    "jovin",
    "run",
    "jin",
    "commit",
    "concludes",
    "discussion",
    "binary",
    "trees",
    "next",
    "let",
    "talk",
    "binary",
    "search",
    "trees",
    "binary",
    "search",
    "tree",
    "bst",
    "binary",
    "tree",
    "satisfies",
    "two",
    "conditions",
    "left",
    "subtree",
    "node",
    "contain",
    "nodes",
    "keys",
    "less",
    "current",
    "nodes",
    "key",
    "right",
    "sub",
    "tre",
    "node",
    "contain",
    "nodes",
    "keys",
    "greater",
    "current",
    "nodes",
    "key",
    "see",
    "let",
    "copy",
    "see",
    "tree",
    "actually",
    "binary",
    "search",
    "tree",
    "verify",
    "two",
    "properties",
    "hold",
    "nodes",
    "follow",
    "two",
    "conditions",
    "every",
    "sub",
    "tree",
    "binary",
    "search",
    "tree",
    "must",
    "also",
    "binary",
    "search",
    "tree",
    "let",
    "verify",
    "pick",
    "sub",
    "tree",
    "inside",
    "pick",
    "node",
    "see",
    "tree",
    "node",
    "see",
    "binary",
    "search",
    "tree",
    "questions",
    "often",
    "asked",
    "relating",
    "binary",
    "trees",
    "binary",
    "search",
    "trees",
    "lumped",
    "together",
    "answer",
    "single",
    "function",
    "function",
    "might",
    "expected",
    "write",
    "write",
    "function",
    "check",
    "binary",
    "tree",
    "binary",
    "search",
    "tree",
    "means",
    "ensure",
    "two",
    "conditions",
    "hold",
    "second",
    "write",
    "function",
    "find",
    "maximum",
    "key",
    "binary",
    "tree",
    "could",
    "generic",
    "question",
    "finding",
    "maximum",
    "key",
    "another",
    "question",
    "might",
    "face",
    "write",
    "function",
    "find",
    "minimum",
    "key",
    "binary",
    "tream",
    "answer",
    "answer",
    "questions",
    "together",
    "single",
    "function",
    "called",
    "bst",
    "bst",
    "takes",
    "node",
    "bst",
    "returns",
    "three",
    "things",
    "look",
    "return",
    "value",
    "returns",
    "whether",
    "node",
    "tree",
    "node",
    "bst",
    "going",
    "value",
    "determining",
    "going",
    "either",
    "true",
    "false",
    "telling",
    "us",
    "whether",
    "tree",
    "node",
    "node",
    "root",
    "bst",
    "also",
    "returns",
    "minimum",
    "key",
    "entire",
    "tree",
    "also",
    "returns",
    "maximum",
    "key",
    "entire",
    "tree",
    "two",
    "useful",
    "see",
    "moment",
    "way",
    "calculate",
    "bst",
    "node",
    "actually",
    "looking",
    "left",
    "sub",
    "tree",
    "right",
    "subtree",
    "recursively",
    "call",
    "bst",
    "left",
    "subtree",
    "node",
    "call",
    "bst",
    "right",
    "subtree",
    "node",
    "get",
    "back",
    "three",
    "values",
    "left",
    "subtree",
    "binary",
    "search",
    "tree",
    "right",
    "subt",
    "tree",
    "binary",
    "search",
    "tree",
    "minimum",
    "key",
    "left",
    "sub",
    "tree",
    "minimum",
    "key",
    "right",
    "sub",
    "tree",
    "maximum",
    "key",
    "left",
    "subtree",
    "maximum",
    "key",
    "right",
    "sub",
    "tree",
    "say",
    "bst",
    "node",
    "entire",
    "tree",
    "binary",
    "search",
    "tree",
    "well",
    "left",
    "sub",
    "tree",
    "binary",
    "search",
    "tree",
    "right",
    "sub",
    "tree",
    "binary",
    "search",
    "tree",
    "verify",
    "two",
    "properties",
    "maximum",
    "key",
    "left",
    "sub",
    "tree",
    "either",
    "none",
    "means",
    "left",
    "sub",
    "tree",
    "current",
    "nodes",
    "key",
    "greater",
    "maximum",
    "key",
    "minimum",
    "key",
    "right",
    "sub",
    "tree",
    "smallest",
    "key",
    "right",
    "sub",
    "tree",
    "either",
    "none",
    "means",
    "right",
    "subt",
    "tree",
    "minimum",
    "key",
    "right",
    "subtree",
    "greater",
    "current",
    "nodes",
    "key",
    "condition",
    "one",
    "condition",
    "two",
    "tells",
    "us",
    "whether",
    "entire",
    "tree",
    "binary",
    "search",
    "tree",
    "finally",
    "also",
    "calculate",
    "minimum",
    "key",
    "maximum",
    "key",
    "simply",
    "computing",
    "minimum",
    "left",
    "minimum",
    "node",
    "key",
    "right",
    "minimum",
    "maximum",
    "calculated",
    "checking",
    "maximum",
    "left",
    "maximum",
    "node",
    "key",
    "right",
    "maximum",
    "okay",
    "return",
    "sbst",
    "function",
    "whether",
    "node",
    "tree",
    "represent",
    "ed",
    "rooted",
    "node",
    "binary",
    "search",
    "tree",
    "minimum",
    "maximum",
    "key",
    "look",
    "tree",
    "right",
    "let",
    "verify",
    "whether",
    "bstd",
    "well",
    "check",
    "probably",
    "tell",
    "see",
    "three",
    "appears",
    "left",
    "sub",
    "child",
    "two",
    "three",
    "key",
    "greater",
    "two",
    "problem",
    "violation",
    "property",
    "elsewhere",
    "property",
    "satisfied",
    "check",
    "node",
    "find",
    "left",
    "sub",
    "tree",
    "always",
    "smaller",
    "right",
    "node",
    "right",
    "sub",
    "tree",
    "larger",
    "node",
    "let",
    "check",
    "bst",
    "tree",
    "1",
    "false",
    "hand",
    "tree",
    "bst",
    "tree",
    "looking",
    "create",
    "using",
    "tree",
    "node",
    "par",
    "stuple",
    "note",
    "keys",
    "way",
    "implemented",
    "tree",
    "node",
    "keys",
    "numbers",
    "also",
    "strings",
    "need",
    "change",
    "anything",
    "creates",
    "tree2",
    "even",
    "display",
    "tree2",
    "tree2",
    "dot",
    "display",
    "keys",
    "see",
    "structure",
    "jades",
    "center",
    "left",
    "barage",
    "right",
    "sonak",
    "barage",
    "sonak",
    "akash",
    "h",
    "sidhant",
    "vishal",
    "st",
    "get",
    "back",
    "true",
    "smallest",
    "value",
    "akash",
    "highest",
    "value",
    "vishal",
    "verify",
    "alphabetical",
    "order",
    "pretty",
    "handy",
    "way",
    "check",
    "binary",
    "tree",
    "binary",
    "search",
    "tree",
    "common",
    "interview",
    "question",
    "might",
    "face",
    "next",
    "remember",
    "need",
    "store",
    "keys",
    "also",
    "user",
    "objects",
    "within",
    "key",
    "uh",
    "key",
    "within",
    "bst",
    "define",
    "new",
    "class",
    "called",
    "bst",
    "node",
    "represent",
    "notes",
    "binary",
    "search",
    "tree",
    "bst",
    "node",
    "key",
    "constructor",
    "also",
    "accept",
    "value",
    "optional",
    "set",
    "key",
    "set",
    "value",
    "also",
    "set",
    "left",
    "right",
    "apart",
    "also",
    "set",
    "another",
    "property",
    "called",
    "parent",
    "parent",
    "point",
    "parent",
    "node",
    "instance",
    "node",
    "left",
    "subtree",
    "route",
    "parent",
    "barage",
    "point",
    "jades",
    "useful",
    "upward",
    "travel",
    "given",
    "pointer",
    "node",
    "go",
    "back",
    "find",
    "root",
    "tree",
    "parent",
    "helpful",
    "bst",
    "node",
    "let",
    "try",
    "recreate",
    "bst",
    "right",
    "usernames",
    "keys",
    "user",
    "objects",
    "values",
    "first",
    "create",
    "level",
    "zero",
    "level",
    "z",
    "create",
    "bst",
    "node",
    "key",
    "jades",
    "username",
    "string",
    "jades",
    "value",
    "jades",
    "user",
    "object",
    "created",
    "check",
    "key",
    "value",
    "see",
    "jades",
    "key",
    "user",
    "object",
    "value",
    "let",
    "create",
    "let",
    "create",
    "level",
    "one",
    "level",
    "one",
    "set",
    "tree",
    "left",
    "bst",
    "node",
    "barage",
    "username",
    "barage",
    "one",
    "thing",
    "set",
    "set",
    "tree",
    "left",
    "parent",
    "tree",
    "similarly",
    "said",
    "tree",
    "write",
    "tree",
    "wr",
    "sono",
    "set",
    "bst",
    "node",
    "son",
    "username",
    "key",
    "sono",
    "value",
    "set",
    "tree",
    "wr",
    "parent",
    "tre",
    "view",
    "values",
    "see",
    "inserted",
    "barage",
    "username",
    "barage",
    "inserted",
    "sonak",
    "user",
    "sonak",
    "keys",
    "values",
    "respectively",
    "uh",
    "exercise",
    "try",
    "add",
    "next",
    "level",
    "keys",
    "values",
    "verif",
    "inserted",
    "properly",
    "see",
    "way",
    "represent",
    "data",
    "usernames",
    "user",
    "objects",
    "binary",
    "search",
    "tree",
    "getting",
    "pretty",
    "close",
    "data",
    "structure",
    "want",
    "create",
    "display",
    "keys",
    "tree",
    "calling",
    "display",
    "keys",
    "function",
    "also",
    "rather",
    "nice",
    "good",
    "thing",
    "python",
    "python",
    "functions",
    "dynamic",
    "need",
    "specify",
    "types",
    "objects",
    "defining",
    "function",
    "display",
    "keys",
    "function",
    "used",
    "tree",
    "node",
    "bst",
    "node",
    "classes",
    "requires",
    "object",
    "class",
    "property",
    "key",
    "able",
    "display",
    "keys",
    "visual",
    "setting",
    "true",
    "functions",
    "defined",
    "fact",
    "function",
    "defined",
    "tree",
    "node",
    "also",
    "work",
    "bst",
    "node",
    "okay",
    "moving",
    "right",
    "along",
    "way",
    "construct",
    "bstd",
    "bit",
    "inconvenient",
    "insert",
    "values",
    "manually",
    "far",
    "manually",
    "checking",
    "whether",
    "insert",
    "value",
    "left",
    "right",
    "rather",
    "way",
    "automatically",
    "able",
    "call",
    "function",
    "insert",
    "common",
    "question",
    "well",
    "write",
    "function",
    "insert",
    "new",
    "node",
    "binary",
    "search",
    "stream",
    "use",
    "bst",
    "property",
    "perform",
    "insertion",
    "efficiently",
    "let",
    "grab",
    "copy",
    "tree",
    "think",
    "easily",
    "okay",
    "tree",
    "let",
    "say",
    "want",
    "insert",
    "new",
    "user",
    "username",
    "tanya",
    "tree",
    "first",
    "start",
    "root",
    "compare",
    "key",
    "inserted",
    "current",
    "nodes",
    "key",
    "current",
    "node",
    "root",
    "compare",
    "tanya",
    "jades",
    "see",
    "tanya",
    "greater",
    "jades",
    "comes",
    "j",
    "obviously",
    "tanya",
    "inserted",
    "left",
    "sub",
    "tree",
    "rather",
    "tanya",
    "inserted",
    "right",
    "subtree",
    "key",
    "smaller",
    "recursively",
    "insert",
    "right",
    "left",
    "sub",
    "tree",
    "key",
    "larger",
    "recursively",
    "insert",
    "right",
    "sub",
    "tree",
    "encounter",
    "sonak",
    "tanya",
    "also",
    "greater",
    "sonak",
    "greater",
    "comes",
    "call",
    "recursively",
    "call",
    "insert",
    "subtree",
    "subtree",
    "rooted",
    "vishal",
    "time",
    "notice",
    "tanya",
    "smaller",
    "vishal",
    "less",
    "v",
    "need",
    "recursively",
    "insert",
    "left",
    "sofry",
    "left",
    "sofry",
    "point",
    "create",
    "new",
    "node",
    "attach",
    "left",
    "child",
    "vishal",
    "see",
    "node",
    "tanya",
    "get",
    "added",
    "position",
    "tree",
    "recursive",
    "implementation",
    "insert",
    "exactly",
    "discussed",
    "first",
    "check",
    "key",
    "less",
    "current",
    "nodes",
    "key",
    "case",
    "insert",
    "left",
    "sub",
    "tree",
    "check",
    "key",
    "greater",
    "current",
    "nodes",
    "key",
    "case",
    "insert",
    "right",
    "sub",
    "tree",
    "ending",
    "condition",
    "node",
    "none",
    "means",
    "hit",
    "position",
    "left",
    "subtree",
    "need",
    "go",
    "left",
    "right",
    "sub",
    "tree",
    "go",
    "need",
    "go",
    "right",
    "create",
    "new",
    "node",
    "create",
    "new",
    "node",
    "node",
    "equal",
    "bst",
    "node",
    "return",
    "node",
    "return",
    "node",
    "interesting",
    "thing",
    "returning",
    "root",
    "node",
    "back",
    "insert",
    "called",
    "insert",
    "node",
    "left",
    "get",
    "back",
    "pointer",
    "left",
    "sub",
    "tree",
    "set",
    "back",
    "node",
    "left",
    "also",
    "set",
    "parent",
    "left",
    "subtree",
    "node",
    "okay",
    "updating",
    "parent",
    "study",
    "function",
    "carefully",
    "see",
    "works",
    "uh",
    "exactly",
    "talked",
    "finally",
    "return",
    "turns",
    "pointer",
    "tree",
    "let",
    "use",
    "recreate",
    "tree",
    "create",
    "first",
    "node",
    "call",
    "insert",
    "function",
    "none",
    "initially",
    "tree",
    "begin",
    "called",
    "insert",
    "none",
    "remember",
    "insert",
    "performing",
    "insertion",
    "returns",
    "pointer",
    "tree",
    "call",
    "insert",
    "none",
    "want",
    "insert",
    "value",
    "jades",
    "username",
    "want",
    "insert",
    "want",
    "insert",
    "key",
    "jades",
    "username",
    "value",
    "jades",
    "gives",
    "us",
    "tree",
    "tree",
    "one",
    "element",
    "see",
    "tree",
    "dot",
    "key",
    "tree",
    "value",
    "remaining",
    "nodes",
    "inserted",
    "tree",
    "call",
    "insert",
    "tree",
    "call",
    "barage",
    "username",
    "barage",
    "call",
    "son",
    "username",
    "sonak",
    "akash",
    "username",
    "akash",
    "way",
    "adding",
    "bage",
    "adding",
    "sonak",
    "adding",
    "akash",
    "h",
    "sidhant",
    "vishal",
    "see",
    "specifying",
    "exactly",
    "notes",
    "need",
    "inserted",
    "uh",
    "see",
    "nodes",
    "inserted",
    "inserted",
    "right",
    "places",
    "jades",
    "see",
    "binary",
    "searchy",
    "properties",
    "preserved",
    "also",
    "exactly",
    "replicated",
    "tree",
    "structure",
    "left",
    "sub",
    "child",
    "jades",
    "birj",
    "right",
    "child",
    "sonak",
    "barage",
    "left",
    "child",
    "akash",
    "right",
    "child",
    "hon",
    "note",
    "however",
    "order",
    "insertion",
    "nodes",
    "change",
    "structure",
    "resulting",
    "tree",
    "instance",
    "insert",
    "nodes",
    "increasing",
    "order",
    "username",
    "example",
    "inserting",
    "akash",
    "jades",
    "san",
    "sonak",
    "lexicographic",
    "increasing",
    "order",
    "try",
    "display",
    "tree",
    "end",
    "end",
    "unbalanced",
    "skewed",
    "tree",
    "see",
    "created",
    "skewed",
    "unbalanced",
    "tree",
    "well",
    "let",
    "look",
    "start",
    "akash",
    "single",
    "node",
    "try",
    "insert",
    "barage",
    "realize",
    "need",
    "go",
    "right",
    "insert",
    "barage",
    "try",
    "insert",
    "hon",
    "realize",
    "need",
    "go",
    "right",
    "akash",
    "right",
    "barage",
    "go",
    "keep",
    "going",
    "way",
    "set",
    "root",
    "node",
    "set",
    "subtree",
    "order",
    "insert",
    "nodes",
    "important",
    "create",
    "huge",
    "skew",
    "within",
    "tree",
    "skewed",
    "unbalanced",
    "trees",
    "problematic",
    "height",
    "sub",
    "trees",
    "longer",
    "logarithmic",
    "compared",
    "number",
    "nodes",
    "tree",
    "right",
    "earlier",
    "deduced",
    "balanced",
    "tree",
    "containing",
    "n",
    "nodes",
    "height",
    "log",
    "n",
    "log",
    "n",
    "one",
    "makes",
    "operations",
    "like",
    "insert",
    "update",
    "find",
    "efficient",
    "skew",
    "tree",
    "height",
    "actually",
    "match",
    "number",
    "nodes",
    "instance",
    "tree",
    "seven",
    "nodes",
    "height",
    "seven",
    "cute",
    "trees",
    "may",
    "get",
    "back",
    "fact",
    "insertion",
    "finding",
    "update",
    "order",
    "n",
    "may",
    "traverse",
    "entire",
    "height",
    "tree",
    "equal",
    "number",
    "nodes",
    "tree",
    "may",
    "defeat",
    "purpose",
    "using",
    "binary",
    "search",
    "tree",
    "first",
    "place",
    "maintaining",
    "balance",
    "binary",
    "search",
    "tree",
    "important",
    "see",
    "seen",
    "insert",
    "node",
    "next",
    "thing",
    "find",
    "value",
    "associated",
    "given",
    "key",
    "binary",
    "search",
    "tree",
    "follow",
    "recursive",
    "strategy",
    "similar",
    "insertion",
    "check",
    "start",
    "top",
    "let",
    "say",
    "want",
    "find",
    "key",
    "hon",
    "start",
    "top",
    "compare",
    "root",
    "node",
    "matches",
    "root",
    "node",
    "simply",
    "return",
    "node",
    "check",
    "whether",
    "need",
    "go",
    "left",
    "right",
    "since",
    "hon",
    "comes",
    "jades",
    "need",
    "go",
    "left",
    "encounter",
    "barage",
    "realize",
    "need",
    "go",
    "right",
    "finally",
    "encounter",
    "hon",
    "return",
    "another",
    "option",
    "value",
    "let",
    "say",
    "tanya",
    "exist",
    "try",
    "search",
    "may",
    "go",
    "kind",
    "direction",
    "end",
    "empty",
    "place",
    "case",
    "simply",
    "return",
    "none",
    "either",
    "find",
    "node",
    "return",
    "return",
    "none",
    "see",
    "call",
    "find",
    "tree",
    "hon",
    "get",
    "back",
    "details",
    "interestingly",
    "balanced",
    "tree",
    "take",
    "two",
    "steps",
    "go",
    "entire",
    "tree",
    "worst",
    "case",
    "check",
    "path",
    "root",
    "leaf",
    "balanced",
    "tree",
    "two",
    "steps",
    "long",
    "makes",
    "convenient",
    "hand",
    "try",
    "find",
    "kitan",
    "see",
    "found",
    "try",
    "creating",
    "larger",
    "bsts",
    "try",
    "finding",
    "notes",
    "important",
    "experiment",
    "operations",
    "defined",
    "simply",
    "matter",
    "calling",
    "function",
    "written",
    "code",
    "experiment",
    "try",
    "creating",
    "larger",
    "trees",
    "multiple",
    "levels",
    "dozens",
    "maybe",
    "hundreds",
    "nodes",
    "try",
    "generating",
    "fake",
    "data",
    "putting",
    "trees",
    "see",
    "trees",
    "build",
    "give",
    "feel",
    "binary",
    "search",
    "trees",
    "work",
    "next",
    "let",
    "talk",
    "updating",
    "value",
    "bst",
    "updating",
    "value",
    "fairly",
    "simple",
    "already",
    "way",
    "finding",
    "node",
    "want",
    "update",
    "node",
    "let",
    "say",
    "want",
    "update",
    "node",
    "heon",
    "key",
    "hmon",
    "want",
    "update",
    "want",
    "update",
    "value",
    "new",
    "value",
    "user",
    "hon",
    "changing",
    "name",
    "changing",
    "email",
    "first",
    "find",
    "find",
    "node",
    "node",
    "none",
    "simply",
    "change",
    "value",
    "node",
    "simple",
    "also",
    "seeing",
    "reusing",
    "find",
    "function",
    "good",
    "practice",
    "always",
    "incorporate",
    "programs",
    "functions",
    "whenever",
    "find",
    "copy",
    "pasting",
    "code",
    "maybe",
    "changing",
    "one",
    "two",
    "things",
    "think",
    "whether",
    "extract",
    "piece",
    "code",
    "function",
    "reuse",
    "function",
    "always",
    "try",
    "make",
    "code",
    "generic",
    "less",
    "code",
    "write",
    "less",
    "uh",
    "chances",
    "errors",
    "easier",
    "understand",
    "smaller",
    "functions",
    "become",
    "write",
    "small",
    "reusable",
    "generic",
    "functions",
    "whenever",
    "principle",
    "called",
    "dr",
    "principle",
    "dry",
    "principle",
    "stands",
    "repeat",
    "whenever",
    "writing",
    "programs",
    "update",
    "repeating",
    "using",
    "find",
    "function",
    "find",
    "right",
    "node",
    "simply",
    "updating",
    "setting",
    "value",
    "let",
    "update",
    "hmon",
    "new",
    "value",
    "see",
    "updated",
    "data",
    "hon",
    "j",
    "hon",
    "j",
    "value",
    "node",
    "successfully",
    "updated",
    "easily",
    "check",
    "time",
    "complexity",
    "update",
    "fine",
    "finally",
    "last",
    "operation",
    "required",
    "write",
    "function",
    "retrieve",
    "key",
    "value",
    "pairs",
    "stored",
    "binary",
    "search",
    "tree",
    "sorted",
    "order",
    "keys",
    "question",
    "might",
    "face",
    "uh",
    "simply",
    "ordit",
    "reversal",
    "different",
    "way",
    "stating",
    "ordit",
    "reversal",
    "figure",
    "reason",
    "inorder",
    "traversal",
    "binary",
    "search",
    "tree",
    "produces",
    "sorted",
    "aray",
    "sorted",
    "list",
    "keys",
    "think",
    "list",
    "function",
    "call",
    "list",
    "node",
    "left",
    "call",
    "list",
    "node",
    "right",
    "give",
    "us",
    "two",
    "arrays",
    "assume",
    "list",
    "node",
    "left",
    "gives",
    "us",
    "list",
    "key",
    "value",
    "pairs",
    "left",
    "subtree",
    "sorted",
    "order",
    "similarly",
    "get",
    "list",
    "key",
    "value",
    "pairs",
    "right",
    "subtree",
    "sorted",
    "order",
    "simply",
    "insert",
    "key",
    "value",
    "pair",
    "current",
    "node",
    "recursively",
    "automatically",
    "fills",
    "entire",
    "array",
    "end",
    "condition",
    "encounter",
    "empty",
    "node",
    "simply",
    "return",
    "empty",
    "array",
    "see",
    "pass",
    "tree",
    "get",
    "back",
    "list",
    "users",
    "key",
    "value",
    "pairs",
    "arranged",
    "sorted",
    "order",
    "keys",
    "exercise",
    "determine",
    "time",
    "complexity",
    "state",
    "comple",
    "st",
    "space",
    "complexity",
    "list",
    "function",
    "balanc",
    "tree",
    "unbalanced",
    "tree",
    "hint",
    "make",
    "difference",
    "think",
    "let",
    "save",
    "work",
    "talked",
    "binary",
    "trees",
    "operations",
    "binary",
    "trees",
    "next",
    "thing",
    "look",
    "balanced",
    "binary",
    "trees",
    "common",
    "question",
    "gets",
    "asked",
    "write",
    "function",
    "determine",
    "binary",
    "tree",
    "balanced",
    "recursive",
    "strategy",
    "fact",
    "really",
    "definition",
    "balance",
    "binded",
    "trees",
    "left",
    "sub",
    "tree",
    "balanced",
    "right",
    "sub",
    "tree",
    "balanced",
    "difference",
    "heights",
    "left",
    "right",
    "sub",
    "tree",
    "one",
    "okay",
    "important",
    "thing",
    "looking",
    "balance",
    "always",
    "looking",
    "perfect",
    "perfect",
    "balance",
    "may",
    "always",
    "possible",
    "create",
    "tree",
    "perfect",
    "balance",
    "perfectly",
    "balanced",
    "tree",
    "every",
    "node",
    "left",
    "sub",
    "tree",
    "right",
    "sub",
    "tree",
    "exact",
    "height",
    "fill",
    "nodes",
    "levels",
    "happen",
    "certain",
    "numbers",
    "example",
    "one",
    "node",
    "satisfied",
    "property",
    "tree",
    "three",
    "nodes",
    "satisfy",
    "property",
    "tree",
    "seven",
    "nodes",
    "satisfies",
    "property",
    "may",
    "able",
    "get",
    "tree",
    "six",
    "nodes",
    "satisfy",
    "property",
    "instance",
    "remove",
    "vishal",
    "see",
    "left",
    "sub",
    "tree",
    "right",
    "sub",
    "tree",
    "node",
    "sono",
    "equal",
    "height",
    "balancing",
    "relax",
    "criteria",
    "slightly",
    "simply",
    "need",
    "ensure",
    "difference",
    "heights",
    "left",
    "right",
    "sub",
    "trees",
    "one",
    "code",
    "balanced",
    "pretty",
    "straightforward",
    "return",
    "two",
    "things",
    "balance",
    "return",
    "whether",
    "tree",
    "node",
    "balanced",
    "also",
    "return",
    "height",
    "tree",
    "rooted",
    "node",
    "way",
    "implement",
    "first",
    "calling",
    "balanced",
    "node",
    "left",
    "calling",
    "balanced",
    "node",
    "write",
    "way",
    "exactly",
    "implement",
    "recursive",
    "functions",
    "well",
    "sometimes",
    "write",
    "recursive",
    "functions",
    "signature",
    "immediately",
    "write",
    "return",
    "value",
    "assume",
    "assume",
    "recursive",
    "call",
    "going",
    "return",
    "values",
    "recursive",
    "call",
    "balanced",
    "node",
    "left",
    "going",
    "return",
    "whether",
    "left",
    "subtree",
    "balanced",
    "height",
    "left",
    "subtree",
    "assume",
    "balanced",
    "node",
    "right",
    "going",
    "recall",
    "uh",
    "going",
    "return",
    "whether",
    "right",
    "sub",
    "tree",
    "balanced",
    "height",
    "right",
    "sub",
    "tree",
    "return",
    "entire",
    "tree",
    "balanced",
    "left",
    "sub",
    "tree",
    "balanced",
    "right",
    "sub",
    "tree",
    "balanced",
    "absolute",
    "value",
    "differences",
    "height",
    "less",
    "1",
    "means",
    "height",
    "l",
    "minus",
    "height",
    "r",
    "either",
    "0",
    "1",
    "finally",
    "calculate",
    "height",
    "tree",
    "simply",
    "1",
    "plus",
    "maximum",
    "height",
    "left",
    "sub",
    "tree",
    "right",
    "sub",
    "tree",
    "return",
    "implement",
    "recursive",
    "function",
    "think",
    "recursively",
    "one",
    "last",
    "thing",
    "end",
    "condition",
    "end",
    "condition",
    "although",
    "often",
    "last",
    "thing",
    "think",
    "first",
    "thing",
    "put",
    "end",
    "condition",
    "check",
    "whether",
    "node",
    "none",
    "call",
    "node",
    "left",
    "may",
    "left",
    "sub",
    "tree",
    "may",
    "call",
    "balanced",
    "none",
    "node",
    "none",
    "simply",
    "return",
    "true",
    "uh",
    "empty",
    "tree",
    "balanced",
    "default",
    "imbalance",
    "height",
    "zero",
    "balanced",
    "function",
    "four",
    "five",
    "lines",
    "code",
    "able",
    "reason",
    "recursion",
    "easily",
    "may",
    "get",
    "stuck",
    "may",
    "spend",
    "entire",
    "45",
    "minutes",
    "trying",
    "write",
    "function",
    "debug",
    "always",
    "try",
    "think",
    "recursive",
    "terms",
    "always",
    "always",
    "helps",
    "write",
    "want",
    "plain",
    "english",
    "determine",
    "inputs",
    "outputs",
    "function",
    "maybe",
    "also",
    "test",
    "cases",
    "ready",
    "start",
    "implementing",
    "function",
    "becomes",
    "really",
    "easy",
    "tree",
    "instance",
    "balanced",
    "check",
    "balanced",
    "get",
    "back",
    "true",
    "tree",
    "looking",
    "balanced",
    "tree",
    "2",
    "check",
    "balanced",
    "get",
    "back",
    "false",
    "also",
    "get",
    "height",
    "tree",
    "three",
    "get",
    "height",
    "tree",
    "seven",
    "another",
    "tree",
    "tree",
    "tree",
    "shown",
    "balanced",
    "create",
    "tree",
    "check",
    "balanced",
    "using",
    "balanced",
    "function",
    "another",
    "concept",
    "called",
    "complete",
    "binary",
    "trees",
    "slightly",
    "similar",
    "balanced",
    "binary",
    "trees",
    "slightly",
    "stricter",
    "criteria",
    "check",
    "problem",
    "simply",
    "need",
    "modify",
    "balanced",
    "code",
    "balanced",
    "slightly",
    "get",
    "code",
    "complete",
    "binary",
    "trees",
    "check",
    "problem",
    "lead",
    "right",
    "looked",
    "binary",
    "search",
    "trees",
    "looked",
    "balanced",
    "binary",
    "trees",
    "let",
    "bring",
    "together",
    "balanced",
    "binary",
    "search",
    "trees",
    "one",
    "question",
    "face",
    "point",
    "write",
    "function",
    "create",
    "balanced",
    "binary",
    "search",
    "tree",
    "sorted",
    "list",
    "key",
    "value",
    "pairs",
    "sorted",
    "list",
    "key",
    "value",
    "pairs",
    "keys",
    "could",
    "example",
    "could",
    "usernames",
    "values",
    "could",
    "user",
    "objects",
    "sorted",
    "key",
    "list",
    "create",
    "balanced",
    "binary",
    "search",
    "tree",
    "basic",
    "logic",
    "similar",
    "binary",
    "search",
    "something",
    "covered",
    "lesson",
    "one",
    "check",
    "look",
    "middle",
    "element",
    "instance",
    "list",
    "15",
    "elements",
    "element",
    "position",
    "7",
    "counting",
    "zero",
    "element",
    "position",
    "7",
    "middle",
    "element",
    "take",
    "middle",
    "element",
    "create",
    "new",
    "binary",
    "search",
    "tree",
    "middle",
    "element",
    "root",
    "node",
    "okay",
    "take",
    "make",
    "middle",
    "element",
    "root",
    "node",
    "take",
    "left",
    "half",
    "list",
    "use",
    "create",
    "balanced",
    "bst",
    "make",
    "left",
    "child",
    "middle",
    "element",
    "root",
    "node",
    "take",
    "right",
    "half",
    "halves",
    "seven",
    "elements",
    "take",
    "right",
    "half",
    "create",
    "balanced",
    "bst",
    "make",
    "right",
    "child",
    "middle",
    "element",
    "idea",
    "make",
    "balanced",
    "bstd",
    "left",
    "right",
    "child",
    "recursion",
    "right",
    "recursive",
    "solution",
    "make",
    "balance",
    "bst",
    "takes",
    "data",
    "list",
    "key",
    "value",
    "pairs",
    "takes",
    "low",
    "high",
    "also",
    "takes",
    "parent",
    "look",
    "low",
    "set",
    "zero",
    "default",
    "high",
    "default",
    "set",
    "last",
    "index",
    "data",
    "use",
    "get",
    "middle",
    "index",
    "instance",
    "low",
    "zero",
    "high",
    "14",
    "middle",
    "index",
    "7",
    "get",
    "back",
    "key",
    "value",
    "middle",
    "index",
    "calculate",
    "find",
    "data",
    "made",
    "gives",
    "us",
    "key",
    "value",
    "since",
    "username",
    "user",
    "object",
    "create",
    "root",
    "node",
    "create",
    "root",
    "node",
    "using",
    "bst",
    "node",
    "call",
    "make",
    "balance",
    "bst",
    "data",
    "time",
    "low",
    "mid",
    "minus",
    "one",
    "indices",
    "0",
    "6",
    "make",
    "left",
    "child",
    "road",
    "call",
    "make",
    "balanced",
    "bst",
    "right",
    "node",
    "right",
    "half",
    "mid",
    "1",
    "index",
    "8",
    "14",
    "make",
    "right",
    "sub",
    "tree",
    "return",
    "root",
    "pretty",
    "much",
    "thing",
    "might",
    "need",
    "terminating",
    "condition",
    "low",
    "becomes",
    "less",
    "high",
    "means",
    "elements",
    "create",
    "trees",
    "simply",
    "return",
    "none",
    "left",
    "right",
    "sub",
    "tre",
    "parents",
    "nodes",
    "get",
    "set",
    "none",
    "makes",
    "balance",
    "bst",
    "function",
    "also",
    "thing",
    "called",
    "parent",
    "going",
    "around",
    "let",
    "figure",
    "parent",
    "basic",
    "idea",
    "list",
    "key",
    "value",
    "pairs",
    "uh",
    "key",
    "value",
    "pairs",
    "sorted",
    "increasing",
    "increasing",
    "lexor",
    "graphic",
    "order",
    "keys",
    "calling",
    "make",
    "balance",
    "bst",
    "data",
    "gives",
    "us",
    "tree",
    "let",
    "view",
    "tree",
    "go",
    "created",
    "tree",
    "perfectly",
    "wanted",
    "jades",
    "center",
    "bar",
    "sunak",
    "side",
    "appropriate",
    "nodes",
    "side",
    "children",
    "nodes",
    "recall",
    "list",
    "users",
    "inserted",
    "one",
    "one",
    "resulted",
    "skewed",
    "tree",
    "getting",
    "list",
    "users",
    "username",
    "user",
    "data",
    "inserting",
    "see",
    "calling",
    "display",
    "keys",
    "tree",
    "three",
    "returns",
    "skewed",
    "tree",
    "okay",
    "whenever",
    "sorted",
    "array",
    "want",
    "create",
    "balanced",
    "bst",
    "way",
    "start",
    "middle",
    "finally",
    "one",
    "question",
    "may",
    "asked",
    "balance",
    "unbalanced",
    "binary",
    "search",
    "tree",
    "pretty",
    "simple",
    "point",
    "kind",
    "trick",
    "question",
    "given",
    "given",
    "question",
    "directly",
    "may",
    "able",
    "think",
    "balance",
    "unbalance",
    "binary",
    "search",
    "string",
    "way",
    "create",
    "b",
    "balanced",
    "binary",
    "search",
    "tree",
    "sorted",
    "array",
    "key",
    "value",
    "pairs",
    "way",
    "get",
    "sorted",
    "array",
    "key",
    "value",
    "pairs",
    "simply",
    "becomes",
    "calling",
    "sorted",
    "array",
    "calling",
    "list",
    "node",
    "also",
    "ordered",
    "traval",
    "ordered",
    "tr",
    "veral",
    "binary",
    "search",
    "tree",
    "gives",
    "us",
    "sorted",
    "array",
    "key",
    "value",
    "pairs",
    "passing",
    "make",
    "balanced",
    "bst",
    "function",
    "okay",
    "trick",
    "question",
    "see",
    "benefit",
    "reusing",
    "functions",
    "balancing",
    "unbalanced",
    "bst",
    "becomes",
    "single",
    "line",
    "code",
    "nice",
    "created",
    "tree",
    "uh",
    "value",
    "none",
    "insert",
    "values",
    "one",
    "one",
    "see",
    "creates",
    "skew",
    "tree",
    "inserting",
    "values",
    "increasing",
    "order",
    "elect",
    "graphic",
    "order",
    "keep",
    "adding",
    "right",
    "children",
    "never",
    "add",
    "right",
    "left",
    "child",
    "call",
    "balance",
    "bst",
    "function",
    "internally",
    "takes",
    "gets",
    "ordered",
    "traversal",
    "ordered",
    "traversal",
    "lists",
    "keys",
    "key",
    "value",
    "pairs",
    "sorted",
    "order",
    "call",
    "make",
    "balance",
    "bstd",
    "function",
    "starts",
    "middle",
    "creates",
    "balance",
    "binary",
    "search",
    "tree",
    "see",
    "balance",
    "binary",
    "search",
    "tree",
    "maintain",
    "balance",
    "grow",
    "data",
    "structure",
    "simple",
    "thing",
    "insert",
    "balance",
    "tree",
    "every",
    "insertion",
    "brings",
    "us",
    "complexities",
    "various",
    "operations",
    "balanced",
    "bst",
    "insertion",
    "takes",
    "order",
    "login",
    "tree",
    "balanced",
    "height",
    "order",
    "login",
    "insertion",
    "may",
    "traverse",
    "path",
    "root",
    "leaf",
    "path",
    "length",
    "maximum",
    "equal",
    "height",
    "order",
    "login",
    "also",
    "balancing",
    "every",
    "insertion",
    "also",
    "order",
    "n",
    "term",
    "added",
    "order",
    "n",
    "plus",
    "order",
    "log",
    "n",
    "log",
    "n",
    "becomes",
    "much",
    "smaller",
    "n",
    "n",
    "grows",
    "order",
    "n",
    "plus",
    "order",
    "login",
    "order",
    "n",
    "makes",
    "insertion",
    "order",
    "finding",
    "node",
    "becomes",
    "order",
    "login",
    "updating",
    "node",
    "becomes",
    "order",
    "login",
    "verify",
    "listing",
    "getting",
    "list",
    "notes",
    "order",
    "n",
    "real",
    "improvement",
    "order",
    "n",
    "order",
    "order",
    "login",
    "let",
    "think",
    "looking",
    "100",
    "million",
    "records",
    "log",
    "base",
    "2",
    "100",
    "million",
    "26",
    "27",
    "takes",
    "26",
    "operations",
    "find",
    "update",
    "node",
    "within",
    "balance",
    "bst",
    "opposed",
    "100",
    "million",
    "operations",
    "see",
    "26",
    "loop",
    "size",
    "length",
    "26",
    "operation",
    "inside",
    "takes",
    "microc",
    "seconds",
    "1",
    "microc",
    "10",
    "6",
    "seconds",
    "hand",
    "order",
    "n",
    "involves",
    "looping",
    "entire",
    "list",
    "looping",
    "100",
    "million",
    "numbers",
    "rather",
    "26",
    "obviously",
    "takes",
    "far",
    "far",
    "longer",
    "saw",
    "took",
    "10",
    "seconds",
    "right",
    "seconds",
    "find",
    "update",
    "finding",
    "updating",
    "node",
    "balanced",
    "binary",
    "search",
    "tree",
    "times",
    "faster",
    "original",
    "solution",
    "changed",
    "data",
    "structure",
    "importance",
    "data",
    "structures",
    "user",
    "able",
    "view",
    "profile",
    "microc",
    "seconds",
    "least",
    "part",
    "request",
    "take",
    "long",
    "user",
    "experience",
    "better",
    "cpu",
    "busy",
    "shorter",
    "time",
    "able",
    "serve",
    "eight",
    "hundreds",
    "thousands",
    "users",
    "every",
    "second",
    "finally",
    "hardware",
    "cost",
    "also",
    "far",
    "lower",
    "cpu",
    "busy",
    "lesser",
    "time",
    "need",
    "use",
    "large",
    "machine",
    "need",
    "use",
    "many",
    "machines",
    "support",
    "hundreds",
    "millions",
    "users",
    "users",
    "benefit",
    "choosing",
    "right",
    "data",
    "structure",
    "one",
    "tip",
    "speed",
    "insertions",
    "may",
    "may",
    "choose",
    "perform",
    "balancing",
    "periodically",
    "instead",
    "every",
    "insertions",
    "example",
    "balance",
    "every",
    "100th",
    "insertion",
    "every",
    "thousandth",
    "insertion",
    "every",
    "insertion",
    "whatever",
    "know",
    "balance",
    "often",
    "need",
    "insert",
    "things",
    "versus",
    "often",
    "need",
    "restore",
    "balance",
    "another",
    "idea",
    "balancing",
    "maybe",
    "periodically",
    "end",
    "every",
    "hour",
    "second",
    "two",
    "may",
    "slight",
    "dip",
    "performance",
    "may",
    "performing",
    "balancing",
    "even",
    "way",
    "take",
    "copy",
    "tree",
    "balance",
    "simply",
    "replace",
    "pointer",
    "original",
    "tree",
    "many",
    "tricks",
    "apply",
    "fact",
    "also",
    "algorithmic",
    "trick",
    "brings",
    "insertion",
    "balancing",
    "together",
    "order",
    "login",
    "operation",
    "look",
    "right",
    "end",
    "stay",
    "till",
    "end",
    "uh",
    "let",
    "come",
    "back",
    "answer",
    "original",
    "problem",
    "statement",
    "remember",
    "senior",
    "backend",
    "engineer",
    "tasked",
    "developing",
    "fast",
    "data",
    "structure",
    "manage",
    "profile",
    "information",
    "username",
    "name",
    "email",
    "100",
    "million",
    "users",
    "allow",
    "insertion",
    "find",
    "update",
    "listing",
    "users",
    "username",
    "efficiently",
    "possible",
    "answer",
    "question",
    "instead",
    "creating",
    "user",
    "database",
    "class",
    "create",
    "generic",
    "class",
    "called",
    "tree",
    "map",
    "making",
    "things",
    "generic",
    "gone",
    "along",
    "let",
    "define",
    "function",
    "called",
    "tre",
    "map",
    "internally",
    "stores",
    "binary",
    "search",
    "tree",
    "balanced",
    "binary",
    "search",
    "tree",
    "inside",
    "initialize",
    "tree",
    "map",
    "set",
    "self",
    "root",
    "none",
    "means",
    "created",
    "tree",
    "far",
    "instead",
    "defining",
    "functions",
    "insert",
    "update",
    "delete",
    "going",
    "use",
    "special",
    "functions",
    "python",
    "classes",
    "going",
    "use",
    "function",
    "set",
    "item",
    "going",
    "use",
    "function",
    "set",
    "item",
    "set",
    "item",
    "like",
    "insert",
    "except",
    "combination",
    "insert",
    "update",
    "set",
    "item",
    "pass",
    "key",
    "value",
    "course",
    "self",
    "refer",
    "tree",
    "map",
    "object",
    "first",
    "thing",
    "get",
    "root",
    "basically",
    "binary",
    "search",
    "tree",
    "storing",
    "internally",
    "get",
    "binary",
    "search",
    "tree",
    "find",
    "look",
    "key",
    "inside",
    "binary",
    "search",
    "tree",
    "key",
    "found",
    "find",
    "node",
    "tree",
    "come",
    "else",
    "position",
    "simply",
    "update",
    "value",
    "find",
    "node",
    "happens",
    "initially",
    "initially",
    "self",
    "root",
    "none",
    "call",
    "find",
    "none",
    "pass",
    "key",
    "get",
    "back",
    "none",
    "first",
    "set",
    "self",
    "root",
    "inserting",
    "key",
    "tree",
    "okay",
    "key",
    "exists",
    "within",
    "binary",
    "search",
    "tree",
    "update",
    "key",
    "exist",
    "within",
    "binary",
    "search",
    "tree",
    "insert",
    "binary",
    "search",
    "tree",
    "okay",
    "combined",
    "insert",
    "update",
    "single",
    "operation",
    "called",
    "set",
    "item",
    "similarly",
    "define",
    "another",
    "operation",
    "called",
    "get",
    "item",
    "find",
    "operation",
    "find",
    "node",
    "inside",
    "self",
    "root",
    "using",
    "find",
    "function",
    "defined",
    "earlier",
    "node",
    "present",
    "found",
    "return",
    "value",
    "node",
    "otherwise",
    "return",
    "none",
    "given",
    "key",
    "retrieve",
    "value",
    "defined",
    "one",
    "last",
    "function",
    "called",
    "iter",
    "replacement",
    "list",
    "function",
    "simply",
    "say",
    "call",
    "list",
    "self",
    "root",
    "gives",
    "us",
    "list",
    "key",
    "value",
    "pairs",
    "special",
    "syntax",
    "say",
    "x",
    "x",
    "list",
    "put",
    "round",
    "brackets",
    "around",
    "round",
    "brackets",
    "around",
    "creates",
    "generator",
    "longer",
    "list",
    "generator",
    "generator",
    "something",
    "use",
    "within",
    "loop",
    "iter",
    "function",
    "allow",
    "class",
    "used",
    "directly",
    "within",
    "loop",
    "see",
    "example",
    "second",
    "finally",
    "another",
    "function",
    "called",
    "underscore",
    "uncore",
    "len",
    "remember",
    "double",
    "underscores",
    "double",
    "underscore",
    "set",
    "item",
    "dore",
    "dcore",
    "get",
    "item",
    "dcore",
    "similarly",
    "double",
    "uncore",
    "uh",
    "lenore",
    "simply",
    "return",
    "size",
    "self",
    "root",
    "simply",
    "return",
    "size",
    "binary",
    "tree",
    "function",
    "called",
    "display",
    "going",
    "simply",
    "display",
    "keys",
    "okay",
    "defined",
    "stream",
    "app",
    "structure",
    "funny",
    "looking",
    "methods",
    "like",
    "know",
    "see",
    "moment",
    "know",
    "functionality",
    "may",
    "wondering",
    "define",
    "like",
    "reason",
    "special",
    "methods",
    "treated",
    "specially",
    "python",
    "use",
    "let",
    "first",
    "uh",
    "get",
    "list",
    "users",
    "later",
    "insert",
    "tree",
    "let",
    "get",
    "tree",
    "map",
    "instantiate",
    "tree",
    "map",
    "function",
    "uh",
    "treap",
    "class",
    "gives",
    "us",
    "new",
    "treap",
    "map",
    "inside",
    "binary",
    "tree",
    "check",
    "check",
    "tree",
    "map",
    "root",
    "see",
    "none",
    "value",
    "try",
    "display",
    "see",
    "tree",
    "map",
    "empty",
    "insert",
    "instead",
    "calling",
    "treap",
    "insert",
    "instead",
    "calling",
    "treap",
    "doore",
    "uncore",
    "set",
    "item",
    "use",
    "indexing",
    "notation",
    "open",
    "square",
    "brackets",
    "put",
    "key",
    "want",
    "insert",
    "want",
    "key",
    "insert",
    "key",
    "akash",
    "string",
    "want",
    "insert",
    "value",
    "akash",
    "simply",
    "say",
    "tree",
    "akash",
    "akash",
    "similarly",
    "tree",
    "certain",
    "key",
    "indexing",
    "notation",
    "set",
    "right",
    "going",
    "first",
    "look",
    "key",
    "defined",
    "set",
    "item",
    "finds",
    "key",
    "going",
    "update",
    "value",
    "key",
    "find",
    "key",
    "going",
    "insert",
    "key",
    "value",
    "pair",
    "new",
    "node",
    "tree",
    "let",
    "check",
    "let",
    "see",
    "check",
    "tree",
    "map",
    "root",
    "see",
    "bst",
    "node",
    "try",
    "display",
    "see",
    "structure",
    "jades",
    "sonak",
    "akash",
    "also",
    "note",
    "balanced",
    "tree",
    "go",
    "back",
    "set",
    "item",
    "notice",
    "whenever",
    "insert",
    "right",
    "also",
    "balance",
    "b",
    "tree",
    "change",
    "logic",
    "balancing",
    "every",
    "insertion",
    "maybe",
    "every",
    "100",
    "insertions",
    "may",
    "need",
    "track",
    "somewhere",
    "current",
    "number",
    "current",
    "insertion",
    "counter",
    "gets",
    "100",
    "balancing",
    "set",
    "counter",
    "back",
    "zero",
    "exercise",
    "perform",
    "insertion",
    "perform",
    "balancing",
    "certain",
    "intervals",
    "way",
    "retrieve",
    "element",
    "retrieving",
    "element",
    "also",
    "really",
    "simple",
    "call",
    "treap",
    "jades",
    "um",
    "index",
    "gives",
    "value",
    "found",
    "found",
    "simply",
    "returns",
    "none",
    "defined",
    "function",
    "underscore",
    "uncore",
    "lenore",
    "uncore",
    "see",
    "value",
    "three",
    "use",
    "len",
    "function",
    "used",
    "lists",
    "dictionaries",
    "let",
    "add",
    "things",
    "let",
    "set",
    "values",
    "let",
    "see",
    "see",
    "works",
    "exactly",
    "expected",
    "able",
    "set",
    "values",
    "able",
    "update",
    "values",
    "able",
    "display",
    "tree",
    "remaining",
    "balanced",
    "remember",
    "mentioned",
    "use",
    "loop",
    "put",
    "tree",
    "map",
    "directly",
    "loop",
    "defined",
    "underscore",
    "uncore",
    "iter",
    "function",
    "iter",
    "function",
    "returns",
    "generator",
    "use",
    "loop",
    "get",
    "back",
    "key",
    "value",
    "pairs",
    "list",
    "function",
    "used",
    "inside",
    "iter",
    "print",
    "keys",
    "values",
    "fact",
    "want",
    "convert",
    "list",
    "need",
    "pass",
    "list",
    "generator",
    "iterable",
    "iterable",
    "class",
    "defined",
    "way",
    "iterate",
    "class",
    "get",
    "elements",
    "key",
    "value",
    "pair",
    "list",
    "call",
    "list",
    "get",
    "back",
    "list",
    "key",
    "value",
    "pairs",
    "okay",
    "made",
    "python",
    "friendly",
    "class",
    "know",
    "instantiating",
    "easy",
    "simply",
    "create",
    "new",
    "tree",
    "map",
    "adding",
    "values",
    "easy",
    "simply",
    "use",
    "indexing",
    "notation",
    "removing",
    "elements",
    "easy",
    "well",
    "removing",
    "finding",
    "elements",
    "easy",
    "simply",
    "use",
    "indexing",
    "notation",
    "updating",
    "elements",
    "inserting",
    "also",
    "check",
    "size",
    "tree",
    "quite",
    "easily",
    "using",
    "len",
    "function",
    "also",
    "use",
    "iterate",
    "keys",
    "iterate",
    "users",
    "loop",
    "quite",
    "easily",
    "also",
    "update",
    "values",
    "see",
    "values",
    "updated",
    "purpose",
    "make",
    "easier",
    "people",
    "use",
    "data",
    "structure",
    "senior",
    "backend",
    "engineer",
    "may",
    "designed",
    "data",
    "structure",
    "may",
    "implemented",
    "binary",
    "search",
    "trees",
    "inside",
    "important",
    "people",
    "team",
    "people",
    "using",
    "data",
    "structure",
    "know",
    "internal",
    "implementation",
    "important",
    "able",
    "use",
    "easily",
    "always",
    "think",
    "carefully",
    "interface",
    "api",
    "functions",
    "modules",
    "classes",
    "try",
    "make",
    "python",
    "friendly",
    "possible",
    "something",
    "appreciate",
    "appreciated",
    "interviews",
    "make",
    "python",
    "friendly",
    "people",
    "want",
    "use",
    "something",
    "created",
    "extremely",
    "intuitive",
    "need",
    "really",
    "understand",
    "underlying",
    "details",
    "instance",
    "could",
    "using",
    "class",
    "could",
    "idea",
    "binary",
    "search",
    "tree",
    "know",
    "insert",
    "get",
    "value",
    "know",
    "super",
    "efficient",
    "designed",
    "need",
    "worry",
    "internal",
    "details",
    "encapsulation",
    "good",
    "apis",
    "important",
    "skill",
    "cultivate",
    "work",
    "programming",
    "problems",
    "let",
    "save",
    "work",
    "committing",
    "uh",
    "tell",
    "way",
    "create",
    "self",
    "balance",
    "b",
    "ing",
    "binary",
    "trees",
    "self",
    "balancing",
    "binary",
    "tree",
    "remains",
    "balanced",
    "every",
    "insertion",
    "deletion",
    "fact",
    "several",
    "decades",
    "research",
    "gone",
    "creating",
    "binary",
    "trees",
    "binary",
    "trees",
    "trees",
    "well",
    "binary",
    "nature",
    "many",
    "approaches",
    "devised",
    "instance",
    "red",
    "black",
    "trees",
    "avl",
    "trees",
    "b",
    "trees",
    "example",
    "aval",
    "tree",
    "whenever",
    "node",
    "goes",
    "balance",
    "rotate",
    "tree",
    "see",
    "visually",
    "whenever",
    "see",
    "imbalance",
    "tree",
    "rotate",
    "tracking",
    "balance",
    "factor",
    "difference",
    "height",
    "left",
    "sub",
    "tree",
    "right",
    "sub",
    "tree",
    "node",
    "rotating",
    "unbalanced",
    "sub",
    "trees",
    "along",
    "path",
    "insertion",
    "deletion",
    "balance",
    "see",
    "balance",
    "factor",
    "zero",
    "right",
    "balance",
    "factor",
    "becomes",
    "one",
    "balance",
    "factor",
    "becomes",
    "two",
    "rotate",
    "set",
    "balance",
    "factor",
    "back",
    "balance",
    "factor",
    "becomes",
    "minus",
    "2",
    "right",
    "rotation",
    "balance",
    "factor",
    "becomes",
    "minus",
    "2",
    "minus",
    "one",
    "two",
    "rotations",
    "four",
    "cases",
    "total",
    "left",
    "right",
    "case",
    "right",
    "left",
    "case",
    "left",
    "left",
    "case",
    "right",
    "right",
    "case",
    "four",
    "cases",
    "demonstrated",
    "well",
    "may",
    "need",
    "rotation",
    "may",
    "need",
    "multiple",
    "times",
    "along",
    "path",
    "insertion",
    "insert",
    "node",
    "node",
    "creates",
    "imbalance",
    "need",
    "work",
    "backwards",
    "need",
    "keep",
    "going",
    "parent",
    "parent",
    "keep",
    "rotating",
    "nodes",
    "whenever",
    "need",
    "rebalance",
    "based",
    "updated",
    "balance",
    "factor",
    "node",
    "seems",
    "little",
    "complicated",
    "actually",
    "multiple",
    "cases",
    "handle",
    "need",
    "write",
    "couple",
    "helper",
    "functions",
    "need",
    "write",
    "function",
    "left",
    "rotate",
    "rotates",
    "node",
    "left",
    "still",
    "preserving",
    "binary",
    "search",
    "tre",
    "property",
    "need",
    "write",
    "function",
    "right",
    "rotate",
    "rotates",
    "function",
    "rotates",
    "right",
    "preserving",
    "bstd",
    "property",
    "insertion",
    "also",
    "need",
    "perform",
    "rotation",
    "right",
    "places",
    "need",
    "track",
    "balance",
    "factor",
    "inside",
    "node",
    "things",
    "work",
    "worry",
    "normally",
    "asked",
    "implement",
    "aval",
    "tree",
    "within",
    "within",
    "interview",
    "within",
    "coding",
    "assessment",
    "really",
    "need",
    "learn",
    "implementation",
    "nevertheless",
    "interesting",
    "data",
    "structure",
    "study",
    "couple",
    "resources",
    "check",
    "check",
    "youtube",
    "video",
    "explains",
    "wonderfully",
    "check",
    "implementation",
    "geeks",
    "geek",
    "org",
    "important",
    "thing",
    "us",
    "take",
    "away",
    "something",
    "may",
    "asked",
    "implementation",
    "complexity",
    "important",
    "thing",
    "rotation",
    "takes",
    "constant",
    "time",
    "log",
    "rotations",
    "may",
    "required",
    "starting",
    "balance",
    "tree",
    "inserting",
    "new",
    "mode",
    "may",
    "traverse",
    "path",
    "height",
    "length",
    "log",
    "n",
    "may",
    "need",
    "perform",
    "login",
    "rotations",
    "maybe",
    "twice",
    "means",
    "order",
    "login",
    "time",
    "able",
    "insert",
    "maintain",
    "balanced",
    "property",
    "binary",
    "tree",
    "right",
    "need",
    "recreate",
    "entire",
    "tree",
    "makes",
    "tree",
    "efficient",
    "working",
    "100",
    "million",
    "records",
    "inserting",
    "also",
    "take",
    "20",
    "steps",
    "finding",
    "also",
    "take",
    "20",
    "steps",
    "updating",
    "also",
    "take",
    "20",
    "steps",
    "work",
    "micros",
    "seconds",
    "makes",
    "data",
    "structure",
    "efficient",
    "conclude",
    "discussion",
    "binary",
    "search",
    "trees",
    "quick",
    "summary",
    "looked",
    "problem",
    "creating",
    "data",
    "structure",
    "allows",
    "efficient",
    "storage",
    "retrieval",
    "updation",
    "also",
    "efficient",
    "iteration",
    "sorted",
    "order",
    "first",
    "started",
    "list",
    "sorted",
    "list",
    "values",
    "sorted",
    "keys",
    "realized",
    "probably",
    "right",
    "idea",
    "working",
    "really",
    "large",
    "number",
    "records",
    "created",
    "binary",
    "tree",
    "structure",
    "looked",
    "binary",
    "trees",
    "looked",
    "create",
    "looked",
    "easy",
    "ways",
    "visualize",
    "easy",
    "ways",
    "create",
    "tupes",
    "looked",
    "calculate",
    "heights",
    "sizes",
    "traverse",
    "order",
    "postorder",
    "looked",
    "binary",
    "search",
    "trees",
    "property",
    "left",
    "sub",
    "tree",
    "keys",
    "smaller",
    "root",
    "noes",
    "keys",
    "right",
    "subtrees",
    "keys",
    "larger",
    "root",
    "node",
    "keys",
    "property",
    "holds",
    "every",
    "subtree",
    "makes",
    "really",
    "easy",
    "find",
    "locate",
    "specific",
    "element",
    "find",
    "position",
    "insert",
    "element",
    "created",
    "binary",
    "search",
    "trees",
    "created",
    "operations",
    "insert",
    "update",
    "find",
    "list",
    "binary",
    "search",
    "tree",
    "also",
    "determined",
    "ways",
    "check",
    "binary",
    "tree",
    "binary",
    "search",
    "tree",
    "talked",
    "balancing",
    "saw",
    "create",
    "balanced",
    "binary",
    "search",
    "trees",
    "binary",
    "search",
    "trees",
    "form",
    "basis",
    "many",
    "modern",
    "programming",
    "languages",
    "language",
    "features",
    "instance",
    "maps",
    "java",
    "binary",
    "search",
    "trees",
    "data",
    "storage",
    "systems",
    "like",
    "file",
    "system",
    "indexes",
    "relational",
    "databases",
    "also",
    "use",
    "something",
    "called",
    "b",
    "trees",
    "extension",
    "binary",
    "search",
    "trees",
    "important",
    "know",
    "binary",
    "search",
    "trees",
    "even",
    "may",
    "ever",
    "need",
    "implement",
    "may",
    "asked",
    "many",
    "cases",
    "may",
    "need",
    "pick",
    "binary",
    "search",
    "tree",
    "data",
    "structure",
    "problem",
    "like",
    "case",
    "may",
    "wonder",
    "dictionaries",
    "python",
    "also",
    "binary",
    "search",
    "trees",
    "well",
    "dictionaries",
    "python",
    "binary",
    "search",
    "trees",
    "soon",
    "release",
    "assignment",
    "find",
    "lesson",
    "page",
    "work",
    "hash",
    "tables",
    "assignment",
    "problems",
    "try",
    "try",
    "implement",
    "rotations",
    "self",
    "balancing",
    "insertion",
    "try",
    "implement",
    "deletion",
    "node",
    "binary",
    "search",
    "tree",
    "slightly",
    "complicated",
    "delete",
    "node",
    "left",
    "right",
    "subtree",
    "try",
    "deletion",
    "balancing",
    "really",
    "challenge",
    "couple",
    "find",
    "finding",
    "lowest",
    "common",
    "ancestor",
    "two",
    "nodes",
    "tree",
    "common",
    "node",
    "common",
    "parent",
    "nodes",
    "use",
    "parent",
    "property",
    "finding",
    "next",
    "node",
    "lexicographic",
    "order",
    "given",
    "node",
    "find",
    "next",
    "node",
    "complexity",
    "given",
    "number",
    "k",
    "find",
    "k",
    "node",
    "binary",
    "search",
    "tree",
    "employ",
    "clever",
    "tricks",
    "couple",
    "resources",
    "open",
    "find",
    "questions",
    "important",
    "thing",
    "take",
    "away",
    "almost",
    "involve",
    "form",
    "recursion",
    "either",
    "work",
    "uh",
    "left",
    "subtree",
    "right",
    "sub",
    "tree",
    "may",
    "also",
    "require",
    "store",
    "additional",
    "information",
    "within",
    "node",
    "instance",
    "uh",
    "one",
    "uh",
    "given",
    "number",
    "c",
    "find",
    "k",
    "node",
    "may",
    "require",
    "store",
    "size",
    "balanced",
    "binary",
    "search",
    "tree",
    "node",
    "next",
    "review",
    "lecture",
    "video",
    "execute",
    "jupiter",
    "notebook",
    "experiment",
    "code",
    "complete",
    "assignment",
    "hopefully",
    "next",
    "lesson",
    "called",
    "divide",
    "conquer",
    "sorting",
    "algorithms",
    "data",
    "structures",
    "algorithms",
    "python",
    "see",
    "next",
    "time",
    "thank",
    "goodbye",
    "let",
    "look",
    "assignment",
    "two",
    "data",
    "structures",
    "algorithms",
    "python",
    "topic",
    "assignment",
    "hash",
    "tables",
    "python",
    "dictionaries",
    "let",
    "get",
    "started",
    "first",
    "thing",
    "go",
    "course",
    "website",
    "python",
    "course",
    "website",
    "find",
    "lessons",
    "previous",
    "assignments",
    "looking",
    "assignment",
    "two",
    "may",
    "want",
    "open",
    "assignment",
    "2",
    "based",
    "inspired",
    "topics",
    "discussed",
    "assign",
    "lesson",
    "two",
    "may",
    "also",
    "want",
    "watch",
    "lesson",
    "two",
    "complete",
    "notebook",
    "work",
    "assignment",
    "2",
    "let",
    "open",
    "assignment",
    "apply",
    "concepts",
    "learned",
    "first",
    "two",
    "lessons",
    "implement",
    "hash",
    "table",
    "scratch",
    "python",
    "interesting",
    "hash",
    "tables",
    "important",
    "data",
    "structure",
    "present",
    "pretty",
    "much",
    "every",
    "programming",
    "language",
    "common",
    "topic",
    "discussed",
    "asked",
    "coding",
    "interviews",
    "see",
    "implement",
    "scratch",
    "one",
    "central",
    "problems",
    "hash",
    "tables",
    "called",
    "collisions",
    "see",
    "handle",
    "hashing",
    "collisions",
    "using",
    "linear",
    "probing",
    "also",
    "replicate",
    "functionality",
    "python",
    "dictionary",
    "python",
    "dictionaries",
    "actually",
    "implemented",
    "using",
    "hash",
    "tables",
    "see",
    "replicate",
    "way",
    "python",
    "dictionaries",
    "created",
    "used",
    "modified",
    "way",
    "access",
    "keys",
    "iterate",
    "keys",
    "set",
    "values",
    "change",
    "values",
    "pretty",
    "much",
    "reimplement",
    "python",
    "dictionary",
    "assignment",
    "starter",
    "notebook",
    "click",
    "view",
    "notebook",
    "open",
    "notebook",
    "jupiter",
    "notebook",
    "work",
    "notebook",
    "find",
    "question",
    "marks",
    "certain",
    "places",
    "complete",
    "assignment",
    "replace",
    "question",
    "marks",
    "appropriate",
    "values",
    "expressions",
    "statements",
    "ensure",
    "notebook",
    "runs",
    "properly",
    "end",
    "end",
    "okay",
    "make",
    "sure",
    "run",
    "code",
    "cells",
    "change",
    "variable",
    "names",
    "cases",
    "may",
    "need",
    "add",
    "code",
    "cells",
    "new",
    "statements",
    "since",
    "using",
    "temporary",
    "online",
    "service",
    "code",
    "execution",
    "keep",
    "saving",
    "work",
    "running",
    "jovian",
    "doc",
    "commit",
    "regular",
    "intervals",
    "optional",
    "questions",
    "considered",
    "evaluation",
    "learning",
    "okay",
    "let",
    "run",
    "code",
    "recommended",
    "way",
    "run",
    "code",
    "using",
    "free",
    "online",
    "resources",
    "binder",
    "specifically",
    "also",
    "run",
    "computer",
    "locally",
    "going",
    "click",
    "run",
    "click",
    "run",
    "binder",
    "may",
    "take",
    "minutes",
    "sometimes",
    "depending",
    "current",
    "traffic",
    "platform",
    "jupyter",
    "notebook",
    "running",
    "first",
    "thing",
    "like",
    "click",
    "kernel",
    "restart",
    "clear",
    "output",
    "execute",
    "code",
    "cells",
    "see",
    "outputs",
    "scratch",
    "also",
    "going",
    "hide",
    "header",
    "toolbar",
    "zoom",
    "little",
    "bit",
    "see",
    "things",
    "little",
    "better",
    "first",
    "thing",
    "set",
    "project",
    "name",
    "import",
    "jovian",
    "library",
    "run",
    "joan",
    "commit",
    "allow",
    "save",
    "snapshot",
    "work",
    "jovian",
    "profile",
    "copy",
    "assignment",
    "starter",
    "notebook",
    "modifications",
    "make",
    "every",
    "time",
    "run",
    "get",
    "saved",
    "personal",
    "copy",
    "personal",
    "copy",
    "submit",
    "end",
    "let",
    "talk",
    "problem",
    "statement",
    "assignment",
    "recreate",
    "python",
    "dictionaries",
    "scratch",
    "using",
    "data",
    "structure",
    "called",
    "hash",
    "tables",
    "dictionaries",
    "python",
    "used",
    "store",
    "key",
    "value",
    "pairs",
    "keys",
    "sto",
    "used",
    "store",
    "retrieve",
    "values",
    "example",
    "dictionary",
    "storing",
    "retrieving",
    "phone",
    "numbers",
    "using",
    "people",
    "names",
    "dictionary",
    "called",
    "phone",
    "numbers",
    "way",
    "create",
    "dictionary",
    "using",
    "special",
    "character",
    "brace",
    "curly",
    "bracket",
    "called",
    "dictionary",
    "key",
    "value",
    "pairs",
    "one",
    "key",
    "value",
    "pair",
    "key",
    "key",
    "case",
    "string",
    "akash",
    "colon",
    "value",
    "value",
    "case",
    "phone",
    "number",
    "create",
    "key",
    "value",
    "pair",
    "comma",
    "separated",
    "key",
    "value",
    "pairs",
    "need",
    "create",
    "dictionary",
    "see",
    "dictionary",
    "created",
    "displayed",
    "exact",
    "way",
    "access",
    "person",
    "phone",
    "number",
    "using",
    "name",
    "variable",
    "phone",
    "numbers",
    "use",
    "indexing",
    "notation",
    "square",
    "bracket",
    "pass",
    "key",
    "get",
    "back",
    "name",
    "may",
    "wonder",
    "happens",
    "key",
    "present",
    "great",
    "thing",
    "jupiter",
    "insert",
    "new",
    "cell",
    "like",
    "click",
    "insert",
    "cell",
    "use",
    "keyboard",
    "shortcut",
    "b",
    "check",
    "maybe",
    "let",
    "check",
    "key",
    "vishal",
    "okay",
    "get",
    "back",
    "key",
    "error",
    "may",
    "also",
    "wonder",
    "happens",
    "case",
    "sensitive",
    "matter",
    "check",
    "easily",
    "lot",
    "questions",
    "might",
    "get",
    "lot",
    "questions",
    "may",
    "want",
    "even",
    "ask",
    "forum",
    "look",
    "online",
    "resolved",
    "simply",
    "creating",
    "new",
    "cell",
    "typing",
    "code",
    "right",
    "happens",
    "questions",
    "answered",
    "writing",
    "code",
    "let",
    "add",
    "new",
    "phone",
    "numbers",
    "create",
    "initial",
    "set",
    "phone",
    "numbers",
    "access",
    "phone",
    "number",
    "add",
    "new",
    "values",
    "adding",
    "new",
    "values",
    "like",
    "accessing",
    "instead",
    "accessing",
    "put",
    "equal",
    "actually",
    "set",
    "value",
    "add",
    "new",
    "value",
    "phone",
    "number",
    "vishal",
    "also",
    "update",
    "existing",
    "value",
    "dictionary",
    "simply",
    "accessing",
    "value",
    "putting",
    "equal",
    "putting",
    "new",
    "value",
    "see",
    "dictionary",
    "updated",
    "contain",
    "new",
    "phone",
    "number",
    "7878",
    "original",
    "phone",
    "number",
    "948",
    "948",
    "also",
    "view",
    "names",
    "phone",
    "number",
    "stored",
    "phone",
    "number",
    "dictionary",
    "using",
    "loop",
    "say",
    "name",
    "phone",
    "numbers",
    "put",
    "dictionary",
    "loop",
    "get",
    "back",
    "key",
    "within",
    "loop",
    "see",
    "name",
    "phone",
    "number",
    "displayed",
    "using",
    "print",
    "statement",
    "things",
    "within",
    "dictionary",
    "dictionaries",
    "python",
    "implemented",
    "using",
    "data",
    "structure",
    "called",
    "hash",
    "table",
    "hash",
    "table",
    "uses",
    "list",
    "array",
    "store",
    "key",
    "value",
    "pairs",
    "uses",
    "hashing",
    "function",
    "determine",
    "index",
    "storing",
    "retrieving",
    "data",
    "associated",
    "given",
    "key",
    "looks",
    "like",
    "uh",
    "key",
    "john",
    "smith",
    "function",
    "called",
    "hash",
    "function",
    "hash",
    "takes",
    "key",
    "returns",
    "index",
    "within",
    "list",
    "use",
    "hashing",
    "function",
    "well",
    "one",
    "approach",
    "discussed",
    "lesson",
    "two",
    "store",
    "key",
    "value",
    "pairs",
    "list",
    "simply",
    "search",
    "list",
    "time",
    "want",
    "look",
    "value",
    "key",
    "inefficient",
    "requires",
    "looking",
    "potentially",
    "keys",
    "get",
    "key",
    "want",
    "maybe",
    "half",
    "keys",
    "makes",
    "order",
    "n",
    "operation",
    "n",
    "size",
    "list",
    "pretty",
    "inefficient",
    "want",
    "something",
    "faster",
    "hash",
    "function",
    "actually",
    "operates",
    "constant",
    "time",
    "hash",
    "simply",
    "takes",
    "key",
    "converts",
    "key",
    "number",
    "sense",
    "gives",
    "index",
    "specific",
    "key",
    "value",
    "pair",
    "constant",
    "time",
    "rather",
    "order",
    "makes",
    "hash",
    "table",
    "efficient",
    "right",
    "hash",
    "function",
    "require",
    "looping",
    "list",
    "simply",
    "takes",
    "key",
    "gives",
    "index",
    "simply",
    "get",
    "key",
    "value",
    "pair",
    "value",
    "index",
    "objective",
    "assignment",
    "implement",
    "hash",
    "table",
    "class",
    "supports",
    "operations",
    "insert",
    "operation",
    "way",
    "insert",
    "new",
    "key",
    "value",
    "pair",
    "find",
    "operation",
    "find",
    "value",
    "associated",
    "given",
    "key",
    "update",
    "operation",
    "update",
    "value",
    "associated",
    "given",
    "key",
    "list",
    "operation",
    "list",
    "keys",
    "stored",
    "hash",
    "table",
    "going",
    "use",
    "python",
    "classes",
    "brief",
    "introduction",
    "python",
    "classes",
    "lesson",
    "two",
    "course",
    "check",
    "lesson",
    "want",
    "refreshing",
    "python",
    "classes",
    "class",
    "hash",
    "table",
    "inside",
    "class",
    "hash",
    "table",
    "bunch",
    "methods",
    "insert",
    "method",
    "apart",
    "taking",
    "self",
    "argument",
    "remember",
    "self",
    "argument",
    "refers",
    "object",
    "class",
    "created",
    "equivalent",
    "variable",
    "java",
    "actual",
    "arguments",
    "method",
    "actual",
    "arguments",
    "key",
    "value",
    "insert",
    "function",
    "insert",
    "method",
    "take",
    "key",
    "value",
    "find",
    "method",
    "take",
    "key",
    "update",
    "method",
    "take",
    "key",
    "value",
    "find",
    "method",
    "takes",
    "key",
    "job",
    "return",
    "value",
    "insert",
    "method",
    "takes",
    "key",
    "value",
    "insert",
    "key",
    "value",
    "pair",
    "hash",
    "table",
    "list",
    "method",
    "used",
    "list",
    "keys",
    "table",
    "begin",
    "implementation",
    "let",
    "save",
    "commit",
    "work",
    "running",
    "jin",
    "commit",
    "let",
    "run",
    "go",
    "notebook",
    "committed",
    "come",
    "back",
    "particular",
    "page",
    "find",
    "profile",
    "click",
    "run",
    "continue",
    "work",
    "based",
    "modifications",
    "already",
    "made",
    "okay",
    "build",
    "hashtable",
    "class",
    "step",
    "step",
    "first",
    "step",
    "create",
    "python",
    "list",
    "hold",
    "key",
    "value",
    "pairs",
    "remember",
    "hashtable",
    "internally",
    "uses",
    "list",
    "store",
    "key",
    "value",
    "pairs",
    "create",
    "list",
    "fixed",
    "size",
    "set",
    "variable",
    "max",
    "hashtable",
    "size",
    "size",
    "4096",
    "initially",
    "going",
    "create",
    "python",
    "list",
    "size",
    "create",
    "python",
    "list",
    "size",
    "want",
    "values",
    "set",
    "none",
    "way",
    "course",
    "start",
    "typing",
    "none",
    "would",
    "take",
    "long",
    "time",
    "use",
    "simple",
    "technique",
    "put",
    "n",
    "496",
    "one",
    "one",
    "great",
    "things",
    "python",
    "expressive",
    "language",
    "creating",
    "list",
    "elements",
    "simply",
    "requires",
    "single",
    "expression",
    "check",
    "even",
    "check",
    "length",
    "data",
    "list",
    "list",
    "created",
    "successfully",
    "test",
    "cases",
    "one",
    "check",
    "length",
    "list",
    "4096",
    "another",
    "check",
    "simply",
    "picking",
    "random",
    "value",
    "list",
    "99",
    "checking",
    "equal",
    "9",
    "n",
    "really",
    "want",
    "shot",
    "test",
    "checking",
    "item",
    "data",
    "list",
    "item",
    "equals",
    "none",
    "okay",
    "trick",
    "write",
    "word",
    "called",
    "assert",
    "assert",
    "comparison",
    "true",
    "nothing",
    "lets",
    "code",
    "proceed",
    "usual",
    "point",
    "comparison",
    "becomes",
    "false",
    "throws",
    "error",
    "let",
    "see",
    "see",
    "error",
    "means",
    "worked",
    "fine",
    "comparison",
    "wrong",
    "let",
    "say",
    "item",
    "wanted",
    "items",
    "equal",
    "7",
    "put",
    "data",
    "list",
    "contain",
    "item",
    "7even",
    "certain",
    "position",
    "get",
    "assertion",
    "error",
    "okay",
    "create",
    "test",
    "cases",
    "putting",
    "assert",
    "idea",
    "whatever",
    "try",
    "make",
    "sure",
    "adding",
    "test",
    "cases",
    "depending",
    "test",
    "cases",
    "given",
    "okay",
    "simply",
    "guide",
    "right",
    "direction",
    "okay",
    "next",
    "list",
    "need",
    "way",
    "store",
    "insert",
    "key",
    "value",
    "pairs",
    "list",
    "hashing",
    "function",
    "comes",
    "picture",
    "hashing",
    "function",
    "used",
    "convert",
    "strings",
    "data",
    "types",
    "numbers",
    "used",
    "list",
    "indices",
    "example",
    "example",
    "hashing",
    "function",
    "converts",
    "string",
    "akash",
    "number",
    "four",
    "key",
    "value",
    "pair",
    "akash",
    "phone",
    "number",
    "78",
    "78",
    "78",
    "78",
    "78",
    "stored",
    "position",
    "four",
    "within",
    "data",
    "list",
    "simple",
    "algorithm",
    "hashing",
    "convert",
    "strings",
    "numeric",
    "list",
    "indices",
    "hashing",
    "algorithm",
    "single",
    "definition",
    "come",
    "hashing",
    "algorithm",
    "fact",
    "coming",
    "good",
    "hashing",
    "algorithm",
    "area",
    "research",
    "course",
    "python",
    "dictionaries",
    "use",
    "hashing",
    "built",
    "python",
    "fairly",
    "optimized",
    "hashing",
    "algorithm",
    "probably",
    "result",
    "several",
    "years",
    "research",
    "one",
    "simple",
    "technique",
    "iterate",
    "string",
    "character",
    "character",
    "convert",
    "character",
    "number",
    "using",
    "python",
    "function",
    "see",
    "call",
    "ardd",
    "character",
    "x",
    "get",
    "back",
    "number",
    "already",
    "gives",
    "way",
    "converting",
    "characters",
    "numbers",
    "entire",
    "strings",
    "need",
    "iterate",
    "string",
    "character",
    "character",
    "simply",
    "add",
    "numbers",
    "character",
    "obtain",
    "hash",
    "entire",
    "string",
    "simple",
    "technique",
    "keep",
    "number",
    "hello",
    "take",
    "odd",
    "hello",
    "odd",
    "e",
    "odd",
    "l",
    "odd",
    "l",
    "odd",
    "add",
    "together",
    "since",
    "want",
    "number",
    "final",
    "result",
    "index",
    "position",
    "within",
    "list",
    "take",
    "remainder",
    "result",
    "size",
    "data",
    "list",
    "right",
    "possible",
    "add",
    "numbers",
    "together",
    "may",
    "end",
    "pretty",
    "big",
    "number",
    "take",
    "remainder",
    "4096",
    "max",
    "hash",
    "table",
    "size",
    "variable",
    "get",
    "back",
    "number",
    "smaller",
    "4096",
    "use",
    "remain",
    "index",
    "let",
    "first",
    "define",
    "function",
    "called",
    "get",
    "index",
    "takes",
    "data",
    "list",
    "takes",
    "string",
    "returns",
    "applies",
    "hashing",
    "algorithm",
    "return",
    "index",
    "string",
    "key",
    "character",
    "string",
    "need",
    "convert",
    "character",
    "number",
    "convert",
    "character",
    "string",
    "number",
    "calling",
    "character",
    "great",
    "update",
    "result",
    "adding",
    "number",
    "say",
    "result",
    "plus",
    "equals",
    "number",
    "pretty",
    "straightforward",
    "repeats",
    "characters",
    "string",
    "get",
    "back",
    "final",
    "result",
    "result",
    "may",
    "longer",
    "actual",
    "size",
    "list",
    "may",
    "want",
    "check",
    "size",
    "list",
    "okay",
    "remember",
    "one",
    "could",
    "also",
    "probably",
    "written",
    "max",
    "hash",
    "table",
    "size",
    "would",
    "wrong",
    "passing",
    "data",
    "list",
    "passing",
    "data",
    "list",
    "although",
    "far",
    "created",
    "data",
    "list",
    "size",
    "4096",
    "function",
    "ideally",
    "looking",
    "size",
    "data",
    "list",
    "global",
    "variables",
    "keep",
    "mind",
    "right",
    "thing",
    "check",
    "l",
    "data",
    "list",
    "allow",
    "allow",
    "function",
    "work",
    "data",
    "lists",
    "different",
    "sizes",
    "standard",
    "size",
    "40",
    "96",
    "defined",
    "okay",
    "important",
    "thing",
    "always",
    "make",
    "sure",
    "functions",
    "use",
    "arguments",
    "passed",
    "generic",
    "work",
    "input",
    "particular",
    "input",
    "defined",
    "earlier",
    "okay",
    "go",
    "function",
    "get",
    "index",
    "defined",
    "tests",
    "pass",
    "data",
    "list",
    "pass",
    "empty",
    "string",
    "characters",
    "result",
    "likely",
    "zero",
    "create",
    "another",
    "one",
    "result",
    "585",
    "another",
    "one",
    "result",
    "941",
    "great",
    "testing",
    "function",
    "custom",
    "test",
    "cases",
    "going",
    "create",
    "new",
    "data",
    "list",
    "2",
    "going",
    "size",
    "9",
    "48",
    "going",
    "size",
    "48",
    "testing",
    "get",
    "index",
    "data",
    "list",
    "well",
    "let",
    "say",
    "looking",
    "key",
    "akash",
    "know",
    "let",
    "see",
    "actually",
    "test",
    "happens",
    "add",
    "plus",
    "plus",
    "k",
    "h",
    "number",
    "585",
    "since",
    "size",
    "list",
    "48",
    "getting",
    "back",
    "result",
    "48",
    "divided",
    "585",
    "getting",
    "oh",
    "sorry",
    "585",
    "remainder",
    "48",
    "getting",
    "back",
    "number",
    "9",
    "equal",
    "9",
    "okay",
    "let",
    "check",
    "equal",
    "9",
    "indeed",
    "equal",
    "9",
    "hand",
    "max",
    "hash",
    "table",
    "size",
    "see",
    "since",
    "taking",
    "consideration",
    "actual",
    "size",
    "list",
    "passed",
    "function",
    "getting",
    "back",
    "value",
    "585",
    "taking",
    "remainder",
    "4096",
    "okay",
    "remember",
    "take",
    "result",
    "remainder",
    "size",
    "data",
    "list",
    "passed",
    "one",
    "several",
    "gas",
    "assignment",
    "reason",
    "something",
    "need",
    "keep",
    "mind",
    "function",
    "uses",
    "arguments",
    "depend",
    "external",
    "global",
    "variables",
    "constants",
    "things",
    "like",
    "called",
    "pure",
    "function",
    "course",
    "pure",
    "function",
    "also",
    "modify",
    "external",
    "global",
    "variables",
    "simply",
    "takes",
    "arguments",
    "returns",
    "result",
    "irrespective",
    "anything",
    "else",
    "outside",
    "insert",
    "key",
    "value",
    "pair",
    "hash",
    "table",
    "simply",
    "get",
    "hash",
    "key",
    "key",
    "value",
    "pair",
    "simply",
    "get",
    "hash",
    "key",
    "calling",
    "get",
    "index",
    "data",
    "list",
    "key",
    "get",
    "back",
    "index",
    "585",
    "inside",
    "data",
    "list",
    "given",
    "index",
    "simply",
    "set",
    "key",
    "value",
    "pair",
    "element",
    "stored",
    "index",
    "operation",
    "expressed",
    "single",
    "line",
    "code",
    "calling",
    "get",
    "index",
    "data",
    "list",
    "month",
    "going",
    "give",
    "us",
    "index",
    "going",
    "invoke",
    "set",
    "particular",
    "index",
    "within",
    "data",
    "list",
    "element",
    "hon",
    "comma",
    "hon",
    "phone",
    "number",
    "retrieve",
    "find",
    "element",
    "associated",
    "pair",
    "simply",
    "get",
    "hash",
    "ele",
    "value",
    "associated",
    "key",
    "simply",
    "get",
    "hash",
    "key",
    "look",
    "index",
    "within",
    "data",
    "list",
    "key",
    "akash",
    "data",
    "list",
    "call",
    "get",
    "index",
    "get",
    "index",
    "key",
    "akash",
    "gives",
    "us",
    "index",
    "call",
    "data",
    "list",
    "pass",
    "position",
    "idx",
    "give",
    "us",
    "key",
    "value",
    "pair",
    "remember",
    "stored",
    "key",
    "value",
    "pair",
    "given",
    "index",
    "get",
    "back",
    "value",
    "know",
    "store",
    "value",
    "get",
    "hash",
    "key",
    "store",
    "key",
    "value",
    "pair",
    "retrieve",
    "value",
    "get",
    "hash",
    "key",
    "retrieve",
    "key",
    "value",
    "pair",
    "get",
    "value",
    "also",
    "list",
    "keys",
    "list",
    "keys",
    "special",
    "code",
    "using",
    "let",
    "see",
    "called",
    "list",
    "comprehension",
    "let",
    "take",
    "quick",
    "look",
    "list",
    "comprehension",
    "list",
    "comprehension",
    "works",
    "like",
    "create",
    "list",
    "list",
    "x",
    "uh",
    "let",
    "say",
    "let",
    "call",
    "list",
    "one",
    "list",
    "two",
    "good",
    "variable",
    "names",
    "always",
    "help",
    "list",
    "one",
    "write",
    "x",
    "x",
    "list",
    "one",
    "x",
    "list",
    "one",
    "patches",
    "elements",
    "one",
    "one",
    "list",
    "specify",
    "numbers",
    "fetched",
    "right",
    "anything",
    "simply",
    "returning",
    "number",
    "putting",
    "entire",
    "thing",
    "list",
    "creates",
    "new",
    "list",
    "see",
    "copy",
    "original",
    "list",
    "could",
    "could",
    "write",
    "x",
    "2",
    "x",
    "list",
    "one",
    "would",
    "end",
    "list",
    "element",
    "double",
    "particular",
    "element",
    "could",
    "also",
    "x",
    "x",
    "wanted",
    "could",
    "also",
    "call",
    "function",
    "let",
    "see",
    "function",
    "call",
    "let",
    "maybe",
    "put",
    "numbers",
    "could",
    "put",
    "maybe",
    "function",
    "math",
    "round",
    "x",
    "oh",
    "sorry",
    "math",
    "seal",
    "going",
    "give",
    "us",
    "ceiling",
    "becomes",
    "2",
    "becomes",
    "3",
    "operation",
    "element",
    "list",
    "put",
    "bracket",
    "four",
    "going",
    "apply",
    "operation",
    "entire",
    "list",
    "called",
    "list",
    "comprehension",
    "python",
    "powerful",
    "way",
    "express",
    "complex",
    "operations",
    "lists",
    "dictionaries",
    "one",
    "final",
    "thing",
    "list",
    "operations",
    "condition",
    "x",
    "list",
    "one",
    "followed",
    "condition",
    "condition",
    "apply",
    "x",
    "x",
    "greater",
    "three",
    "let",
    "say",
    "put",
    "condition",
    "happens",
    "choose",
    "numbers",
    "list",
    "one",
    "satisfy",
    "condition",
    "x",
    "greater",
    "3",
    "means",
    "would",
    "skip",
    "would",
    "skip",
    "2",
    "would",
    "get",
    "would",
    "get",
    "6",
    "would",
    "get",
    "7",
    "would",
    "apply",
    "math",
    "se",
    "get",
    "back",
    "467",
    "list",
    "comprehension",
    "nutshell",
    "get",
    "list",
    "keys",
    "four",
    "key",
    "value",
    "pairs",
    "data",
    "list",
    "key",
    "value",
    "pair",
    "none",
    "remember",
    "lot",
    "none",
    "values",
    "huge",
    "list",
    "key",
    "value",
    "pair",
    "none",
    "simply",
    "return",
    "kv0",
    "remember",
    "key",
    "value",
    "pair",
    "like",
    "key",
    "value",
    "pair",
    "uh",
    "akash",
    "phone",
    "number",
    "also",
    "put",
    "tuples",
    "also",
    "put",
    "round",
    "bracket",
    "want",
    "even",
    "without",
    "thing",
    "key",
    "value",
    "pair",
    "kv",
    "0",
    "going",
    "give",
    "key",
    "kv1",
    "going",
    "give",
    "value",
    "simply",
    "get",
    "key",
    "key",
    "value",
    "pairs",
    "data",
    "list",
    "element",
    "position",
    "key",
    "value",
    "pair",
    "none",
    "called",
    "pairs",
    "probably",
    "called",
    "keys",
    "see",
    "keys",
    "akash",
    "hth",
    "use",
    "get",
    "index",
    "function",
    "next",
    "step",
    "complete",
    "hash",
    "table",
    "implementation",
    "following",
    "instructions",
    "given",
    "comments",
    "basic",
    "hash",
    "table",
    "class",
    "class",
    "constructor",
    "constructor",
    "takes",
    "object",
    "self",
    "self",
    "going",
    "point",
    "actual",
    "object",
    "actual",
    "hash",
    "table",
    "gets",
    "created",
    "using",
    "class",
    "takes",
    "maximum",
    "size",
    "want",
    "make",
    "hash",
    "table",
    "configurable",
    "always",
    "want",
    "4096",
    "elements",
    "internal",
    "list",
    "may",
    "need",
    "hash",
    "table",
    "store",
    "values",
    "may",
    "need",
    "hash",
    "table",
    "store",
    "fewer",
    "values",
    "going",
    "set",
    "default",
    "value",
    "max",
    "hash",
    "table",
    "size",
    "provide",
    "argument",
    "default",
    "create",
    "list",
    "size",
    "4096",
    "also",
    "want",
    "option",
    "specify",
    "maximum",
    "size",
    "need",
    "create",
    "list",
    "size",
    "max",
    "size",
    "values",
    "set",
    "none",
    "may",
    "tempted",
    "would",
    "wrong",
    "remember",
    "always",
    "use",
    "arguments",
    "function",
    "try",
    "depend",
    "external",
    "value",
    "external",
    "constant",
    "would",
    "wrong",
    "may",
    "also",
    "tempted",
    "data",
    "list",
    "data",
    "list",
    "equals",
    "data",
    "list",
    "already",
    "created",
    "would",
    "also",
    "wrong",
    "using",
    "max",
    "size",
    "also",
    "tying",
    "class",
    "implementation",
    "global",
    "variable",
    "global",
    "variable",
    "list",
    "modified",
    "objects",
    "class",
    "number",
    "hash",
    "tables",
    "create",
    "using",
    "class",
    "use",
    "data",
    "list",
    "want",
    "hash",
    "table",
    "create",
    "maybe",
    "hash",
    "table",
    "phone",
    "numbers",
    "hash",
    "table",
    "addresses",
    "hash",
    "table",
    "something",
    "else",
    "internal",
    "data",
    "list",
    "going",
    "create",
    "copy",
    "original",
    "list",
    "simply",
    "going",
    "point",
    "original",
    "list",
    "want",
    "want",
    "none",
    "want",
    "multiply",
    "max",
    "size",
    "go",
    "correct",
    "way",
    "looking",
    "insert",
    "insert",
    "see",
    "get",
    "index",
    "need",
    "need",
    "pass",
    "key",
    "remember",
    "need",
    "pass",
    "data",
    "list",
    "self",
    "datal",
    "list",
    "right",
    "want",
    "use",
    "data",
    "list",
    "stored",
    "inside",
    "specific",
    "object",
    "class",
    "want",
    "use",
    "global",
    "data",
    "list",
    "something",
    "mistake",
    "often",
    "make",
    "initially",
    "still",
    "made",
    "mistake",
    "certain",
    "global",
    "variables",
    "defined",
    "using",
    "global",
    "variables",
    "inside",
    "class",
    "avoid",
    "anything",
    "want",
    "put",
    "inside",
    "class",
    "object",
    "need",
    "put",
    "inside",
    "self",
    "like",
    "done",
    "access",
    "need",
    "use",
    "self",
    "dot",
    "access",
    "specific",
    "property",
    "element",
    "even",
    "method",
    "self",
    "datal",
    "list",
    "pass",
    "key",
    "data",
    "list",
    "get",
    "index",
    "gives",
    "us",
    "index",
    "get",
    "index",
    "function",
    "defined",
    "earlier",
    "seen",
    "already",
    "want",
    "store",
    "index",
    "inside",
    "list",
    "call",
    "self",
    "datal",
    "list",
    "idx",
    "want",
    "store",
    "key",
    "value",
    "pair",
    "simply",
    "put",
    "key",
    "comma",
    "value",
    "wish",
    "also",
    "put",
    "brackets",
    "necessary",
    "going",
    "insert",
    "key",
    "value",
    "pair",
    "find",
    "value",
    "associated",
    "given",
    "key",
    "first",
    "get",
    "index",
    "key",
    "call",
    "get",
    "index",
    "self",
    "datal",
    "list",
    "key",
    "retrieve",
    "data",
    "stored",
    "index",
    "would",
    "simply",
    "self",
    "data",
    "list",
    "idx",
    "key",
    "value",
    "pair",
    "none",
    "key",
    "value",
    "pair",
    "none",
    "well",
    "nothing",
    "index",
    "return",
    "none",
    "another",
    "option",
    "would",
    "also",
    "maybe",
    "raise",
    "index",
    "error",
    "message",
    "etc",
    "etc",
    "return",
    "good",
    "enough",
    "key",
    "value",
    "pair",
    "get",
    "back",
    "key",
    "value",
    "return",
    "value",
    "keep",
    "mind",
    "simply",
    "return",
    "would",
    "get",
    "error",
    "would",
    "get",
    "exception",
    "may",
    "go",
    "unexplained",
    "whenever",
    "destructuring",
    "trying",
    "get",
    "two",
    "values",
    "tuple",
    "make",
    "sure",
    "tuple",
    "none",
    "especially",
    "case",
    "starting",
    "list",
    "nuns",
    "place",
    "supposed",
    "storing",
    "key",
    "value",
    "pairs",
    "fine",
    "update",
    "going",
    "pretty",
    "much",
    "identical",
    "insert",
    "see",
    "difference",
    "simply",
    "say",
    "get",
    "index",
    "self",
    "data",
    "list",
    "key",
    "simply",
    "store",
    "key",
    "value",
    "pair",
    "inside",
    "simply",
    "store",
    "oops",
    "key",
    "comma",
    "value",
    "inside",
    "self",
    "datal",
    "list",
    "idx",
    "list",
    "straightforward",
    "self",
    "kb",
    "none",
    "get",
    "key",
    "value",
    "pairs",
    "empty",
    "simply",
    "get",
    "kv0",
    "going",
    "give",
    "us",
    "key",
    "kv",
    "see",
    "already",
    "creating",
    "basic",
    "hash",
    "table",
    "max",
    "size",
    "1024",
    "first",
    "thing",
    "verify",
    "length",
    "basic",
    "data",
    "list",
    "1024",
    "go",
    "insert",
    "values",
    "insert",
    "value",
    "akash",
    "insert",
    "key",
    "value",
    "pairs",
    "insert",
    "value",
    "9999",
    "akash",
    "one",
    "key",
    "value",
    "pair",
    "inserting",
    "hon",
    "8888",
    "call",
    "basic",
    "table",
    "insert",
    "call",
    "insert",
    "function",
    "self",
    "point",
    "basic",
    "table",
    "created",
    "calling",
    "insert",
    "specific",
    "basic",
    "table",
    "self",
    "point",
    "basic",
    "table",
    "self",
    "datal",
    "list",
    "become",
    "basic",
    "table",
    "datal",
    "list",
    "remaining",
    "arguments",
    "akash",
    "9999",
    "get",
    "passed",
    "key",
    "value",
    "code",
    "execute",
    "get",
    "index",
    "within",
    "self",
    "data",
    "list",
    "key",
    "akash",
    "within",
    "self",
    "datal",
    "list",
    "basic",
    "table",
    "datal",
    "list",
    "case",
    "add",
    "given",
    "index",
    "computed",
    "store",
    "key",
    "value",
    "pair",
    "akash",
    "phone",
    "number",
    "work",
    "inserting",
    "values",
    "finding",
    "value",
    "insert",
    "two",
    "values",
    "find",
    "value",
    "give",
    "us",
    "value",
    "8888",
    "may",
    "want",
    "maybe",
    "modify",
    "test",
    "case",
    "also",
    "include",
    "test",
    "value",
    "inserted",
    "feel",
    "free",
    "modify",
    "test",
    "cases",
    "add",
    "new",
    "test",
    "cases",
    "checking",
    "one",
    "value",
    "values",
    "next",
    "let",
    "see",
    "update",
    "value",
    "call",
    "basic",
    "table",
    "update",
    "set",
    "7777",
    "suppose",
    "implemented",
    "update",
    "let",
    "moment",
    "return",
    "suppose",
    "implemented",
    "update",
    "called",
    "update",
    "would",
    "get",
    "false",
    "value",
    "get",
    "updated",
    "check",
    "simply",
    "checking",
    "basic",
    "table",
    "find",
    "akash",
    "see",
    "still",
    "value",
    "9999",
    "test",
    "cases",
    "helpful",
    "let",
    "remove",
    "return",
    "okay",
    "value",
    "seems",
    "updated",
    "fine",
    "let",
    "get",
    "list",
    "keys",
    "list",
    "keys",
    "match",
    "true",
    "kv",
    "none",
    "would",
    "get",
    "back",
    "kei",
    "value",
    "pair",
    "would",
    "get",
    "back",
    "nuns",
    "want",
    "test",
    "cases",
    "need",
    "create",
    "test",
    "cases",
    "test",
    "make",
    "sure",
    "implementation",
    "correct",
    "done",
    "would",
    "want",
    "want",
    "run",
    "commit",
    "next",
    "step",
    "something",
    "may",
    "thought",
    "working",
    "assignment",
    "ensure",
    "different",
    "keys",
    "point",
    "index",
    "things",
    "converting",
    "character",
    "number",
    "adding",
    "characters",
    "obviously",
    "words",
    "characters",
    "different",
    "orders",
    "obviously",
    "different",
    "keys",
    "hash",
    "listen",
    "silent",
    "exactly",
    "keys",
    "exactly",
    "hash",
    "instance",
    "check",
    "get",
    "index",
    "listen",
    "get",
    "index",
    "silent",
    "okay",
    "also",
    "need",
    "data",
    "list",
    "let",
    "put",
    "data",
    "list",
    "hash",
    "655",
    "means",
    "insert",
    "value",
    "key",
    "listen",
    "insert",
    "value",
    "key",
    "silent",
    "data",
    "position",
    "get",
    "overwritten",
    "try",
    "basic",
    "table",
    "find",
    "listen",
    "get",
    "value",
    "associated",
    "silent",
    "bad",
    "called",
    "collisions",
    "called",
    "collision",
    "two",
    "keys",
    "colliding",
    "sense",
    "leading",
    "hash",
    "hash",
    "table",
    "implement",
    "ultimately",
    "going",
    "collisions",
    "number",
    "strings",
    "number",
    "keys",
    "possible",
    "infinite",
    "limited",
    "number",
    "positions",
    "indices",
    "table",
    "hashtable",
    "implementation",
    "incomplete",
    "data",
    "loss",
    "handle",
    "collisions",
    "multiple",
    "techniques",
    "handle",
    "collisions",
    "technique",
    "use",
    "assignment",
    "called",
    "linear",
    "probing",
    "works",
    "inserting",
    "new",
    "key",
    "value",
    "pair",
    "target",
    "index",
    "key",
    "occupied",
    "another",
    "key",
    "simply",
    "try",
    "next",
    "index",
    "next",
    "index",
    "also",
    "occupied",
    "another",
    "key",
    "try",
    "next",
    "try",
    "next",
    "try",
    "next",
    "till",
    "find",
    "closest",
    "empty",
    "location",
    "finding",
    "key",
    "value",
    "pair",
    "apply",
    "strategy",
    "inste",
    "searching",
    "empty",
    "location",
    "time",
    "search",
    "location",
    "contains",
    "key",
    "value",
    "pair",
    "matching",
    "key",
    "get",
    "hash",
    "key",
    "want",
    "find",
    "check",
    "position",
    "occupied",
    "another",
    "key",
    "key",
    "try",
    "next",
    "index",
    "try",
    "next",
    "index",
    "try",
    "next",
    "index",
    "till",
    "find",
    "position",
    "occupied",
    "key",
    "value",
    "pair",
    "key",
    "find",
    "empty",
    "position",
    "means",
    "key",
    "exist",
    "exist",
    "somewhere",
    "string",
    "searches",
    "come",
    "updating",
    "key",
    "value",
    "pair",
    "apply",
    "strategy",
    "instead",
    "searching",
    "empty",
    "location",
    "look",
    "location",
    "contains",
    "key",
    "value",
    "pair",
    "matching",
    "key",
    "update",
    "value",
    "handle",
    "collisions",
    "hash",
    "table",
    "handle",
    "collisions",
    "define",
    "function",
    "called",
    "get",
    "valid",
    "index",
    "first",
    "gets",
    "hash",
    "using",
    "get",
    "index",
    "start",
    "searching",
    "data",
    "list",
    "returns",
    "first",
    "index",
    "either",
    "empty",
    "contains",
    "key",
    "value",
    "pair",
    "matching",
    "given",
    "key",
    "addressing",
    "two",
    "requirements",
    "one",
    "shot",
    "get",
    "valid",
    "index",
    "function",
    "insertion",
    "looking",
    "empty",
    "position",
    "find",
    "update",
    "looking",
    "position",
    "occupied",
    "given",
    "key",
    "value",
    "given",
    "key",
    "value",
    "pair",
    "okay",
    "given",
    "key",
    "specifically",
    "get",
    "valid",
    "index",
    "function",
    "let",
    "work",
    "start",
    "index",
    "returned",
    "get",
    "index",
    "true",
    "know",
    "long",
    "may",
    "need",
    "iterate",
    "get",
    "key",
    "value",
    "pair",
    "stored",
    "index",
    "may",
    "simply",
    "question",
    "putting",
    "index",
    "data",
    "list",
    "getting",
    "key",
    "value",
    "pair",
    "key",
    "value",
    "pair",
    "none",
    "means",
    "nothing",
    "index",
    "empty",
    "great",
    "done",
    "simply",
    "return",
    "index",
    "hand",
    "values",
    "get",
    "key",
    "value",
    "key",
    "matches",
    "key",
    "want",
    "store",
    "great",
    "return",
    "index",
    "neither",
    "hold",
    "true",
    "move",
    "index",
    "next",
    "position",
    "move",
    "next",
    "position",
    "possible",
    "may",
    "run",
    "indexes",
    "index",
    "may",
    "become",
    "equal",
    "length",
    "data",
    "list",
    "wrap",
    "around",
    "go",
    "back",
    "zeroth",
    "position",
    "important",
    "part",
    "go",
    "around",
    "list",
    "sense",
    "circular",
    "keep",
    "looping",
    "around",
    "something",
    "needs",
    "stored",
    "last",
    "position",
    "last",
    "position",
    "occupied",
    "move",
    "back",
    "zero",
    "position",
    "check",
    "get",
    "valid",
    "index",
    "defined",
    "correctly",
    "cells",
    "output",
    "true",
    "sample",
    "test",
    "cases",
    "include",
    "test",
    "cases",
    "finally",
    "done",
    "save",
    "work",
    "next",
    "step",
    "incorporate",
    "linear",
    "probing",
    "hash",
    "table",
    "new",
    "class",
    "called",
    "probing",
    "hash",
    "table",
    "need",
    "use",
    "get",
    "index",
    "get",
    "valid",
    "index",
    "pretty",
    "similar",
    "code",
    "let",
    "work",
    "aware",
    "simply",
    "copy",
    "paste",
    "code",
    "run",
    "issues",
    "copy",
    "paste",
    "code",
    "always",
    "make",
    "sure",
    "writing",
    "code",
    "carefully",
    "writing",
    "word",
    "variable",
    "method",
    "argument",
    "code",
    "test",
    "cases",
    "test",
    "probing",
    "hash",
    "table",
    "try",
    "examples",
    "see",
    "works",
    "fine",
    "specifically",
    "taking",
    "example",
    "listen",
    "silent",
    "basic",
    "hashtable",
    "would",
    "key",
    "probing",
    "hash",
    "table",
    "would",
    "different",
    "position",
    "probing",
    "hash",
    "table",
    "different",
    "positions",
    "point",
    "done",
    "assignment",
    "make",
    "submission",
    "run",
    "commit",
    "take",
    "link",
    "make",
    "submission",
    "assignment",
    "page",
    "option",
    "simply",
    "run",
    "jin",
    "submit",
    "python",
    "dsa",
    "assignment",
    "2",
    "make",
    "submission",
    "evaluated",
    "automatically",
    "let",
    "click",
    "evaluated",
    "automatically",
    "scroll",
    "see",
    "get",
    "grade",
    "grade",
    "also",
    "get",
    "comments",
    "question",
    "see",
    "question",
    "numbers",
    "see",
    "question",
    "five",
    "question",
    "four",
    "seems",
    "like",
    "since",
    "implemented",
    "get",
    "index",
    "function",
    "since",
    "implemented",
    "data",
    "list",
    "correctly",
    "question",
    "one",
    "pass",
    "let",
    "see",
    "question",
    "one",
    "quickly",
    "question",
    "one",
    "create",
    "python",
    "list",
    "size",
    "max",
    "table",
    "hash",
    "size",
    "question",
    "two",
    "pass",
    "question",
    "two",
    "get",
    "index",
    "function",
    "question",
    "three",
    "pass",
    "question",
    "three",
    "complete",
    "hashtable",
    "implementation",
    "question",
    "four",
    "fail",
    "get",
    "valid",
    "index",
    "defined",
    "yet",
    "question",
    "five",
    "led",
    "exception",
    "obviously",
    "code",
    "execute",
    "blanks",
    "need",
    "filled",
    "keep",
    "use",
    "feedback",
    "know",
    "exactly",
    "fix",
    "stuck",
    "point",
    "know",
    "go",
    "forum",
    "let",
    "see",
    "forum",
    "forum",
    "subcategory",
    "assignment",
    "2",
    "create",
    "new",
    "topic",
    "want",
    "longer",
    "discussion",
    "simply",
    "go",
    "main",
    "topic",
    "assignment",
    "tables",
    "python",
    "dictionaries",
    "ask",
    "question",
    "already",
    "lot",
    "discussions",
    "going",
    "possible",
    "question",
    "may",
    "already",
    "answered",
    "also",
    "optional",
    "questions",
    "optional",
    "question",
    "implement",
    "python",
    "friendly",
    "interface",
    "hash",
    "table",
    "instead",
    "defining",
    "functions",
    "insert",
    "update",
    "find",
    "define",
    "functions",
    "get",
    "item",
    "set",
    "item",
    "instead",
    "list",
    "define",
    "function",
    "ater",
    "also",
    "also",
    "instead",
    "using",
    "hash",
    "function",
    "instead",
    "using",
    "custom",
    "hash",
    "function",
    "defined",
    "define",
    "use",
    "function",
    "inbuilt",
    "python",
    "called",
    "hash",
    "takes",
    "string",
    "object",
    "returns",
    "number",
    "since",
    "hash",
    "accept",
    "list",
    "take",
    "remainder",
    "manually",
    "case",
    "example",
    "taken",
    "remainder",
    "gotten",
    "back",
    "number",
    "3569",
    "define",
    "hash",
    "table",
    "done",
    "able",
    "use",
    "like",
    "python",
    "dictionary",
    "able",
    "use",
    "exactly",
    "like",
    "create",
    "hash",
    "table",
    "insert",
    "value",
    "use",
    "indexing",
    "notation",
    "insert",
    "value",
    "retrieve",
    "value",
    "use",
    "indexing",
    "notation",
    "get",
    "value",
    "back",
    "compare",
    "number",
    "update",
    "value",
    "simply",
    "use",
    "indexing",
    "notation",
    "get",
    "list",
    "values",
    "simply",
    "call",
    "list",
    "function",
    "also",
    "use",
    "within",
    "loop",
    "also",
    "defined",
    "function",
    "called",
    "repper",
    "str",
    "str",
    "let",
    "python",
    "print",
    "representation",
    "like",
    "simply",
    "run",
    "cell",
    "contains",
    "name",
    "variable",
    "one",
    "bunch",
    "improvements",
    "try",
    "hash",
    "tables",
    "great",
    "exercise",
    "want",
    "improve",
    "python",
    "programming",
    "skills",
    "also",
    "understand",
    "hash",
    "tables",
    "work",
    "complete",
    "four",
    "exercises",
    "pretty",
    "much",
    "question",
    "related",
    "hash",
    "tables",
    "answer",
    "know",
    "know",
    "everything",
    "exercises",
    "may",
    "take",
    "another",
    "30",
    "minutes",
    "45",
    "minutes",
    "completely",
    "worth",
    "time",
    "maybe",
    "spend",
    "aside",
    "set",
    "aside",
    "hours",
    "weekend",
    "work",
    "optional",
    "exercises",
    "one",
    "track",
    "size",
    "hash",
    "table",
    "instead",
    "loop",
    "entire",
    "table",
    "get",
    "number",
    "key",
    "value",
    "pairs",
    "store",
    "length",
    "somewhere",
    "track",
    "size",
    "order",
    "one",
    "one",
    "implement",
    "deletion",
    "implement",
    "deletion",
    "topic",
    "called",
    "technique",
    "called",
    "tombstones",
    "used",
    "use",
    "tombstone",
    "technique",
    "implement",
    "little",
    "code",
    "implement",
    "dynamic",
    "resizing",
    "instead",
    "starting",
    "hash",
    "table",
    "given",
    "size",
    "requiring",
    "user",
    "specify",
    "size",
    "maybe",
    "start",
    "hash",
    "table",
    "let",
    "say",
    "128",
    "elements",
    "double",
    "soon",
    "reach",
    "128",
    "elements",
    "maybe",
    "even",
    "avoid",
    "collisions",
    "may",
    "want",
    "double",
    "soon",
    "reach",
    "64",
    "elements",
    "like",
    "50",
    "capacity",
    "dynamic",
    "resizing",
    "technique",
    "allows",
    "automatically",
    "grow",
    "shrink",
    "data",
    "list",
    "internally",
    "another",
    "technique",
    "collision",
    "resolution",
    "called",
    "separate",
    "chaining",
    "instead",
    "going",
    "next",
    "index",
    "maintain",
    "linked",
    "list",
    "position",
    "key",
    "keys",
    "still",
    "use",
    "position",
    "look",
    "link",
    "list",
    "looking",
    "key",
    "add",
    "new",
    "element",
    "link",
    "list",
    "position",
    "adding",
    "new",
    "key",
    "separate",
    "chaining",
    "explained",
    "youtube",
    "video",
    "look",
    "try",
    "explain",
    "one",
    "final",
    "thing",
    "also",
    "complexity",
    "analysis",
    "talk",
    "average",
    "case",
    "time",
    "complexity",
    "average",
    "good",
    "hashing",
    "function",
    "implemented",
    "improvements",
    "like",
    "dynamic",
    "resizing",
    "average",
    "time",
    "complexity",
    "insert",
    "update",
    "find",
    "delete",
    "order",
    "one",
    "list",
    "course",
    "still",
    "order",
    "n",
    "hand",
    "worst",
    "case",
    "time",
    "complexity",
    "collisions",
    "still",
    "order",
    "something",
    "ponder",
    "upon",
    "average",
    "case",
    "complexity",
    "differ",
    "worst",
    "case",
    "complexity",
    "also",
    "something",
    "discussed",
    "lesson",
    "three",
    "course",
    "talk",
    "quick",
    "sort",
    "see",
    "insert",
    "find",
    "update",
    "average",
    "case",
    "complexity",
    "order",
    "one",
    "worst",
    "case",
    "complexity",
    "order",
    "n",
    "something",
    "look",
    "online",
    "try",
    "see",
    "search",
    "tutorial",
    "learn",
    "happens",
    "complexity",
    "hash",
    "tables",
    "different",
    "binary",
    "search",
    "trees",
    "discussed",
    "binary",
    "search",
    "trees",
    "lot",
    "detail",
    "lesson",
    "two",
    "question",
    "becomes",
    "prefer",
    "using",
    "hash",
    "tables",
    "prefer",
    "using",
    "binary",
    "search",
    "trees",
    "vice",
    "versa",
    "interesting",
    "questions",
    "may",
    "get",
    "asked",
    "questions",
    "interviews",
    "well",
    "help",
    "especially",
    "ponder",
    "upon",
    "questions",
    "even",
    "end",
    "solving",
    "optional",
    "questions",
    "look",
    "complexity",
    "analysis",
    "think",
    "forum",
    "thread",
    "discuss",
    "thoughts",
    "next",
    "review",
    "lecture",
    "video",
    "review",
    "assignment",
    "work",
    "video",
    "ex",
    "execute",
    "jupiter",
    "notebook",
    "complete",
    "assignment",
    "attempt",
    "optional",
    "questions",
    "well",
    "participate",
    "forum",
    "discussions",
    "walkthr",
    "assignment",
    "two",
    "data",
    "structures",
    "algorithms",
    "python",
    "hello",
    "welcome",
    "data",
    "structures",
    "algorithms",
    "python",
    "online",
    "certification",
    "course",
    "conducted",
    "jovian",
    "today",
    "lesson",
    "three",
    "name",
    "akash",
    "ceo",
    "jovian",
    "instructor",
    "course",
    "follow",
    "along",
    "course",
    "complete",
    "four",
    "weekly",
    "assignments",
    "course",
    "project",
    "earn",
    "certificate",
    "accomplishment",
    "course",
    "let",
    "get",
    "started",
    "first",
    "thing",
    "visit",
    "course",
    "website",
    "python",
    "visit",
    "python",
    "bring",
    "course",
    "website",
    "find",
    "information",
    "material",
    "course",
    "check",
    "lessons",
    "1",
    "two",
    "assignments",
    "1",
    "two",
    "still",
    "open",
    "submission",
    "let",
    "open",
    "lesson",
    "three",
    "topic",
    "today",
    "sorting",
    "algorithms",
    "divide",
    "conquer",
    "watch",
    "video",
    "recording",
    "lesson",
    "also",
    "catch",
    "version",
    "hindi",
    "code",
    "used",
    "lesson",
    "provided",
    "let",
    "open",
    "link",
    "sorting",
    "divide",
    "conquer",
    "code",
    "present",
    "looking",
    "tutorial",
    "code",
    "lesson",
    "scroll",
    "see",
    "code",
    "execute",
    "code",
    "two",
    "options",
    "either",
    "execute",
    "code",
    "online",
    "using",
    "free",
    "online",
    "resources",
    "recommend",
    "download",
    "run",
    "computer",
    "lo",
    "locally",
    "instructions",
    "given",
    "going",
    "use",
    "first",
    "one",
    "click",
    "run",
    "button",
    "top",
    "page",
    "select",
    "run",
    "binder",
    "let",
    "us",
    "scroll",
    "let",
    "us",
    "click",
    "run",
    "button",
    "click",
    "run",
    "binder",
    "open",
    "interface",
    "like",
    "looking",
    "jupyter",
    "notebook",
    "jupyter",
    "notebook",
    "interactive",
    "programming",
    "environment",
    "write",
    "code",
    "look",
    "results",
    "also",
    "write",
    "explanations",
    "provided",
    "jupyter",
    "notebook",
    "setup",
    "install",
    "anything",
    "code",
    "execute",
    "running",
    "cloud",
    "also",
    "download",
    "run",
    "computer",
    "following",
    "instructions",
    "first",
    "thing",
    "click",
    "kernel",
    "menu",
    "click",
    "restart",
    "clear",
    "output",
    "remove",
    "outputs",
    "previous",
    "executions",
    "code",
    "execute",
    "code",
    "see",
    "outputs",
    "fresh",
    "also",
    "going",
    "zoom",
    "little",
    "bit",
    "look",
    "code",
    "let",
    "get",
    "started",
    "coding",
    "focus",
    "practical",
    "course",
    "talking",
    "different",
    "data",
    "structures",
    "algorithms",
    "topic",
    "today",
    "sorting",
    "algorithms",
    "divide",
    "conquer",
    "algorithms",
    "python",
    "every",
    "lecture",
    "focus",
    "specific",
    "problem",
    "notebook",
    "tutorial",
    "focus",
    "problem",
    "looking",
    "let",
    "read",
    "question",
    "working",
    "new",
    "feature",
    "jovian",
    "called",
    "top",
    "notebooks",
    "week",
    "write",
    "function",
    "sort",
    "list",
    "notebooks",
    "decreasing",
    "order",
    "likes",
    "keep",
    "mind",
    "millions",
    "notebooks",
    "created",
    "every",
    "every",
    "week",
    "function",
    "needs",
    "efficient",
    "possible",
    "key",
    "point",
    "classical",
    "problem",
    "computing",
    "problem",
    "sorting",
    "list",
    "objects",
    "comes",
    "computer",
    "science",
    "software",
    "development",
    "important",
    "understand",
    "common",
    "approaches",
    "sorting",
    "work",
    "tradeoffs",
    "use",
    "solve",
    "problem",
    "solve",
    "simplified",
    "version",
    "problem",
    "quite",
    "simple",
    "state",
    "write",
    "program",
    "sort",
    "list",
    "numbers",
    "sorting",
    "usually",
    "refers",
    "sorting",
    "ascending",
    "order",
    "unless",
    "specified",
    "otherwise",
    "question",
    "today",
    "write",
    "program",
    "sort",
    "list",
    "numbers",
    "expand",
    "upon",
    "answer",
    "original",
    "question",
    "well",
    "method",
    "following",
    "throughout",
    "course",
    "continue",
    "follow",
    "systematic",
    "strategy",
    "solving",
    "programming",
    "problems",
    "step",
    "one",
    "state",
    "problem",
    "clearly",
    "identify",
    "input",
    "output",
    "formats",
    "step",
    "two",
    "come",
    "example",
    "inputs",
    "outputs",
    "try",
    "cover",
    "edge",
    "cases",
    "step",
    "three",
    "come",
    "correct",
    "solution",
    "problem",
    "stated",
    "plain",
    "english",
    "step",
    "four",
    "implement",
    "solution",
    "test",
    "using",
    "example",
    "inputs",
    "important",
    "implement",
    "simple",
    "solution",
    "need",
    "correct",
    "solution",
    "first",
    "efficient",
    "one",
    "implement",
    "test",
    "analyze",
    "complexity",
    "identify",
    "inefficiencies",
    "apply",
    "right",
    "right",
    "techniques",
    "overcome",
    "inefficiency",
    "knowledge",
    "right",
    "data",
    "structures",
    "algorithms",
    "comes",
    "picture",
    "apply",
    "new",
    "technique",
    "state",
    "solution",
    "implement",
    "analyze",
    "complexity",
    "repeat",
    "necessary",
    "strategy",
    "follow",
    "today",
    "well",
    "step",
    "one",
    "state",
    "problem",
    "clearly",
    "identify",
    "input",
    "output",
    "formats",
    "problem",
    "stated",
    "clearly",
    "enough",
    "us",
    "need",
    "write",
    "function",
    "sort",
    "list",
    "numbers",
    "ascending",
    "increasing",
    "order",
    "input",
    "input",
    "single",
    "argument",
    "called",
    "nums",
    "list",
    "numbers",
    "instance",
    "list",
    "numbers",
    "see",
    "specific",
    "order",
    "output",
    "sorted",
    "version",
    "input",
    "list",
    "numbers",
    "sorted",
    "order",
    "based",
    "two",
    "write",
    "signature",
    "function",
    "function",
    "called",
    "sort",
    "something",
    "else",
    "accept",
    "one",
    "input",
    "right",
    "written",
    "code",
    "put",
    "pass",
    "running",
    "code",
    "using",
    "shift",
    "plus",
    "enter",
    "shortcut",
    "also",
    "use",
    "run",
    "button",
    "toolbar",
    "either",
    "run",
    "shift",
    "plus",
    "enter",
    "great",
    "thing",
    "jupiter",
    "notebooks",
    "add",
    "code",
    "cells",
    "anywhere",
    "test",
    "anything",
    "want",
    "instance",
    "want",
    "insert",
    "code",
    "cell",
    "click",
    "insert",
    "cell",
    "menu",
    "option",
    "click",
    "outside",
    "cell",
    "left",
    "press",
    "b",
    "button",
    "write",
    "code",
    "run",
    "please",
    "feel",
    "free",
    "experiment",
    "notebook",
    "go",
    "along",
    "step",
    "two",
    "come",
    "example",
    "inputs",
    "outputs",
    "important",
    "need",
    "think",
    "different",
    "scenarios",
    "may",
    "want",
    "test",
    "function",
    "put",
    "production",
    "catch",
    "errors",
    "early",
    "thinking",
    "scenarios",
    "help",
    "identify",
    "special",
    "cases",
    "need",
    "handle",
    "code",
    "easier",
    "right",
    "writing",
    "code",
    "may",
    "lead",
    "bugs",
    "scenarios",
    "able",
    "come",
    "may",
    "continue",
    "increase",
    "list",
    "first",
    "one",
    "list",
    "numbers",
    "random",
    "order",
    "numbers",
    "random",
    "order",
    "try",
    "slightly",
    "smaller",
    "list",
    "larger",
    "lists",
    "second",
    "list",
    "already",
    "sorted",
    "need",
    "ensure",
    "already",
    "sorted",
    "list",
    "become",
    "unsorted",
    "third",
    "list",
    "sorted",
    "descending",
    "order",
    "may",
    "want",
    "check",
    "see",
    "need",
    "handle",
    "case",
    "separately",
    "somehow",
    "list",
    "containing",
    "repeating",
    "elements",
    "something",
    "may",
    "thought",
    "question",
    "never",
    "said",
    "numbers",
    "unique",
    "could",
    "repeating",
    "elements",
    "empty",
    "list",
    "interesting",
    "input",
    "output",
    "also",
    "empty",
    "list",
    "list",
    "containing",
    "one",
    "element",
    "list",
    "containing",
    "one",
    "element",
    "repeated",
    "many",
    "many",
    "times",
    "even",
    "really",
    "long",
    "list",
    "u",
    "something",
    "may",
    "want",
    "test",
    "want",
    "algorithm",
    "efficient",
    "end",
    "long",
    "list",
    "may",
    "help",
    "us",
    "evaluate",
    "efficiency",
    "empirically",
    "scenarios",
    "need",
    "create",
    "test",
    "cases",
    "scenarios",
    "test",
    "cases",
    "involve",
    "creating",
    "input",
    "output",
    "instance",
    "input",
    "num0",
    "could",
    "list",
    "431",
    "expected",
    "output",
    "let",
    "call",
    "output",
    "zero",
    "would",
    "13",
    "4",
    "good",
    "way",
    "put",
    "create",
    "test",
    "case",
    "use",
    "later",
    "testing",
    "put",
    "tests",
    "particular",
    "structure",
    "create",
    "dictionary",
    "creating",
    "dictionary",
    "like",
    "help",
    "us",
    "automate",
    "testing",
    "test",
    "cases",
    "single",
    "helper",
    "function",
    "going",
    "test",
    "case",
    "create",
    "dictionary",
    "two",
    "keys",
    "first",
    "key",
    "called",
    "input",
    "second",
    "key",
    "called",
    "output",
    "inputs",
    "arguments",
    "go",
    "function",
    "remember",
    "one",
    "argument",
    "one",
    "key",
    "key",
    "nums",
    "key",
    "nums",
    "input",
    "value",
    "test",
    "case",
    "output",
    "simply",
    "contain",
    "output",
    "returned",
    "function",
    "set",
    "test",
    "cases",
    "test",
    "zero",
    "list",
    "numbers",
    "random",
    "order",
    "test",
    "one",
    "also",
    "another",
    "list",
    "numbers",
    "random",
    "order",
    "see",
    "specific",
    "order",
    "list",
    "already",
    "sorted",
    "output",
    "obviously",
    "random",
    "ordered",
    "list",
    "output",
    "numbers",
    "sorted",
    "order",
    "list",
    "sorted",
    "descending",
    "order",
    "output",
    "list",
    "increasing",
    "order",
    "list",
    "containing",
    "repeating",
    "elements",
    "see",
    "numbers",
    "1",
    "2",
    "6",
    "7",
    "12",
    "repeat",
    "empty",
    "list",
    "list",
    "containing",
    "one",
    "element",
    "list",
    "containing",
    "one",
    "element",
    "repeated",
    "many",
    "many",
    "times",
    "final",
    "test",
    "case",
    "create",
    "really",
    "long",
    "list",
    "start",
    "sorted",
    "list",
    "created",
    "using",
    "range",
    "function",
    "shuffle",
    "create",
    "put",
    "otherwise",
    "may",
    "spend",
    "lot",
    "time",
    "creating",
    "list",
    "writing",
    "sorted",
    "version",
    "much",
    "work",
    "always",
    "use",
    "computer",
    "always",
    "use",
    "helper",
    "functions",
    "whenever",
    "even",
    "create",
    "test",
    "cases",
    "use",
    "range",
    "function",
    "range",
    "function",
    "takes",
    "either",
    "single",
    "number",
    "two",
    "numbers",
    "something",
    "like",
    "range",
    "2",
    "10",
    "range",
    "10",
    "look",
    "way",
    "prints",
    "range",
    "0",
    "10",
    "actually",
    "want",
    "see",
    "couple",
    "ways",
    "list",
    "range",
    "10",
    "gets",
    "converted",
    "list",
    "use",
    "loop",
    "put",
    "x",
    "range",
    "10",
    "print",
    "x",
    "see",
    "contains",
    "numbers",
    "0",
    "9",
    "important",
    "range",
    "include",
    "end",
    "element",
    "range",
    "okay",
    "keep",
    "mind",
    "difference",
    "range",
    "list",
    "list",
    "contains",
    "10",
    "numbers",
    "together",
    "range",
    "internally",
    "simply",
    "maintains",
    "counter",
    "use",
    "range",
    "loop",
    "simply",
    "starts",
    "counter",
    "zero",
    "increments",
    "starts",
    "counter",
    "starting",
    "value",
    "2",
    "10",
    "starts",
    "counter",
    "two",
    "increases",
    "end",
    "value",
    "minus",
    "one",
    "use",
    "much",
    "space",
    "list",
    "simply",
    "uses",
    "one",
    "single",
    "variable",
    "internally",
    "efficient",
    "case",
    "right",
    "need",
    "lists",
    "create",
    "list",
    "numbers",
    "0",
    "9",
    "list",
    "list",
    "also",
    "going",
    "0",
    "list",
    "sorted",
    "shuffle",
    "inner",
    "list",
    "import",
    "random",
    "module",
    "python",
    "call",
    "random",
    "shuffle",
    "call",
    "random",
    "shuffle",
    "list",
    "shuffles",
    "first",
    "list",
    "list",
    "input",
    "nums",
    "list",
    "sorted",
    "list",
    "output",
    "even",
    "check",
    "list",
    "actually",
    "shuffled",
    "maybe",
    "looking",
    "first",
    "10",
    "elements",
    "see",
    "shuffled",
    "numbers",
    "hand",
    "check",
    "list",
    "see",
    "order",
    "test",
    "cases",
    "important",
    "create",
    "good",
    "test",
    "cases",
    "even",
    "interviews",
    "start",
    "coding",
    "even",
    "suggest",
    "solution",
    "try",
    "list",
    "test",
    "cases",
    "either",
    "verbally",
    "interviewer",
    "coding",
    "assessment",
    "may",
    "create",
    "block",
    "comments",
    "top",
    "start",
    "listing",
    "test",
    "cases",
    "top",
    "create",
    "proper",
    "test",
    "case",
    "dictionaries",
    "like",
    "takes",
    "minutes",
    "totally",
    "worth",
    "test",
    "algorithms",
    "easily",
    "finally",
    "take",
    "test",
    "cases",
    "test0",
    "test",
    "8",
    "put",
    "single",
    "list",
    "called",
    "tests",
    "great",
    "made",
    "good",
    "progress",
    "far",
    "next",
    "let",
    "come",
    "simple",
    "correct",
    "solution",
    "stated",
    "plain",
    "english",
    "coming",
    "correct",
    "solution",
    "pretty",
    "straightforward",
    "list",
    "numbers",
    "iterate",
    "list",
    "let",
    "grab",
    "list",
    "numbers",
    "something",
    "look",
    "go",
    "list",
    "numbers",
    "iterate",
    "list",
    "numbers",
    "starting",
    "left",
    "start",
    "left",
    "compare",
    "number",
    "number",
    "follows",
    "compare",
    "99",
    "10",
    "99",
    "greater",
    "10",
    "say",
    "sure",
    "99",
    "appear",
    "10",
    "final",
    "sorted",
    "array",
    "sorted",
    "array",
    "default",
    "means",
    "increasing",
    "order",
    "numbers",
    "right",
    "solving",
    "first",
    "simply",
    "swap",
    "99",
    "10",
    "know",
    "10",
    "appear",
    "99",
    "99",
    "appear",
    "10",
    "continue",
    "swap",
    "move",
    "next",
    "position",
    "compare",
    "99",
    "next",
    "element",
    "9",
    "turns",
    "higher",
    "well",
    "swap",
    "keep",
    "going",
    "iterate",
    "list",
    "element",
    "compare",
    "number",
    "number",
    "follows",
    "number",
    "greater",
    "one",
    "follows",
    "swap",
    "two",
    "elements",
    "alone",
    "probably",
    "enough",
    "compile",
    "entire",
    "list",
    "entire",
    "sorted",
    "list",
    "99",
    "way",
    "end",
    "end",
    "follow",
    "process",
    "rest",
    "list",
    "still",
    "sorted",
    "repeat",
    "steps",
    "1",
    "2",
    "3",
    "start",
    "left",
    "start",
    "comparing",
    "10",
    "9",
    "10",
    "8",
    "keep",
    "swapping",
    "elements",
    "go",
    "forward",
    "claim",
    "may",
    "need",
    "repeat",
    "steps",
    "1",
    "3",
    "n",
    "minus",
    "one",
    "times",
    "ensure",
    "array",
    "sorted",
    "guess",
    "hint",
    "one",
    "iteration",
    "process",
    "largest",
    "number",
    "list",
    "reach",
    "end",
    "means",
    "time",
    "putting",
    "one",
    "largest",
    "numbers",
    "end",
    "need",
    "around",
    "end",
    "steps",
    "animation",
    "showing",
    "thing",
    "compare",
    "six",
    "five",
    "switch",
    "compare",
    "six",
    "three",
    "switch",
    "compare",
    "6",
    "one",
    "switch",
    "compare",
    "6",
    "8",
    "switch",
    "order",
    "next",
    "compare",
    "eight",
    "seven",
    "switch",
    "next",
    "compare",
    "eight",
    "two",
    "switch",
    "finally",
    "con",
    "compare",
    "eight",
    "four",
    "switch",
    "way",
    "largest",
    "number",
    "eight",
    "reached",
    "end",
    "froze",
    "freeze",
    "position",
    "start",
    "beginning",
    "see",
    "time",
    "next",
    "number",
    "seven",
    "end",
    "next",
    "time",
    "number",
    "six",
    "end",
    "next",
    "time",
    "number",
    "five",
    "end",
    "n",
    "repetitions",
    "process",
    "comparison",
    "left",
    "right",
    "sorted",
    "array",
    "approach",
    "called",
    "bubble",
    "sort",
    "causes",
    "smaller",
    "elements",
    "bubble",
    "top",
    "beginning",
    "see",
    "numbers",
    "1",
    "three",
    "slowly",
    "bubble",
    "top",
    "causes",
    "larger",
    "numbers",
    "like",
    "eight",
    "seven",
    "sink",
    "bottom",
    "watch",
    "entire",
    "animation",
    "get",
    "full",
    "sense",
    "bubble",
    "sort",
    "works",
    "also",
    "really",
    "help",
    "take",
    "example",
    "paper",
    "work",
    "step",
    "step",
    "especially",
    "sorting",
    "algorithms",
    "really",
    "helps",
    "okay",
    "come",
    "correct",
    "solution",
    "let",
    "implement",
    "let",
    "test",
    "using",
    "example",
    "implementation",
    "also",
    "pretty",
    "straightforward",
    "bubble",
    "sort",
    "function",
    "def",
    "bubble",
    "sort",
    "takes",
    "list",
    "numbers",
    "may",
    "want",
    "modify",
    "list",
    "numbers",
    "place",
    "test",
    "cases",
    "reusable",
    "avoid",
    "modifying",
    "test",
    "inputs",
    "going",
    "create",
    "copy",
    "list",
    "avoid",
    "changing",
    "way",
    "create",
    "copy",
    "simply",
    "call",
    "list",
    "function",
    "list",
    "input",
    "set",
    "replacing",
    "nums",
    "copy",
    "nums",
    "depending",
    "particular",
    "use",
    "case",
    "may",
    "necessary",
    "something",
    "actually",
    "check",
    "coding",
    "assessment",
    "interviewer",
    "talking",
    "interviewer",
    "check",
    "want",
    "array",
    "sorted",
    "place",
    "want",
    "new",
    "array",
    "created",
    "want",
    "okay",
    "sorting",
    "place",
    "probably",
    "need",
    "may",
    "still",
    "want",
    "keep",
    "otherwise",
    "may",
    "end",
    "modifying",
    "test",
    "cases",
    "unintentionally",
    "may",
    "lead",
    "problems",
    "always",
    "good",
    "create",
    "copy",
    "input",
    "rather",
    "modifying",
    "place",
    "okay",
    "let",
    "come",
    "steps",
    "1",
    "2",
    "three",
    "see",
    "step",
    "four",
    "outermost",
    "step",
    "really",
    "iterate",
    "array",
    "go",
    "take",
    "check",
    "range",
    "len",
    "nums",
    "minus",
    "one",
    "number",
    "elements",
    "array",
    "n",
    "n",
    "obtained",
    "using",
    "len",
    "nums",
    "want",
    "go",
    "indexes",
    "0o",
    "n",
    "2",
    "total",
    "number",
    "indices",
    "0",
    "nus1",
    "go",
    "nus1",
    "last",
    "element",
    "element",
    "compare",
    "okay",
    "keep",
    "mind",
    "want",
    "run",
    "iteration",
    "till",
    "pointer",
    "comes",
    "point",
    "till",
    "last",
    "element",
    "check",
    "put",
    "range",
    "0",
    "len",
    "nums",
    "minus",
    "one",
    "highest",
    "value",
    "take",
    "len",
    "nums",
    "minus",
    "2",
    "next",
    "compare",
    "nums",
    "nums",
    "1",
    "compare",
    "number",
    "element",
    "comes",
    "greater",
    "means",
    "two",
    "order",
    "simply",
    "swap",
    "set",
    "nums",
    "comma",
    "nums",
    "1",
    "nums",
    "1",
    "comma",
    "nums",
    "interesting",
    "way",
    "sorting",
    "c",
    "java",
    "would",
    "write",
    "three",
    "four",
    "steps",
    "swap",
    "numbers",
    "python",
    "really",
    "simple",
    "first",
    "say",
    "xy",
    "let",
    "say",
    "saying",
    "x",
    "comma",
    "2a",
    "3",
    "see",
    "values",
    "2",
    "three",
    "simply",
    "write",
    "x",
    "yx",
    "happens",
    "value",
    "gets",
    "placed",
    "x",
    "value",
    "x",
    "gets",
    "placed",
    "single",
    "step",
    "swapping",
    "two",
    "numbers",
    "go",
    "swap",
    "two",
    "elements",
    "exactly",
    "showing",
    "swapping",
    "two",
    "elements",
    "next",
    "repeat",
    "left",
    "penultimate",
    "element",
    "way",
    "pushed",
    "largest",
    "element",
    "end",
    "need",
    "repeat",
    "process",
    "n",
    "minus",
    "one",
    "times",
    "time",
    "pushing",
    "one",
    "largest",
    "elements",
    "end",
    "n",
    "minus",
    "one",
    "repetitions",
    "three",
    "steps",
    "end",
    "sorted",
    "list",
    "finally",
    "return",
    "sorted",
    "list",
    "let",
    "test",
    "example",
    "way",
    "make",
    "sense",
    "simple",
    "way",
    "debug",
    "add",
    "print",
    "statements",
    "add",
    "print",
    "statement",
    "maybe",
    "print",
    "value",
    "used",
    "underscore",
    "actually",
    "use",
    "value",
    "let",
    "say",
    "wanted",
    "use",
    "value",
    "print",
    "iteration",
    "j",
    "inside",
    "print",
    "value",
    "also",
    "print",
    "value",
    "nums",
    "also",
    "print",
    "value",
    "nums",
    "1",
    "top",
    "also",
    "print",
    "nums",
    "add",
    "print",
    "statements",
    "execute",
    "algorithm",
    "able",
    "see",
    "exactly",
    "happening",
    "inside",
    "iteration",
    "great",
    "way",
    "debug",
    "code",
    "facing",
    "issues",
    "also",
    "understand",
    "code",
    "case",
    "wo",
    "need",
    "going",
    "comment",
    "let",
    "test",
    "get",
    "test",
    "zero",
    "get",
    "nums",
    "input",
    "get",
    "output",
    "print",
    "input",
    "expected",
    "output",
    "finally",
    "calculate",
    "result",
    "passing",
    "num",
    "zero",
    "bubble",
    "sort",
    "printing",
    "actual",
    "output",
    "finally",
    "whether",
    "two",
    "match",
    "see",
    "input",
    "unsorted",
    "list",
    "expected",
    "output",
    "sorted",
    "version",
    "got",
    "fact",
    "perfect",
    "match",
    "implemented",
    "first",
    "sorting",
    "algorithm",
    "pretty",
    "straightforward",
    "lines",
    "code",
    "exercise",
    "try",
    "implement",
    "memory",
    "uh",
    "write",
    "plain",
    "english",
    "first",
    "try",
    "implement",
    "good",
    "coding",
    "practice",
    "also",
    "evaluate",
    "test",
    "cases",
    "remember",
    "created",
    "nine",
    "test",
    "cases",
    "ev",
    "help",
    "evaluate",
    "test",
    "cases",
    "given",
    "helper",
    "function",
    "called",
    "evaluate",
    "test",
    "cases",
    "part",
    "jovian",
    "library",
    "install",
    "jovian",
    "library",
    "pip",
    "install",
    "jovian",
    "python",
    "dsa",
    "python",
    "dsa",
    "name",
    "course",
    "also",
    "module",
    "helper",
    "functions",
    "course",
    "import",
    "evaluate",
    "test",
    "cases",
    "evaluate",
    "test",
    "cases",
    "simply",
    "goes",
    "list",
    "test",
    "cases",
    "pulls",
    "inputs",
    "passes",
    "arguments",
    "function",
    "provided",
    "bubble",
    "sort",
    "gets",
    "outputs",
    "compares",
    "outputs",
    "also",
    "prints",
    "information",
    "like",
    "input",
    "expected",
    "output",
    "actual",
    "output",
    "whether",
    "match",
    "let",
    "check",
    "see",
    "test",
    "case",
    "zero",
    "work",
    "tested",
    "larger",
    "list",
    "including",
    "negative",
    "numbers",
    "worked",
    "well",
    "see",
    "test",
    "result",
    "passed",
    "another",
    "list",
    "seems",
    "work",
    "fine",
    "already",
    "sorted",
    "one",
    "sorted",
    "decreasing",
    "order",
    "works",
    "one",
    "repeating",
    "numbers",
    "works",
    "two",
    "empty",
    "list",
    "works",
    "single",
    "element",
    "works",
    "works",
    "element",
    "repeated",
    "finally",
    "final",
    "test",
    "case",
    "elements",
    "remember",
    "see",
    "expected",
    "output",
    "actual",
    "output",
    "successfully",
    "sorted",
    "elements",
    "really",
    "power",
    "programming",
    "without",
    "look",
    "numbers",
    "written",
    "four",
    "five",
    "lines",
    "code",
    "sorted",
    "elements",
    "test",
    "cases",
    "passed",
    "although",
    "look",
    "took",
    "15",
    "seconds",
    "sorting",
    "elements",
    "maybe",
    "maybe",
    "bad",
    "looking",
    "probably",
    "millions",
    "notebooks",
    "every",
    "week",
    "jo",
    "want",
    "faster",
    "sorting",
    "algorithm",
    "okay",
    "improve",
    "algorithm",
    "need",
    "understand",
    "algorithm",
    "complexity",
    "identify",
    "inefficiencies",
    "core",
    "operation",
    "bubble",
    "sort",
    "look",
    "code",
    "operation",
    "comparison",
    "comparing",
    "number",
    "next",
    "number",
    "swapping",
    "comparison",
    "almost",
    "always",
    "happens",
    "swapping",
    "happen",
    "nearly",
    "often",
    "want",
    "find",
    "time",
    "complexity",
    "want",
    "upper",
    "bound",
    "worst",
    "case",
    "time",
    "complexity",
    "assume",
    "roughly",
    "every",
    "comparison",
    "also",
    "leads",
    "swap",
    "worst",
    "case",
    "count",
    "number",
    "comparisons",
    "function",
    "input",
    "size",
    "size",
    "list",
    "given",
    "input",
    "give",
    "us",
    "idea",
    "time",
    "complexity",
    "okay",
    "see",
    "two",
    "loops",
    "length",
    "loop",
    "n",
    "minus",
    "one",
    "inside",
    "inner",
    "loop",
    "comparison",
    "total",
    "number",
    "comparisons",
    "n",
    "minus1",
    "n",
    "n",
    "n",
    "2",
    "n",
    "1",
    "expressing",
    "big",
    "notation",
    "get",
    "rough",
    "idea",
    "number",
    "comparisons",
    "number",
    "operations",
    "algorithm",
    "grow",
    "grows",
    "time",
    "ignore",
    "lower",
    "order",
    "terms",
    "like",
    "2",
    "n",
    "1",
    "conclude",
    "time",
    "complexity",
    "bubble",
    "sort",
    "order",
    "n",
    "square",
    "also",
    "known",
    "quadratic",
    "complexity",
    "verify",
    "bubble",
    "sort",
    "requires",
    "order",
    "one",
    "additional",
    "space",
    "exercise",
    "quick",
    "hint",
    "see",
    "allocating",
    "new",
    "lists",
    "create",
    "copy",
    "list",
    "let",
    "count",
    "apart",
    "additional",
    "space",
    "required",
    "allocating",
    "new",
    "variables",
    "creating",
    "range",
    "remember",
    "mentioned",
    "range",
    "simple",
    "simply",
    "contains",
    "single",
    "variable",
    "inside",
    "keeps",
    "incrementing",
    "loop",
    "two",
    "ranges",
    "maybe",
    "two",
    "variables",
    "assigned",
    "constant",
    "irrespective",
    "size",
    "input",
    "bubble",
    "sort",
    "requires",
    "order",
    "one",
    "additional",
    "space",
    "may",
    "asked",
    "space",
    "complexity",
    "slightly",
    "tricky",
    "thing",
    "sometimes",
    "strictly",
    "speaking",
    "space",
    "complexity",
    "also",
    "includes",
    "size",
    "input",
    "store",
    "n",
    "numbers",
    "n",
    "elements",
    "need",
    "n",
    "spaces",
    "memory",
    "space",
    "complexity",
    "bubble",
    "sword",
    "sense",
    "order",
    "n",
    "something",
    "check",
    "interviewer",
    "asking",
    "space",
    "complexity",
    "ask",
    "want",
    "know",
    "additional",
    "space",
    "required",
    "overall",
    "space",
    "complexity",
    "order",
    "need",
    "store",
    "actual",
    "input",
    "list",
    "somewhere",
    "hand",
    "amount",
    "additional",
    "space",
    "required",
    "order",
    "one",
    "constant",
    "factor",
    "independent",
    "size",
    "list",
    "bubble",
    "sort",
    "works",
    "analyzing",
    "order",
    "square",
    "complexity",
    "keeping",
    "mind",
    "list",
    "numbers",
    "takes",
    "12",
    "seconds",
    "n",
    "n",
    "square",
    "multiplied",
    "constant",
    "12",
    "seconds",
    "list",
    "elements",
    "would",
    "10",
    "n",
    "whole",
    "square",
    "100",
    "times",
    "amount",
    "time",
    "would",
    "take",
    "sort",
    "means",
    "would",
    "take",
    "20",
    "minutes",
    "sort",
    "numbers",
    "would",
    "say",
    "bit",
    "inefficient",
    "list",
    "million",
    "numbers",
    "would",
    "take",
    "close",
    "2",
    "days",
    "sorted",
    "python",
    "maybe",
    "might",
    "four",
    "five",
    "times",
    "faster",
    "moment",
    "go",
    "million",
    "10",
    "million",
    "actually",
    "end",
    "taking",
    "year",
    "bad",
    "n",
    "square",
    "quadratic",
    "complexity",
    "something",
    "would",
    "like",
    "away",
    "grows",
    "fast",
    "soon",
    "hit",
    "maybe",
    "elements",
    "starts",
    "taking",
    "longer",
    "seconds",
    "minutes",
    "days",
    "point",
    "longer",
    "use",
    "particular",
    "algorithm",
    "need",
    "optimize",
    "bubble",
    "sort",
    "inefficiency",
    "bubble",
    "sort",
    "comes",
    "fact",
    "shifting",
    "elements",
    "one",
    "position",
    "time",
    "time",
    "go",
    "list",
    "capture",
    "information",
    "list",
    "simply",
    "moving",
    "one",
    "element",
    "left",
    "right",
    "speak",
    "time",
    "moving",
    "one",
    "time",
    "swaps",
    "rather",
    "would",
    "nice",
    "place",
    "elements",
    "directly",
    "maybe",
    "positions",
    "ahead",
    "look",
    "optimized",
    "algorithms",
    "another",
    "common",
    "algorithm",
    "used",
    "called",
    "insertion",
    "sort",
    "code",
    "insertion",
    "sort",
    "look",
    "code",
    "insertion",
    "sort",
    "uh",
    "example",
    "see",
    "works",
    "look",
    "insertion",
    "sort",
    "lot",
    "detail",
    "roughly",
    "arrange",
    "cards",
    "hand",
    "starting",
    "move",
    "cards",
    "around",
    "maybe",
    "left",
    "edge",
    "sorted",
    "cards",
    "right",
    "edge",
    "unsorted",
    "cards",
    "keep",
    "moving",
    "new",
    "cards",
    "sorted",
    "positions",
    "works",
    "exercise",
    "go",
    "function",
    "read",
    "source",
    "code",
    "describe",
    "algorithm",
    "plain",
    "english",
    "reading",
    "source",
    "code",
    "essential",
    "skill",
    "software",
    "development",
    "something",
    "work",
    "whether",
    "software",
    "development",
    "data",
    "science",
    "maybe",
    "comments",
    "code",
    "documentation",
    "person",
    "written",
    "code",
    "available",
    "left",
    "company",
    "open",
    "source",
    "library",
    "cases",
    "read",
    "understand",
    "code",
    "read",
    "describe",
    "insertion",
    "sort",
    "algorithm",
    "plain",
    "english",
    "look",
    "online",
    "see",
    "matches",
    "written",
    "second",
    "also",
    "determine",
    "time",
    "space",
    "complexity",
    "insertion",
    "sord",
    "see",
    "better",
    "bubble",
    "sord",
    "explain",
    "couple",
    "exercises",
    "bubble",
    "sword",
    "insertion",
    "sord",
    "continue",
    "want",
    "recall",
    "jupiter",
    "notebook",
    "running",
    "online",
    "platform",
    "hub",
    "binder",
    "ml",
    "since",
    "free",
    "uh",
    "shut",
    "time",
    "want",
    "capture",
    "snapshot",
    "work",
    "regular",
    "intervals",
    "use",
    "jovian",
    "library",
    "install",
    "jovian",
    "library",
    "using",
    "p",
    "install",
    "jovian",
    "import",
    "jovian",
    "run",
    "commit",
    "run",
    "commit",
    "captures",
    "snapshot",
    "jupyter",
    "notebook",
    "puts",
    "jovian",
    "profile",
    "profile",
    "run",
    "able",
    "resume",
    "work",
    "clicking",
    "run",
    "button",
    "page",
    "anytime",
    "notebook",
    "go",
    "profile",
    "click",
    "jovian",
    "profile",
    "click",
    "home",
    "check",
    "either",
    "overview",
    "notebooks",
    "tab",
    "able",
    "find",
    "notebook",
    "like",
    "go",
    "okay",
    "coming",
    "back",
    "step",
    "six",
    "want",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "algorithm",
    "perform",
    "slorting",
    "efficiently",
    "apply",
    "strategy",
    "called",
    "divide",
    "conquer",
    "divide",
    "conquer",
    "common",
    "strategy",
    "used",
    "across",
    "board",
    "many",
    "different",
    "kinds",
    "algorithms",
    "general",
    "steps",
    "applied",
    "different",
    "different",
    "ways",
    "across",
    "different",
    "problems",
    "step",
    "one",
    "divide",
    "inputs",
    "two",
    "roughly",
    "equal",
    "parts",
    "okay",
    "exactly",
    "equal",
    "two",
    "roughly",
    "equal",
    "parts",
    "idea",
    "two",
    "parts",
    "used",
    "inputs",
    "sub",
    "problems",
    "use",
    "recursion",
    "recursively",
    "solve",
    "problem",
    "individually",
    "two",
    "parts",
    "problem",
    "created",
    "two",
    "sub",
    "problems",
    "call",
    "recursion",
    "recursive",
    "solution",
    "use",
    "divide",
    "conquer",
    "keep",
    "going",
    "gives",
    "solution",
    "combine",
    "results",
    "solve",
    "problem",
    "original",
    "inputs",
    "okay",
    "results",
    "sub",
    "problems",
    "combine",
    "get",
    "back",
    "final",
    "result",
    "last",
    "thing",
    "need",
    "know",
    "going",
    "keep",
    "calling",
    "keep",
    "division",
    "recursively",
    "input",
    "size",
    "100",
    "call",
    "function",
    "inputs",
    "size",
    "50",
    "50",
    "call",
    "function",
    "50",
    "call",
    "function",
    "inputs",
    "size",
    "25",
    "25",
    "half",
    "keep",
    "going",
    "eventually",
    "end",
    "small",
    "indivisible",
    "ible",
    "inputs",
    "solve",
    "problem",
    "directly",
    "include",
    "terminating",
    "conditions",
    "recursion",
    "stops",
    "okay",
    "include",
    "terminating",
    "conditions",
    "small",
    "indivisible",
    "inputs",
    "divide",
    "conquer",
    "take",
    "problem",
    "divided",
    "two",
    "sub",
    "problems",
    "recursively",
    "solve",
    "sub",
    "problems",
    "get",
    "solutions",
    "sub",
    "problems",
    "combine",
    "also",
    "call",
    "divide",
    "conquer",
    "combine",
    "sense",
    "merge",
    "sort",
    "algorithm",
    "classic",
    "application",
    "divide",
    "conquer",
    "sorting",
    "problem",
    "let",
    "take",
    "look",
    "merge",
    "sort",
    "looking",
    "example",
    "visually",
    "list",
    "needs",
    "sorted",
    "increasing",
    "order",
    "remember",
    "step",
    "one",
    "divide",
    "problem",
    "two",
    "sub",
    "problems",
    "half",
    "list",
    "little",
    "half",
    "another",
    "half",
    "split",
    "four",
    "elements",
    "three",
    "elements",
    "take",
    "call",
    "cursively",
    "call",
    "sorting",
    "problem",
    "algorithm",
    "two",
    "split",
    "38",
    "27",
    "1",
    "12",
    "43",
    "3",
    "another",
    "982",
    "becomes",
    "10",
    "becomes",
    "split",
    "38",
    "27",
    "split",
    "43",
    "3",
    "982",
    "10",
    "ended",
    "single",
    "elements",
    "recursion",
    "ended",
    "terminating",
    "condition",
    "longer",
    "split",
    "list",
    "start",
    "combining",
    "problems",
    "looking",
    "sort",
    "list",
    "one",
    "element",
    "38",
    "well",
    "list",
    "already",
    "sorted",
    "return",
    "27",
    "already",
    "sorted",
    "single",
    "element",
    "return",
    "two",
    "sub",
    "lists",
    "need",
    "combine",
    "one",
    "element",
    "simply",
    "compare",
    "two",
    "elements",
    "tell",
    "27",
    "comes",
    "first",
    "38",
    "comes",
    "second",
    "combine",
    "two",
    "results",
    "get",
    "2738",
    "similarly",
    "433",
    "combine",
    "get",
    "343",
    "get",
    "982",
    "10",
    "next",
    "combine",
    "two",
    "results",
    "combination",
    "important",
    "okay",
    "need",
    "look",
    "probably",
    "tell",
    "three",
    "come",
    "first",
    "27",
    "38",
    "43",
    "combined",
    "similarly",
    "combined",
    "9",
    "10",
    "82",
    "take",
    "final",
    "results",
    "two",
    "final",
    "list",
    "combine",
    "back",
    "get",
    "fully",
    "sorted",
    "list",
    "okay",
    "talk",
    "combination",
    "called",
    "merge",
    "operation",
    "lot",
    "detail",
    "soon",
    "roughly",
    "idea",
    "keep",
    "splitting",
    "half",
    "combine",
    "halves",
    "let",
    "state",
    "plain",
    "english",
    "first",
    "terminating",
    "condition",
    "input",
    "list",
    "empty",
    "contains",
    "one",
    "element",
    "already",
    "sorted",
    "return",
    "divide",
    "list",
    "numbers",
    "two",
    "roughly",
    "equal",
    "parts",
    "sort",
    "part",
    "recursively",
    "using",
    "merge",
    "sort",
    "algorithm",
    "power",
    "recursion",
    "get",
    "back",
    "two",
    "sorted",
    "lists",
    "merge",
    "two",
    "sorted",
    "lists",
    "get",
    "single",
    "sorted",
    "list",
    "key",
    "operation",
    "called",
    "merge",
    "sort",
    "always",
    "merging",
    "sorted",
    "list",
    "making",
    "bigger",
    "bigger",
    "sorted",
    "lists",
    "merge",
    "operation",
    "something",
    "may",
    "asked",
    "write",
    "interview",
    "coding",
    "challenge",
    "apart",
    "whole",
    "merge",
    "sort",
    "operation",
    "something",
    "try",
    "explain",
    "try",
    "think",
    "merge",
    "operation",
    "might",
    "work",
    "explain",
    "words",
    "space",
    "let",
    "jump",
    "implementation",
    "merge",
    "sort",
    "implement",
    "merge",
    "sort",
    "assuming",
    "already",
    "helper",
    "function",
    "called",
    "merge",
    "useful",
    "trick",
    "program",
    "may",
    "need",
    "complicated",
    "piece",
    "logic",
    "logic",
    "figured",
    "yet",
    "assume",
    "already",
    "function",
    "write",
    "use",
    "first",
    "implement",
    "later",
    "merge",
    "sort",
    "algorithm",
    "merge",
    "sort",
    "algorithm",
    "numbers",
    "given",
    "input",
    "merge",
    "sort",
    "terminating",
    "condition",
    "length",
    "numbers",
    "less",
    "equal",
    "one",
    "means",
    "list",
    "empty",
    "one",
    "element",
    "return",
    "numbers",
    "get",
    "midpoint",
    "return",
    "length",
    "numbers",
    "divided",
    "two",
    "remember",
    "using",
    "double",
    "slash",
    "single",
    "slash",
    "would",
    "return",
    "decimal",
    "use",
    "decimal",
    "index",
    "position",
    "list",
    "using",
    "double",
    "slash",
    "take",
    "length",
    "numbers",
    "divided",
    "two",
    "size",
    "list",
    "10",
    "get",
    "back",
    "five",
    "split",
    "list",
    "two",
    "halves",
    "interesting",
    "syntax",
    "let",
    "look",
    "syntax",
    "actually",
    "means",
    "let",
    "say",
    "list",
    "list",
    "let",
    "say",
    "mid",
    "value",
    "well",
    "check",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "six",
    "elements",
    "two",
    "mid",
    "value",
    "three",
    "let",
    "check",
    "x",
    "mid",
    "give",
    "us",
    "well",
    "gives",
    "us",
    "1",
    "35",
    "well",
    "actually",
    "x",
    "colon",
    "mid",
    "means",
    "x",
    "0",
    "mid",
    "x",
    "0",
    "mid",
    "means",
    "elements",
    "position",
    "zero",
    "till",
    "position",
    "mid",
    "important",
    "like",
    "range",
    "get",
    "indexes",
    "position",
    "0",
    "1",
    "two",
    "position",
    "three",
    "okay",
    "gives",
    "us",
    "three",
    "elements",
    "let",
    "check",
    "thing",
    "x",
    "mid",
    "colon",
    "gives",
    "gives",
    "elements",
    "starting",
    "position",
    "mid",
    "way",
    "end",
    "also",
    "write",
    "minus",
    "one",
    "also",
    "write",
    "len",
    "x",
    "one",
    "skip",
    "python",
    "automatically",
    "interpret",
    "want",
    "elements",
    "starting",
    "mid",
    "end",
    "12",
    "5",
    "1",
    "positions",
    "3",
    "4",
    "5",
    "hence",
    "split",
    "list",
    "need",
    "invoke",
    "135",
    "1251",
    "get",
    "back",
    "two",
    "parts",
    "list",
    "nice",
    "thing",
    "jupiter",
    "whenever",
    "understand",
    "line",
    "code",
    "create",
    "cell",
    "try",
    "simple",
    "example",
    "left",
    "half",
    "nums",
    "zero",
    "mid",
    "right",
    "half",
    "nums",
    "mid",
    "colon",
    "magic",
    "happens",
    "call",
    "function",
    "recursively",
    "call",
    "merge",
    "sort",
    "function",
    "call",
    "call",
    "merge",
    "sort",
    "left",
    "gives",
    "us",
    "back",
    "list",
    "sorted",
    "list",
    "left",
    "half",
    "called",
    "left",
    "sorted",
    "call",
    "merge",
    "sort",
    "function",
    "right",
    "give",
    "us",
    "back",
    "sorted",
    "list",
    "called",
    "right",
    "sorted",
    "combine",
    "results",
    "two",
    "halves",
    "calling",
    "merge",
    "operation",
    "saying",
    "want",
    "merge",
    "left",
    "sorted",
    "right",
    "sorted",
    "get",
    "back",
    "final",
    "sorted",
    "numbers",
    "return",
    "sorted",
    "numbers",
    "merge",
    "sort",
    "yeah",
    "almost",
    "seem",
    "seems",
    "like",
    "magic",
    "pretty",
    "small",
    "pretty",
    "straightforward",
    "four",
    "five",
    "lines",
    "code",
    "combine",
    "lines",
    "let",
    "come",
    "merge",
    "operation",
    "seems",
    "meat",
    "right",
    "missing",
    "piece",
    "merge",
    "two",
    "sorted",
    "arrays",
    "repeatedly",
    "compare",
    "two",
    "least",
    "elements",
    "array",
    "copy",
    "smaller",
    "one",
    "new",
    "array",
    "process",
    "might",
    "look",
    "like",
    "let",
    "say",
    "two",
    "parts",
    "147",
    "023",
    "three",
    "want",
    "get",
    "sorted",
    "list",
    "notice",
    "already",
    "sorted",
    "results",
    "recursive",
    "call",
    "merge",
    "sort",
    "keep",
    "pointer",
    "left",
    "one",
    "pointer",
    "one",
    "pointer",
    "zero",
    "compare",
    "two",
    "take",
    "smaller",
    "one",
    "put",
    "list",
    "know",
    "put",
    "smaller",
    "numbers",
    "also",
    "greater",
    "zero",
    "since",
    "one",
    "greater",
    "z",
    "numbers",
    "greater",
    "zero",
    "greater",
    "one",
    "follows",
    "numbers",
    "right",
    "one",
    "right",
    "0",
    "greater",
    "z",
    "hence",
    "0o",
    "come",
    "first",
    "position",
    "put",
    "advance",
    "pointer",
    "see",
    "compare",
    "one",
    "two",
    "time",
    "one",
    "smaller",
    "know",
    "numbers",
    "greater",
    "two",
    "also",
    "greater",
    "one",
    "numbers",
    "also",
    "greater",
    "one",
    "hence",
    "know",
    "one",
    "next",
    "largest",
    "number",
    "put",
    "one",
    "advance",
    "pointer",
    "keep",
    "going",
    "time",
    "compare",
    "two",
    "four",
    "put",
    "two",
    "advanc",
    "pointer",
    "put",
    "three",
    "advance",
    "pointer",
    "point",
    "exhaust",
    "one",
    "lists",
    "exhaust",
    "one",
    "list",
    "stop",
    "comparing",
    "simply",
    "copy",
    "remaining",
    "elements",
    "copy",
    "four",
    "7even",
    "exhausted",
    "list",
    "get",
    "back",
    "sorted",
    "merged",
    "array",
    "0",
    "1",
    "2",
    "3",
    "4",
    "7",
    "really",
    "simple",
    "involves",
    "step",
    "involves",
    "one",
    "comparison",
    "incrementing",
    "one",
    "pointer",
    "either",
    "incrementing",
    "pointer",
    "incrementing",
    "pointer",
    "okay",
    "let",
    "define",
    "merge",
    "operation",
    "see",
    "benefit",
    "assuming",
    "function",
    "already",
    "existed",
    "def",
    "worry",
    "actual",
    "sorting",
    "recursion",
    "etc",
    "simply",
    "worry",
    "merging",
    "two",
    "sorted",
    "arrays",
    "first",
    "create",
    "list",
    "store",
    "results",
    "nums",
    "one",
    "nums",
    "two",
    "two",
    "left",
    "right",
    "list",
    "going",
    "combine",
    "going",
    "set",
    "set",
    "two",
    "indexes",
    "two",
    "numbers",
    "iteration",
    "two",
    "pointers",
    "two",
    "lists",
    "set",
    "position",
    "zero",
    "currently",
    "position",
    "zero",
    "loop",
    "tool",
    "list",
    "say",
    "less",
    "len",
    "nums",
    "one",
    "j",
    "less",
    "len",
    "nums",
    "2",
    "four",
    "elements",
    "left",
    "list",
    "go",
    "0",
    "three",
    "four",
    "positions",
    "five",
    "elements",
    "right",
    "list",
    "j",
    "grow",
    "0",
    "five",
    "0",
    "four",
    "five",
    "positions",
    "check",
    "remember",
    "want",
    "make",
    "sure",
    "indices",
    "valid",
    "reached",
    "end",
    "want",
    "skip",
    "simply",
    "copy",
    "remaining",
    "list",
    "right",
    "see",
    "soon",
    "reach",
    "point",
    "comparisons",
    "made",
    "exit",
    "loop",
    "check",
    "one",
    "smaller",
    "nums",
    "1",
    "left",
    "list",
    "current",
    "element",
    "smaller",
    "nums",
    "2",
    "j",
    "append",
    "merged",
    "list",
    "nums",
    "one",
    "increment",
    "exactly",
    "done",
    "put",
    "well",
    "let",
    "say",
    "put",
    "one",
    "increment",
    "left",
    "pointer",
    "hand",
    "true",
    "append",
    "element",
    "right",
    "nums",
    "j",
    "increment",
    "right",
    "pointer",
    "case",
    "loop",
    "incrementing",
    "one",
    "pointers",
    "loop",
    "ends",
    "one",
    "lists",
    "would",
    "exhausted",
    "loop",
    "ends",
    "get",
    "remaining",
    "parts",
    "lists",
    "get",
    "nums",
    "one",
    "colon",
    "get",
    "remaining",
    "elements",
    "first",
    "list",
    "left",
    "list",
    "ns",
    "2",
    "j",
    "colon",
    "get",
    "remaining",
    "elements",
    "right",
    "list",
    "remember",
    "since",
    "one",
    "exhausted",
    "one",
    "two",
    "going",
    "empty",
    "right",
    "check",
    "one",
    "empty",
    "simply",
    "add",
    "remaining",
    "one",
    "simpler",
    "solution",
    "add",
    "merg",
    "append",
    "lists",
    "end",
    "automatically",
    "takes",
    "care",
    "empty",
    "case",
    "left",
    "side",
    "becomes",
    "empty",
    "adds",
    "nothing",
    "merged",
    "array",
    "adds",
    "remaining",
    "numbers",
    "right",
    "side",
    "right",
    "side",
    "becomes",
    "empty",
    "adds",
    "remaining",
    "numbers",
    "left",
    "left",
    "side",
    "adds",
    "nothing",
    "small",
    "trick",
    "merge",
    "operation",
    "difficult",
    "questions",
    "take",
    "specific",
    "cells",
    "try",
    "examples",
    "see",
    "working",
    "let",
    "try",
    "merge",
    "operation",
    "two",
    "sorted",
    "lists",
    "see",
    "go",
    "see",
    "arranged",
    "numbers",
    "arranged",
    "sorted",
    "order",
    "merge",
    "operation",
    "merge",
    "sort",
    "operation",
    "test",
    "merge",
    "sort",
    "function",
    "get",
    "first",
    "set",
    "inputs",
    "outputs",
    "test",
    "zero",
    "see",
    "input",
    "expected",
    "output",
    "actual",
    "output",
    "well",
    "let",
    "test",
    "cases",
    "using",
    "evaluate",
    "test",
    "cases",
    "function",
    "jovian",
    "simply",
    "going",
    "call",
    "evaluate",
    "test",
    "cases",
    "entire",
    "list",
    "test",
    "cases",
    "see",
    "test",
    "cases",
    "seem",
    "passing",
    "one",
    "test",
    "cases",
    "failed",
    "go",
    "go",
    "back",
    "add",
    "print",
    "statements",
    "inside",
    "merge",
    "function",
    "add",
    "print",
    "statements",
    "inside",
    "merge",
    "sort",
    "function",
    "right",
    "places",
    "add",
    "print",
    "statements",
    "right",
    "function",
    "definition",
    "uh",
    "right",
    "body",
    "function",
    "first",
    "statement",
    "inside",
    "loop",
    "inside",
    "loop",
    "whatever",
    "changing",
    "parameters",
    "print",
    "inside",
    "loop",
    "finally",
    "also",
    "print",
    "return",
    "value",
    "function",
    "way",
    "build",
    "full",
    "picture",
    "function",
    "makes",
    "much",
    "easier",
    "solve",
    "issues",
    "test",
    "cases",
    "print",
    "functions",
    "make",
    "easy",
    "fix",
    "errors",
    "code",
    "worry",
    "errors",
    "always",
    "errors",
    "code",
    "important",
    "able",
    "find",
    "way",
    "fix",
    "easily",
    "without",
    "test",
    "cases",
    "without",
    "printing",
    "may",
    "get",
    "stuck",
    "may",
    "keep",
    "staring",
    "code",
    "trying",
    "figure",
    "exactly",
    "went",
    "wrong",
    "please",
    "one",
    "last",
    "thing",
    "want",
    "notice",
    "execution",
    "took",
    "50",
    "milliseconds",
    "hand",
    "remember",
    "bubble",
    "sort",
    "took",
    "15",
    "seconds",
    "sort",
    "numbers",
    "sort",
    "much",
    "much",
    "faster",
    "right",
    "millisecond",
    "10",
    "minus",
    "3",
    "seconds",
    "second",
    "probably",
    "sort",
    "200",
    "200",
    "list",
    "size",
    "makes",
    "merge",
    "sort",
    "much",
    "powerful",
    "much",
    "efficient",
    "analyze",
    "complexity",
    "learn",
    "sort",
    "fact",
    "efficient",
    "terms",
    "biger",
    "notation",
    "well",
    "let",
    "analyze",
    "algorithm",
    "complexity",
    "identify",
    "inefficiencies",
    "analyzing",
    "recursive",
    "algorithms",
    "get",
    "tricky",
    "helps",
    "track",
    "follow",
    "chain",
    "recursive",
    "calls",
    "add",
    "print",
    "statements",
    "merge",
    "sort",
    "function",
    "merge",
    "function",
    "simply",
    "see",
    "merge",
    "sort",
    "function",
    "invoked",
    "okay",
    "add",
    "print",
    "statement",
    "inside",
    "merge",
    "add",
    "print",
    "statement",
    "inside",
    "merge",
    "sort",
    "also",
    "tracking",
    "something",
    "called",
    "depth",
    "track",
    "chain",
    "depth",
    "recursive",
    "call",
    "see",
    "mean",
    "second",
    "okay",
    "looks",
    "like",
    "called",
    "merge",
    "sort",
    "big",
    "list",
    "elements",
    "unsorted",
    "merge",
    "sort",
    "internally",
    "led",
    "two",
    "calls",
    "merge",
    "sort",
    "see",
    "one",
    "one",
    "two",
    "calls",
    "merge",
    "sort",
    "one",
    "left",
    "half",
    "list",
    "one",
    "right",
    "half",
    "list",
    "unequal",
    "two",
    "merge",
    "sorts",
    "finally",
    "returned",
    "merg",
    "lists",
    "finally",
    "called",
    "merge",
    "operation",
    "two",
    "see",
    "merge",
    "operation",
    "final",
    "merge",
    "operation",
    "called",
    "two",
    "merge",
    "sort",
    "lists",
    "merge",
    "operation",
    "working",
    "two",
    "sorted",
    "lists",
    "okay",
    "see",
    "merge",
    "sort",
    "invokes",
    "invokes",
    "merge",
    "sort",
    "twice",
    "time",
    "array",
    "half",
    "size",
    "see",
    "merge",
    "sort",
    "invoked",
    "arrays",
    "lists",
    "half",
    "size",
    "also",
    "invokes",
    "merge",
    "function",
    "merge",
    "two",
    "resulting",
    "arrays",
    "two",
    "sorted",
    "arrays",
    "two",
    "calls",
    "merge",
    "sort",
    "observe",
    "closely",
    "make",
    "two",
    "calls",
    "merge",
    "sort",
    "one",
    "call",
    "merge",
    "internal",
    "calls",
    "make",
    "two",
    "calls",
    "merge",
    "sort",
    "one",
    "call",
    "merge",
    "till",
    "end",
    "single",
    "elements",
    "point",
    "merge",
    "sort",
    "simply",
    "returns",
    "single",
    "element",
    "mer",
    "algorithm",
    "ultimately",
    "points",
    "series",
    "merge",
    "operations",
    "see",
    "merge",
    "sort",
    "calling",
    "merge",
    "sort",
    "internally",
    "calling",
    "merge",
    "operation",
    "ultimately",
    "first",
    "merging",
    "5",
    "merging",
    "2",
    "6",
    "merging",
    "2a",
    "6",
    "merging",
    "123",
    "merging",
    "7",
    "12",
    "merging",
    "7",
    "12",
    "7",
    "finally",
    "merging",
    "123",
    "1277",
    "finally",
    "merging",
    "big",
    "list",
    "right",
    "ultimately",
    "whole",
    "bunch",
    "merge",
    "operations",
    "look",
    "inside",
    "merge",
    "operation",
    "comparison",
    "happening",
    "append",
    "end",
    "step",
    "happening",
    "comparing",
    "appending",
    "two",
    "key",
    "operations",
    "every",
    "comparison",
    "append",
    "simply",
    "count",
    "comparisons",
    "happening",
    "enough",
    "get",
    "time",
    "complexity",
    "number",
    "comparisons",
    "happening",
    "well",
    "straightforward",
    "two",
    "lists",
    "nums",
    "one",
    "nums",
    "two",
    "total",
    "length",
    "two",
    "lists",
    "n",
    "size",
    "number",
    "iterations",
    "equal",
    "worst",
    "case",
    "would",
    "equal",
    "lengths",
    "two",
    "lists",
    "combined",
    "may",
    "first",
    "maybe",
    "increment",
    "one",
    "increment",
    "j",
    "one",
    "increment",
    "1",
    "j",
    "1",
    "total",
    "number",
    "iterations",
    "len",
    "nums",
    "1",
    "plus",
    "len",
    "ns",
    "2",
    "right",
    "remember",
    "merge",
    "called",
    "merge",
    "sort",
    "called",
    "list",
    "size",
    "n",
    "merge",
    "called",
    "list",
    "size",
    "n",
    "by2",
    "n",
    "by2",
    "roughly",
    "total",
    "list",
    "total",
    "length",
    "ns",
    "one",
    "plus",
    "nums",
    "2",
    "actually",
    "overall",
    "length",
    "n",
    "real",
    "trick",
    "merge",
    "merge",
    "operation",
    "order",
    "n",
    "operation",
    "n",
    "number",
    "elements",
    "total",
    "number",
    "elements",
    "okay",
    "merge",
    "operation",
    "takes",
    "4",
    "5",
    "9",
    "comparisons",
    "merge",
    "operation",
    "takes",
    "five",
    "comparisons",
    "merge",
    "operation",
    "takes",
    "three",
    "comparisons",
    "way",
    "visualize",
    "problem",
    "tree",
    "calling",
    "merge",
    "sort",
    "n",
    "n",
    "elements",
    "ends",
    "calling",
    "merge",
    "sort",
    "n",
    "by2",
    "elements",
    "ends",
    "calling",
    "mer",
    "n",
    "by4",
    "elements",
    "way",
    "start",
    "merging",
    "get",
    "individual",
    "elements",
    "calling",
    "merge",
    "literally",
    "single",
    "elements",
    "come",
    "calling",
    "merge",
    "point",
    "calling",
    "merge",
    "elements",
    "size",
    "n",
    "8",
    "n",
    "8",
    "calling",
    "merge",
    "eight",
    "times",
    "sub",
    "problems",
    "makes",
    "call",
    "merge",
    "sub",
    "problems",
    "list",
    "size",
    "n",
    "8",
    "eight",
    "calls",
    "merge",
    "size",
    "n",
    "8",
    "total",
    "number",
    "comparisons",
    "done",
    "n",
    "every",
    "stage",
    "check",
    "top",
    "level",
    "uh",
    "calling",
    "merge",
    "n",
    "total",
    "elements",
    "total",
    "number",
    "comparisons",
    "n",
    "second",
    "level",
    "calling",
    "merge",
    "n",
    "by2",
    "elements",
    "calling",
    "merge",
    "n",
    "by2",
    "elements",
    "total",
    "number",
    "comparisons",
    "2",
    "n",
    "by2",
    "n",
    "calling",
    "merge",
    "n",
    "by4",
    "elements",
    "four",
    "times",
    "n",
    "height",
    "tree",
    "h",
    "total",
    "number",
    "comparisons",
    "n",
    "h",
    "right",
    "level",
    "require",
    "n",
    "comparisons",
    "merge",
    "call",
    "merges",
    "every",
    "level",
    "sub",
    "problems",
    "height",
    "tree",
    "total",
    "number",
    "comparisons",
    "n",
    "h",
    "get",
    "height",
    "tree",
    "height",
    "tree",
    "h",
    "see",
    "go",
    "level",
    "zero",
    "one",
    "element",
    "level",
    "one",
    "two",
    "elements",
    "level",
    "two",
    "four",
    "sub",
    "problems",
    "level",
    "three",
    "eight",
    "sub",
    "problems",
    "level",
    "k",
    "2",
    "k",
    "sub",
    "problems",
    "keep",
    "going",
    "level",
    "hus",
    "one",
    "level",
    "h",
    "2",
    "sub",
    "problems",
    "remember",
    "last",
    "level",
    "simp",
    "simply",
    "sub",
    "problems",
    "merge",
    "merge",
    "calls",
    "single",
    "elements",
    "means",
    "total",
    "n",
    "elements",
    "n",
    "leaf",
    "nodes",
    "follows",
    "2",
    "h",
    "n",
    "okay",
    "let",
    "think",
    "reason",
    "something",
    "may",
    "work",
    "pen",
    "paper",
    "get",
    "correctly",
    "height",
    "tree",
    "h",
    "2",
    "h",
    "1",
    "equal",
    "n",
    "bottommost",
    "layer",
    "n",
    "leaves",
    "tree",
    "follows",
    "h",
    "log",
    "n",
    "1",
    "since",
    "said",
    "n",
    "h",
    "comparisons",
    "h",
    "log",
    "n",
    "1",
    "follows",
    "complexity",
    "merge",
    "sort",
    "n",
    "log",
    "n",
    "big",
    "improvement",
    "n",
    "square",
    "may",
    "seem",
    "like",
    "much",
    "n",
    "sare",
    "n",
    "login",
    "12",
    "13",
    "log",
    "base",
    "2",
    "hundred",
    "times",
    "faster",
    "even",
    "array",
    "million",
    "elements",
    "take",
    "seconds",
    "sorted",
    "verify",
    "actually",
    "creating",
    "list",
    "million",
    "elements",
    "okay",
    "complexity",
    "mer",
    "sort",
    "n",
    "log",
    "n",
    "get",
    "drawing",
    "sub",
    "problem",
    "tree",
    "realizing",
    "get",
    "sub",
    "problem",
    "tree",
    "height",
    "log",
    "n",
    "log",
    "n",
    "plus",
    "one",
    "step",
    "perform",
    "merge",
    "operation",
    "multiple",
    "merge",
    "operations",
    "totaling",
    "n",
    "comparison",
    "n",
    "login",
    "complexity",
    "merge",
    "sort",
    "also",
    "discussion",
    "space",
    "complexity",
    "something",
    "leave",
    "exercise",
    "read",
    "see",
    "reason",
    "space",
    "complexity",
    "mer",
    "sort",
    "order",
    "n",
    "okay",
    "time",
    "complexity",
    "order",
    "n",
    "log",
    "n",
    "space",
    "complexity",
    "order",
    "n",
    "hint",
    "order",
    "n",
    "see",
    "inside",
    "merge",
    "operation",
    "creating",
    "new",
    "list",
    "copying",
    "elements",
    "two",
    "lists",
    "new",
    "lists",
    "allocating",
    "new",
    "list",
    "inside",
    "merge",
    "longer",
    "constant",
    "list",
    "size",
    "size",
    "problem",
    "hence",
    "roughly",
    "space",
    "complexity",
    "order",
    "n",
    "okay",
    "conclude",
    "discussion",
    "merge",
    "sort",
    "divide",
    "conquer",
    "algorithm",
    "split",
    "list",
    "half",
    "recursively",
    "sort",
    "merge",
    "two",
    "sorted",
    "lists",
    "initial",
    "condition",
    "one",
    "zero",
    "elements",
    "several",
    "extensions",
    "variations",
    "merge",
    "sort",
    "called",
    "kway",
    "merge",
    "sort",
    "split",
    "two",
    "parts",
    "k",
    "parts",
    "counting",
    "inversions",
    "problem",
    "modify",
    "mer",
    "sort",
    "little",
    "bit",
    "also",
    "find",
    "information",
    "list",
    "finally",
    "hybrid",
    "algorithms",
    "combine",
    "merge",
    "sort",
    "insertion",
    "sort",
    "smaller",
    "list",
    "use",
    "insertion",
    "sort",
    "efficient",
    "bigger",
    "list",
    "use",
    "merge",
    "sort",
    "splitting",
    "list",
    "get",
    "small",
    "enough",
    "problem",
    "let",
    "say",
    "10",
    "less",
    "elements",
    "use",
    "insertion",
    "sort",
    "brings",
    "us",
    "next",
    "question",
    "make",
    "one",
    "level",
    "optimization",
    "stop",
    "go",
    "one",
    "step",
    "apply",
    "another",
    "technique",
    "overcome",
    "inefficiency",
    "merge",
    "sort",
    "time",
    "complexity",
    "pretty",
    "good",
    "actually",
    "sort",
    "millions",
    "even",
    "tens",
    "millions",
    "elements",
    "merge",
    "sort",
    "quite",
    "reliably",
    "space",
    "complexity",
    "causes",
    "problem",
    "merge",
    "sort",
    "requires",
    "allocating",
    "additional",
    "space",
    "additional",
    "spac",
    "large",
    "input",
    "makes",
    "somewhat",
    "slow",
    "practice",
    "memory",
    "allocation",
    "expensive",
    "computations",
    "comparison",
    "easy",
    "tell",
    "cpu",
    "compare",
    "two",
    "things",
    "memory",
    "swapping",
    "also",
    "easy",
    "still",
    "working",
    "memory",
    "already",
    "allocate",
    "new",
    "memory",
    "often",
    "request",
    "operating",
    "system",
    "uh",
    "allocate",
    "new",
    "memory",
    "get",
    "address",
    "whole",
    "bunch",
    "operations",
    "let",
    "say",
    "order",
    "magnitude",
    "expensive",
    "simply",
    "computations",
    "try",
    "avoid",
    "memory",
    "allocations",
    "far",
    "possible",
    "one",
    "two",
    "variables",
    "fine",
    "dealing",
    "million",
    "elements",
    "probably",
    "going",
    "need",
    "maybe",
    "mb",
    "additional",
    "space",
    "may",
    "slow",
    "algorithm",
    "little",
    "bit",
    "would",
    "still",
    "n",
    "log",
    "n",
    "constant",
    "factor",
    "cost",
    "operation",
    "higher",
    "involves",
    "allocation",
    "overcome",
    "inefficiencies",
    "space",
    "efficien",
    "mer",
    "sord",
    "study",
    "another",
    "divide",
    "conquer",
    "based",
    "algorithm",
    "sorting",
    "algorithm",
    "called",
    "quick",
    "sort",
    "quick",
    "sort",
    "sorts",
    "array",
    "place",
    "means",
    "create",
    "copy",
    "array",
    "internally",
    "sorting",
    "inside",
    "operation",
    "inside",
    "combination",
    "operation",
    "let",
    "see",
    "works",
    "pretty",
    "interesting",
    "pretty",
    "smart",
    "trick",
    "works",
    "list",
    "empty",
    "one",
    "element",
    "return",
    "already",
    "sorted",
    "straightforward",
    "pick",
    "random",
    "element",
    "pick",
    "random",
    "element",
    "list",
    "element",
    "called",
    "pivot",
    "many",
    "strategies",
    "picking",
    "pivot",
    "one",
    "pick",
    "random",
    "element",
    "one",
    "maybe",
    "pick",
    "first",
    "element",
    "last",
    "element",
    "pick",
    "last",
    "element",
    "easily",
    "augment",
    "implementation",
    "pick",
    "random",
    "element",
    "reorder",
    "list",
    "key",
    "operation",
    "reorder",
    "list",
    "elements",
    "values",
    "less",
    "equal",
    "pivot",
    "come",
    "pivot",
    "element",
    "elements",
    "values",
    "greater",
    "pivot",
    "come",
    "pivot",
    "element",
    "element",
    "called",
    "partitioning",
    "partitioning",
    "array",
    "around",
    "pivot",
    "example",
    "let",
    "say",
    "take",
    "three",
    "pivot",
    "element",
    "final",
    "element",
    "want",
    "want",
    "reorder",
    "elements",
    "way",
    "reorder",
    "swapping",
    "comparison",
    "whatever",
    "way",
    "really",
    "focus",
    "partitioning",
    "algorithm",
    "reorder",
    "way",
    "numbers",
    "left",
    "pivot",
    "smaller",
    "numbers",
    "right",
    "pivot",
    "larger",
    "key",
    "key",
    "observation",
    "tell",
    "numbers",
    "sorted",
    "independently",
    "none",
    "numbers",
    "move",
    "right",
    "pivot",
    "similarly",
    "numbers",
    "also",
    "sorted",
    "independently",
    "none",
    "numbers",
    "move",
    "left",
    "pivot",
    "pivot",
    "correct",
    "position",
    "final",
    "sorted",
    "array",
    "correct",
    "final",
    "position",
    "simply",
    "call",
    "quick",
    "sort",
    "half",
    "less",
    "half",
    "portion",
    "array",
    "portion",
    "array",
    "real",
    "combination",
    "required",
    "anymore",
    "right",
    "place",
    "simply",
    "call",
    "quick",
    "sort",
    "side",
    "array",
    "gets",
    "sorted",
    "gets",
    "sorted",
    "recursively",
    "end",
    "entire",
    "sorted",
    "list",
    "right",
    "continue",
    "process",
    "recursively",
    "left",
    "half",
    "pick",
    "pivot",
    "arrange",
    "elements",
    "around",
    "pivot",
    "right",
    "half",
    "pi",
    "pick",
    "pivot",
    "arrange",
    "elements",
    "around",
    "pivot",
    "okay",
    "said",
    "key",
    "observation",
    "partition",
    "pivot",
    "element",
    "right",
    "place",
    "sorted",
    "array",
    "two",
    "parts",
    "array",
    "sorted",
    "independently",
    "place",
    "maybe",
    "take",
    "pen",
    "paper",
    "try",
    "work",
    "makes",
    "lot",
    "sense",
    "actually",
    "put",
    "solve",
    "real",
    "problem",
    "real",
    "example",
    "implementation",
    "quick",
    "sort",
    "assume",
    "already",
    "helper",
    "function",
    "called",
    "partition",
    "pick",
    "pivot",
    "partition",
    "array",
    "return",
    "position",
    "pivot",
    "element",
    "next",
    "quick",
    "sort",
    "step",
    "okay",
    "entire",
    "process",
    "going",
    "assume",
    "function",
    "write",
    "quick",
    "sort",
    "algorithm",
    "implement",
    "partition",
    "function",
    "quick",
    "sort",
    "might",
    "look",
    "like",
    "quick",
    "sort",
    "takes",
    "bunch",
    "numbers",
    "apart",
    "numbers",
    "also",
    "takes",
    "start",
    "index",
    "end",
    "index",
    "remember",
    "want",
    "avoid",
    "creating",
    "copies",
    "list",
    "whole",
    "pro",
    "whole",
    "thinking",
    "line",
    "thinking",
    "call",
    "quicksort",
    "sublist",
    "copy",
    "portion",
    "call",
    "quicksort",
    "simply",
    "changing",
    "passing",
    "original",
    "list",
    "changing",
    "start",
    "end",
    "index",
    "okay",
    "code",
    "end",
    "none",
    "setting",
    "end",
    "length",
    "list",
    "minus",
    "one",
    "one",
    "thing",
    "final",
    "invocation",
    "quick",
    "sort",
    "make",
    "something",
    "like",
    "may",
    "call",
    "quick",
    "sort",
    "let",
    "say",
    "numbers",
    "may",
    "call",
    "quick",
    "sort",
    "list",
    "something",
    "like",
    "case",
    "automatically",
    "start",
    "value",
    "zero",
    "end",
    "value",
    "none",
    "remember",
    "quick",
    "sort",
    "going",
    "sort",
    "array",
    "place",
    "also",
    "said",
    "want",
    "modify",
    "test",
    "cases",
    "one",
    "assumption",
    "making",
    "end",
    "none",
    "means",
    "quicksort",
    "called",
    "list",
    "create",
    "copy",
    "list",
    "right",
    "create",
    "one",
    "copy",
    "beginning",
    "right",
    "list",
    "passed",
    "first",
    "time",
    "create",
    "copies",
    "even",
    "skip",
    "line",
    "entirely",
    "trouble",
    "start",
    "changing",
    "test",
    "case",
    "input",
    "let",
    "keep",
    "let",
    "keep",
    "copy",
    "done",
    "top",
    "level",
    "right",
    "start",
    "create",
    "copy",
    "modifying",
    "input",
    "list",
    "never",
    "creating",
    "copy",
    "uh",
    "quick",
    "sort",
    "called",
    "list",
    "setting",
    "end",
    "len",
    "nums",
    "minus",
    "one",
    "final",
    "valid",
    "index",
    "list",
    "anyway",
    "putting",
    "aside",
    "real",
    "condition",
    "start",
    "less",
    "end",
    "means",
    "let",
    "say",
    "start",
    "end",
    "start",
    "less",
    "end",
    "means",
    "two",
    "elements",
    "right",
    "start",
    "end",
    "equal",
    "means",
    "one",
    "element",
    "start",
    "greater",
    "end",
    "means",
    "zero",
    "elements",
    "really",
    "start",
    "less",
    "end",
    "means",
    "least",
    "two",
    "elements",
    "call",
    "partition",
    "function",
    "call",
    "partition",
    "function",
    "nums",
    "say",
    "want",
    "partition",
    "region",
    "start",
    "end",
    "let",
    "say",
    "region",
    "start",
    "end",
    "want",
    "partition",
    "want",
    "pick",
    "pivot",
    "partition",
    "way",
    "elements",
    "left",
    "pivot",
    "smaller",
    "elements",
    "right",
    "pivot",
    "larger",
    "example",
    "want",
    "four",
    "partition",
    "element",
    "four",
    "pivot",
    "element",
    "partition",
    "array",
    "three",
    "comma",
    "4",
    "comma",
    "5a",
    "23",
    "three",
    "smaller",
    "four",
    "523",
    "bigger",
    "four",
    "return",
    "position",
    "pivot",
    "element",
    "okay",
    "partition",
    "array",
    "return",
    "position",
    "pivot",
    "element",
    "position",
    "get",
    "back",
    "call",
    "quick",
    "sort",
    "region",
    "region",
    "call",
    "quick",
    "sort",
    "start",
    "pivot",
    "minus",
    "one",
    "call",
    "quick",
    "sort",
    "pivot",
    "one",
    "end",
    "okay",
    "passing",
    "actually",
    "explicitly",
    "passing",
    "values",
    "start",
    "end",
    "kick",
    "next",
    "time",
    "copies",
    "list",
    "created",
    "recursive",
    "calls",
    "keep",
    "modifying",
    "place",
    "recur",
    "even",
    "partition",
    "call",
    "modify",
    "place",
    "see",
    "partition",
    "works",
    "moment",
    "partition",
    "gets",
    "slice",
    "original",
    "list",
    "returns",
    "position",
    "pivot",
    "element",
    "call",
    "quick",
    "sort",
    "left",
    "slice",
    "partition",
    "elements",
    "smaller",
    "partition",
    "call",
    "quick",
    "sort",
    "right",
    "slice",
    "elements",
    "come",
    "partition",
    "okay",
    "partition",
    "operation",
    "works",
    "pretty",
    "straightforward",
    "difficult",
    "pick",
    "final",
    "element",
    "pivot",
    "element",
    "want",
    "pick",
    "final",
    "element",
    "want",
    "pick",
    "randomized",
    "element",
    "well",
    "pick",
    "random",
    "position",
    "move",
    "element",
    "final",
    "position",
    "good",
    "picking",
    "final",
    "element",
    "random",
    "pivot",
    "simply",
    "involves",
    "picking",
    "element",
    "moving",
    "final",
    "position",
    "assuming",
    "pivot",
    "final",
    "position",
    "keep",
    "two",
    "pointers",
    "left",
    "right",
    "remember",
    "want",
    "create",
    "want",
    "push",
    "numbers",
    "smaller",
    "pivot",
    "left",
    "want",
    "push",
    "numbers",
    "larger",
    "pivot",
    "right",
    "okay",
    "ultimately",
    "arrange",
    "way",
    "smaller",
    "pivot",
    "larger",
    "pivot",
    "move",
    "pivot",
    "see",
    "left",
    "pointer",
    "right",
    "pointer",
    "inside",
    "partition",
    "two",
    "pointers",
    "far",
    "away",
    "first",
    "check",
    "element",
    "left",
    "pointer",
    "smaller",
    "pivot",
    "well",
    "element",
    "left",
    "pointer",
    "smaller",
    "pivot",
    "simply",
    "advance",
    "left",
    "pointer",
    "forward",
    "goes",
    "five",
    "go",
    "back",
    "next",
    "loop",
    "time",
    "check",
    "element",
    "left",
    "pointer",
    "points",
    "smaller",
    "pivot",
    "five",
    "smaller",
    "three",
    "five",
    "greater",
    "three",
    "case",
    "check",
    "right",
    "pointer",
    "greater",
    "pivot",
    "right",
    "pointer",
    "greater",
    "pivot",
    "means",
    "number",
    "right",
    "position",
    "greater",
    "pivot",
    "move",
    "right",
    "pointer",
    "back",
    "one",
    "space",
    "okay",
    "operation",
    "check",
    "left",
    "pointer",
    "smaller",
    "pivot",
    "right",
    "pointer",
    "greater",
    "pivot",
    "means",
    "two",
    "numbers",
    "place",
    "right",
    "ideally",
    "would",
    "want",
    "smaller",
    "pivot",
    "larger",
    "pivot",
    "swap",
    "two",
    "elements",
    "0er",
    "comes",
    "five",
    "comes",
    "check",
    "zero",
    "left",
    "pointer",
    "smaller",
    "pivot",
    "yes",
    "move",
    "left",
    "pointer",
    "forward",
    "left",
    "pointer",
    "smaller",
    "pivot",
    "six",
    "greater",
    "three",
    "check",
    "right",
    "pointer",
    "larger",
    "pivot",
    "yes",
    "move",
    "right",
    "pointer",
    "forward",
    "five",
    "still",
    "correct",
    "position",
    "know",
    "right",
    "edge",
    "everything",
    "greater",
    "three",
    "end",
    "position",
    "left",
    "element",
    "smaller",
    "larger",
    "pivot",
    "check",
    "right",
    "element",
    "right",
    "element",
    "smaller",
    "pivot",
    "want",
    "larger",
    "swap",
    "two",
    "two",
    "order",
    "see",
    "one2",
    "smaller",
    "pivot",
    "651",
    "larger",
    "pivot",
    "one",
    "final",
    "check",
    "two",
    "smaller",
    "pivot",
    "yes",
    "advance",
    "left",
    "pointer",
    "pointers",
    "position",
    "tell",
    "point",
    "point",
    "position",
    "onwards",
    "numbers",
    "larger",
    "pivot",
    "simply",
    "simply",
    "swap",
    "element",
    "pivot",
    "go",
    "end",
    "1",
    "02",
    "3",
    "5",
    "11",
    "6",
    "okay",
    "partition",
    "operation",
    "understand",
    "pen",
    "paper",
    "write",
    "write",
    "write",
    "array",
    "create",
    "pivot",
    "create",
    "left",
    "pointer",
    "right",
    "pointer",
    "keep",
    "creating",
    "copies",
    "array",
    "step",
    "loop",
    "okay",
    "understand",
    "things",
    "difficult",
    "involves",
    "two",
    "pointers",
    "little",
    "tricky",
    "code",
    "partition",
    "let",
    "follow",
    "code",
    "go",
    "briefly",
    "point",
    "since",
    "halfway",
    "course",
    "able",
    "read",
    "code",
    "also",
    "comments",
    "understand",
    "discussed",
    "plain",
    "english",
    "understand",
    "terms",
    "code",
    "okay",
    "one",
    "exercise",
    "explain",
    "visual",
    "approach",
    "plain",
    "english",
    "step",
    "step",
    "second",
    "exercise",
    "read",
    "code",
    "understand",
    "maybe",
    "even",
    "try",
    "write",
    "memory",
    "take",
    "english",
    "description",
    "try",
    "write",
    "part",
    "partition",
    "function",
    "memory",
    "memorize",
    "code",
    "convert",
    "english",
    "text",
    "code",
    "okay",
    "uh",
    "know",
    "nums",
    "numbers",
    "need",
    "partitioned",
    "start",
    "end",
    "end",
    "none",
    "simply",
    "set",
    "end",
    "last",
    "index",
    "len",
    "nums",
    "minus",
    "one",
    "initialize",
    "start",
    "end",
    "pointers",
    "initialize",
    "left",
    "right",
    "pointers",
    "remember",
    "want",
    "use",
    "end",
    "element",
    "end",
    "element",
    "want",
    "use",
    "end",
    "element",
    "pivot",
    "left",
    "point",
    "left",
    "pointer",
    "start",
    "right",
    "pointer",
    "end",
    "minus",
    "one",
    "set",
    "white",
    "right",
    "pointer",
    "greater",
    "left",
    "pointer",
    "increment",
    "left",
    "pointer",
    "number",
    "left",
    "pointer",
    "less",
    "equal",
    "pivot",
    "decrement",
    "otherwise",
    "decrement",
    "right",
    "pointer",
    "number",
    "right",
    "pointer",
    "greater",
    "pivot",
    "otherwise",
    "two",
    "place",
    "swapped",
    "swap",
    "finally",
    "place",
    "pivot",
    "place",
    "two",
    "parts",
    "exactly",
    "happening",
    "let",
    "see",
    "let",
    "see",
    "partition",
    "taking",
    "list",
    "calling",
    "partition",
    "three",
    "number",
    "used",
    "pivot",
    "three",
    "ends",
    "102",
    "516",
    "partition",
    "function",
    "returns",
    "position",
    "pivot",
    "see",
    "used",
    "quick",
    "sort",
    "partition",
    "function",
    "returns",
    "position",
    "pivot",
    "call",
    "quick",
    "sort",
    "left",
    "partition",
    "pivot",
    "right",
    "partition",
    "pivot",
    "test",
    "quick",
    "sort",
    "okay",
    "another",
    "exercise",
    "add",
    "print",
    "statements",
    "inside",
    "partition",
    "function",
    "already",
    "print",
    "statements",
    "simply",
    "uncomment",
    "uncomment",
    "print",
    "statements",
    "display",
    "list",
    "left",
    "pointer",
    "right",
    "pointer",
    "beginning",
    "end",
    "every",
    "loop",
    "study",
    "partitioning",
    "works",
    "similarly",
    "also",
    "add",
    "print",
    "statements",
    "inside",
    "quick",
    "sort",
    "function",
    "study",
    "recursive",
    "calls",
    "going",
    "study",
    "done",
    "merge",
    "merge",
    "sort",
    "add",
    "print",
    "statements",
    "quick",
    "quick",
    "sort",
    "look",
    "recursive",
    "calls",
    "want",
    "completely",
    "clear",
    "perfect",
    "idea",
    "code",
    "want",
    "lost",
    "adding",
    "print",
    "statements",
    "looking",
    "small",
    "examples",
    "making",
    "sure",
    "working",
    "perfectly",
    "really",
    "helps",
    "let",
    "look",
    "quick",
    "sort",
    "action",
    "input",
    "expected",
    "output",
    "actual",
    "output",
    "match",
    "great",
    "evaluate",
    "test",
    "cases",
    "using",
    "evaluate",
    "test",
    "cases",
    "functions",
    "function",
    "jovian",
    "import",
    "python",
    "dsa",
    "evaluate",
    "test",
    "cases",
    "call",
    "evaluate",
    "test",
    "cases",
    "see",
    "passes",
    "test",
    "cases",
    "also",
    "notice",
    "marginally",
    "faster",
    "mer",
    "sort",
    "sorted",
    "lists",
    "sometimes",
    "may",
    "see",
    "yeah",
    "see",
    "see",
    "cases",
    "quick",
    "sort",
    "marginally",
    "faster",
    "merge",
    "sort",
    "larger",
    "list",
    "allocating",
    "new",
    "space",
    "okay",
    "coming",
    "time",
    "complexity",
    "quick",
    "sort",
    "assuming",
    "able",
    "good",
    "partition",
    "time",
    "time",
    "dividing",
    "list",
    "roughly",
    "equal",
    "halves",
    "roughly",
    "equal",
    "parts",
    "like",
    "start",
    "list",
    "size",
    "n",
    "partition",
    "n",
    "by2",
    "n",
    "by2",
    "sub",
    "problem",
    "tree",
    "looks",
    "like",
    "call",
    "quick",
    "sort",
    "two",
    "lists",
    "n",
    "by2",
    "n",
    "by2",
    "call",
    "quick",
    "sort",
    "four",
    "lists",
    "size",
    "n",
    "by2",
    "n",
    "by4",
    "n",
    "by4",
    "activity",
    "inside",
    "quick",
    "sort",
    "quick",
    "sort",
    "core",
    "operation",
    "partition",
    "right",
    "puts",
    "one",
    "element",
    "element",
    "right",
    "place",
    "element",
    "smaller",
    "left",
    "elements",
    "larger",
    "right",
    "partition",
    "actual",
    "work",
    "comparison",
    "swapping",
    "happens",
    "many",
    "comparisons",
    "perform",
    "partition",
    "would",
    "say",
    "number",
    "comparisons",
    "equal",
    "size",
    "actual",
    "list",
    "see",
    "see",
    "going",
    "comparing",
    "numbers",
    "like",
    "comparing",
    "number",
    "pivot",
    "number",
    "gets",
    "compared",
    "pivot",
    "exactly",
    "roughly",
    "means",
    "total",
    "n",
    "comparisons",
    "n",
    "size",
    "list",
    "okay",
    "n",
    "comparison",
    "partition",
    "partition",
    "performs",
    "n",
    "operations",
    "partition",
    "order",
    "n",
    "function",
    "height",
    "tree",
    "height",
    "tree",
    "log",
    "n",
    "go",
    "n",
    "one",
    "takes",
    "login",
    "steps",
    "keep",
    "going",
    "n",
    "by2",
    "n",
    "4",
    "n",
    "8",
    "n",
    "2",
    "log",
    "n",
    "becomes",
    "n",
    "n1",
    "time",
    "complexity",
    "quick",
    "sort",
    "login",
    "able",
    "partition",
    "array",
    "roughly",
    "equal",
    "parts",
    "happens",
    "average",
    "picking",
    "random",
    "pivots",
    "time",
    "end",
    "roughly",
    "equal",
    "parts",
    "maybe",
    "75",
    "35",
    "75",
    "25",
    "still",
    "less",
    "range",
    "quick",
    "sort",
    "complexity",
    "n",
    "login",
    "called",
    "average",
    "case",
    "complexity",
    "hand",
    "really",
    "bad",
    "partition",
    "really",
    "bad",
    "partition",
    "maybe",
    "picked",
    "smallest",
    "element",
    "pivot",
    "pick",
    "smallest",
    "element",
    "pivot",
    "elements",
    "go",
    "right",
    "pivot",
    "end",
    "calling",
    "quick",
    "sort",
    "problem",
    "size",
    "n",
    "minus",
    "one",
    "maybe",
    "pick",
    "smallest",
    "element",
    "pivot",
    "elements",
    "go",
    "right",
    "pivot",
    "end",
    "calling",
    "quick",
    "sort",
    "problem",
    "size",
    "n",
    "minus",
    "2",
    "unbalanced",
    "skew",
    "tree",
    "happens",
    "skew",
    "tree",
    "height",
    "time",
    "n",
    "see",
    "n",
    "n",
    "3",
    "going",
    "one",
    "height",
    "three",
    "n",
    "amount",
    "work",
    "involved",
    "partitioning",
    "run",
    "entire",
    "list",
    "partition",
    "list",
    "right",
    "case",
    "time",
    "complexity",
    "roughly",
    "n",
    "n",
    "1",
    "2",
    "time",
    "complexi",
    "order",
    "n",
    "square",
    "bad",
    "bad",
    "bubble",
    "sort",
    "despite",
    "quadratic",
    "worst",
    "case",
    "time",
    "complexity",
    "quick",
    "sort",
    "still",
    "preferred",
    "many",
    "situations",
    "really",
    "depends",
    "kind",
    "algorithm",
    "need",
    "use",
    "kind",
    "memory",
    "constraints",
    "quick",
    "sorts",
    "complexity",
    "closer",
    "end",
    "login",
    "practice",
    "especially",
    "good",
    "strategy",
    "picking",
    "pivot",
    "good",
    "strategy",
    "picking",
    "random",
    "pivot",
    "another",
    "one",
    "called",
    "picking",
    "median",
    "medians",
    "check",
    "well",
    "n",
    "login",
    "average",
    "time",
    "complexity",
    "quick",
    "sort",
    "n",
    "square",
    "worst",
    "case",
    "time",
    "complexity",
    "quick",
    "sort",
    "exercise",
    "verify",
    "quick",
    "sort",
    "requires",
    "order",
    "one",
    "additional",
    "space",
    "means",
    "really",
    "need",
    "copy",
    "ar",
    "create",
    "copy",
    "want",
    "affect",
    "test",
    "cases",
    "could",
    "removed",
    "line",
    "quick",
    "sort",
    "would",
    "work",
    "fine",
    "need",
    "create",
    "copy",
    "list",
    "array",
    "requires",
    "order",
    "one",
    "additional",
    "space",
    "space",
    "complexity",
    "also",
    "includes",
    "often",
    "size",
    "space",
    "required",
    "store",
    "input",
    "say",
    "quick",
    "sort",
    "space",
    "complexity",
    "order",
    "n",
    "okay",
    "get",
    "question",
    "space",
    "complexity",
    "may",
    "want",
    "ask",
    "talking",
    "additional",
    "space",
    "also",
    "want",
    "include",
    "input",
    "space",
    "complexity",
    "quick",
    "sort",
    "two",
    "sorting",
    "algorithms",
    "looked",
    "looked",
    "looked",
    "bubble",
    "sort",
    "looked",
    "insertion",
    "sort",
    "optimized",
    "using",
    "divide",
    "conquer",
    "got",
    "merge",
    "sort",
    "order",
    "n",
    "log",
    "n",
    "also",
    "space",
    "complexity",
    "additional",
    "space",
    "requirement",
    "order",
    "n",
    "avoided",
    "using",
    "quick",
    "sort",
    "uses",
    "order",
    "one",
    "additional",
    "space",
    "order",
    "square",
    "complexity",
    "worst",
    "case",
    "time",
    "complexity",
    "right",
    "choice",
    "pivot",
    "closer",
    "n",
    "login",
    "sorting",
    "see",
    "python",
    "expressive",
    "language",
    "sorting",
    "algorithms",
    "often",
    "quite",
    "confusing",
    "implement",
    "java",
    "actually",
    "pretty",
    "straightforward",
    "implement",
    "python",
    "need",
    "follow",
    "method",
    "state",
    "first",
    "plain",
    "english",
    "test",
    "cases",
    "ready",
    "test",
    "function",
    "write",
    "code",
    "carefully",
    "checking",
    "line",
    "errors",
    "create",
    "small",
    "functions",
    "wherever",
    "need",
    "try",
    "much",
    "logic",
    "one",
    "function",
    "good",
    "rule",
    "thumb",
    "7",
    "8",
    "lines",
    "code",
    "per",
    "function",
    "bigger",
    "toy",
    "problems",
    "also",
    "even",
    "software",
    "developer",
    "something",
    "try",
    "follow",
    "seven",
    "eight",
    "lines",
    "code",
    "function",
    "try",
    "split",
    "two",
    "functions",
    "okay",
    "way",
    "difficult",
    "go",
    "wrong",
    "let",
    "return",
    "original",
    "problem",
    "statement",
    "let",
    "read",
    "working",
    "new",
    "feature",
    "jovian",
    "called",
    "top",
    "notebook",
    "week",
    "top",
    "notebooks",
    "week",
    "write",
    "function",
    "sort",
    "list",
    "notebooks",
    "decreasing",
    "order",
    "likes",
    "keep",
    "mind",
    "millions",
    "notebooks",
    "created",
    "every",
    "week",
    "want",
    "build",
    "scale",
    "function",
    "needs",
    "efficient",
    "possible",
    "first",
    "need",
    "sort",
    "objects",
    "time",
    "numbers",
    "second",
    "also",
    "want",
    "sort",
    "decreasing",
    "order",
    "likes",
    "notebook",
    "okay",
    "need",
    "use",
    "merge",
    "sort",
    "quick",
    "sort",
    "techniques",
    "already",
    "discussed",
    "define",
    "com",
    "custom",
    "comparison",
    "function",
    "compare",
    "two",
    "notebooks",
    "okay",
    "let",
    "create",
    "class",
    "capture",
    "basic",
    "information",
    "notebooks",
    "class",
    "still",
    "following",
    "method",
    "speak",
    "right",
    "step",
    "one",
    "come",
    "input",
    "output",
    "format",
    "input",
    "format",
    "input",
    "format",
    "would",
    "using",
    "class",
    "create",
    "creating",
    "class",
    "notebook",
    "uh",
    "title",
    "username",
    "likes",
    "create",
    "class",
    "gets",
    "stored",
    "properties",
    "titles",
    "username",
    "likes",
    "also",
    "string",
    "represent",
    "ation",
    "create",
    "test",
    "cases",
    "creating",
    "test",
    "cases",
    "creating",
    "test",
    "cases",
    "nb0",
    "nb9",
    "let",
    "put",
    "list",
    "see",
    "list",
    "notebooks",
    "nb0",
    "nb9",
    "see",
    "string",
    "representation",
    "see",
    "first",
    "notebook",
    "aash",
    "basic",
    "373",
    "likes",
    "second",
    "one",
    "532",
    "likes",
    "clearly",
    "order",
    "terms",
    "likes",
    "next",
    "define",
    "custom",
    "comparison",
    "function",
    "comparing",
    "two",
    "notebooks",
    "return",
    "strings",
    "lesser",
    "equal",
    "greater",
    "establish",
    "order",
    "two",
    "objects",
    "okay",
    "return",
    "lesser",
    "nb1",
    "come",
    "position",
    "index",
    "lesser",
    "position",
    "nb2",
    "sorted",
    "list",
    "okay",
    "case",
    "problem",
    "means",
    "want",
    "sort",
    "things",
    "decreasing",
    "order",
    "likes",
    "first",
    "notebook",
    "highest",
    "number",
    "likes",
    "maybe",
    "second",
    "notebook",
    "second",
    "highest",
    "number",
    "likes",
    "third",
    "notebook",
    "lower",
    "number",
    "likes",
    "two",
    "notebooks",
    "nb1",
    "nb2",
    "nb1",
    "likes",
    "greater",
    "nb2",
    "likes",
    "nb1",
    "come",
    "lesser",
    "index",
    "okay",
    "return",
    "lesser",
    "come",
    "lower",
    "position",
    "sorted",
    "list",
    "return",
    "lesser",
    "want",
    "decreasing",
    "order",
    "nb1",
    "likes",
    "equal",
    "nb2",
    "likes",
    "return",
    "equal",
    "nb1",
    "likes",
    "less",
    "nb2",
    "likes",
    "means",
    "uh",
    "nb2",
    "like",
    "notebook",
    "nb1",
    "less",
    "like",
    "notebook",
    "nb1",
    "actually",
    "come",
    "greater",
    "position",
    "return",
    "greater",
    "okay",
    "comparison",
    "function",
    "return",
    "whether",
    "first",
    "input",
    "come",
    "show",
    "lesser",
    "position",
    "sorted",
    "list",
    "compared",
    "second",
    "input",
    "languages",
    "like",
    "java",
    "normally",
    "convention",
    "return",
    "negative",
    "number",
    "zero",
    "positive",
    "number",
    "find",
    "python",
    "allows",
    "return",
    "strings",
    "strings",
    "first",
    "class",
    "citizens",
    "python",
    "lot",
    "clearer",
    "debugging",
    "things",
    "face",
    "issues",
    "look",
    "actual",
    "strings",
    "also",
    "easier",
    "write",
    "write",
    "codee",
    "prefer",
    "using",
    "strings",
    "also",
    "use",
    "also",
    "use",
    "numbers",
    "like",
    "negative",
    "0",
    "positive",
    "totally",
    "implementation",
    "merge",
    "sort",
    "accepts",
    "custom",
    "comparison",
    "function",
    "let",
    "see",
    "merge",
    "sort",
    "function",
    "merge",
    "sort",
    "function",
    "uses",
    "takes",
    "list",
    "objects",
    "time",
    "list",
    "numbers",
    "also",
    "takes",
    "compare",
    "function",
    "default",
    "also",
    "provide",
    "default",
    "comparison",
    "still",
    "use",
    "numbers",
    "numbers",
    "default",
    "assumption",
    "want",
    "sorting",
    "want",
    "sorting",
    "increasing",
    "order",
    "default",
    "sorting",
    "looks",
    "like",
    "numbers",
    "pretty",
    "straightforward",
    "also",
    "pass",
    "custom",
    "comparison",
    "function",
    "terminating",
    "condition",
    "length",
    "less",
    "two",
    "simply",
    "return",
    "list",
    "get",
    "mid",
    "index",
    "call",
    "merge",
    "sort",
    "left",
    "half",
    "custom",
    "comparison",
    "function",
    "call",
    "merge",
    "sort",
    "right",
    "half",
    "custom",
    "comparison",
    "function",
    "call",
    "merge",
    "custom",
    "comparison",
    "function",
    "happens",
    "inside",
    "merge",
    "inside",
    "merge",
    "earlier",
    "know",
    "two",
    "halves",
    "left",
    "right",
    "custom",
    "comparison",
    "function",
    "create",
    "pointers",
    "two",
    "also",
    "create",
    "final",
    "result",
    "list",
    "merged",
    "iterate",
    "left",
    "list",
    "right",
    "list",
    "u",
    "going",
    "compare",
    "left",
    "element",
    "right",
    "el",
    "element",
    "calling",
    "compare",
    "greater",
    "less",
    "comparison",
    "calling",
    "compare",
    "result",
    "element",
    "left",
    "lesser",
    "equal",
    "element",
    "right",
    "append",
    "result",
    "array",
    "increment",
    "left",
    "counter",
    "otherwise",
    "lesser",
    "equal",
    "means",
    "element",
    "left",
    "first",
    "element",
    "left",
    "show",
    "lower",
    "position",
    "sorted",
    "final",
    "sorted",
    "list",
    "append",
    "first",
    "append",
    "right",
    "child",
    "right",
    "element",
    "increment",
    "right",
    "pointer",
    "finally",
    "attach",
    "remaining",
    "elements",
    "something",
    "review",
    "something",
    "covered",
    "lot",
    "detail",
    "let",
    "see",
    "let",
    "call",
    "merge",
    "sort",
    "notebooks",
    "let",
    "check",
    "notebooks",
    "sorted",
    "likes",
    "indeed",
    "see",
    "position",
    "zero",
    "notebook",
    "highest",
    "number",
    "likes",
    "next",
    "one",
    "next",
    "one",
    "since",
    "written",
    "generic",
    "merch",
    "sort",
    "function",
    "works",
    "compare",
    "function",
    "quickly",
    "use",
    "sort",
    "notebooks",
    "title",
    "well",
    "maybe",
    "number",
    "views",
    "per",
    "notebook",
    "number",
    "versions",
    "notebook",
    "number",
    "comments",
    "notebook",
    "could",
    "sorting",
    "well",
    "could",
    "even",
    "use",
    "hybrid",
    "example",
    "taking",
    "comparing",
    "titles",
    "nb1",
    "nb2",
    "simple",
    "comparison",
    "strings",
    "also",
    "compared",
    "using",
    "comparison",
    "operators",
    "nb1",
    "title",
    "less",
    "nb2",
    "title",
    "return",
    "lesser",
    "otherwise",
    "return",
    "equal",
    "greater",
    "able",
    "sort",
    "ascending",
    "order",
    "titles",
    "see",
    "n",
    "c",
    "c",
    "f",
    "e",
    "l",
    "l",
    "py",
    "py",
    "okay",
    "py",
    "h",
    "py",
    "h",
    "py",
    "p",
    "torch",
    "okay",
    "order",
    "sorted",
    "order",
    "titles",
    "exercise",
    "sort",
    "order",
    "username",
    "title",
    "means",
    "first",
    "compare",
    "username",
    "usernames",
    "equal",
    "compare",
    "titles",
    "compare",
    "probably",
    "write",
    "another",
    "comparison",
    "function",
    "compare",
    "username",
    "titles",
    "use",
    "two",
    "level",
    "comparison",
    "use",
    "sorting",
    "okay",
    "another",
    "exercise",
    "going",
    "forward",
    "implement",
    "test",
    "generic",
    "versions",
    "bubble",
    "sort",
    "insertion",
    "sort",
    "quick",
    "sort",
    "using",
    "empty",
    "cells",
    "given",
    "right",
    "point",
    "course",
    "start",
    "writing",
    "code",
    "writing",
    "maybe",
    "solving",
    "one",
    "problem",
    "every",
    "day",
    "really",
    "practice",
    "concepts",
    "internalize",
    "also",
    "problem",
    "work",
    "notebook",
    "create",
    "save",
    "commit",
    "show",
    "also",
    "create",
    "new",
    "notebooks",
    "one",
    "way",
    "create",
    "new",
    "notebooks",
    "go",
    "jovian",
    "click",
    "new",
    "button",
    "click",
    "blank",
    "notebook",
    "give",
    "title",
    "let",
    "say",
    "quick",
    "sort",
    "generic",
    "set",
    "privacy",
    "create",
    "notebook",
    "creates",
    "notebook",
    "click",
    "run",
    "button",
    "run",
    "one",
    "way",
    "another",
    "way",
    "given",
    "problem",
    "solving",
    "template",
    "come",
    "back",
    "lesson",
    "page",
    "find",
    "problem",
    "solving",
    "template",
    "click",
    "problem",
    "solving",
    "template",
    "click",
    "duplicate",
    "create",
    "copy",
    "notebook",
    "profile",
    "let",
    "profile",
    "click",
    "run",
    "run",
    "binder",
    "even",
    "run",
    "locally",
    "computer",
    "make",
    "changes",
    "come",
    "back",
    "run",
    "commit",
    "end",
    "link",
    "share",
    "go",
    "twitter",
    "share",
    "link",
    "write",
    "tweet",
    "uh",
    "tag",
    "us",
    "also",
    "use",
    "60",
    "days",
    "python",
    "okay",
    "maybe",
    "say",
    "quick",
    "sort",
    "algorithm",
    "generic",
    "objects",
    "tweet",
    "retweet",
    "tweet",
    "want",
    "support",
    "everybody",
    "taking",
    "part",
    "course",
    "course",
    "page",
    "find",
    "link",
    "course",
    "community",
    "forum",
    "go",
    "ask",
    "questions",
    "questions",
    "even",
    "discuss",
    "ideas",
    "discussed",
    "exercises",
    "shared",
    "go",
    "lesson",
    "three",
    "instance",
    "create",
    "new",
    "topic",
    "maybe",
    "want",
    "talk",
    "generic",
    "implementation",
    "quick",
    "sort",
    "maybe",
    "create",
    "new",
    "topic",
    "post",
    "query",
    "able",
    "make",
    "work",
    "post",
    "notebook",
    "ask",
    "question",
    "discussion",
    "helping",
    "people",
    "answering",
    "people",
    "questions",
    "written",
    "really",
    "great",
    "posts",
    "links",
    "problems",
    "shared",
    "check",
    "links",
    "links",
    "try",
    "problems",
    "make",
    "submissions",
    "solve",
    "problems",
    "interview",
    "questions",
    "well",
    "check",
    "results",
    "correct",
    "use",
    "solving",
    "problem",
    "solving",
    "template",
    "starting",
    "point",
    "shared",
    "starter",
    "notebook",
    "assignment",
    "assignment",
    "need",
    "run",
    "notebook",
    "run",
    "binder",
    "instance",
    "question",
    "mark",
    "bunch",
    "places",
    "find",
    "like",
    "question",
    "marks",
    "text",
    "find",
    "question",
    "marks",
    "code",
    "simply",
    "need",
    "put",
    "code",
    "answers",
    "question",
    "marks",
    "replace",
    "code",
    "see",
    "question",
    "marks",
    "replace",
    "step",
    "step",
    "instructions",
    "guide",
    "comments",
    "guide",
    "step",
    "step",
    "solve",
    "finally",
    "also",
    "make",
    "submission",
    "right",
    "end",
    "run",
    "code",
    "also",
    "able",
    "submit",
    "directly",
    "make",
    "submission",
    "assignment",
    "get",
    "automated",
    "get",
    "evaluated",
    "automated",
    "fashion",
    "instantly",
    "get",
    "pass",
    "fail",
    "grade",
    "get",
    "pass",
    "grade",
    "great",
    "get",
    "fail",
    "grade",
    "also",
    "get",
    "comments",
    "went",
    "wrong",
    "solution",
    "use",
    "comments",
    "fix",
    "issues",
    "great",
    "way",
    "get",
    "quick",
    "feedback",
    "keep",
    "fixing",
    "issues",
    "uh",
    "especially",
    "watch",
    "edge",
    "cases",
    "assignment",
    "one",
    "assignment",
    "two",
    "called",
    "hash",
    "tables",
    "python",
    "dictionaries",
    "interesting",
    "assignment",
    "going",
    "implement",
    "hash",
    "tables",
    "power",
    "python",
    "dictionaries",
    "scratch",
    "python",
    "also",
    "replicate",
    "interface",
    "python",
    "dictionaries",
    "check",
    "interesting",
    "assignment",
    "similar",
    "format",
    "find",
    "question",
    "marks",
    "certain",
    "places",
    "need",
    "replace",
    "appropriate",
    "values",
    "expressions",
    "statements",
    "way",
    "working",
    "step",
    "step",
    "see",
    "working",
    "implement",
    "hash",
    "functions",
    "hash",
    "tables",
    "commonly",
    "asked",
    "interviews",
    "well",
    "important",
    "assignment",
    "interview",
    "preparation",
    "coding",
    "assessment",
    "preparation",
    "well",
    "also",
    "teaches",
    "lot",
    "really",
    "good",
    "practices",
    "python",
    "programming",
    "particular",
    "check",
    "assignment",
    "2",
    "well",
    "send",
    "email",
    "soon",
    "assignment",
    "3",
    "ready",
    "check",
    "back",
    "couple",
    "days",
    "see",
    "page",
    "python",
    "next",
    "review",
    "lecture",
    "video",
    "execute",
    "jupiter",
    "notebook",
    "use",
    "interactive",
    "nature",
    "jupiter",
    "experiment",
    "code",
    "complete",
    "assignment",
    "attempt",
    "optional",
    "questions",
    "well",
    "assignment",
    "required",
    "questions",
    "make",
    "submission",
    "soon",
    "done",
    "required",
    "questions",
    "optional",
    "questions",
    "slightly",
    "harder",
    "highly",
    "recommend",
    "improve",
    "understanding",
    "give",
    "practice",
    "help",
    "internalize",
    "concepts",
    "better",
    "participate",
    "forum",
    "discussions",
    "join",
    "start",
    "study",
    "group",
    "great",
    "way",
    "learn",
    "get",
    "together",
    "friends",
    "maybe",
    "watch",
    "lecture",
    "together",
    "zoom",
    "call",
    "pause",
    "video",
    "discussions",
    "wherever",
    "doubts",
    "discussion",
    "great",
    "way",
    "solve",
    "specific",
    "doubts",
    "may",
    "also",
    "help",
    "articulate",
    "understanding",
    "better",
    "explain",
    "others",
    "also",
    "answer",
    "lot",
    "questions",
    "please",
    "data",
    "structures",
    "algorithms",
    "python",
    "thank",
    "good",
    "day",
    "good",
    "night",
    "hello",
    "welcome",
    "data",
    "structures",
    "algorithms",
    "python",
    "live",
    "online",
    "certification",
    "course",
    "organized",
    "jovian",
    "today",
    "lesson",
    "four",
    "recursion",
    "memorization",
    "dynamic",
    "programming",
    "name",
    "akash",
    "instructor",
    "find",
    "twitter",
    "akash",
    "nes",
    "follow",
    "along",
    "course",
    "complete",
    "weekly",
    "assignments",
    "also",
    "earn",
    "certificate",
    "accomplishment",
    "add",
    "linkedin",
    "profile",
    "find",
    "hosted",
    "jovian",
    "profile",
    "well",
    "let",
    "get",
    "started",
    "data",
    "structures",
    "algorithms",
    "course",
    "python",
    "1",
    "two",
    "today",
    "lesson",
    "four",
    "let",
    "open",
    "lesson",
    "4",
    "topic",
    "recursion",
    "dynamic",
    "programming",
    "find",
    "recording",
    "lesson",
    "also",
    "watch",
    "version",
    "hindi",
    "would",
    "prefer",
    "lecture",
    "cover",
    "recursion",
    "memorization",
    "dynamic",
    "programming",
    "looking",
    "two",
    "common",
    "problems",
    "dynamic",
    "programming",
    "longest",
    "common",
    "subsequence",
    "problem",
    "napsack",
    "problem",
    "coding",
    "problems",
    "live",
    "using",
    "problem",
    "solving",
    "template",
    "using",
    "one",
    "one",
    "way",
    "another",
    "since",
    "lesson",
    "one",
    "let",
    "open",
    "problem",
    "solving",
    "template",
    "template",
    "use",
    "solve",
    "coding",
    "problem",
    "illustrate",
    "solving",
    "two",
    "problems",
    "using",
    "template",
    "today",
    "first",
    "thing",
    "need",
    "run",
    "template",
    "see",
    "explanation",
    "code",
    "well",
    "run",
    "code",
    "two",
    "options",
    "run",
    "using",
    "free",
    "online",
    "resources",
    "run",
    "computer",
    "simplest",
    "way",
    "run",
    "click",
    "run",
    "button",
    "select",
    "run",
    "binder",
    "one",
    "click",
    "set",
    "machine",
    "cloud",
    "start",
    "jupiter",
    "notebook",
    "server",
    "able",
    "execute",
    "code",
    "modify",
    "notebook",
    "save",
    "version",
    "profile",
    "continue",
    "working",
    "running",
    "jupiter",
    "hub",
    "server",
    "going",
    "zoom",
    "bit",
    "see",
    "things",
    "clearly",
    "okay",
    "problem",
    "solving",
    "template",
    "said",
    "working",
    "two",
    "problems",
    "problem",
    "statements",
    "listed",
    "see",
    "first",
    "problem",
    "longest",
    "common",
    "sub",
    "subsequence",
    "listed",
    "part",
    "lesson",
    "notebook",
    "lesson",
    "page",
    "well",
    "find",
    "link",
    "problem",
    "statement",
    "lesson",
    "page",
    "two",
    "let",
    "first",
    "modify",
    "title",
    "notebook",
    "problem",
    "solving",
    "template",
    "let",
    "change",
    "title",
    "dynamic",
    "programming",
    "longest",
    "common",
    "subsequence",
    "let",
    "get",
    "rid",
    "think",
    "need",
    "uh",
    "going",
    "keep",
    "section",
    "run",
    "code",
    "share",
    "notebook",
    "somebody",
    "else",
    "way",
    "run",
    "start",
    "assignment",
    "problem",
    "let",
    "save",
    "profile",
    "going",
    "give",
    "name",
    "longest",
    "common",
    "subsequence",
    "appropriate",
    "name",
    "going",
    "give",
    "project",
    "name",
    "install",
    "jovian",
    "python",
    "library",
    "run",
    "commit",
    "started",
    "template",
    "editing",
    "template",
    "running",
    "saved",
    "copy",
    "template",
    "profile",
    "see",
    "link",
    "able",
    "access",
    "notebook",
    "run",
    "continue",
    "work",
    "jupyter",
    "notebook",
    "shuts",
    "want",
    "continue",
    "tomorrow",
    "instance",
    "okay",
    "let",
    "look",
    "problem",
    "statement",
    "copy",
    "problem",
    "statement",
    "well",
    "see",
    "directly",
    "within",
    "notebook",
    "paste",
    "problem",
    "statement",
    "getting",
    "problem",
    "statement",
    "source",
    "always",
    "good",
    "idea",
    "include",
    "link",
    "original",
    "source",
    "well",
    "okay",
    "problem",
    "statement",
    "front",
    "us",
    "question",
    "write",
    "function",
    "find",
    "length",
    "longest",
    "common",
    "subsequence",
    "new",
    "term",
    "unpack",
    "two",
    "sequences",
    "let",
    "first",
    "learn",
    "mean",
    "sequence",
    "sequence",
    "group",
    "items",
    "deterministic",
    "ordering",
    "instance",
    "list",
    "tuple",
    "range",
    "even",
    "string",
    "common",
    "sequence",
    "types",
    "p",
    "string",
    "serendipitous",
    "group",
    "items",
    "also",
    "contains",
    "order",
    "see",
    "e",
    "comes",
    "r",
    "comes",
    "e",
    "sequence",
    "list",
    "would",
    "also",
    "sequence",
    "would",
    "list",
    "numbers",
    "sequence",
    "looking",
    "subsequence",
    "subsequence",
    "subsequence",
    "sequence",
    "obtained",
    "deleting",
    "removing",
    "zero",
    "elements",
    "another",
    "sequence",
    "instance",
    "look",
    "serend",
    "deus",
    "remove",
    "characters",
    "r",
    "e",
    "n",
    "us",
    "left",
    "edpt",
    "edpt",
    "subsequence",
    "serendipitous",
    "two",
    "things",
    "note",
    "edpt",
    "occur",
    "continuously",
    "elements",
    "occur",
    "anywhere",
    "within",
    "sequence",
    "order",
    "edpt",
    "occur",
    "particular",
    "order",
    "edpt",
    "occur",
    "model",
    "occur",
    "e",
    "p",
    "occur",
    "occur",
    "p",
    "two",
    "requirements",
    "edpt",
    "subsequence",
    "serendipitous",
    "visually",
    "speaking",
    "see",
    "take",
    "sequence",
    "draw",
    "boxes",
    "around",
    "characters",
    "elements",
    "sequence",
    "take",
    "elements",
    "boxes",
    "order",
    "end",
    "subsequence",
    "understand",
    "sequence",
    "subsequence",
    "question",
    "asked",
    "interview",
    "sure",
    "mean",
    "longest",
    "common",
    "subsequence",
    "even",
    "sequence",
    "ask",
    "interviewer",
    "mean",
    "subsequence",
    "mean",
    "sequence",
    "happy",
    "tell",
    "important",
    "communicate",
    "whatever",
    "thinking",
    "whatever",
    "questions",
    "contrary",
    "might",
    "think",
    "asking",
    "questions",
    "actually",
    "good",
    "thing",
    "questions",
    "ask",
    "appreciated",
    "okay",
    "talked",
    "sequence",
    "subsequence",
    "common",
    "subsequence",
    "look",
    "two",
    "strings",
    "serendipitous",
    "precipitation",
    "pick",
    "elements",
    "boxes",
    "r",
    "e",
    "p",
    "see",
    "rei",
    "p",
    "subsequence",
    "serendipitous",
    "e",
    "p",
    "also",
    "subsequence",
    "precipitation",
    "sub",
    "sub",
    "sequence",
    "common",
    "subsequence",
    "sequences",
    "called",
    "common",
    "subsequence",
    "p",
    "common",
    "subsequence",
    "serendipitous",
    "precipitation",
    "many",
    "common",
    "subsequences",
    "instance",
    "could",
    "look",
    "would",
    "common",
    "subsequence",
    "could",
    "look",
    "would",
    "common",
    "subsequence",
    "well",
    "picked",
    "n",
    "could",
    "also",
    "pick",
    "n",
    "n",
    "would",
    "also",
    "common",
    "subsequence",
    "two",
    "longest",
    "common",
    "subsequence",
    "name",
    "suggests",
    "subsequence",
    "common",
    "subsequence",
    "two",
    "sequences",
    "maximum",
    "possible",
    "length",
    "verify",
    "try",
    "different",
    "subsequences",
    "see",
    "rei",
    "p",
    "longest",
    "common",
    "subsequence",
    "two",
    "strings",
    "two",
    "sequences",
    "length",
    "seven",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "write",
    "function",
    "find",
    "length",
    "longest",
    "common",
    "subsequence",
    "two",
    "sequences",
    "question",
    "visual",
    "example",
    "tells",
    "answer",
    "okay",
    "question",
    "understood",
    "question",
    "start",
    "applying",
    "method",
    "learning",
    "throughout",
    "systematic",
    "strategy",
    "apply",
    "nothing",
    "method",
    "changed",
    "since",
    "first",
    "lesson",
    "even",
    "though",
    "covered",
    "whole",
    "variety",
    "topics",
    "like",
    "binary",
    "search",
    "binary",
    "search",
    "trees",
    "sorting",
    "algorithms",
    "divide",
    "conquer",
    "method",
    "remained",
    "first",
    "step",
    "state",
    "problem",
    "clearly",
    "identify",
    "input",
    "output",
    "formats",
    "second",
    "step",
    "come",
    "example",
    "inputs",
    "outputs",
    "used",
    "test",
    "solutions",
    "try",
    "cover",
    "edge",
    "cases",
    "help",
    "us",
    "write",
    "code",
    "correct",
    "anticipating",
    "errors",
    "might",
    "face",
    "come",
    "correct",
    "solution",
    "problem",
    "stated",
    "plain",
    "english",
    "important",
    "state",
    "problem",
    "plain",
    "english",
    "start",
    "coding",
    "communicate",
    "ideas",
    "also",
    "make",
    "clear",
    "express",
    "implement",
    "solution",
    "test",
    "using",
    "example",
    "inputs",
    "fix",
    "bugs",
    "find",
    "able",
    "find",
    "bugs",
    "written",
    "good",
    "test",
    "cases",
    "analyze",
    "algorithm",
    "complexity",
    "identify",
    "efficiencies",
    "likely",
    "first",
    "solution",
    "come",
    "optimal",
    "correct",
    "inefficiency",
    "important",
    "go",
    "process",
    "first",
    "finding",
    "brute",
    "force",
    "solution",
    "finding",
    "inefficiency",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "repeat",
    "steps",
    "3",
    "six",
    "identif",
    "right",
    "technique",
    "case",
    "learn",
    "couple",
    "techniques",
    "called",
    "memorization",
    "dynamic",
    "programming",
    "go",
    "back",
    "state",
    "correct",
    "solution",
    "implement",
    "solution",
    "test",
    "analyze",
    "scope",
    "improvement",
    "otherwise",
    "say",
    "arrived",
    "optimal",
    "good",
    "enough",
    "optimal",
    "enough",
    "solution",
    "okay",
    "hope",
    "point",
    "started",
    "memorize",
    "process",
    "keep",
    "repeating",
    "become",
    "second",
    "nature",
    "every",
    "time",
    "see",
    "problem",
    "first",
    "thing",
    "state",
    "problem",
    "clearly",
    "identify",
    "input",
    "output",
    "formats",
    "problem",
    "already",
    "stated",
    "clearly",
    "enough",
    "let",
    "state",
    "slightly",
    "clearly",
    "let",
    "say",
    "given",
    "write",
    "words",
    "important",
    "whatever",
    "clear",
    "given",
    "two",
    "sequences",
    "need",
    "find",
    "length",
    "longest",
    "common",
    "subsequence",
    "simple",
    "enough",
    "two",
    "inputs",
    "decide",
    "input",
    "output",
    "formats",
    "sequence",
    "one",
    "sequence",
    "example",
    "serendipitous",
    "sequence",
    "2",
    "another",
    "sequence",
    "example",
    "precipitation",
    "great",
    "two",
    "inputs",
    "require",
    "output",
    "would",
    "length",
    "longest",
    "common",
    "subsequence",
    "let",
    "abbreviate",
    "lcs",
    "case",
    "know",
    "subsequence",
    "looks",
    "like",
    "seen",
    "based",
    "create",
    "see",
    "problem",
    "created",
    "um",
    "talk",
    "next",
    "thing",
    "double",
    "click",
    "texell",
    "start",
    "editing",
    "using",
    "language",
    "called",
    "markdown",
    "see",
    "creates",
    "block",
    "quote",
    "creates",
    "bold",
    "font",
    "creates",
    "cod",
    "like",
    "font",
    "let",
    "see",
    "know",
    "way",
    "go",
    "back",
    "display",
    "mode",
    "press",
    "shift",
    "plus",
    "enter",
    "see",
    "problem",
    "block",
    "code",
    "styling",
    "markdown",
    "really",
    "useful",
    "easy",
    "learn",
    "language",
    "formatting",
    "text",
    "especially",
    "jupyter",
    "notebooks",
    "learn",
    "based",
    "create",
    "signature",
    "function",
    "function",
    "len",
    "lcs",
    "accept",
    "sequence",
    "sequence",
    "one",
    "sequence",
    "2",
    "return",
    "something",
    "okay",
    "basic",
    "signature",
    "function",
    "even",
    "though",
    "much",
    "establishing",
    "arguments",
    "first",
    "step",
    "towards",
    "solving",
    "problem",
    "let",
    "save",
    "work",
    "time",
    "time",
    "important",
    "keep",
    "saving",
    "work",
    "jovian",
    "running",
    "free",
    "online",
    "service",
    "shut",
    "minutes",
    "inactivity",
    "run",
    "save",
    "notebook",
    "profile",
    "rerun",
    "okay",
    "next",
    "step",
    "come",
    "example",
    "inputs",
    "outputs",
    "need",
    "try",
    "cover",
    "edge",
    "cases",
    "written",
    "test",
    "cases",
    "already",
    "common",
    "case",
    "general",
    "case",
    "string",
    "like",
    "serendipitous",
    "precipitation",
    "common",
    "case",
    "one",
    "common",
    "elements",
    "subsequence",
    "common",
    "subsequence",
    "length",
    "7",
    "may",
    "also",
    "want",
    "test",
    "another",
    "type",
    "data",
    "one",
    "nice",
    "things",
    "python",
    "write",
    "functions",
    "operate",
    "particular",
    "class",
    "sub",
    "classes",
    "kind",
    "data",
    "long",
    "satisfies",
    "certain",
    "criteria",
    "instance",
    "strings",
    "list",
    "allow",
    "indexing",
    "picking",
    "element",
    "nth",
    "element",
    "sequence",
    "sequences",
    "function",
    "able",
    "work",
    "strings",
    "lists",
    "another",
    "case",
    "two",
    "sequences",
    "common",
    "subsequence",
    "function",
    "throw",
    "error",
    "gracefully",
    "return",
    "number",
    "zero",
    "empty",
    "sequence",
    "subsequence",
    "every",
    "sequence",
    "make",
    "sense",
    "think",
    "case",
    "common",
    "subsequence",
    "empty",
    "sequence",
    "common",
    "subsequence",
    "answer",
    "zero",
    "one",
    "extreme",
    "case",
    "one",
    "subsequence",
    "another",
    "case",
    "one",
    "sequence",
    "empty",
    "another",
    "case",
    "sequences",
    "empty",
    "important",
    "otherwise",
    "might",
    "miss",
    "certain",
    "special",
    "cases",
    "face",
    "error",
    "code",
    "solution",
    "finally",
    "also",
    "case",
    "multiple",
    "subsequences",
    "length",
    "instance",
    "b",
    "c",
    "ef",
    "b",
    "cf",
    "e",
    "c",
    "e",
    "c",
    "e",
    "one",
    "long",
    "subsequence",
    "length",
    "three",
    "longest",
    "verify",
    "bdf",
    "another",
    "subsequence",
    "common",
    "two",
    "also",
    "length",
    "test",
    "cases",
    "let",
    "copy",
    "test",
    "cases",
    "interview",
    "coding",
    "assessment",
    "might",
    "want",
    "write",
    "comments",
    "single",
    "coding",
    "screen",
    "try",
    "list",
    "least",
    "four",
    "five",
    "go",
    "far",
    "also",
    "help",
    "streamline",
    "solution",
    "always",
    "something",
    "appreciated",
    "interviewers",
    "let",
    "let",
    "get",
    "let",
    "copy",
    "test",
    "cases",
    "think",
    "ideas",
    "things",
    "test",
    "come",
    "right",
    "number",
    "tests",
    "whatever",
    "takes",
    "feel",
    "confident",
    "need",
    "okay",
    "done",
    "taken",
    "test",
    "cases",
    "converted",
    "dictionaries",
    "see",
    "first",
    "sequence",
    "sequence",
    "one",
    "remember",
    "written",
    "written",
    "names",
    "inputs",
    "signature",
    "function",
    "create",
    "test",
    "cases",
    "dictionary",
    "test",
    "easily",
    "sequence",
    "one",
    "sequence",
    "2",
    "input",
    "subd",
    "dictionary",
    "inside",
    "main",
    "test",
    "case",
    "dictionary",
    "output",
    "output",
    "function",
    "seven",
    "verify",
    "general",
    "case",
    "another",
    "case",
    "case",
    "uh",
    "two",
    "sequences",
    "lists",
    "numbers",
    "case",
    "output",
    "expect",
    "five",
    "another",
    "general",
    "case",
    "longest",
    "stone",
    "case",
    "verify",
    "n",
    "e",
    "common",
    "subsequence",
    "output",
    "three",
    "two",
    "sequences",
    "common",
    "elements",
    "come",
    "left",
    "half",
    "keyboard",
    "come",
    "right",
    "half",
    "keyboard",
    "quick",
    "way",
    "generate",
    "two",
    "sequences",
    "dense",
    "condensed",
    "see",
    "dense",
    "actually",
    "piece",
    "inside",
    "condensed",
    "special",
    "case",
    "dense",
    "continuous",
    "substring",
    "string",
    "uh",
    "even",
    "would",
    "still",
    "subsequence",
    "de",
    "occur",
    "order",
    "one",
    "example",
    "case",
    "sequence",
    "one",
    "longest",
    "common",
    "subsequence",
    "length",
    "five",
    "case",
    "one",
    "sequences",
    "empty",
    "see",
    "case",
    "output",
    "zero",
    "sequences",
    "empty",
    "case",
    "multiple",
    "longest",
    "common",
    "subsequences",
    "even",
    "case",
    "function",
    "able",
    "figure",
    "answer",
    "correctly",
    "let",
    "take",
    "let",
    "us",
    "copy",
    "test",
    "cases",
    "t0",
    "t7",
    "eight",
    "test",
    "cases",
    "add",
    "test",
    "cases",
    "please",
    "feel",
    "free",
    "coming",
    "good",
    "test",
    "cases",
    "skill",
    "develop",
    "also",
    "put",
    "test",
    "cases",
    "function",
    "called",
    "lcs",
    "longest",
    "common",
    "subsequent",
    "tests",
    "easily",
    "available",
    "testing",
    "okay",
    "okay",
    "next",
    "step",
    "come",
    "correct",
    "solution",
    "problem",
    "seen",
    "problem",
    "identified",
    "scenarios",
    "need",
    "come",
    "simple",
    "correct",
    "solution",
    "stated",
    "plain",
    "english",
    "efficient",
    "correct",
    "one",
    "idea",
    "one",
    "idea",
    "see",
    "couple",
    "sequences",
    "let",
    "create",
    "two",
    "counters",
    "idx1",
    "idx",
    "2",
    "starting",
    "zero",
    "idx1",
    "pointer",
    "start",
    "tracking",
    "elements",
    "first",
    "sequence",
    "id",
    "x2",
    "pointer",
    "start",
    "tracking",
    "elements",
    "second",
    "sequence",
    "write",
    "recursive",
    "function",
    "write",
    "recursive",
    "function",
    "compute",
    "lcs",
    "sequence",
    "one",
    "idx",
    "idx1",
    "end",
    "sequence",
    "2",
    "id",
    "x2",
    "end",
    "mean",
    "uh",
    "let",
    "say",
    "idx1",
    "value",
    "three",
    "idx",
    "2",
    "value",
    "1",
    "see",
    "0",
    "1",
    "2",
    "3",
    "sequence",
    "one",
    "idx1",
    "onwards",
    "l",
    "og",
    "sequence",
    "2",
    "idx",
    "uh",
    "idx",
    "2",
    "onwards",
    "l",
    "ch",
    "e",
    "looking",
    "portion",
    "problem",
    "portion",
    "problem",
    "recursive",
    "function",
    "invoked",
    "idx1",
    "id",
    "x2",
    "return",
    "length",
    "longest",
    "common",
    "subsequence",
    "two",
    "portions",
    "l",
    "og",
    "lcem",
    "need",
    "longest",
    "common",
    "subsequence",
    "entire",
    "string",
    "logic",
    "writing",
    "recursive",
    "function",
    "theoretically",
    "compute",
    "subsequence",
    "position",
    "onwards",
    "sequence",
    "one",
    "idx1",
    "idx1",
    "pointing",
    "l",
    "id",
    "x2",
    "pointing",
    "l",
    "well",
    "sequence",
    "one",
    "idx1",
    "sequence",
    "2",
    "id",
    "x2",
    "equal",
    "character",
    "l",
    "belongs",
    "lcs",
    "portion",
    "portion",
    "okay",
    "think",
    "makes",
    "sense",
    "uh",
    "elements",
    "equal",
    "pick",
    "longest",
    "common",
    "subsequence",
    "pick",
    "longest",
    "common",
    "subsequence",
    "remaining",
    "always",
    "add",
    "l",
    "subsequence",
    "make",
    "subsequence",
    "longer",
    "right",
    "way",
    "follows",
    "l",
    "always",
    "occur",
    "longest",
    "common",
    "subsequence",
    "l",
    "g",
    "lch",
    "em",
    "okay",
    "know",
    "occur",
    "l",
    "occur",
    "longest",
    "common",
    "subsequence",
    "length",
    "longest",
    "length",
    "uh",
    "longest",
    "common",
    "subsequence",
    "length",
    "longest",
    "common",
    "subsequence",
    "ogy",
    "chem",
    "1",
    "okay",
    "see",
    "recursion",
    "required",
    "say",
    "sequence",
    "one",
    "idx1",
    "sequence",
    "2",
    "id",
    "x2",
    "equal",
    "simply",
    "call",
    "recursive",
    "function",
    "sequence",
    "one",
    "idx1",
    "1",
    "og",
    "sequence",
    "2",
    "id",
    "x2",
    "1",
    "ch",
    "em",
    "assume",
    "recursion",
    "give",
    "us",
    "solution",
    "simply",
    "add",
    "one",
    "equal",
    "okay",
    "one",
    "case",
    "sequence",
    "one",
    "idx1",
    "sequence",
    "one",
    "id2",
    "equal",
    "great",
    "equal",
    "case",
    "instance",
    "see",
    "idx1",
    "id",
    "x2",
    "zero",
    "idx1",
    "points",
    "idx",
    "2",
    "points",
    "b",
    "equal",
    "one",
    "two",
    "things",
    "hold",
    "either",
    "occur",
    "longest",
    "common",
    "sub",
    "sequence",
    "two",
    "strings",
    "b",
    "occur",
    "longest",
    "common",
    "subsequence",
    "two",
    "strings",
    "know",
    "one",
    "power",
    "recursion",
    "try",
    "simply",
    "ignore",
    "get",
    "longest",
    "common",
    "subsequence",
    "bent",
    "b",
    "est",
    "check",
    "length",
    "simply",
    "ignore",
    "b",
    "get",
    "longest",
    "common",
    "subsequence",
    "n",
    "est",
    "est",
    "check",
    "length",
    "whichever",
    "longer",
    "length",
    "becomes",
    "solution",
    "two",
    "strings",
    "okay",
    "looks",
    "like",
    "start",
    "analogy",
    "alchemy",
    "compare",
    "two",
    "equal",
    "know",
    "longest",
    "common",
    "subsequence",
    "one",
    "length",
    "1",
    "plus",
    "lcs",
    "analogy",
    "lemi",
    "okay",
    "compare",
    "n",
    "l",
    "see",
    "equal",
    "either",
    "n",
    "come",
    "longest",
    "common",
    "subsequence",
    "l",
    "come",
    "longest",
    "common",
    "subsequence",
    "try",
    "remove",
    "n",
    "see",
    "l",
    "og",
    "g",
    "remove",
    "l",
    "see",
    "ch",
    "emy",
    "l",
    "unequal",
    "either",
    "occur",
    "lcs",
    "two",
    "strings",
    "l",
    "occur",
    "lcs",
    "two",
    "strings",
    "occur",
    "lcs",
    "remove",
    "try",
    "l",
    "occur",
    "lcs",
    "remove",
    "l",
    "try",
    "get",
    "match",
    "case",
    "know",
    "l",
    "occurs",
    "longest",
    "common",
    "subsequence",
    "two",
    "elements",
    "get",
    "lcs",
    "ogy",
    "chemy",
    "okay",
    "know",
    "recursive",
    "calls",
    "complete",
    "see",
    "entire",
    "tree",
    "pans",
    "see",
    "time",
    "either",
    "get",
    "one",
    "child",
    "get",
    "two",
    "children",
    "go",
    "way",
    "go",
    "back",
    "simply",
    "count",
    "number",
    "matches",
    "path",
    "keep",
    "take",
    "keep",
    "taking",
    "maximum",
    "get",
    "back",
    "answer",
    "let",
    "say",
    "get",
    "back",
    "answer",
    "size",
    "two",
    "get",
    "back",
    "answer",
    "size",
    "one",
    "answer",
    "simply",
    "maximum",
    "2",
    "1",
    "two",
    "answer",
    "simply",
    "maximum",
    "two",
    "let",
    "say",
    "three",
    "three",
    "answer",
    "simply",
    "1",
    "3",
    "4",
    "okay",
    "way",
    "build",
    "solution",
    "looked",
    "recursive",
    "solution",
    "expressed",
    "text",
    "looked",
    "recursive",
    "solution",
    "expressed",
    "tree",
    "possible",
    "still",
    "may",
    "make",
    "sense",
    "exactly",
    "working",
    "start",
    "trying",
    "create",
    "tree",
    "pick",
    "pen",
    "paper",
    "start",
    "drawing",
    "pen",
    "paper",
    "take",
    "example",
    "try",
    "read",
    "step",
    "try",
    "work",
    "like",
    "computer",
    "okay",
    "thinking",
    "way",
    "help",
    "understand",
    "algorithm",
    "one",
    "last",
    "thing",
    "either",
    "sequence",
    "one",
    "idx",
    "onwards",
    "sequence",
    "two",
    "idx",
    "onwards",
    "empty",
    "means",
    "index",
    "reached",
    "end",
    "point",
    "recursion",
    "lcs",
    "empty",
    "length",
    "zero",
    "okay",
    "recursive",
    "solution",
    "copy",
    "recursive",
    "solution",
    "along",
    "entire",
    "tree",
    "obviously",
    "interview",
    "need",
    "write",
    "um",
    "lot",
    "detail",
    "need",
    "show",
    "diagram",
    "sometimes",
    "really",
    "need",
    "need",
    "express",
    "clearly",
    "create",
    "two",
    "counters",
    "uh",
    "condition",
    "check",
    "whether",
    "two",
    "elements",
    "counter",
    "positions",
    "equal",
    "equal",
    "inequal",
    "using",
    "recursion",
    "using",
    "recursion",
    "use",
    "reuse",
    "sub",
    "problems",
    "compute",
    "final",
    "problem",
    "okay",
    "understanding",
    "recursion",
    "really",
    "important",
    "solving",
    "data",
    "structures",
    "algorithms",
    "problem",
    "like",
    "super",
    "power",
    "pretty",
    "much",
    "pretty",
    "much",
    "every",
    "problem",
    "see",
    "one",
    "way",
    "another",
    "boil",
    "recursion",
    "one",
    "way",
    "okay",
    "let",
    "save",
    "work",
    "ready",
    "implement",
    "solution",
    "recursive",
    "solution",
    "front",
    "us",
    "remember",
    "four",
    "steps",
    "let",
    "go",
    "let",
    "go",
    "ahead",
    "implement",
    "see",
    "let",
    "call",
    "lcs",
    "recursive",
    "accept",
    "sequence",
    "one",
    "sequence",
    "2",
    "let",
    "also",
    "initialize",
    "idx1",
    "id",
    "x2",
    "calling",
    "function",
    "recursively",
    "simply",
    "use",
    "two",
    "counters",
    "idx1",
    "id",
    "x2",
    "set",
    "zero",
    "first",
    "thing",
    "need",
    "idx1",
    "equal",
    "length",
    "sequence",
    "1",
    "id",
    "x2",
    "equal",
    "length",
    "sequence",
    "2",
    "return",
    "zero",
    "common",
    "thing",
    "happens",
    "base",
    "case",
    "end",
    "scenario",
    "something",
    "describing",
    "algorithm",
    "describe",
    "end",
    "drawing",
    "tree",
    "notice",
    "end",
    "case",
    "end",
    "scenario",
    "coding",
    "algorithm",
    "end",
    "scenario",
    "base",
    "case",
    "comes",
    "top",
    "otherwise",
    "try",
    "access",
    "idx1",
    "sequence",
    "one",
    "throw",
    "error",
    "need",
    "handle",
    "base",
    "case",
    "beginning",
    "okay",
    "next",
    "moving",
    "ahead",
    "sequence",
    "one",
    "idx1",
    "equals",
    "sequence",
    "2",
    "id",
    "x2",
    "great",
    "found",
    "match",
    "simply",
    "return",
    "call",
    "lcs",
    "recursive",
    "sequence",
    "one",
    "2",
    "increment",
    "idx",
    "1",
    "1",
    "also",
    "increment",
    "idx",
    "2",
    "one",
    "need",
    "incremented",
    "going",
    "use",
    "element",
    "common",
    "element",
    "element",
    "subsequence",
    "okay",
    "one",
    "recursive",
    "call",
    "nice",
    "otherwise",
    "either",
    "ignore",
    "first",
    "element",
    "current",
    "element",
    "sequence",
    "one",
    "current",
    "element",
    "sequence",
    "2",
    "two",
    "options",
    "option",
    "one",
    "ignore",
    "current",
    "element",
    "sequence",
    "one",
    "becomes",
    "lcs",
    "recursive",
    "sequence",
    "1",
    "sequence",
    "2",
    "idx1",
    "1",
    "id",
    "x2",
    "option",
    "two",
    "lcs",
    "recursive",
    "sequence",
    "one",
    "sequence",
    "2",
    "time",
    "increment",
    "id",
    "x2",
    "okay",
    "make",
    "sure",
    "understand",
    "piece",
    "really",
    "key",
    "length",
    "longest",
    "common",
    "subsequence",
    "simply",
    "maximum",
    "option",
    "one",
    "option",
    "two",
    "okay",
    "may",
    "seemed",
    "like",
    "fairly",
    "tricky",
    "problem",
    "start",
    "thinking",
    "recursively",
    "okay",
    "happens",
    "simply",
    "compare",
    "first",
    "two",
    "equal",
    "unequal",
    "okay",
    "need",
    "solve",
    "problem",
    "remaining",
    "um",
    "either",
    "add",
    "one",
    "take",
    "ignore",
    "one",
    "elements",
    "right",
    "get",
    "thought",
    "recursive",
    "thought",
    "solution",
    "code",
    "simply",
    "presents",
    "seven",
    "lines",
    "code",
    "okay",
    "lcs",
    "recursive",
    "solution",
    "let",
    "test",
    "let",
    "look",
    "test",
    "case",
    "t0",
    "okay",
    "serendipitous",
    "precipitation",
    "inputs",
    "let",
    "call",
    "lcs",
    "let",
    "keep",
    "around",
    "view",
    "later",
    "let",
    "c",
    "call",
    "lcs",
    "recursive",
    "t0",
    "course",
    "need",
    "fetch",
    "t0",
    "input",
    "uh",
    "get",
    "sequence",
    "one",
    "input",
    "similarly",
    "need",
    "get",
    "input",
    "get",
    "sequence",
    "2",
    "input",
    "see",
    "takes",
    "returns",
    "value",
    "7",
    "equal",
    "output",
    "way",
    "simply",
    "check",
    "put",
    "t0",
    "output",
    "also",
    "going",
    "put",
    "special",
    "command",
    "called",
    "percentage",
    "percentage",
    "time",
    "going",
    "tell",
    "us",
    "long",
    "cell",
    "takes",
    "execute",
    "yeah",
    "see",
    "get",
    "back",
    "true",
    "cell",
    "takes",
    "495",
    "seconds",
    "half",
    "second",
    "execute",
    "tested",
    "test",
    "case",
    "one",
    "small",
    "thing",
    "tell",
    "improve",
    "slightly",
    "t0",
    "input",
    "dictionary",
    "names",
    "elements",
    "dictionary",
    "sequence",
    "one",
    "sequence",
    "2",
    "also",
    "match",
    "argument",
    "names",
    "lcs",
    "recursive",
    "see",
    "sequence",
    "one",
    "sequence",
    "2",
    "simply",
    "say",
    "star",
    "star",
    "t0",
    "input",
    "python",
    "automatically",
    "grab",
    "key",
    "sequence",
    "one",
    "passed",
    "argument",
    "sequence",
    "one",
    "sequence",
    "2",
    "passed",
    "argument",
    "sequence",
    "2",
    "small",
    "trick",
    "helps",
    "us",
    "speed",
    "reduce",
    "amount",
    "code",
    "need",
    "write",
    "okay",
    "tested",
    "one",
    "test",
    "case",
    "enough",
    "testing",
    "test",
    "cases",
    "test",
    "cases",
    "write",
    "loop",
    "tests",
    "etc",
    "something",
    "else",
    "use",
    "evaluate",
    "test",
    "cases",
    "function",
    "jovian",
    "python",
    "dsa",
    "module",
    "import",
    "evaluate",
    "test",
    "cases",
    "helper",
    "function",
    "created",
    "really",
    "simple",
    "write",
    "use",
    "loop",
    "well",
    "call",
    "evaluate",
    "test",
    "cases",
    "function",
    "want",
    "test",
    "lcs",
    "recursive",
    "test",
    "lcs",
    "tests",
    "going",
    "try",
    "test",
    "case",
    "see",
    "tried",
    "test",
    "case",
    "zero",
    "pass",
    "tried",
    "test",
    "case",
    "one",
    "also",
    "printing",
    "input",
    "expected",
    "output",
    "actual",
    "output",
    "test",
    "case",
    "one",
    "lists",
    "lists",
    "work",
    "used",
    "indexing",
    "length",
    "things",
    "available",
    "strings",
    "lists",
    "something",
    "nice",
    "python",
    "dynamic",
    "nature",
    "functions",
    "uh",
    "worked",
    "perfectly",
    "fine",
    "another",
    "one",
    "longest",
    "stone",
    "expected",
    "output",
    "three",
    "actual",
    "output",
    "three",
    "well",
    "ads",
    "f",
    "e",
    "w",
    "another",
    "string",
    "nothing",
    "common",
    "expect",
    "expected",
    "actual",
    "output",
    "zero",
    "one",
    "one",
    "already",
    "subsequence",
    "another",
    "smaller",
    "one",
    "becomes",
    "longest",
    "common",
    "subsequence",
    "empty",
    "string",
    "two",
    "empty",
    "strings",
    "finally",
    "multiple",
    "longest",
    "common",
    "subsequences",
    "still",
    "get",
    "back",
    "right",
    "output",
    "failed",
    "would",
    "know",
    "exactly",
    "went",
    "wrong",
    "instance",
    "issue",
    "case",
    "two",
    "empty",
    "would",
    "tell",
    "probably",
    "handled",
    "empty",
    "case",
    "properly",
    "great",
    "test",
    "cases",
    "important",
    "okay",
    "see",
    "timings",
    "well",
    "took",
    "uh",
    "well",
    "480",
    "milliseconds",
    "highest",
    "still",
    "bit",
    "high",
    "would",
    "say",
    "480",
    "milliseconds",
    "looking",
    "sequences",
    "serendipitous",
    "precipitation",
    "short",
    "length",
    "looking",
    "really",
    "long",
    "sequence",
    "instance",
    "technique",
    "used",
    "dna",
    "sequencing",
    "looking",
    "two",
    "dna",
    "strand",
    "two",
    "two",
    "dna",
    "strings",
    "trying",
    "get",
    "common",
    "subsequence",
    "go",
    "thousands",
    "sometimes",
    "millions",
    "elements",
    "would",
    "make",
    "rather",
    "slow",
    "okay",
    "want",
    "improve",
    "algorithm",
    "let",
    "commit",
    "work",
    "uh",
    "first",
    "thing",
    "improve",
    "algorithm",
    "analyze",
    "complexity",
    "long",
    "really",
    "take",
    "okay",
    "identify",
    "inefficient",
    "efficiencies",
    "analyze",
    "complexity",
    "let",
    "look",
    "example",
    "let",
    "consider",
    "worst",
    "case",
    "worst",
    "case",
    "occur",
    "seen",
    "two",
    "elements",
    "match",
    "simply",
    "one",
    "sub",
    "problem",
    "one",
    "recursive",
    "call",
    "two",
    "elements",
    "two",
    "elements",
    "sequences",
    "match",
    "two",
    "recursive",
    "calls",
    "two",
    "completely",
    "distinct",
    "sequences",
    "none",
    "sequences",
    "none",
    "elements",
    "match",
    "time",
    "end",
    "two",
    "sub",
    "problems",
    "becomes",
    "worst",
    "case",
    "worst",
    "case",
    "occurs",
    "time",
    "two",
    "sub",
    "problems",
    "sequences",
    "common",
    "elements",
    "example",
    "sequence",
    "length",
    "six",
    "sequence",
    "length",
    "8",
    "tree",
    "look",
    "like",
    "longer",
    "put",
    "actual",
    "sequences",
    "simply",
    "put",
    "length",
    "string",
    "start",
    "start",
    "strings",
    "length",
    "6",
    "8",
    "say",
    "either",
    "ignore",
    "first",
    "character",
    "first",
    "string",
    "first",
    "sequence",
    "ignore",
    "first",
    "element",
    "second",
    "sequence",
    "gives",
    "us",
    "two",
    "sub",
    "problems",
    "time",
    "sequences",
    "length",
    "5",
    "8",
    "case",
    "six",
    "seven",
    "case",
    "okay",
    "either",
    "reduce",
    "one",
    "left",
    "reduce",
    "one",
    "right",
    "either",
    "reduce",
    "one",
    "left",
    "reduce",
    "one",
    "right",
    "way",
    "create",
    "tree",
    "also",
    "see",
    "lot",
    "common",
    "trees",
    "get",
    "created",
    "really",
    "inefficiency",
    "talk",
    "happen",
    "57",
    "call",
    "47",
    "56",
    "57",
    "call",
    "47",
    "56",
    "47",
    "47",
    "get",
    "repeated",
    "56",
    "56",
    "get",
    "repeated",
    "three",
    "times",
    "lot",
    "repeated",
    "calls",
    "going",
    "occur",
    "even",
    "see",
    "top",
    "see",
    "l",
    "og",
    "problem",
    "called",
    "repeatedly",
    "um",
    "really",
    "source",
    "inefficiency",
    "question",
    "becomes",
    "know",
    "leaf",
    "nodes",
    "end",
    "0",
    "0",
    "entire",
    "tree",
    "ends",
    "count",
    "number",
    "leaf",
    "nodes",
    "okay",
    "count",
    "keep",
    "expanding",
    "tree",
    "completely",
    "expand",
    "skip",
    "count",
    "number",
    "leaf",
    "nodes",
    "count",
    "number",
    "lea",
    "nodes",
    "know",
    "binary",
    "tree",
    "number",
    "leaf",
    "nodes",
    "number",
    "leaf",
    "nodes",
    "l",
    "um",
    "height",
    "tree",
    "number",
    "leaf",
    "nodes",
    "n",
    "height",
    "tre",
    "log",
    "n",
    "based",
    "actually",
    "determine",
    "actual",
    "size",
    "tree",
    "well",
    "know",
    "count",
    "number",
    "unique",
    "paths",
    "root",
    "leaf",
    "give",
    "us",
    "number",
    "leaves",
    "right",
    "time",
    "two",
    "choices",
    "either",
    "reduce",
    "left",
    "reduce",
    "right",
    "get",
    "0",
    "0",
    "would",
    "reduce",
    "elements",
    "left",
    "would",
    "reduce",
    "elements",
    "right",
    "means",
    "strings",
    "strings",
    "length",
    "sequences",
    "length",
    "n",
    "would",
    "make",
    "n",
    "choices",
    "total",
    "right",
    "time",
    "make",
    "plus",
    "n",
    "choices",
    "time",
    "choose",
    "whether",
    "want",
    "reduce",
    "left",
    "right",
    "two",
    "choices",
    "make",
    "two",
    "choices",
    "n",
    "times",
    "right",
    "way",
    "put",
    "really",
    "means",
    "time",
    "comp",
    "two",
    "choices",
    "2",
    "2",
    "ultied",
    "2",
    "ultied",
    "2",
    "keep",
    "multiplying",
    "end",
    "2",
    "n",
    "leaf",
    "nodes",
    "okay",
    "exercise",
    "draw",
    "tree",
    "piece",
    "paper",
    "mark",
    "number",
    "leaf",
    "nodes",
    "length",
    "part",
    "plus",
    "n",
    "figure",
    "based",
    "conclude",
    "takes",
    "2",
    "n",
    "leaves",
    "complete",
    "tree",
    "2",
    "power",
    "plus",
    "n",
    "number",
    "leaves",
    "total",
    "number",
    "elements",
    "tree",
    "simply",
    "double",
    "something",
    "easy",
    "verify",
    "check",
    "instance",
    "consider",
    "two",
    "levels",
    "two",
    "leaves",
    "total",
    "number",
    "elements",
    "tree",
    "2",
    "1",
    "3",
    "actually",
    "double",
    "minus",
    "1",
    "2",
    "2",
    "4",
    "1",
    "3",
    "three",
    "levels",
    "see",
    "four",
    "leaves",
    "total",
    "number",
    "elements",
    "tree",
    "4",
    "2",
    "8",
    "1",
    "7",
    "see",
    "follows",
    "essentially",
    "exponential",
    "number",
    "sub",
    "problems",
    "calling",
    "recursive",
    "function",
    "exponential",
    "number",
    "times",
    "inside",
    "recursive",
    "function",
    "inside",
    "recursive",
    "function",
    "constant",
    "time",
    "work",
    "see",
    "special",
    "work",
    "comparison",
    "addition",
    "constant",
    "time",
    "make",
    "2",
    "n",
    "plus",
    "n",
    "recursive",
    "calls",
    "inside",
    "constant",
    "work",
    "time",
    "complexity",
    "order",
    "2",
    "n",
    "okay",
    "rough",
    "explanation",
    "gone",
    "lot",
    "depth",
    "covered",
    "three",
    "lessons",
    "exercise",
    "verify",
    "exactly",
    "n",
    "okay",
    "recursive",
    "solution",
    "know",
    "know",
    "time",
    "complexity",
    "2",
    "n",
    "let",
    "copy",
    "inefficiency",
    "said",
    "algorithm",
    "calling",
    "problem",
    "calling",
    "exact",
    "problem",
    "lcs",
    "recursive",
    "function",
    "called",
    "idx",
    "equal",
    "idx1",
    "5",
    "id",
    "x2",
    "equal",
    "7",
    "idx1",
    "equal",
    "5",
    "id",
    "x2",
    "equal",
    "7",
    "time",
    "uh",
    "twice",
    "sub",
    "problems",
    "called",
    "twice",
    "sub",
    "problems",
    "within",
    "called",
    "twice",
    "course",
    "sub",
    "problems",
    "get",
    "shared",
    "lot",
    "repetition",
    "simple",
    "solution",
    "simply",
    "remember",
    "results",
    "okay",
    "technique",
    "called",
    "memorization",
    "may",
    "also",
    "call",
    "memorization",
    "remembering",
    "things",
    "memorization",
    "technical",
    "term",
    "remember",
    "solutions",
    "dictionary",
    "called",
    "memo",
    "going",
    "going",
    "follow",
    "recursive",
    "strategy",
    "time",
    "going",
    "maintain",
    "dictionary",
    "called",
    "memo",
    "going",
    "track",
    "intermediate",
    "results",
    "within",
    "dictionary",
    "find",
    "intermediate",
    "result",
    "already",
    "exists",
    "dictionary",
    "compute",
    "okay",
    "let",
    "see",
    "write",
    "lcs",
    "memorized",
    "let",
    "say",
    "lcs",
    "memo",
    "short",
    "takes",
    "sequence",
    "one",
    "takes",
    "sequence",
    "two",
    "time",
    "create",
    "dictionary",
    "called",
    "memo",
    "write",
    "function",
    "inside",
    "write",
    "helper",
    "function",
    "recursive",
    "help",
    "function",
    "inside",
    "lcs",
    "memo",
    "function",
    "access",
    "sequence",
    "one",
    "sequence",
    "2",
    "simply",
    "start",
    "idx1",
    "zero",
    "id",
    "x2",
    "zer",
    "well",
    "idx1",
    "track",
    "position",
    "sequence",
    "one",
    "id",
    "x2",
    "track",
    "position",
    "sequence",
    "2",
    "first",
    "thing",
    "create",
    "using",
    "two",
    "indices",
    "create",
    "key",
    "going",
    "create",
    "key",
    "idx1",
    "comma",
    "id",
    "x2",
    "key",
    "present",
    "memo",
    "way",
    "check",
    "key",
    "exists",
    "dictionary",
    "simply",
    "return",
    "memo",
    "key",
    "simple",
    "problem",
    "solved",
    "solve",
    "problem",
    "already",
    "already",
    "something",
    "solved",
    "need",
    "solve",
    "problem",
    "save",
    "memo",
    "know",
    "write",
    "three",
    "recursive",
    "cases",
    "base",
    "case",
    "idx1",
    "equal",
    "length",
    "sequence",
    "one",
    "id",
    "x2",
    "equal",
    "length",
    "sequence",
    "2",
    "simply",
    "set",
    "memo",
    "key",
    "zero",
    "point",
    "reached",
    "end",
    "strings",
    "nothing",
    "left",
    "us",
    "compare",
    "lf",
    "idx",
    "sequence",
    "one",
    "idx1",
    "equals",
    "sequence",
    "2",
    "id",
    "x2",
    "case",
    "case",
    "current",
    "characters",
    "equal",
    "go",
    "go",
    "look",
    "tree",
    "case",
    "like",
    "current",
    "characters",
    "pointing",
    "equal",
    "case",
    "simply",
    "return",
    "simply",
    "get",
    "result",
    "1",
    "plus",
    "result",
    "remaining",
    "first",
    "character",
    "remote",
    "case",
    "simply",
    "set",
    "memo",
    "key",
    "call",
    "recursive",
    "function",
    "recurse",
    "idx1",
    "1",
    "id",
    "x2",
    "1",
    "create",
    "else",
    "case",
    "two",
    "elements",
    "equal",
    "two",
    "options",
    "going",
    "write",
    "two",
    "options",
    "separately",
    "let",
    "max",
    "directly",
    "max",
    "say",
    "recurse",
    "idx1",
    "1",
    "comma",
    "id",
    "x2",
    "recurse",
    "idx1",
    "comma",
    "id",
    "x2",
    "one",
    "okay",
    "finally",
    "recurse",
    "function",
    "return",
    "memo",
    "key",
    "whichever",
    "case",
    "computed",
    "result",
    "saved",
    "memo",
    "time",
    "computations",
    "get",
    "repeated",
    "let",
    "us",
    "return",
    "recurse",
    "0a",
    "0",
    "0",
    "comma",
    "0",
    "entire",
    "string",
    "common",
    "strategy",
    "apply",
    "whenever",
    "come",
    "recursive",
    "solution",
    "see",
    "inefficiency",
    "coming",
    "problem",
    "called",
    "need",
    "apply",
    "technique",
    "called",
    "memorization",
    "right",
    "technique",
    "able",
    "simply",
    "store",
    "intermediate",
    "results",
    "really",
    "simple",
    "create",
    "dictionary",
    "add",
    "one",
    "two",
    "lines",
    "code",
    "make",
    "sure",
    "save",
    "result",
    "dictionary",
    "whenever",
    "compute",
    "result",
    "next",
    "time",
    "compute",
    "okay",
    "test",
    "test",
    "test",
    "cases",
    "evaluate",
    "test",
    "cases",
    "lcs",
    "memo",
    "lcs",
    "tests",
    "see",
    "test",
    "cases",
    "pass",
    "test",
    "cases",
    "pass",
    "see",
    "time",
    "taken",
    "lower",
    "okay",
    "nice",
    "time",
    "taken",
    "lower",
    "went",
    "450",
    "milliseconds",
    "go",
    "see",
    "took",
    "480",
    "milliseconds",
    "finding",
    "longest",
    "common",
    "subsequence",
    "precipitation",
    "serendipitous",
    "case",
    "took",
    "234",
    "is2",
    "millisecond",
    "times",
    "faster",
    "even",
    "strings",
    "length",
    "7",
    "8",
    "huge",
    "boost",
    "um",
    "let",
    "analyze",
    "complexity",
    "let",
    "uh",
    "look",
    "complexity",
    "quick",
    "easy",
    "way",
    "find",
    "complexity",
    "solution",
    "see",
    "computation",
    "many",
    "times",
    "computation",
    "occur",
    "bulk",
    "computation",
    "occurring",
    "recursive",
    "call",
    "computation",
    "avoided",
    "already",
    "something",
    "memo",
    "okay",
    "means",
    "number",
    "computations",
    "need",
    "equal",
    "maximum",
    "number",
    "elements",
    "end",
    "memo",
    "keys",
    "memo",
    "look",
    "like",
    "keys",
    "memo",
    "look",
    "like",
    "idx1",
    "idx",
    "2",
    "great",
    "values",
    "take",
    "idx1",
    "take",
    "0",
    "values",
    "length",
    "sequence",
    "one",
    "let",
    "say",
    "id",
    "x2",
    "take",
    "0",
    "n",
    "values",
    "n",
    "sequence",
    "length",
    "sequence",
    "2",
    "total",
    "possible",
    "number",
    "keys",
    "n",
    "possible",
    "number",
    "keys",
    "n",
    "possible",
    "number",
    "things",
    "need",
    "store",
    "memo",
    "n",
    "constant",
    "work",
    "next",
    "time",
    "try",
    "access",
    "need",
    "work",
    "need",
    "call",
    "recursion",
    "simply",
    "access",
    "memorization",
    "right",
    "tells",
    "us",
    "complexity",
    "case",
    "memorization",
    "case",
    "general",
    "equal",
    "number",
    "keys",
    "case",
    "n",
    "time",
    "complexity",
    "order",
    "n",
    "gone",
    "2",
    "n",
    "plus",
    "n",
    "equal",
    "30",
    "would",
    "1",
    "billion",
    "time",
    "order",
    "n",
    "let",
    "say",
    "strings",
    "15",
    "15",
    "would",
    "225",
    "operations",
    "gone",
    "1",
    "billion",
    "operations",
    "225",
    "operations",
    "simply",
    "storing",
    "intermediate",
    "results",
    "powerful",
    "technique",
    "apply",
    "time",
    "see",
    "first",
    "time",
    "57",
    "computed",
    "next",
    "time",
    "57",
    "need",
    "computed",
    "tree",
    "actually",
    "marked",
    "tree",
    "memorization",
    "first",
    "time",
    "47",
    "computed",
    "never",
    "needs",
    "computed",
    "entire",
    "tree",
    "computation",
    "gets",
    "eliminated",
    "similarly",
    "entire",
    "tree",
    "computation",
    "gets",
    "eliminated",
    "eliminating",
    "1",
    "billion",
    "computations",
    "almost",
    "except",
    "225",
    "computation",
    "left",
    "practically",
    "nothing",
    "speeds",
    "algorithm",
    "huge",
    "huge",
    "factor",
    "memorization",
    "said",
    "really",
    "easy",
    "compute",
    "time",
    "complexity",
    "memorization",
    "simply",
    "count",
    "number",
    "keys",
    "track",
    "much",
    "work",
    "need",
    "compute",
    "key",
    "assuming",
    "already",
    "recursive",
    "solutions",
    "remaining",
    "okay",
    "much",
    "work",
    "need",
    "compute",
    "key",
    "using",
    "existing",
    "solutions",
    "case",
    "constant",
    "needed",
    "compare",
    "add",
    "add",
    "okay",
    "let",
    "write",
    "simple",
    "optimized",
    "plain",
    "english",
    "explanation",
    "memorization",
    "worth",
    "good",
    "exercise",
    "try",
    "also",
    "look",
    "another",
    "technique",
    "called",
    "dynamic",
    "programming",
    "downside",
    "memorization",
    "requires",
    "recursive",
    "calls",
    "problem",
    "small",
    "cases",
    "really",
    "problems",
    "recursion",
    "overhead",
    "overhead",
    "recursion",
    "see",
    "way",
    "function",
    "execution",
    "complete",
    "need",
    "function",
    "execution",
    "complete",
    "complete",
    "complete",
    "need",
    "complete",
    "complete",
    "right",
    "idea",
    "new",
    "recursive",
    "call",
    "takes",
    "space",
    "memory",
    "also",
    "takes",
    "longer",
    "allocate",
    "memory",
    "set",
    "function",
    "stack",
    "function",
    "stack",
    "ex",
    "ution",
    "function",
    "large",
    "tree",
    "creating",
    "hundreds",
    "thousands",
    "possibly",
    "millions",
    "open",
    "functions",
    "memory",
    "eat",
    "lot",
    "memory",
    "sometimes",
    "also",
    "take",
    "uh",
    "take",
    "longer",
    "time",
    "solution",
    "replace",
    "recursion",
    "iteration",
    "using",
    "technique",
    "called",
    "dynamic",
    "programming",
    "almost",
    "thing",
    "changes",
    "instead",
    "using",
    "dictionary",
    "track",
    "intermediate",
    "results",
    "create",
    "matrix",
    "know",
    "sequence",
    "one",
    "uh",
    "idx1",
    "go",
    "0o",
    "n",
    "0",
    "n1",
    "let",
    "say",
    "n1",
    "length",
    "sequence",
    "one",
    "sequence",
    "idx",
    "2",
    "go",
    "0",
    "n2",
    "see",
    "n2",
    "length",
    "sequence",
    "2",
    "use",
    "loop",
    "couple",
    "loops",
    "fill",
    "sub",
    "problems",
    "without",
    "require",
    "recursion",
    "okay",
    "let",
    "say",
    "two",
    "strings",
    "working",
    "string",
    "one",
    "cgt",
    "string",
    "two",
    "dna",
    "sequences",
    "look",
    "like",
    "create",
    "table",
    "size",
    "n",
    "1",
    "1",
    "n",
    "n1",
    "1",
    "n2",
    "1",
    "see",
    "n1",
    "rows",
    "length",
    "n1",
    "n1",
    "rows",
    "additional",
    "row",
    "similarly",
    "n2",
    "one",
    "rows",
    "length",
    "n2",
    "n2",
    "one",
    "columns",
    "see",
    "n2",
    "columns",
    "additional",
    "column",
    "table",
    "j",
    "let",
    "say",
    "table",
    "uh",
    "j",
    "zero",
    "pointer",
    "first",
    "sequence",
    "j",
    "pointer",
    "second",
    "sequence",
    "selects",
    "row",
    "j",
    "selects",
    "column",
    "table",
    "j",
    "represents",
    "longest",
    "common",
    "subsequence",
    "sequence",
    "one",
    "means",
    "sequence",
    "one",
    "let",
    "say",
    "1",
    "uh",
    "j",
    "1",
    "represents",
    "longest",
    "subsequence",
    "sequence",
    "one",
    "positions",
    "one",
    "means",
    "zeroth",
    "position",
    "sequence",
    "2",
    "j",
    "means",
    "positions",
    "first",
    "position",
    "one",
    "means",
    "zeroth",
    "position",
    "means",
    "okay",
    "table",
    "one",
    "table",
    "represents",
    "longest",
    "common",
    "subsequence",
    "two",
    "zero",
    "hand",
    "skip",
    "ahead",
    "little",
    "bit",
    "skip",
    "ahead",
    "let",
    "say",
    "position",
    "count",
    "goes",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "six",
    "0",
    "1",
    "uh",
    "0",
    "1",
    "2",
    "3",
    "table",
    "6a",
    "3",
    "table",
    "6a",
    "3",
    "takes",
    "first",
    "six",
    "elements",
    "gtca",
    "first",
    "three",
    "elements",
    "ag",
    "sequence",
    "2",
    "stores",
    "result",
    "longest",
    "common",
    "subsequence",
    "two",
    "okay",
    "let",
    "look",
    "table",
    "maybe",
    "even",
    "draw",
    "table",
    "piece",
    "paper",
    "verify",
    "length",
    "three",
    "right",
    "see",
    "ag",
    "g",
    "ag",
    "g",
    "occurs",
    "ag",
    "g",
    "subsequence",
    "g",
    "tca",
    "longest",
    "common",
    "subsequence",
    "three",
    "compare",
    "next",
    "elements",
    "compare",
    "sequence",
    "one",
    "sequence",
    "2",
    "j",
    "let",
    "say",
    "looking",
    "let",
    "pi",
    "example",
    "let",
    "say",
    "sequence",
    "let",
    "say",
    "value",
    "value",
    "0",
    "1",
    "2",
    "3",
    "4",
    "value",
    "0",
    "1",
    "2",
    "value",
    "two",
    "let",
    "say",
    "j",
    "value",
    "1",
    "0",
    "1",
    "compare",
    "sequence",
    "one",
    "g",
    "sequence",
    "2",
    "sequence",
    "2",
    "j",
    "also",
    "g",
    "equal",
    "equal",
    "able",
    "1",
    "j",
    "value",
    "right",
    "remember",
    "2",
    "j",
    "1",
    "table",
    "one",
    "1",
    "table",
    "one",
    "3",
    "0",
    "1",
    "2",
    "3",
    "table",
    "uh",
    "table",
    "one",
    "1",
    "j",
    "1",
    "table",
    "one",
    "3",
    "table",
    "table",
    "1",
    "j",
    "1",
    "2",
    "j",
    "one",
    "table",
    "one",
    "three",
    "two",
    "table",
    "one",
    "three",
    "two",
    "value",
    "two",
    "value",
    "obtained",
    "adding",
    "one",
    "table",
    "one",
    "comma",
    "j",
    "two",
    "elements",
    "equal",
    "say",
    "take",
    "longest",
    "common",
    "subsequence",
    "ta",
    "add",
    "one",
    "give",
    "us",
    "longest",
    "common",
    "subsequence",
    "ag",
    "exact",
    "logic",
    "recursion",
    "simply",
    "reversed",
    "looking",
    "last",
    "element",
    "keep",
    "filling",
    "last",
    "value",
    "using",
    "previous",
    "values",
    "okay",
    "one",
    "case",
    "similarly",
    "another",
    "case",
    "equal",
    "longest",
    "common",
    "sub",
    "subsequence",
    "gtca",
    "longest",
    "common",
    "subsequence",
    "ag",
    "g",
    "1",
    "plus",
    "longest",
    "common",
    "subsequence",
    "gtc",
    "ag",
    "okay",
    "1",
    "plus",
    "value",
    "one",
    "case",
    "case",
    "equal",
    "let",
    "look",
    "value",
    "example",
    "gt",
    "side",
    "okay",
    "let",
    "let",
    "look",
    "one",
    "uh",
    "gt",
    "side",
    "ag",
    "gac",
    "side",
    "element",
    "c",
    "element",
    "equal",
    "means",
    "longest",
    "common",
    "sub",
    "sequence",
    "two",
    "either",
    "contain",
    "contain",
    "c",
    "contain",
    "obviously",
    "one",
    "strings",
    "end",
    "contain",
    "result",
    "contain",
    "contain",
    "c",
    "result",
    "simply",
    "take",
    "maximum",
    "two",
    "maximum",
    "two",
    "get",
    "result",
    "two",
    "elements",
    "equal",
    "fill",
    "table",
    "start",
    "top",
    "first",
    "row",
    "zeros",
    "empty",
    "strings",
    "first",
    "column",
    "also",
    "zeros",
    "empty",
    "strings",
    "fill",
    "element",
    "compare",
    "two",
    "elements",
    "equal",
    "equal",
    "simply",
    "add",
    "one",
    "diagonally",
    "left",
    "top",
    "left",
    "element",
    "unequal",
    "take",
    "maximum",
    "element",
    "element",
    "left",
    "way",
    "fill",
    "entire",
    "table",
    "okay",
    "dynamic",
    "programming",
    "solution",
    "know",
    "seem",
    "little",
    "bit",
    "complicated",
    "uh",
    "honestly",
    "still",
    "get",
    "confused",
    "dynamic",
    "programming",
    "lot",
    "times",
    "like",
    "draw",
    "tables",
    "write",
    "things",
    "carefully",
    "okay",
    "especially",
    "specially",
    "careful",
    "indexes",
    "saying",
    "sequence",
    "1",
    "sequence",
    "2",
    "j",
    "equal",
    "table",
    "one",
    "1",
    "j",
    "1",
    "1",
    "plus",
    "table",
    "ig",
    "watch",
    "indices",
    "carefully",
    "let",
    "implement",
    "solution",
    "let",
    "implement",
    "dynamic",
    "programming",
    "solution",
    "let",
    "say",
    "lcs",
    "dynamic",
    "program",
    "programming",
    "say",
    "dp",
    "sequence",
    "one",
    "sequence",
    "2",
    "first",
    "thing",
    "need",
    "need",
    "table",
    "results",
    "table",
    "let",
    "grab",
    "n1",
    "n2",
    "length",
    "sequence",
    "one",
    "length",
    "sequence",
    "2",
    "need",
    "create",
    "table",
    "zeros",
    "create",
    "table",
    "zeros",
    "way",
    "way",
    "create",
    "list",
    "zeros",
    "04",
    "underscore",
    "let",
    "say",
    "n1",
    "let",
    "give",
    "n1",
    "n2",
    "values",
    "want",
    "create",
    "list",
    "zeros",
    "length",
    "n1",
    "simply",
    "say",
    "0",
    "underscore",
    "0",
    "x",
    "simply",
    "ignoring",
    "whatever",
    "value",
    "getting",
    "range",
    "rrange",
    "n1",
    "going",
    "give",
    "list",
    "zeros",
    "want",
    "list",
    "n1",
    "zeros",
    "want",
    "want",
    "want",
    "rows",
    "want",
    "list",
    "zeros",
    "length",
    "n2",
    "0",
    "x",
    "range",
    "n2",
    "see",
    "five",
    "rows",
    "1",
    "2",
    "3",
    "4",
    "5",
    "seven",
    "columns",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "table",
    "want",
    "create",
    "initially",
    "okay",
    "table",
    "created",
    "going",
    "exact",
    "table",
    "table",
    "simply",
    "going",
    "start",
    "string",
    "position",
    "one",
    "time",
    "position",
    "zero",
    "want",
    "additional",
    "row",
    "consider",
    "either",
    "makes",
    "computations",
    "little",
    "easier",
    "say",
    "idx1",
    "len",
    "ed",
    "x1",
    "range",
    "n1",
    "going",
    "iterate",
    "rows",
    "idx",
    "2",
    "range",
    "n2",
    "going",
    "iterate",
    "columns",
    "first",
    "compare",
    "sequence",
    "one",
    "idx1",
    "equal",
    "sequence",
    "2",
    "id",
    "x2",
    "equal",
    "fill",
    "table",
    "1",
    "n",
    "j",
    "1",
    "1",
    "ig",
    "okay",
    "see",
    "see",
    "suppose",
    "first",
    "elements",
    "equal",
    "suppose",
    "suppose",
    "idx1",
    "zero",
    "id",
    "x2",
    "also",
    "zero",
    "suppose",
    "equal",
    "value",
    "one",
    "value",
    "one",
    "plus",
    "diagonally",
    "top",
    "element",
    "holds",
    "true",
    "anywhere",
    "within",
    "list",
    "wherever",
    "two",
    "elements",
    "equal",
    "like",
    "g",
    "g",
    "equal",
    "value",
    "1",
    "plus",
    "value",
    "else",
    "table",
    "1",
    "j",
    "1",
    "max",
    "table",
    "comma",
    "j",
    "1",
    "stay",
    "row",
    "go",
    "previous",
    "row",
    "go",
    "previous",
    "column",
    "table",
    "1",
    "comma",
    "j",
    "previous",
    "column",
    "okay",
    "case",
    "g",
    "equal",
    "g",
    "equal",
    "take",
    "maximum",
    "two",
    "values",
    "going",
    "fill",
    "table",
    "us",
    "simply",
    "say",
    "return",
    "table",
    "simply",
    "want",
    "bottom",
    "right",
    "element",
    "simply",
    "say",
    "return",
    "table",
    "minus",
    "one",
    "minus",
    "one",
    "going",
    "get",
    "last",
    "row",
    "last",
    "column",
    "dynamic",
    "programming",
    "solution",
    "let",
    "evaluate",
    "test",
    "cases",
    "okay",
    "turns",
    "okay",
    "let",
    "call",
    "j",
    "turns",
    "idx1",
    "defined",
    "let",
    "make",
    "ij",
    "coding",
    "live",
    "see",
    "even",
    "decade",
    "coding",
    "still",
    "make",
    "issues",
    "says",
    "list",
    "list",
    "index",
    "range",
    "seems",
    "like",
    "1",
    "j",
    "1",
    "ah",
    "remember",
    "need",
    "additional",
    "row",
    "additional",
    "column",
    "track",
    "case",
    "either",
    "strings",
    "empty",
    "need",
    "get",
    "range",
    "n2",
    "1",
    "need",
    "get",
    "range",
    "n1",
    "1",
    "okay",
    "helps",
    "test",
    "cases",
    "fix",
    "issues",
    "test",
    "case",
    "zero",
    "passes",
    "test",
    "case",
    "1",
    "2",
    "3",
    "pass",
    "see",
    "test",
    "cases",
    "passed",
    "also",
    "verify",
    "amount",
    "time",
    "took",
    "lower",
    "amount",
    "time",
    "took",
    "memorization",
    "okay",
    "dynamic",
    "programming",
    "approach",
    "simply",
    "create",
    "table",
    "fill",
    "table",
    "sometimes",
    "working",
    "indices",
    "within",
    "table",
    "get",
    "confusing",
    "helps",
    "work",
    "paper",
    "make",
    "clear",
    "write",
    "english",
    "written",
    "plain",
    "english",
    "exercise",
    "verify",
    "complexity",
    "dynamic",
    "programming",
    "approach",
    "order",
    "n1",
    "n2",
    "memorization",
    "actually",
    "straightforward",
    "see",
    "two",
    "loops",
    "loops",
    "simply",
    "comparison",
    "addition",
    "even",
    "recursion",
    "even",
    "recursion",
    "worry",
    "worry",
    "comparison",
    "addition",
    "take",
    "maximum",
    "pretty",
    "straightforward",
    "order",
    "n1",
    "n2",
    "even",
    "invoke",
    "another",
    "function",
    "take",
    "much",
    "memory",
    "take",
    "much",
    "time",
    "efficient",
    "solve",
    "pretty",
    "much",
    "every",
    "dynamic",
    "pro",
    "dynamic",
    "programming",
    "problem",
    "write",
    "recursive",
    "solution",
    "come",
    "brute",
    "force",
    "solution",
    "keep",
    "mind",
    "recursion",
    "almost",
    "always",
    "way",
    "go",
    "creating",
    "brute",
    "force",
    "solution",
    "come",
    "recursive",
    "solution",
    "identify",
    "draw",
    "recursion",
    "tree",
    "see",
    "sub",
    "problem",
    "called",
    "point",
    "introduce",
    "memorization",
    "introduce",
    "memorization",
    "sometimes",
    "write",
    "memoized",
    "solution",
    "enough",
    "easy",
    "reason",
    "put",
    "memo",
    "done",
    "um",
    "even",
    "interviewer",
    "coding",
    "assessment",
    "accept",
    "solution",
    "cases",
    "asked",
    "remove",
    "recursion",
    "write",
    "iterative",
    "fashion",
    "start",
    "drawing",
    "table",
    "think",
    "rows",
    "columns",
    "table",
    "uh",
    "need",
    "represent",
    "j",
    "element",
    "table",
    "represented",
    "first",
    "first",
    "elements",
    "sequence",
    "one",
    "first",
    "j",
    "elements",
    "sequence",
    "2",
    "longest",
    "subsequence",
    "use",
    "build",
    "next",
    "row",
    "next",
    "column",
    "filled",
    "entire",
    "table",
    "simply",
    "use",
    "last",
    "value",
    "okay",
    "straightforward",
    "uh",
    "come",
    "way",
    "solving",
    "problem",
    "solve",
    "5",
    "10",
    "dynamic",
    "pro",
    "programming",
    "problems",
    "get",
    "intuition",
    "build",
    "table",
    "always",
    "helpful",
    "solve",
    "pen",
    "paper",
    "first",
    "especially",
    "dynamic",
    "programming",
    "clear",
    "element",
    "table",
    "represents",
    "otherwise",
    "may",
    "make",
    "lot",
    "one",
    "errors",
    "like",
    "missing",
    "plus",
    "one",
    "missing",
    "plus",
    "one",
    "get",
    "confused",
    "like",
    "pretty",
    "much",
    "time",
    "time",
    "complexity",
    "pretty",
    "straightforward",
    "cases",
    "simply",
    "size",
    "table",
    "sometimes",
    "may",
    "constant",
    "work",
    "keep",
    "mind",
    "see",
    "inside",
    "loop",
    "inside",
    "inside",
    "loop",
    "go",
    "back",
    "check",
    "entire",
    "length",
    "string",
    "introduce",
    "another",
    "factor",
    "equation",
    "keep",
    "mind",
    "cases",
    "counting",
    "iteration",
    "good",
    "enough",
    "give",
    "idea",
    "time",
    "complexity",
    "okay",
    "first",
    "problem",
    "let",
    "us",
    "commit",
    "save",
    "saved",
    "profile",
    "open",
    "see",
    "notebook",
    "called",
    "longest",
    "common",
    "subsequences",
    "share",
    "online",
    "whenever",
    "work",
    "notebook",
    "always",
    "good",
    "idea",
    "make",
    "public",
    "put",
    "jovian",
    "need",
    "run",
    "share",
    "online",
    "press",
    "share",
    "button",
    "share",
    "twitter",
    "linkedin",
    "facebook",
    "wherever",
    "like",
    "first",
    "problem",
    "looked",
    "let",
    "come",
    "back",
    "lesson",
    "four",
    "uh",
    "way",
    "problems",
    "talking",
    "problem",
    "statements",
    "graphs",
    "images",
    "see",
    "second",
    "link",
    "open",
    "problem",
    "solving",
    "template",
    "use",
    "second",
    "problem",
    "let",
    "run",
    "going",
    "look",
    "second",
    "problem",
    "napack",
    "problem",
    "let",
    "read",
    "napsack",
    "problem",
    "also",
    "called",
    "01",
    "napsack",
    "problem",
    "many",
    "variations",
    "problem",
    "one",
    "way",
    "state",
    "might",
    "come",
    "across",
    "something",
    "similar",
    "charge",
    "selecting",
    "football",
    "soccer",
    "team",
    "large",
    "pool",
    "players",
    "player",
    "cost",
    "rating",
    "selection",
    "going",
    "come",
    "team",
    "year",
    "large",
    "pool",
    "players",
    "player",
    "cost",
    "player",
    "rating",
    "limited",
    "budget",
    "need",
    "build",
    "team",
    "within",
    "budget",
    "highest",
    "total",
    "rating",
    "team",
    "create",
    "fits",
    "within",
    "budget",
    "okay",
    "question",
    "maximize",
    "total",
    "rating",
    "fit",
    "fit",
    "total",
    "cost",
    "within",
    "budget",
    "two",
    "variables",
    "rating",
    "variables",
    "rating",
    "needs",
    "maximized",
    "cost",
    "needs",
    "simply",
    "optimized",
    "extent",
    "fits",
    "budget",
    "simplifying",
    "assumption",
    "assume",
    "minimum",
    "maximum",
    "team",
    "size",
    "simplification",
    "later",
    "introduce",
    "criteria",
    "well",
    "want",
    "build",
    "team",
    "exactly",
    "10",
    "people",
    "see",
    "also",
    "solve",
    "problem",
    "way",
    "napsack",
    "problem",
    "let",
    "copy",
    "jupiter",
    "notebook",
    "fresh",
    "problem",
    "solving",
    "template",
    "let",
    "simply",
    "change",
    "title",
    "also",
    "called",
    "01",
    "napsack",
    "problem",
    "item",
    "either",
    "chosen",
    "chosen",
    "let",
    "give",
    "project",
    "name",
    "let",
    "commit",
    "let",
    "paste",
    "problem",
    "statement",
    "okay",
    "problem",
    "statement",
    "specific",
    "special",
    "form",
    "general",
    "problem",
    "statement",
    "look",
    "general",
    "problem",
    "statement",
    "second",
    "try",
    "state",
    "problem",
    "clearly",
    "systematic",
    "strategy",
    "apply",
    "state",
    "problem",
    "clearly",
    "identify",
    "input",
    "output",
    "formats",
    "come",
    "example",
    "inputs",
    "outputs",
    "try",
    "cover",
    "edge",
    "cases",
    "come",
    "correct",
    "solution",
    "problem",
    "state",
    "solution",
    "plain",
    "english",
    "simple",
    "correct",
    "solution",
    "complex",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "uh",
    "analyze",
    "algorithm",
    "identify",
    "inefficiencies",
    "implementing",
    "solution",
    "finally",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "repeat",
    "process",
    "stating",
    "solution",
    "implementing",
    "analyzing",
    "state",
    "problem",
    "clearly",
    "abstract",
    "problem",
    "general",
    "terms",
    "stated",
    "let",
    "grab",
    "take",
    "look",
    "given",
    "n",
    "elements",
    "weight",
    "profit",
    "n",
    "elements",
    "profit",
    "element",
    "weight",
    "element",
    "need",
    "determine",
    "maximum",
    "profit",
    "obtained",
    "selecting",
    "subset",
    "elements",
    "weighing",
    "given",
    "weight",
    "w",
    "capacity",
    "maximum",
    "capacity",
    "let",
    "say",
    "maximum",
    "capacity",
    "15",
    "select",
    "certain",
    "elements",
    "fill",
    "total",
    "weight",
    "capacity",
    "total",
    "profit",
    "maximized",
    "called",
    "napsack",
    "problem",
    "assuming",
    "bag",
    "napsack",
    "capacity",
    "15",
    "kg",
    "weights",
    "items",
    "profits",
    "case",
    "see",
    "example",
    "optimal",
    "selection",
    "four",
    "elements",
    "weights",
    "5",
    "3",
    "2",
    "5",
    "fill",
    "total",
    "capacity",
    "16",
    "15",
    "solution",
    "maximum",
    "profit",
    "obtain",
    "7",
    "4",
    "11",
    "5",
    "16",
    "3",
    "19",
    "try",
    "combinations",
    "verify",
    "actually",
    "best",
    "solution",
    "give",
    "shot",
    "inputs",
    "pretty",
    "clear",
    "input",
    "weights",
    "weights",
    "list",
    "uh",
    "numbers",
    "containing",
    "weights",
    "profits",
    "list",
    "numbers",
    "containing",
    "profits",
    "length",
    "weights",
    "finally",
    "capacity",
    "maximum",
    "weight",
    "allowed",
    "go",
    "outputs",
    "output",
    "would",
    "simply",
    "max",
    "profit",
    "maximum",
    "profit",
    "obtained",
    "selecting",
    "elements",
    "total",
    "weight",
    "w",
    "capacity",
    "okay",
    "great",
    "gives",
    "us",
    "pretty",
    "good",
    "starting",
    "point",
    "write",
    "function",
    "signature",
    "write",
    "max",
    "let",
    "say",
    "def",
    "max",
    "profit",
    "give",
    "weights",
    "give",
    "profits",
    "give",
    "capacity",
    "pass",
    "defined",
    "problem",
    "stated",
    "identified",
    "input",
    "output",
    "formats",
    "need",
    "come",
    "example",
    "inputs",
    "test",
    "cases",
    "listed",
    "test",
    "cases",
    "generic",
    "test",
    "cases",
    "random",
    "set",
    "weights",
    "profits",
    "identify",
    "napsack",
    "optimal",
    "solution",
    "one",
    "option",
    "elements",
    "included",
    "take",
    "everything",
    "another",
    "option",
    "none",
    "elements",
    "included",
    "think",
    "scenarios",
    "one",
    "one",
    "elements",
    "included",
    "may",
    "also",
    "think",
    "areas",
    "use",
    "complete",
    "capacity",
    "okay",
    "use",
    "complete",
    "capacity",
    "optimal",
    "solution",
    "actually",
    "taking",
    "lower",
    "capacity",
    "may",
    "way",
    "fill",
    "capacity",
    "may",
    "lower",
    "profit",
    "another",
    "option",
    "takes",
    "less",
    "complete",
    "capacity",
    "higher",
    "profit",
    "think",
    "cases",
    "think",
    "think",
    "good",
    "test",
    "cases",
    "copy",
    "express",
    "test",
    "cases",
    "dictionaries",
    "test",
    "zero",
    "test",
    "one",
    "test",
    "two",
    "express",
    "dictionaries",
    "covering",
    "test",
    "cases",
    "mentioned",
    "see",
    "weights",
    "profits",
    "capacity",
    "165",
    "optimal",
    "solution",
    "309",
    "simply",
    "asking",
    "optimal",
    "solution",
    "maximum",
    "profit",
    "obtained",
    "extension",
    "problem",
    "identify",
    "elements",
    "chosen",
    "simple",
    "extension",
    "good",
    "exercise",
    "try",
    "discuss",
    "forums",
    "test",
    "zero",
    "test",
    "one",
    "test",
    "2",
    "test",
    "three",
    "four",
    "five",
    "total",
    "six",
    "six",
    "test",
    "cases",
    "let",
    "copy",
    "test",
    "cases",
    "let",
    "put",
    "single",
    "string",
    "gives",
    "us",
    "test",
    "cases",
    "okay",
    "coming",
    "solution",
    "first",
    "step",
    "try",
    "come",
    "recursive",
    "solution",
    "recursive",
    "solution",
    "quite",
    "straightforward",
    "write",
    "recursive",
    "function",
    "max",
    "profit",
    "given",
    "index",
    "time",
    "one",
    "sequence",
    "given",
    "index",
    "within",
    "sequence",
    "let",
    "say",
    "index",
    "idx",
    "computes",
    "maximum",
    "profit",
    "obtained",
    "using",
    "elements",
    "idx",
    "onwards",
    "31",
    "5",
    "47",
    "using",
    "elements",
    "idx",
    "onwards",
    "maximum",
    "profit",
    "obtained",
    "right",
    "using",
    "given",
    "capacity",
    "take",
    "uh",
    "index",
    "take",
    "index",
    "capacity",
    "let",
    "say",
    "idx",
    "one",
    "look",
    "elements",
    "capacity",
    "10",
    "try",
    "fill",
    "capacity",
    "10",
    "recursive",
    "function",
    "creating",
    "recursive",
    "function",
    "like",
    "simple",
    "reason",
    "suppose",
    "idx",
    "value",
    "one",
    "capacity",
    "10",
    "let",
    "say",
    "capacity",
    "3",
    "weight",
    "element",
    "greater",
    "capacity",
    "means",
    "show",
    "selected",
    "fit",
    "inside",
    "bag",
    "napag",
    "solution",
    "sub",
    "problem",
    "idx",
    "equal",
    "1",
    "capacity",
    "equal",
    "3",
    "solution",
    "sub",
    "problem",
    "element",
    "removed",
    "include",
    "element",
    "within",
    "napsack",
    "right",
    "remove",
    "element",
    "simply",
    "consider",
    "elements",
    "remaining",
    "elements",
    "essentially",
    "means",
    "idx",
    "1",
    "max",
    "profit",
    "idx",
    "1",
    "profit",
    "uh",
    "weights",
    "idx",
    "plus",
    "1",
    "profits",
    "idx",
    "plus",
    "1",
    "capacity",
    "answer",
    "max",
    "profit",
    "weight",
    "idx",
    "profits",
    "idx",
    "capacity",
    "current",
    "weight",
    "5",
    "greater",
    "capacity",
    "3",
    "recursive",
    "function",
    "invoked",
    "one",
    "option",
    "general",
    "case",
    "enough",
    "capacity",
    "let",
    "say",
    "capacity",
    "10",
    "recursion",
    "called",
    "capacity",
    "10",
    "idx1",
    "two",
    "choices",
    "either",
    "include",
    "element",
    "napsack",
    "include",
    "element",
    "know",
    "whether",
    "optimal",
    "solution",
    "element",
    "try",
    "two",
    "possibilities",
    "either",
    "pick",
    "weights",
    "idx",
    "element",
    "simply",
    "compute",
    "result",
    "cases",
    "pick",
    "maximum",
    "pick",
    "weights",
    "idx",
    "pick",
    "element",
    "capacity",
    "remains",
    "let",
    "say",
    "capacity",
    "10",
    "simply",
    "try",
    "fill",
    "capacity",
    "10",
    "using",
    "remaining",
    "elements",
    "simply",
    "call",
    "max",
    "profit",
    "weights",
    "idx",
    "1",
    "profits",
    "idx",
    "plus1",
    "onwards",
    "remaining",
    "capacity",
    "10",
    "pick",
    "element",
    "pick",
    "element",
    "capacity",
    "10",
    "optimal",
    "solution",
    "best",
    "solution",
    "case",
    "profit",
    "three",
    "solution",
    "case",
    "since",
    "also",
    "used",
    "capacity",
    "need",
    "add",
    "three",
    "profit",
    "need",
    "subtract",
    "five",
    "capacity",
    "right",
    "pick",
    "weights",
    "idx",
    "maximum",
    "profit",
    "case",
    "profits",
    "idx",
    "plus",
    "max",
    "profit",
    "weights",
    "idx",
    "1",
    "onwards",
    "profits",
    "idx",
    "plus",
    "one",
    "onwards",
    "used",
    "capacity",
    "reduce",
    "capacity",
    "recursive",
    "call",
    "okay",
    "recursive",
    "call",
    "takes",
    "index",
    "capacity",
    "okay",
    "hope",
    "makes",
    "sense",
    "recursive",
    "tree",
    "tells",
    "thing",
    "start",
    "first",
    "index",
    "capacity",
    "pick",
    "first",
    "element",
    "simp",
    "answer",
    "simply",
    "best",
    "solution",
    "second",
    "index",
    "onwards",
    "capacity",
    "pick",
    "first",
    "element",
    "answer",
    "second",
    "solution",
    "onwards",
    "reduced",
    "capacity",
    "profit",
    "added",
    "okay",
    "simply",
    "take",
    "maximum",
    "two",
    "cases",
    "call",
    "two",
    "recursive",
    "calls",
    "simply",
    "take",
    "maximum",
    "two",
    "cases",
    "get",
    "back",
    "final",
    "result",
    "final",
    "best",
    "answer",
    "final",
    "end",
    "case",
    "reached",
    "end",
    "weight",
    "idx",
    "onwards",
    "empty",
    "index",
    "tracking",
    "reached",
    "end",
    "irrespective",
    "capacity",
    "maximum",
    "profit",
    "case",
    "zero",
    "let",
    "try",
    "implement",
    "let",
    "copy",
    "explanation",
    "let",
    "try",
    "implement",
    "solution",
    "let",
    "say",
    "let",
    "call",
    "max",
    "profit",
    "recursive",
    "going",
    "take",
    "set",
    "weights",
    "going",
    "take",
    "set",
    "profits",
    "going",
    "take",
    "capacity",
    "also",
    "going",
    "take",
    "index",
    "index",
    "start",
    "zero",
    "index",
    "start",
    "base",
    "case",
    "idx",
    "equals",
    "length",
    "weights",
    "case",
    "nothing",
    "left",
    "simply",
    "return",
    "zero",
    "elements",
    "check",
    "weights",
    "idx",
    "current",
    "element",
    "greater",
    "weight",
    "capacity",
    "pretty",
    "straightforward",
    "solution",
    "simply",
    "return",
    "max",
    "profit",
    "recursive",
    "weights",
    "profits",
    "capacity",
    "one",
    "uh",
    "sorry",
    "capacity",
    "idx",
    "1",
    "simply",
    "ignore",
    "element",
    "fit",
    "capacity",
    "else",
    "two",
    "options",
    "option",
    "one",
    "option",
    "one",
    "even",
    "though",
    "fit",
    "within",
    "bag",
    "take",
    "optimal",
    "solution",
    "may",
    "still",
    "fits",
    "mean",
    "take",
    "look",
    "option",
    "one",
    "ignore",
    "element",
    "look",
    "option",
    "two",
    "option",
    "two",
    "actually",
    "put",
    "element",
    "bag",
    "since",
    "putting",
    "element",
    "bag",
    "get",
    "get",
    "profit",
    "get",
    "profits",
    "idx",
    "call",
    "max",
    "profits",
    "recursive",
    "time",
    "call",
    "weights",
    "profits",
    "capacity",
    "reduced",
    "little",
    "bit",
    "taken",
    "element",
    "need",
    "fill",
    "remaining",
    "fill",
    "need",
    "fill",
    "bag",
    "remaining",
    "elements",
    "idx",
    "plus",
    "1",
    "onwards",
    "limited",
    "capacity",
    "capacity",
    "minus",
    "weights",
    "idx",
    "finally",
    "put",
    "idx",
    "1",
    "start",
    "calculating",
    "solution",
    "next",
    "element",
    "onwards",
    "max",
    "profit",
    "recursive",
    "difficult",
    "six",
    "seven",
    "lines",
    "code",
    "let",
    "try",
    "test",
    "zero",
    "let",
    "try",
    "max",
    "profit",
    "recursive",
    "test",
    "zero",
    "input",
    "uh",
    "need",
    "get",
    "weights",
    "capacity",
    "profit",
    "simple",
    "way",
    "simply",
    "put",
    "star",
    "star",
    "get",
    "back",
    "get",
    "passed",
    "capacity",
    "get",
    "passed",
    "capacity",
    "parameter",
    "weights",
    "get",
    "passed",
    "weights",
    "parameter",
    "profits",
    "profits",
    "parameter",
    "okay",
    "encountered",
    "error",
    "completely",
    "fine",
    "completely",
    "fine",
    "encounter",
    "error",
    "see",
    "done",
    "uh",
    "really",
    "taken",
    "maximum",
    "two",
    "defined",
    "two",
    "options",
    "options",
    "need",
    "take",
    "max",
    "option",
    "one",
    "option",
    "two",
    "okay",
    "helping",
    "test",
    "test",
    "cases",
    "helps",
    "see",
    "call",
    "max",
    "profit",
    "also",
    "add",
    "timer",
    "max",
    "profit",
    "takes",
    "210",
    "micros",
    "seconds",
    "result",
    "returns",
    "result",
    "309",
    "great",
    "get",
    "back",
    "result",
    "309",
    "expected",
    "function",
    "working",
    "correctly",
    "even",
    "evaluate",
    "test",
    "cases",
    "python",
    "dsa",
    "import",
    "evaluate",
    "test",
    "cases",
    "simply",
    "call",
    "evaluate",
    "test",
    "cases",
    "inputs",
    "pass",
    "max",
    "profit",
    "recursive",
    "pass",
    "test",
    "cases",
    "tests",
    "see",
    "test",
    "cases",
    "test",
    "case",
    "seems",
    "passing",
    "fine",
    "six",
    "test",
    "cases",
    "passed",
    "times",
    "took",
    "recursive",
    "solution",
    "pretty",
    "straightforward",
    "reason",
    "maybe",
    "look",
    "example",
    "draw",
    "tree",
    "recursion",
    "work",
    "paper",
    "code",
    "fact",
    "cases",
    "fairly",
    "simple",
    "recursion",
    "tree",
    "looks",
    "like",
    "time",
    "make",
    "choice",
    "either",
    "include",
    "element",
    "include",
    "element",
    "reason",
    "complexity",
    "easily",
    "n",
    "elements",
    "one",
    "keep",
    "making",
    "choice",
    "means",
    "end",
    "2",
    "n",
    "leaves",
    "follows",
    "complexity",
    "recursive",
    "algorithm",
    "order",
    "2",
    "n",
    "right",
    "could",
    "2",
    "c",
    "2",
    "n",
    "uh",
    "big",
    "notation",
    "order",
    "2",
    "n",
    "exponential",
    "complexity",
    "exponential",
    "complexity",
    "possibility",
    "may",
    "computing",
    "lot",
    "things",
    "repeatedly",
    "creating",
    "many",
    "sub",
    "problems",
    "possible",
    "may",
    "creating",
    "may",
    "recomputing",
    "lot",
    "data",
    "task",
    "exercise",
    "write",
    "memorized",
    "version",
    "need",
    "memorize",
    "trick",
    "look",
    "changing",
    "within",
    "recursive",
    "calls",
    "max",
    "profit",
    "recursive",
    "see",
    "weights",
    "profits",
    "remains",
    "capacity",
    "idx",
    "change",
    "take",
    "capacity",
    "comma",
    "index",
    "idx",
    "key",
    "memorization",
    "dictionary",
    "time",
    "compute",
    "time",
    "let",
    "say",
    "compute",
    "compute",
    "compute",
    "store",
    "result",
    "dictionary",
    "returning",
    "beginning",
    "recursive",
    "function",
    "check",
    "within",
    "dictionary",
    "value",
    "already",
    "present",
    "okay",
    "remember",
    "longest",
    "common",
    "subsequence",
    "defined",
    "recursive",
    "function",
    "internally",
    "defined",
    "memo",
    "dictionary",
    "internally",
    "recursive",
    "function",
    "kept",
    "either",
    "checking",
    "dictionary",
    "filling",
    "dictionary",
    "could",
    "find",
    "value",
    "could",
    "eliminate",
    "lot",
    "repeated",
    "work",
    "problem",
    "okay",
    "challenge",
    "try",
    "implement",
    "memo",
    "solution",
    "go",
    "ahead",
    "implement",
    "dynamic",
    "programming",
    "solution",
    "let",
    "commit",
    "work",
    "analyzed",
    "algorithm",
    "complexity",
    "recursion",
    "order",
    "2",
    "n",
    "memorization",
    "exercise",
    "think",
    "complexity",
    "let",
    "apply",
    "dynamic",
    "programming",
    "let",
    "look",
    "dynamic",
    "programming",
    "solution",
    "dynamic",
    "programming",
    "create",
    "table",
    "always",
    "almost",
    "always",
    "create",
    "table",
    "dynamic",
    "programming",
    "case",
    "see",
    "n",
    "elements",
    "n",
    "rows",
    "within",
    "table",
    "n",
    "elements",
    "choose",
    "number",
    "columns",
    "going",
    "0",
    "capacity",
    "1",
    "uh",
    "going",
    "zero",
    "capacity",
    "total",
    "capacity",
    "plus",
    "1",
    "columns",
    "fact",
    "also",
    "include",
    "another",
    "column",
    "top",
    "another",
    "row",
    "top",
    "shown",
    "n",
    "represents",
    "n",
    "number",
    "elements",
    "n",
    "represents",
    "particular",
    "element",
    "table",
    "represents",
    "table",
    "comma",
    "c",
    "represents",
    "maximum",
    "profit",
    "obtained",
    "using",
    "first",
    "elements",
    "maximum",
    "capacity",
    "c",
    "okay",
    "maximum",
    "capacity",
    "c",
    "let",
    "say",
    "maximum",
    "capacity",
    "three",
    "maximum",
    "profit",
    "obtain",
    "using",
    "first",
    "two",
    "elements",
    "um",
    "let",
    "say",
    "position",
    "using",
    "first",
    "two",
    "elements",
    "list",
    "within",
    "capacity",
    "okay",
    "first",
    "two",
    "elements",
    "weights",
    "one",
    "two",
    "capacity",
    "three",
    "actually",
    "pick",
    "sorry",
    "first",
    "two",
    "elements",
    "weights",
    "two",
    "three",
    "capacity",
    "three",
    "either",
    "pick",
    "element",
    "pick",
    "element",
    "pick",
    "element",
    "profit",
    "one",
    "pick",
    "element",
    "profit",
    "two",
    "solution",
    "pick",
    "element",
    "get",
    "uh",
    "fill",
    "capacity",
    "three",
    "get",
    "profit",
    "two",
    "pick",
    "capacity",
    "three",
    "okay",
    "logic",
    "simple",
    "visual",
    "representation",
    "remember",
    "also",
    "zero",
    "throw",
    "shown",
    "something",
    "another",
    "zero",
    "throw",
    "zero",
    "throw",
    "represents",
    "picked",
    "elements",
    "pick",
    "elements",
    "simply",
    "going",
    "contain",
    "zeros",
    "shown",
    "first",
    "row",
    "assumes",
    "picked",
    "pick",
    "first",
    "element",
    "ca",
    "pick",
    "first",
    "element",
    "till",
    "capacity",
    "two",
    "capacity",
    "two",
    "onwards",
    "pick",
    "first",
    "element",
    "maximum",
    "capacity",
    "one",
    "uh",
    "maximum",
    "profit",
    "one",
    "second",
    "row",
    "row",
    "number",
    "two",
    "row",
    "index",
    "two",
    "represents",
    "fact",
    "pick",
    "elements",
    "pick",
    "elements",
    "capacity",
    "zero",
    "none",
    "picked",
    "capacity",
    "one",
    "none",
    "picked",
    "capacity",
    "two",
    "element",
    "picked",
    "weight",
    "two",
    "gives",
    "maximum",
    "profit",
    "one",
    "capacity",
    "3",
    "element",
    "also",
    "picked",
    "choice",
    "pick",
    "two",
    "might",
    "well",
    "better",
    "pick",
    "one",
    "going",
    "give",
    "higher",
    "profit",
    "finally",
    "capacity",
    "becomes",
    "five",
    "pick",
    "elements",
    "pick",
    "elements",
    "going",
    "give",
    "profit",
    "2",
    "1",
    "3",
    "keep",
    "filling",
    "table",
    "step",
    "set",
    "first",
    "elements",
    "fill",
    "capacity",
    "table",
    "use",
    "information",
    "fill",
    "next",
    "row",
    "next",
    "column",
    "okay",
    "finally",
    "need",
    "using",
    "elements",
    "using",
    "maximum",
    "capacity",
    "maximum",
    "profit",
    "obtain",
    "last",
    "element",
    "table",
    "give",
    "result",
    "okay",
    "logic",
    "look",
    "like",
    "fill",
    "table",
    "row",
    "row",
    "column",
    "column",
    "table",
    "comma",
    "c",
    "table",
    "comma",
    "c",
    "let",
    "say",
    "certain",
    "position",
    "table",
    "comma",
    "c",
    "filled",
    "using",
    "values",
    "row",
    "okay",
    "look",
    "table",
    "comma",
    "c",
    "look",
    "look",
    "element",
    "example",
    "yeah",
    "let",
    "look",
    "element",
    "c",
    "value",
    "three",
    "value",
    "zero",
    "row",
    "shown",
    "1",
    "2",
    "3",
    "4",
    "value",
    "4",
    "c",
    "value",
    "three",
    "yeah",
    "weights",
    "greater",
    "c",
    "0",
    "1",
    "2",
    "3",
    "4",
    "um",
    "weight",
    "weight",
    "weight",
    "element",
    "greater",
    "capacity",
    "weight",
    "element",
    "four",
    "greater",
    "capacity",
    "element",
    "show",
    "maximum",
    "profit",
    "weight",
    "greater",
    "capacity",
    "obviously",
    "show",
    "maximum",
    "profit",
    "show",
    "maximum",
    "profit",
    "cell",
    "filled",
    "using",
    "value",
    "case",
    "put",
    "element",
    "might",
    "well",
    "get",
    "result",
    "using",
    "first",
    "three",
    "elements",
    "case",
    "value",
    "cell",
    "obtained",
    "value",
    "cell",
    "one",
    "case",
    "hand",
    "let",
    "come",
    "come",
    "case",
    "cell",
    "fill",
    "cell",
    "capacity",
    "four",
    "option",
    "either",
    "choosing",
    "element",
    "choosing",
    "element",
    "choose",
    "element",
    "let",
    "say",
    "choose",
    "element",
    "capacity",
    "four",
    "capacity",
    "four",
    "get",
    "back",
    "profit",
    "n9",
    "capacity",
    "left",
    "create",
    "fill",
    "elements",
    "hand",
    "choose",
    "element",
    "value",
    "choose",
    "element",
    "fill",
    "capacity",
    "four",
    "using",
    "value",
    "using",
    "first",
    "three",
    "elements",
    "simply",
    "gives",
    "highest",
    "profit",
    "previous",
    "sell",
    "right",
    "consider",
    "two",
    "cases",
    "whether",
    "choose",
    "element",
    "choose",
    "element",
    "choose",
    "element",
    "value",
    "comes",
    "choose",
    "element",
    "value",
    "comes",
    "let",
    "see",
    "choose",
    "element",
    "profit",
    "nine",
    "comes",
    "fill",
    "capacity",
    "4",
    "remaining",
    "capacity",
    "hand",
    "capacity",
    "six",
    "choose",
    "element",
    "chosen",
    "element",
    "used",
    "capacity",
    "4",
    "still",
    "use",
    "previous",
    "three",
    "elements",
    "fill",
    "remaining",
    "capacity",
    "6",
    "4",
    "capacity",
    "2",
    "go",
    "back",
    "previous",
    "row",
    "check",
    "capacity",
    "2",
    "see",
    "much",
    "maximum",
    "profit",
    "obtain",
    "capacity",
    "2",
    "turns",
    "capacity",
    "two",
    "using",
    "first",
    "three",
    "elements",
    "obtain",
    "maximum",
    "profit",
    "one",
    "maximum",
    "profit",
    "choose",
    "element",
    "99",
    "1",
    "10",
    "similarly",
    "maximum",
    "profit",
    "obtained",
    "choose",
    "element",
    "9",
    "plus",
    "7",
    "minus",
    "uh",
    "plus",
    "previous",
    "row",
    "pick",
    "element",
    "capacity",
    "7",
    "4",
    "3",
    "9",
    "5",
    "14",
    "okay",
    "logic",
    "sometimes",
    "choose",
    "element",
    "sometimes",
    "choose",
    "element",
    "fact",
    "sol",
    "result",
    "cell",
    "simply",
    "maximum",
    "either",
    "choosing",
    "elements",
    "maximum",
    "cell",
    "choosing",
    "element",
    "subtracting",
    "weight",
    "6",
    "4",
    "2",
    "maximum",
    "okay",
    "let",
    "implement",
    "dynamic",
    "programming",
    "solution",
    "work",
    "paper",
    "really",
    "helps",
    "work",
    "paper",
    "let",
    "say",
    "max",
    "profit",
    "dp",
    "dynamic",
    "programming",
    "solution",
    "solution",
    "weights",
    "profits",
    "capacity",
    "let",
    "say",
    "n",
    "len",
    "weights",
    "need",
    "create",
    "um",
    "table",
    "table",
    "table",
    "contains",
    "n",
    "rows",
    "len",
    "n",
    "rows",
    "contain",
    "capacity",
    "one",
    "oh",
    "contain",
    "n",
    "plus1",
    "rows",
    "remember",
    "also",
    "want",
    "consider",
    "case",
    "consider",
    "take",
    "elements",
    "filled",
    "zeros",
    "number",
    "columns",
    "capacity",
    "1",
    "check",
    "values",
    "0",
    "capacity",
    "table",
    "right",
    "check",
    "capacity",
    "looks",
    "like",
    "let",
    "say",
    "n",
    "n",
    "capacity",
    "values",
    "n",
    "case",
    "five",
    "capacity",
    "10",
    "need",
    "len",
    "need",
    "len",
    "well",
    "perfectly",
    "natural",
    "make",
    "mistakes",
    "range",
    "len",
    "range",
    "range",
    "yeah",
    "see",
    "created",
    "n",
    "rows",
    "n",
    "plus",
    "one",
    "rows",
    "one",
    "one",
    "row",
    "containing",
    "contain",
    "zeros",
    "case",
    "pick",
    "elements",
    "created",
    "11",
    "columns",
    "capacity",
    "zero",
    "first",
    "column",
    "also",
    "contain",
    "zeros",
    "something",
    "often",
    "see",
    "dynamic",
    "programming",
    "additional",
    "row",
    "beginning",
    "end",
    "containing",
    "zeros",
    "simply",
    "make",
    "calculations",
    "like",
    "computations",
    "easier",
    "lead",
    "one",
    "error",
    "need",
    "careful",
    "fill",
    "value",
    "using",
    "either",
    "value",
    "subtracting",
    "weight",
    "element",
    "getting",
    "value",
    "previous",
    "row",
    "start",
    "iterating",
    "say",
    "range",
    "n",
    "j",
    "range",
    "c",
    "let",
    "say",
    "c",
    "range",
    "capacity",
    "capacity",
    "table",
    "comma",
    "c",
    "actually",
    "going",
    "1",
    "1",
    "additional",
    "rows",
    "columns",
    "table",
    "1a",
    "1",
    "two",
    "cases",
    "weights",
    "greater",
    "c",
    "current",
    "capacity",
    "simply",
    "look",
    "previous",
    "row",
    "case",
    "let",
    "say",
    "weight",
    "three",
    "greater",
    "current",
    "capacity",
    "2",
    "simply",
    "copy",
    "value",
    "previous",
    "row",
    "column",
    "say",
    "table",
    "comma",
    "c",
    "1",
    "c",
    "capacity",
    "go",
    "value",
    "one",
    "want",
    "affect",
    "first",
    "column",
    "capacity",
    "goes",
    "value",
    "1",
    "value",
    "10",
    "capacity",
    "c",
    "goes",
    "range",
    "1",
    "capacity",
    "weights",
    "greater",
    "capacity",
    "fill",
    "table",
    "hand",
    "fits",
    "within",
    "capacity",
    "two",
    "options",
    "table",
    "1",
    "comma",
    "c",
    "two",
    "options",
    "one",
    "use",
    "current",
    "element",
    "use",
    "current",
    "element",
    "gives",
    "stable",
    "ic",
    "option",
    "use",
    "current",
    "element",
    "get",
    "profit",
    "current",
    "element",
    "profits",
    "high",
    "get",
    "profits",
    "reduces",
    "capacity",
    "pick",
    "table",
    "pick",
    "c",
    "minus",
    "weight",
    "weights",
    "okay",
    "fill",
    "entire",
    "table",
    "pretty",
    "much",
    "nice",
    "thing",
    "dynamic",
    "programming",
    "simply",
    "write",
    "one",
    "solution",
    "one",
    "recurrence",
    "careful",
    "everything",
    "else",
    "taken",
    "care",
    "loop",
    "simply",
    "return",
    "table",
    "minus1",
    "let",
    "see",
    "works",
    "likely",
    "issues",
    "let",
    "see",
    "test",
    "cases",
    "max",
    "profit",
    "dp",
    "tests",
    "great",
    "seeing",
    "issue",
    "already",
    "see",
    "range",
    "range",
    "okay",
    "one",
    "thing",
    "done",
    "well",
    "seems",
    "like",
    "solution",
    "always",
    "zero",
    "ah",
    "capacity",
    "1",
    "takes",
    "values",
    "0",
    "capacity",
    "right",
    "c",
    "iterator",
    "take",
    "values",
    "1",
    "2",
    "3",
    "4",
    "way",
    "maximum",
    "capacity",
    "range",
    "end",
    "uh",
    "range",
    "include",
    "end",
    "value",
    "need",
    "put",
    "capacity",
    "one",
    "okay",
    "way",
    "see",
    "one",
    "errors",
    "always",
    "going",
    "bug",
    "dynamic",
    "programming",
    "probably",
    "solved",
    "um",
    "50",
    "100",
    "problems",
    "dynamic",
    "programming",
    "still",
    "make",
    "errors",
    "um",
    "way",
    "see",
    "test",
    "cases",
    "seems",
    "pass",
    "may",
    "cases",
    "accounted",
    "overall",
    "covered",
    "test",
    "cases",
    "ended",
    "dynamic",
    "programming",
    "solution",
    "let",
    "figure",
    "complexity",
    "pretty",
    "straightforward",
    "filling",
    "table",
    "filling",
    "table",
    "simply",
    "requires",
    "constant",
    "amount",
    "work",
    "comparison",
    "potentially",
    "another",
    "comparison",
    "addition",
    "subtraction",
    "like",
    "four",
    "five",
    "operations",
    "n",
    "n",
    "uh",
    "n",
    "capac",
    "uh",
    "n",
    "capacity",
    "n",
    "length",
    "weights",
    "capac",
    "w",
    "total",
    "capacity",
    "n",
    "w",
    "number",
    "iterations",
    "really",
    "also",
    "complexity",
    "time",
    "complexity",
    "algorithm",
    "napsack",
    "problem",
    "try",
    "figure",
    "maximum",
    "value",
    "also",
    "figure",
    "actual",
    "elements",
    "chosen",
    "napsack",
    "problem",
    "longest",
    "subsequence",
    "problem",
    "figure",
    "actual",
    "longest",
    "subsequence",
    "quence",
    "possible",
    "small",
    "modification",
    "use",
    "forum",
    "questions",
    "contents",
    "lecture",
    "go",
    "back",
    "lesson",
    "page",
    "open",
    "course",
    "community",
    "forum",
    "see",
    "u",
    "lesson",
    "recursion",
    "dynamic",
    "programming",
    "lesson",
    "post",
    "question",
    "also",
    "discuss",
    "ideas",
    "figure",
    "longest",
    "common",
    "subsequence",
    "best",
    "selection",
    "napsack",
    "problem",
    "next",
    "well",
    "review",
    "lecture",
    "video",
    "execute",
    "jupyter",
    "notebook",
    "next",
    "step",
    "also",
    "complete",
    "assignment",
    "released",
    "assignments",
    "one",
    "two",
    "far",
    "go",
    "back",
    "lesson",
    "page",
    "find",
    "lessons",
    "uh",
    "find",
    "assignments",
    "one",
    "two",
    "work",
    "sufficient",
    "time",
    "also",
    "work",
    "optional",
    "questions",
    "participate",
    "forum",
    "discussions",
    "possible",
    "join",
    "study",
    "group",
    "two",
    "great",
    "way",
    "stay",
    "motivated",
    "lesson",
    "four",
    "data",
    "structures",
    "algorithms",
    "python",
    "thanks",
    "talk",
    "soon",
    "hello",
    "welcome",
    "data",
    "structures",
    "algorithms",
    "python",
    "online",
    "certification",
    "course",
    "conducted",
    "jovian",
    "today",
    "lesson",
    "five",
    "graph",
    "algorithms",
    "like",
    "bfs",
    "dfs",
    "shortest",
    "parts",
    "name",
    "akash",
    "instructor",
    "find",
    "twitter",
    "aashan",
    "follow",
    "along",
    "course",
    "complete",
    "assignments",
    "build",
    "course",
    "project",
    "earn",
    "verified",
    "certificate",
    "accomplishment",
    "course",
    "let",
    "get",
    "started",
    "first",
    "thing",
    "go",
    "course",
    "website",
    "python",
    "point",
    "browser",
    "python",
    "open",
    "course",
    "page",
    "course",
    "page",
    "enroll",
    "course",
    "view",
    "pre",
    "previous",
    "lessons",
    "assignments",
    "check",
    "check",
    "course",
    "project",
    "well",
    "open",
    "lesson",
    "five",
    "graph",
    "algorithms",
    "page",
    "watch",
    "video",
    "lesson",
    "later",
    "video",
    "watching",
    "right",
    "also",
    "catch",
    "hindi",
    "version",
    "wish",
    "code",
    "going",
    "use",
    "today",
    "first",
    "notebook",
    "heading",
    "notebooks",
    "let",
    "open",
    "jupyter",
    "notebook",
    "hosted",
    "jovian",
    "familiar",
    "see",
    "explanations",
    "code",
    "cells",
    "write",
    "code",
    "see",
    "code",
    "actually",
    "execute",
    "edit",
    "code",
    "need",
    "run",
    "notebook",
    "find",
    "instructions",
    "run",
    "notebook",
    "right",
    "simplest",
    "way",
    "click",
    "run",
    "select",
    "run",
    "binder",
    "take",
    "second",
    "two",
    "take",
    "jupyter",
    "notebook",
    "create",
    "new",
    "machine",
    "cloud",
    "send",
    "jupyter",
    "notebook",
    "machine",
    "execution",
    "free",
    "service",
    "access",
    "via",
    "jovian",
    "also",
    "run",
    "notebook",
    "computer",
    "directly",
    "wish",
    "check",
    "run",
    "locally",
    "option",
    "okay",
    "jupyter",
    "notebook",
    "server",
    "ready",
    "start",
    "editing",
    "writing",
    "code",
    "let",
    "go",
    "full",
    "screen",
    "okay",
    "topic",
    "today",
    "graph",
    "algorithms",
    "bfs",
    "tfs",
    "shortest",
    "paths",
    "using",
    "python",
    "talk",
    "graph",
    "algorithms",
    "let",
    "try",
    "understand",
    "intuitively",
    "graphs",
    "example",
    "graph",
    "real",
    "world",
    "world",
    "railway",
    "map",
    "india",
    "see",
    "train",
    "stations",
    "india",
    "represented",
    "using",
    "black",
    "dots",
    "points",
    "also",
    "labeled",
    "train",
    "station",
    "points",
    "city",
    "village",
    "also",
    "labeled",
    "see",
    "connections",
    "stations",
    "might",
    "guess",
    "railway",
    "lines",
    "see",
    "three",
    "four",
    "colors",
    "involved",
    "colors",
    "could",
    "represent",
    "different",
    "types",
    "railway",
    "lines",
    "like",
    "different",
    "gauge",
    "meter",
    "gauge",
    "broad",
    "gauge",
    "etc",
    "could",
    "represent",
    "different",
    "zones",
    "information",
    "contained",
    "connections",
    "well",
    "another",
    "important",
    "thing",
    "railway",
    "line",
    "two",
    "cities",
    "also",
    "certain",
    "length",
    "graph",
    "roughly",
    "kind",
    "questions",
    "may",
    "want",
    "ask",
    "example",
    "path",
    "new",
    "delhi",
    "hyderabad",
    "given",
    "information",
    "first",
    "question",
    "even",
    "represent",
    "information",
    "many",
    "railway",
    "lines",
    "connections",
    "different",
    "cities",
    "many",
    "hundreds",
    "cities",
    "even",
    "represent",
    "start",
    "writing",
    "algorithms",
    "answer",
    "questions",
    "right",
    "building",
    "search",
    "train",
    "search",
    "website",
    "would",
    "answer",
    "given",
    "new",
    "delhi",
    "hyderabad",
    "way",
    "get",
    "new",
    "delhi",
    "hyderabad",
    "okay",
    "first",
    "question",
    "might",
    "ask",
    "way",
    "next",
    "question",
    "might",
    "path",
    "shortest",
    "number",
    "stops",
    "go",
    "way",
    "shortest",
    "number",
    "stops",
    "go",
    "way",
    "go",
    "way",
    "another",
    "question",
    "could",
    "path",
    "shortest",
    "distance",
    "right",
    "sometimes",
    "measure",
    "distance",
    "measure",
    "number",
    "stations",
    "number",
    "stops",
    "may",
    "different",
    "along",
    "different",
    "paths",
    "one",
    "may",
    "greater",
    "certain",
    "cases",
    "kind",
    "questions",
    "want",
    "ask",
    "answer",
    "today",
    "another",
    "question",
    "could",
    "stations",
    "reachable",
    "new",
    "delhi",
    "within",
    "one",
    "stop",
    "two",
    "stops",
    "three",
    "stops",
    "10",
    "stops",
    "kind",
    "questions",
    "try",
    "answer",
    "need",
    "way",
    "represent",
    "graphs",
    "abstract",
    "fashion",
    "question",
    "asked",
    "different",
    "context",
    "instance",
    "looking",
    "flight",
    "routes",
    "international",
    "flight",
    "routes",
    "ask",
    "exact",
    "thing",
    "way",
    "get",
    "new",
    "delhi",
    "vancouver",
    "many",
    "stops",
    "require",
    "minimum",
    "number",
    "stops",
    "take",
    "get",
    "new",
    "delhi",
    "vancouver",
    "minimum",
    "time",
    "might",
    "take",
    "maybe",
    "okay",
    "taking",
    "multiple",
    "stops",
    "want",
    "minimize",
    "time",
    "taken",
    "distance",
    "traveled",
    "concerned",
    "miles",
    "reason",
    "another",
    "thing",
    "could",
    "ask",
    "minimum",
    "cost",
    "cost",
    "along",
    "route",
    "okay",
    "one",
    "example",
    "different",
    "domain",
    "hyperlinks",
    "internet",
    "essentially",
    "see",
    "whole",
    "bunch",
    "websites",
    "links",
    "websites",
    "links",
    "websites",
    "point",
    "websites",
    "case",
    "one",
    "way",
    "connection",
    "see",
    "particular",
    "course",
    "website",
    "link",
    "ibm",
    "ibm",
    "may",
    "link",
    "course",
    "website",
    "interesting",
    "thing",
    "slight",
    "variation",
    "called",
    "directed",
    "graph",
    "connection",
    "particular",
    "direction",
    "interesting",
    "ask",
    "way",
    "navigate",
    "cs",
    "itaka",
    "weather",
    "shortest",
    "way",
    "path",
    "look",
    "like",
    "kind",
    "questions",
    "want",
    "answer",
    "today",
    "need",
    "abstract",
    "representation",
    "graphs",
    "start",
    "simplest",
    "possible",
    "representation",
    "certain",
    "points",
    "call",
    "nodes",
    "vertices",
    "two",
    "terms",
    "used",
    "points",
    "nodes",
    "vertices",
    "graph",
    "certain",
    "nodes",
    "vertices",
    "make",
    "things",
    "easy",
    "could",
    "cities",
    "could",
    "web",
    "pages",
    "could",
    "something",
    "else",
    "make",
    "things",
    "easy",
    "number",
    "nodes",
    "graph",
    "10",
    "nodes",
    "number",
    "nodes",
    "0",
    "9",
    "okay",
    "numbered",
    "completely",
    "arbitrarily",
    "reason",
    "name",
    "name",
    "number",
    "zero",
    "number",
    "one",
    "important",
    "use",
    "numbers",
    "0",
    "n",
    "minus1",
    "dealing",
    "n",
    "nodes",
    "see",
    "moment",
    "try",
    "represent",
    "graphs",
    "using",
    "certain",
    "data",
    "structures",
    "like",
    "ad",
    "adjacency",
    "list",
    "etc",
    "want",
    "number",
    "nodes",
    "0",
    "n",
    "minus",
    "one",
    "number",
    "arbitrary",
    "one",
    "represent",
    "anything",
    "sense",
    "one",
    "greater",
    "zero",
    "okay",
    "nodes",
    "labels",
    "edges",
    "nodes",
    "edge",
    "simply",
    "pair",
    "edge",
    "simply",
    "something",
    "like",
    "1a",
    "2",
    "pair",
    "1a",
    "2",
    "tells",
    "edge",
    "node",
    "1",
    "node",
    "2",
    "okay",
    "move",
    "forward",
    "also",
    "store",
    "information",
    "within",
    "edge",
    "call",
    "weight",
    "edge",
    "also",
    "later",
    "look",
    "directed",
    "edges",
    "get",
    "get",
    "us",
    "directed",
    "graphs",
    "let",
    "start",
    "let",
    "see",
    "represent",
    "basic",
    "structure",
    "represent",
    "uh",
    "graph",
    "represent",
    "graph",
    "using",
    "two",
    "variables",
    "one",
    "called",
    "number",
    "nodes",
    "number",
    "nodes",
    "case",
    "five",
    "represent",
    "edges",
    "using",
    "list",
    "pairs",
    "case",
    "pairs",
    "0a",
    "1",
    "case",
    "pairs",
    "0a",
    "1",
    "edge",
    "0a",
    "4",
    "4",
    "h2",
    "uh",
    "1a",
    "2",
    "one",
    "connected",
    "two",
    "edge",
    "case",
    "bidirectional",
    "saying",
    "0",
    "comma",
    "1",
    "say",
    "automatically",
    "says",
    "1",
    "z",
    "also",
    "connected",
    "right",
    "1",
    "comma",
    "2",
    "2a",
    "3",
    "order",
    "write",
    "matter",
    "could",
    "written",
    "3a",
    "2",
    "well",
    "also",
    "1",
    "comma",
    "3",
    "1a",
    "4",
    "great",
    "finally",
    "3a",
    "4",
    "okay",
    "represent",
    "data",
    "structure",
    "drawn",
    "represented",
    "code",
    "using",
    "two",
    "variables",
    "check",
    "simply",
    "print",
    "number",
    "nodes",
    "length",
    "edges",
    "verify",
    "roughly",
    "correct",
    "see",
    "five",
    "nodes",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "edges",
    "okay",
    "seems",
    "right",
    "could",
    "may",
    "mistake",
    "roughly",
    "set",
    "things",
    "correctly",
    "okay",
    "question",
    "becomes",
    "question",
    "representation",
    "good",
    "enough",
    "representation",
    "good",
    "enough",
    "want",
    "convey",
    "structure",
    "graph",
    "someone",
    "could",
    "give",
    "two",
    "variables",
    "without",
    "showing",
    "image",
    "could",
    "use",
    "information",
    "draw",
    "graph",
    "piece",
    "paper",
    "representation",
    "complete",
    "provides",
    "information",
    "graph",
    "may",
    "efficient",
    "example",
    "want",
    "find",
    "nodes",
    "node",
    "one",
    "connected",
    "would",
    "iterate",
    "entire",
    "list",
    "edges",
    "would",
    "go",
    "one",
    "check",
    "either",
    "one",
    "check",
    "either",
    "one",
    "makes",
    "tricky",
    "access",
    "information",
    "efficiently",
    "rather",
    "much",
    "nicer",
    "look",
    "list",
    "notes",
    "one",
    "connected",
    "way",
    "go",
    "want",
    "find",
    "shortest",
    "path",
    "would",
    "first",
    "find",
    "notes",
    "one",
    "connected",
    "would",
    "find",
    "neighbors",
    "would",
    "find",
    "find",
    "neighbors",
    "would",
    "get",
    "pretty",
    "tedious",
    "go",
    "list",
    "many",
    "times",
    "way",
    "neighbor",
    "represent",
    "mean",
    "two",
    "nodes",
    "connected",
    "edge",
    "zero",
    "one",
    "neighbors",
    "0",
    "2",
    "neighbors",
    "simple",
    "nomenclature",
    "use",
    "say",
    "track",
    "path",
    "say",
    "012",
    "edge",
    "say",
    "012",
    "path",
    "012",
    "case",
    "path",
    "3",
    "0",
    "1",
    "path",
    "path",
    "edge",
    "three",
    "0",
    "okay",
    "see",
    "mean",
    "paths",
    "neighbors",
    "time",
    "work",
    "graphs",
    "efficiently",
    "represent",
    "using",
    "called",
    "adjacency",
    "list",
    "name",
    "explains",
    "contains",
    "adjacency",
    "list",
    "contains",
    "list",
    "node",
    "contains",
    "list",
    "nodes",
    "adjacent",
    "node",
    "adjacency",
    "adjacent",
    "neighbor",
    "node",
    "example",
    "node",
    "0",
    "maintain",
    "list",
    "list",
    "contains",
    "numbers",
    "1",
    "four",
    "indicating",
    "0",
    "adjacent",
    "0",
    "neighbor",
    "zero",
    "connected",
    "via",
    "direct",
    "edge",
    "1",
    "four",
    "1",
    "four",
    "1",
    "connected",
    "0",
    "2",
    "3",
    "4",
    "see",
    "1",
    "connected",
    "0",
    "2",
    "3",
    "4",
    "similarly",
    "two",
    "connected",
    "1",
    "3",
    "3",
    "connected",
    "1",
    "2",
    "4",
    "4",
    "connected",
    "0",
    "1",
    "three",
    "convenient",
    "sure",
    "one",
    "since",
    "uh",
    "list",
    "want",
    "find",
    "let",
    "say",
    "nodes",
    "2",
    "connected",
    "directly",
    "access",
    "index",
    "two",
    "within",
    "list",
    "number",
    "vertices",
    "number",
    "nodes",
    "0",
    "n",
    "minus",
    "one",
    "access",
    "directly",
    "adjacency",
    "list",
    "right",
    "directly",
    "access",
    "number",
    "stored",
    "next",
    "two",
    "1",
    "three",
    "makes",
    "convenient",
    "one",
    "important",
    "thing",
    "notice",
    "edges",
    "edge",
    "occurs",
    "twice",
    "edge",
    "01",
    "shows",
    "list",
    "zero",
    "see",
    "list",
    "zero",
    "one",
    "similarly",
    "list",
    "one",
    "zero",
    "edge",
    "shows",
    "two",
    "adjacency",
    "list",
    "nodes",
    "connects",
    "okay",
    "obvious",
    "next",
    "question",
    "might",
    "create",
    "class",
    "represent",
    "gra",
    "adjacency",
    "list",
    "python",
    "okay",
    "question",
    "might",
    "get",
    "asked",
    "step",
    "might",
    "part",
    "another",
    "question",
    "may",
    "get",
    "asked",
    "asked",
    "perform",
    "breadth",
    "first",
    "search",
    "depth",
    "first",
    "search",
    "find",
    "shortest",
    "path",
    "first",
    "step",
    "define",
    "class",
    "graph",
    "maintain",
    "information",
    "graph",
    "adjacency",
    "list",
    "okay",
    "creating",
    "class",
    "graph",
    "first",
    "thing",
    "need",
    "inside",
    "graph",
    "constructor",
    "function",
    "need",
    "put",
    "something",
    "inside",
    "constructor",
    "function",
    "know",
    "first",
    "argument",
    "graph",
    "class",
    "method",
    "python",
    "self",
    "represents",
    "object",
    "get",
    "created",
    "ultimately",
    "create",
    "object",
    "class",
    "apart",
    "information",
    "need",
    "create",
    "graph",
    "pretty",
    "straightforward",
    "simply",
    "work",
    "information",
    "two",
    "variables",
    "together",
    "specify",
    "graph",
    "completely",
    "let",
    "simply",
    "accept",
    "accept",
    "num",
    "nodes",
    "list",
    "edges",
    "information",
    "first",
    "thing",
    "simply",
    "store",
    "num",
    "nodes",
    "self",
    "nom",
    "nodes",
    "create",
    "graph",
    "access",
    "number",
    "notes",
    "easily",
    "need",
    "create",
    "adjacency",
    "list",
    "need",
    "create",
    "adjacency",
    "list",
    "call",
    "self",
    "data",
    "initially",
    "create",
    "list",
    "containing",
    "empty",
    "lists",
    "fill",
    "empty",
    "list",
    "step",
    "step",
    "need",
    "something",
    "like",
    "case",
    "five",
    "five",
    "nodes",
    "need",
    "create",
    "five",
    "empty",
    "lists",
    "general",
    "way",
    "create",
    "repeated",
    "elements",
    "say",
    "want",
    "create",
    "repeated",
    "element",
    "like",
    "0",
    "type",
    "0",
    "10",
    "gives",
    "list",
    "0",
    "0",
    "containing",
    "zeros",
    "hand",
    "create",
    "empty",
    "list",
    "10",
    "let",
    "call",
    "l1",
    "let",
    "see",
    "l1",
    "looks",
    "like",
    "gotten",
    "empty",
    "list",
    "gotten",
    "list",
    "containing",
    "10",
    "empty",
    "lists",
    "let",
    "go",
    "first",
    "element",
    "first",
    "element",
    "first",
    "empty",
    "list",
    "inside",
    "first",
    "element",
    "let",
    "us",
    "add",
    "value",
    "one",
    "okay",
    "let",
    "look",
    "let",
    "look",
    "list",
    "l1",
    "see",
    "happen",
    "happens",
    "one",
    "gets",
    "inserted",
    "lists",
    "problem",
    "problem",
    "create",
    "list",
    "containing",
    "empty",
    "list",
    "containing",
    "object",
    "object",
    "gets",
    "replicated",
    "10",
    "times",
    "python",
    "create",
    "copies",
    "working",
    "numbers",
    "fine",
    "working",
    "let",
    "say",
    "number",
    "zero",
    "fine",
    "uh",
    "internal",
    "structure",
    "inside",
    "z",
    "right",
    "nothing",
    "change",
    "inside",
    "zero",
    "fixed",
    "value",
    "fixed",
    "immutable",
    "value",
    "ca",
    "really",
    "say",
    "l1",
    "0",
    "change",
    "value",
    "internally",
    "set",
    "l1",
    "0",
    "another",
    "value",
    "let",
    "say",
    "set",
    "l1",
    "0",
    "1",
    "instead",
    "getting",
    "zeros",
    "get",
    "ones",
    "take",
    "take",
    "zero",
    "change",
    "something",
    "inside",
    "hand",
    "empty",
    "list",
    "list",
    "showing",
    "10",
    "different",
    "showing",
    "10",
    "different",
    "times",
    "elements",
    "list",
    "outer",
    "list",
    "simply",
    "pointer",
    "empty",
    "list",
    "since",
    "go",
    "inside",
    "empty",
    "list",
    "append",
    "something",
    "since",
    "object",
    "seeing",
    "one",
    "gets",
    "appended",
    "first",
    "list",
    "rest",
    "object",
    "get",
    "back",
    "ones",
    "inside",
    "okay",
    "reason",
    "spending",
    "time",
    "common",
    "common",
    "bug",
    "may",
    "unintentionally",
    "execute",
    "whenever",
    "want",
    "create",
    "list",
    "empty",
    "lists",
    "use",
    "method",
    "method",
    "use",
    "one",
    "method",
    "use",
    "let",
    "say",
    "want",
    "create",
    "list",
    "empty",
    "list",
    "size",
    "10",
    "may",
    "familiar",
    "object",
    "object",
    "called",
    "range",
    "function",
    "called",
    "range",
    "view",
    "list",
    "see",
    "contains",
    "elements",
    "0",
    "9",
    "okay",
    "view",
    "range",
    "simply",
    "shows",
    "0",
    "10",
    "convert",
    "list",
    "see",
    "internally",
    "contains",
    "value",
    "0",
    "9",
    "okay",
    "take",
    "range",
    "something",
    "like",
    "put",
    "range",
    "put",
    "anything",
    "iterable",
    "inside",
    "brackets",
    "list",
    "brackets",
    "say",
    "x",
    "range",
    "simply",
    "put",
    "x",
    "practically",
    "nothing",
    "simply",
    "took",
    "x",
    "range",
    "0",
    "10",
    "returned",
    "x",
    "created",
    "new",
    "list",
    "like",
    "suppose",
    "multiplied",
    "two",
    "x",
    "two",
    "element",
    "range",
    "multiplying",
    "two",
    "get",
    "back",
    "new",
    "list",
    "02",
    "4",
    "68",
    "element",
    "double",
    "elements",
    "range",
    "need",
    "need",
    "empty",
    "lists",
    "right",
    "simply",
    "put",
    "empty",
    "list",
    "ignore",
    "value",
    "x",
    "get",
    "get",
    "get",
    "back",
    "whole",
    "bunch",
    "empty",
    "lists",
    "let",
    "call",
    "l2",
    "element",
    "range",
    "creating",
    "new",
    "empty",
    "list",
    "important",
    "l20",
    "append",
    "1",
    "check",
    "l2",
    "see",
    "one",
    "inserted",
    "inside",
    "first",
    "list",
    "okay",
    "keep",
    "keep",
    "watch",
    "something",
    "probably",
    "go",
    "wrong",
    "point",
    "gone",
    "wrong",
    "many",
    "times",
    "one",
    "last",
    "change",
    "make",
    "whenever",
    "using",
    "variable",
    "python",
    "always",
    "good",
    "idea",
    "call",
    "underscore",
    "still",
    "call",
    "x",
    "sometimes",
    "somebody",
    "reading",
    "code",
    "may",
    "understand",
    "declared",
    "variable",
    "used",
    "assume",
    "maybe",
    "made",
    "mistake",
    "make",
    "things",
    "clear",
    "always",
    "good",
    "idea",
    "make",
    "something",
    "underscore",
    "also",
    "variable",
    "name",
    "valid",
    "name",
    "mark",
    "something",
    "underscore",
    "used",
    "okay",
    "whole",
    "discussion",
    "lists",
    "know",
    "create",
    "list",
    "empty",
    "lists",
    "list",
    "empty",
    "lists",
    "underscore",
    "range",
    "num",
    "nodes",
    "created",
    "list",
    "empty",
    "lists",
    "edge",
    "edges",
    "need",
    "something",
    "need",
    "insert",
    "right",
    "lists",
    "okay",
    "edge",
    "edges",
    "look",
    "like",
    "let",
    "see",
    "edge",
    "edges",
    "print",
    "edge",
    "okay",
    "edge",
    "pair",
    "already",
    "know",
    "pairs",
    "tupes",
    "get",
    "get",
    "values",
    "let",
    "say",
    "let",
    "call",
    "n1",
    "n2",
    "node",
    "one",
    "node",
    "two",
    "get",
    "values",
    "n1",
    "n2",
    "like",
    "say",
    "print",
    "n1",
    "print",
    "n2",
    "see",
    "able",
    "get",
    "values",
    "n1",
    "n2",
    "directly",
    "within",
    "loop",
    "let",
    "call",
    "n1",
    "n2",
    "much",
    "pythonic",
    "way",
    "writing",
    "code",
    "one",
    "things",
    "also",
    "learning",
    "write",
    "code",
    "pythonic",
    "idiomatic",
    "python",
    "something",
    "impress",
    "people",
    "use",
    "interview",
    "coding",
    "challenge",
    "n1",
    "n2",
    "edges",
    "need",
    "first",
    "get",
    "self",
    "data",
    "n1",
    "gives",
    "us",
    "adjacency",
    "list",
    "n1",
    "first",
    "node",
    "append",
    "value",
    "n2",
    "similarly",
    "n2",
    "append",
    "n1",
    "set",
    "graph",
    "let",
    "create",
    "graph",
    "g1",
    "let",
    "call",
    "graph",
    "one",
    "maybe",
    "simply",
    "inv",
    "w",
    "graph",
    "function",
    "give",
    "number",
    "nodes",
    "edges",
    "right",
    "remember",
    "self",
    "passed",
    "python",
    "automatically",
    "object",
    "getting",
    "created",
    "graph",
    "one",
    "object",
    "essentially",
    "number",
    "nodes",
    "five",
    "list",
    "edges",
    "let",
    "see",
    "graph",
    "data",
    "looks",
    "like",
    "go",
    "see",
    "0",
    "connected",
    "1",
    "4",
    "1",
    "connected",
    "0",
    "2",
    "3",
    "4",
    "okay",
    "would",
    "nicer",
    "print",
    "like",
    "maybe",
    "let",
    "see",
    "print",
    "like",
    "way",
    "define",
    "repper",
    "function",
    "define",
    "function",
    "called",
    "underscore",
    "uncore",
    "rpr",
    "contains",
    "simply",
    "takes",
    "self",
    "input",
    "going",
    "going",
    "go",
    "going",
    "call",
    "enumerate",
    "self",
    "data",
    "give",
    "us",
    "let",
    "check",
    "enumerate",
    "self",
    "data",
    "give",
    "us",
    "gives",
    "us",
    "well",
    "maybe",
    "let",
    "see",
    "enumerate",
    "list",
    "gives",
    "us",
    "enumerate",
    "list",
    "gives",
    "us",
    "object",
    "let",
    "get",
    "value",
    "loop",
    "use",
    "enumerator",
    "loop",
    "print",
    "x",
    "enumerate",
    "gives",
    "us",
    "gives",
    "us",
    "values",
    "list",
    "apart",
    "values",
    "also",
    "gives",
    "us",
    "indexes",
    "okay",
    "get",
    "index",
    "value",
    "v",
    "enumerator",
    "see",
    "print",
    "v",
    "get",
    "back",
    "output",
    "okay",
    "say",
    "enumerate",
    "self",
    "data",
    "self",
    "data",
    "contains",
    "elements",
    "get",
    "back",
    "get",
    "back",
    "pair",
    "let",
    "see",
    "get",
    "back",
    "pairs",
    "0a",
    "1",
    "14",
    "1",
    "comma",
    "023",
    "4",
    "2a",
    "213",
    "starting",
    "look",
    "lot",
    "like",
    "want",
    "okay",
    "take",
    "enumerate",
    "self",
    "data",
    "take",
    "pairs",
    "pairs",
    "node",
    "node",
    "n",
    "neighbors",
    "node",
    "n",
    "node",
    "n",
    "first",
    "zero",
    "neighbors",
    "1",
    "four",
    "node",
    "n",
    "one",
    "neighbor",
    "1",
    "two",
    "n",
    "comma",
    "neighbors",
    "enumerate",
    "simply",
    "create",
    "simple",
    "string",
    "using",
    "string",
    "formatting",
    "simply",
    "creating",
    "string",
    "put",
    "place",
    "placeholder",
    "put",
    "n",
    "put",
    "placeholder",
    "put",
    "neighbors",
    "let",
    "see",
    "looks",
    "like",
    "best",
    "thing",
    "jupiter",
    "writing",
    "code",
    "test",
    "code",
    "right",
    "simply",
    "creating",
    "putting",
    "data",
    "new",
    "new",
    "cell",
    "let",
    "see",
    "graph",
    "data",
    "see",
    "converted",
    "enumerated",
    "list",
    "list",
    "strings",
    "string",
    "string",
    "0",
    "pointing",
    "1a",
    "4",
    "string",
    "one",
    "one",
    "pointing",
    "0",
    "2",
    "3",
    "4",
    "still",
    "list",
    "strings",
    "need",
    "return",
    "repper",
    "function",
    "single",
    "string",
    "way",
    "join",
    "together",
    "whenever",
    "list",
    "strings",
    "want",
    "join",
    "together",
    "need",
    "say",
    "want",
    "join",
    "want",
    "join",
    "new",
    "line",
    "call",
    "join",
    "function",
    "string",
    "return",
    "right",
    "repper",
    "function",
    "see",
    "users",
    "moment",
    "similarly",
    "another",
    "function",
    "called",
    "str",
    "str",
    "repper",
    "used",
    "simply",
    "type",
    "graph",
    "one",
    "type",
    "graph",
    "one",
    "output",
    "default",
    "repper",
    "function",
    "get",
    "replaced",
    "repper",
    "function",
    "defining",
    "str",
    "str",
    "graph",
    "1",
    "print",
    "graph",
    "one",
    "insert",
    "graph",
    "one",
    "string",
    "str",
    "str",
    "function",
    "used",
    "simply",
    "use",
    "repper",
    "representation",
    "let",
    "put",
    "self",
    "doore",
    "rpr",
    "okay",
    "let",
    "see",
    "let",
    "put",
    "let",
    "type",
    "graph",
    "one",
    "see",
    "representation",
    "printed",
    "using",
    "reper",
    "function",
    "defined",
    "0",
    "1",
    "4",
    "1",
    "0",
    "2",
    "3",
    "4",
    "2",
    "connected",
    "13",
    "3",
    "connected",
    "1",
    "12",
    "4",
    "four",
    "connected",
    "0",
    "1",
    "3",
    "okay",
    "graph",
    "data",
    "structure",
    "implemented",
    "using",
    "class",
    "adjacency",
    "list",
    "nice",
    "way",
    "print",
    "good",
    "programming",
    "practice",
    "coding",
    "competition",
    "good",
    "interview",
    "let",
    "say",
    "able",
    "type",
    "quickly",
    "working",
    "working",
    "problems",
    "code",
    "project",
    "always",
    "make",
    "sure",
    "classes",
    "define",
    "good",
    "string",
    "representation",
    "type",
    "name",
    "variable",
    "understand",
    "represents",
    "spend",
    "time",
    "thinking",
    "make",
    "clear",
    "okay",
    "adjacency",
    "list",
    "see",
    "useful",
    "moments",
    "couple",
    "questions",
    "try",
    "writing",
    "function",
    "add",
    "edge",
    "graph",
    "represented",
    "adjacency",
    "list",
    "okay",
    "specified",
    "edges",
    "right",
    "beginning",
    "write",
    "function",
    "add",
    "edge",
    "takes",
    "couple",
    "nodes",
    "inserts",
    "edge",
    "two",
    "nodes",
    "hint",
    "code",
    "might",
    "useful",
    "try",
    "another",
    "one",
    "write",
    "function",
    "remove",
    "edge",
    "graph",
    "represented",
    "adjacency",
    "list",
    "may",
    "use",
    "list",
    "remove",
    "functions",
    "remove",
    "particular",
    "element",
    "list",
    "two",
    "good",
    "exercises",
    "complete",
    "okay",
    "continue",
    "let",
    "save",
    "work",
    "know",
    "notebook",
    "running",
    "binder",
    "free",
    "service",
    "save",
    "work",
    "running",
    "capture",
    "snapshot",
    "notebook",
    "changes",
    "made",
    "put",
    "jovian",
    "profile",
    "go",
    "jovian",
    "profile",
    "continue",
    "running",
    "continue",
    "executing",
    "left",
    "okay",
    "another",
    "common",
    "representation",
    "graphs",
    "called",
    "adjacency",
    "matrix",
    "slightly",
    "different",
    "adjacency",
    "lists",
    "case",
    "example",
    "graph",
    "represented",
    "using",
    "matrix",
    "create",
    "matrix",
    "size",
    "n",
    "n",
    "n",
    "number",
    "n",
    "number",
    "nodes",
    "graph",
    "node",
    "instance",
    "since",
    "zero",
    "since",
    "edge",
    "one",
    "two",
    "take",
    "first",
    "row",
    "row",
    "number",
    "one",
    "column",
    "number",
    "two",
    "put",
    "one",
    "otherwise",
    "edge",
    "example",
    "edge",
    "0",
    "two",
    "take",
    "zero",
    "throw",
    "column",
    "number",
    "two",
    "put",
    "zero",
    "okay",
    "put",
    "one",
    "wherever",
    "edge",
    "two",
    "nodes",
    "put",
    "zero",
    "wherever",
    "see",
    "refle",
    "reflexive",
    "property",
    "1",
    "2",
    "1",
    "2",
    "1",
    "also",
    "one",
    "un",
    "directed",
    "edges",
    "course",
    "directed",
    "graph",
    "would",
    "different",
    "okay",
    "exercise",
    "represent",
    "graph",
    "adjacency",
    "matrix",
    "python",
    "hard",
    "instead",
    "adjacency",
    "list",
    "initialized",
    "list",
    "empty",
    "lists",
    "may",
    "want",
    "initialize",
    "list",
    "zeros",
    "list",
    "containing",
    "lists",
    "zeros",
    "okay",
    "may",
    "simply",
    "want",
    "fill",
    "zero",
    "ones",
    "right",
    "place",
    "adjacency",
    "matrices",
    "benefits",
    "sometimes",
    "useful",
    "example",
    "want",
    "immediately",
    "check",
    "edge",
    "two",
    "vertices",
    "two",
    "nodes",
    "quickly",
    "look",
    "look",
    "adjacency",
    "matrix",
    "adjacency",
    "list",
    "get",
    "list",
    "one",
    "search",
    "list",
    "fine",
    "cases",
    "cases",
    "may",
    "want",
    "adjacency",
    "matrix",
    "well",
    "one",
    "way",
    "represent",
    "graph",
    "exercise",
    "okay",
    "know",
    "represented",
    "graphs",
    "start",
    "looking",
    "graph",
    "algorithms",
    "probably",
    "common",
    "graph",
    "algorithm",
    "something",
    "ultimately",
    "get",
    "asked",
    "one",
    "interview",
    "interviewing",
    "bunch",
    "companies",
    "bread",
    "first",
    "search",
    "bread",
    "search",
    "well",
    "looks",
    "like",
    "suppose",
    "real",
    "world",
    "graph",
    "looking",
    "cities",
    "germany",
    "see",
    "roads",
    "cities",
    "length",
    "road",
    "ignore",
    "length",
    "important",
    "cities",
    "connected",
    "cities",
    "connected",
    "others",
    "starting",
    "frankfurt",
    "may",
    "want",
    "find",
    "cities",
    "reach",
    "frankfurt",
    "without",
    "stopping",
    "cities",
    "one",
    "edge",
    "away",
    "frankfurt",
    "look",
    "way",
    "turns",
    "manheim",
    "castle",
    "wburg",
    "three",
    "cities",
    "one",
    "edge",
    "away",
    "frankfur",
    "right",
    "start",
    "drawing",
    "tree",
    "sorts",
    "find",
    "manheim",
    "verburg",
    "castle",
    "one",
    "edge",
    "away",
    "okay",
    "might",
    "ask",
    "cities",
    "two",
    "edges",
    "away",
    "frankfurt",
    "cities",
    "manheim",
    "connected",
    "cars",
    "wburg",
    "connected",
    "two",
    "cities",
    "castle",
    "connected",
    "city",
    "okay",
    "cities",
    "might",
    "ask",
    "cities",
    "three",
    "steps",
    "away",
    "frankfurt",
    "would",
    "remaining",
    "two",
    "cities",
    "augsburg",
    "stur",
    "okay",
    "let",
    "think",
    "find",
    "way",
    "go",
    "step",
    "step",
    "step",
    "like",
    "first",
    "finding",
    "cities",
    "one",
    "step",
    "away",
    "nodes",
    "one",
    "step",
    "away",
    "source",
    "node",
    "finding",
    "nodes",
    "two",
    "steps",
    "away",
    "source",
    "node",
    "give",
    "ultimately",
    "end",
    "node",
    "find",
    "far",
    "away",
    "source",
    "length",
    "shortest",
    "path",
    "two",
    "okay",
    "verify",
    "let",
    "think",
    "instance",
    "see",
    "go",
    "castle",
    "going",
    "way",
    "verburg",
    "nberg",
    "munin",
    "castle",
    "would",
    "shortest",
    "path",
    "binary",
    "search",
    "called",
    "breadth",
    "first",
    "search",
    "bread",
    "first",
    "search",
    "always",
    "discover",
    "shortest",
    "path",
    "first",
    "finding",
    "nodes",
    "distance",
    "one",
    "finding",
    "nodes",
    "distance",
    "2",
    "finding",
    "nodes",
    "distance",
    "three",
    "node",
    "distance",
    "three",
    "shorter",
    "path",
    "would",
    "already",
    "find",
    "found",
    "finding",
    "nodes",
    "length",
    "one",
    "two",
    "distance",
    "one",
    "two",
    "okay",
    "brad",
    "first",
    "search",
    "one",
    "problem",
    "might",
    "um",
    "face",
    "interview",
    "implement",
    "breadth",
    "first",
    "search",
    "given",
    "source",
    "node",
    "graph",
    "using",
    "python",
    "okay",
    "pseudo",
    "code",
    "always",
    "good",
    "idea",
    "write",
    "explain",
    "approach",
    "plain",
    "english",
    "implement",
    "make",
    "mistakes",
    "coding",
    "sodo",
    "code",
    "write",
    "function",
    "bfs",
    "takes",
    "graph",
    "root",
    "source",
    "node",
    "first",
    "say",
    "create",
    "q",
    "creating",
    "taken",
    "wikipedia",
    "first",
    "create",
    "q",
    "q",
    "well",
    "q",
    "simple",
    "data",
    "structure",
    "q",
    "simply",
    "list",
    "follows",
    "first",
    "first",
    "uh",
    "policy",
    "list",
    "want",
    "add",
    "something",
    "q",
    "also",
    "called",
    "nq",
    "nq",
    "operation",
    "want",
    "add",
    "something",
    "queue",
    "add",
    "end",
    "okay",
    "list",
    "simply",
    "keep",
    "adding",
    "things",
    "end",
    "append",
    "things",
    "end",
    "list",
    "want",
    "access",
    "something",
    "queue",
    "access",
    "value",
    "directly",
    "always",
    "access",
    "first",
    "available",
    "value",
    "okay",
    "access",
    "first",
    "available",
    "value",
    "case",
    "called",
    "value",
    "front",
    "access",
    "value",
    "gets",
    "removed",
    "okay",
    "way",
    "see",
    "implement",
    "ment",
    "first",
    "first",
    "policy",
    "like",
    "first",
    "nq",
    "1",
    "nq",
    "3",
    "enq",
    "4",
    "want",
    "dq",
    "want",
    "dq",
    "simply",
    "get",
    "first",
    "value",
    "inserted",
    "one",
    "maybe",
    "nq",
    "numbers",
    "5",
    "2",
    "7",
    "dq",
    "get",
    "back",
    "first",
    "value",
    "inserted",
    "yet",
    "dq",
    "get",
    "back",
    "four",
    "whatever",
    "second",
    "value",
    "inserted",
    "initially",
    "right",
    "q",
    "let",
    "see",
    "queue",
    "useful",
    "create",
    "queue",
    "mark",
    "label",
    "mark",
    "root",
    "label",
    "root",
    "node",
    "discovered",
    "okay",
    "need",
    "somehow",
    "track",
    "nodes",
    "discovered",
    "visited",
    "first",
    "mark",
    "root",
    "node",
    "let",
    "say",
    "starting",
    "node",
    "three",
    "mark",
    "three",
    "discovered",
    "three",
    "discovered",
    "soon",
    "mark",
    "something",
    "discovered",
    "q",
    "okay",
    "queue",
    "empty",
    "accessed",
    "elements",
    "que",
    "dced",
    "elements",
    "que",
    "dq",
    "element",
    "deq",
    "first",
    "element",
    "yet",
    "removed",
    "quebe",
    "looking",
    "particular",
    "goal",
    "node",
    "simply",
    "end",
    "like",
    "found",
    "node",
    "looking",
    "goal",
    "node",
    "let",
    "remove",
    "code",
    "yeah",
    "get",
    "get",
    "first",
    "element",
    "first",
    "node",
    "q",
    "yet",
    "dq",
    "example",
    "initially",
    "three",
    "que",
    "get",
    "back",
    "three",
    "get",
    "three",
    "back",
    "que",
    "check",
    "edges",
    "three",
    "check",
    "three",
    "connected",
    "1",
    "three",
    "connected",
    "two",
    "three",
    "connected",
    "four",
    "see",
    "edges",
    "three",
    "end",
    "edge",
    "check",
    "node",
    "let",
    "say",
    "end",
    "edge",
    "two",
    "check",
    "two",
    "yet",
    "discovered",
    "yet",
    "visited",
    "nq",
    "two",
    "q",
    "similarly",
    "check",
    "one",
    "one",
    "yet",
    "already",
    "discovered",
    "nq",
    "one",
    "list",
    "similarly",
    "four",
    "nq",
    "four",
    "list",
    "okay",
    "dq",
    "three",
    "three",
    "longer",
    "q",
    "moved",
    "forward",
    "longer",
    "going",
    "get",
    "q",
    "three",
    "q",
    "ened",
    "2",
    "1",
    "4",
    "2",
    "1",
    "4",
    "understand",
    "distance",
    "one",
    "pick",
    "next",
    "element",
    "q",
    "dq",
    "next",
    "element",
    "first",
    "first",
    "first",
    "get",
    "back",
    "two",
    "mark",
    "two",
    "visited",
    "great",
    "visited",
    "oh",
    "mark",
    "soon",
    "adding",
    "something",
    "que",
    "also",
    "mark",
    "visited",
    "identified",
    "2",
    "1",
    "four",
    "distance",
    "one",
    "three",
    "added",
    "q",
    "marked",
    "visited",
    "get",
    "two",
    "q",
    "next",
    "iteration",
    "check",
    "nodes",
    "two",
    "connected",
    "yet",
    "visited",
    "two",
    "connected",
    "one",
    "one",
    "already",
    "visited",
    "need",
    "enq",
    "two",
    "connected",
    "three",
    "three",
    "already",
    "visited",
    "need",
    "enq",
    "move",
    "forward",
    "go",
    "one",
    "go",
    "one",
    "realize",
    "0",
    "yet",
    "visited",
    "enq",
    "0",
    "four",
    "visited",
    "nq4",
    "okay",
    "proceed",
    "draw",
    "piece",
    "paper",
    "work",
    "write",
    "piece",
    "paper",
    "would",
    "first",
    "element",
    "gets",
    "inserted",
    "elements",
    "insert",
    "queue",
    "etc",
    "etc",
    "algorithm",
    "exact",
    "discovered",
    "dq",
    "vertex",
    "edges",
    "start",
    "vertex",
    "v",
    "node",
    "v",
    "end",
    "edge",
    "labeled",
    "discovered",
    "market",
    "discovered",
    "enq",
    "q",
    "okay",
    "let",
    "implement",
    "let",
    "see",
    "implement",
    "live",
    "implementing",
    "bfs",
    "get",
    "graph",
    "source",
    "node",
    "first",
    "thing",
    "need",
    "set",
    "q",
    "q",
    "empty",
    "set",
    "discovered",
    "discovered",
    "false",
    "initially",
    "length",
    "want",
    "mark",
    "false",
    "elements",
    "okay",
    "remember",
    "use",
    "notation",
    "false",
    "immutable",
    "value",
    "matter",
    "really",
    "need",
    "use",
    "range",
    "list",
    "comprehension",
    "notation",
    "let",
    "come",
    "mark",
    "label",
    "root",
    "discovered",
    "discovered",
    "source",
    "let",
    "call",
    "root",
    "get",
    "confused",
    "terminology",
    "mark",
    "discovered",
    "root",
    "true",
    "great",
    "insert",
    "nq",
    "root",
    "type",
    "append",
    "nq",
    "simply",
    "means",
    "adding",
    "something",
    "end",
    "know",
    "list",
    "simply",
    "call",
    "append",
    "append",
    "root",
    "great",
    "python",
    "lists",
    "default",
    "support",
    "dq",
    "operation",
    "set",
    "index",
    "track",
    "first",
    "available",
    "element",
    "queue",
    "okay",
    "whenever",
    "dq",
    "element",
    "increase",
    "index",
    "move",
    "forward",
    "index",
    "idx",
    "equal",
    "zero",
    "elements",
    "que",
    "means",
    "next",
    "available",
    "index",
    "less",
    "length",
    "que",
    "first",
    "get",
    "current",
    "dq",
    "deqing",
    "simply",
    "means",
    "getting",
    "getting",
    "first",
    "element",
    "element",
    "recently",
    "inserted",
    "ded",
    "get",
    "current",
    "q",
    "idx",
    "also",
    "increase",
    "idx",
    "soon",
    "dq",
    "something",
    "index",
    "imagine",
    "index",
    "starts",
    "dq",
    "delete",
    "get",
    "value",
    "update",
    "index",
    "next",
    "position",
    "okay",
    "current",
    "dq",
    "operation",
    "next",
    "want",
    "check",
    "edges",
    "current",
    "right",
    "going",
    "say",
    "remember",
    "adjacency",
    "list",
    "representation",
    "get",
    "node",
    "self",
    "data",
    "current",
    "self",
    "data",
    "current",
    "contains",
    "list",
    "nodes",
    "connected",
    "current",
    "node",
    "node",
    "self",
    "data",
    "current",
    "discovered",
    "node",
    "yet",
    "discovered",
    "node",
    "first",
    "mark",
    "discovered",
    "add",
    "q",
    "append",
    "node",
    "okay",
    "end",
    "way",
    "first",
    "source",
    "got",
    "added",
    "q",
    "inserted",
    "inserted",
    "nodes",
    "distance",
    "one",
    "source",
    "insert",
    "follow",
    "trajectory",
    "see",
    "insert",
    "nodes",
    "distance",
    "two",
    "q",
    "right",
    "ultimately",
    "end",
    "entire",
    "process",
    "q",
    "q",
    "contain",
    "list",
    "nodes",
    "would",
    "visited",
    "binary",
    "uh",
    "breadth",
    "first",
    "search",
    "okay",
    "simply",
    "return",
    "q",
    "let",
    "try",
    "graph",
    "one",
    "let",
    "call",
    "bfs",
    "graph",
    "one",
    "graph",
    "let",
    "grab",
    "image",
    "well",
    "let",
    "simply",
    "copy",
    "code",
    "image",
    "come",
    "let",
    "come",
    "put",
    "image",
    "okay",
    "let",
    "call",
    "bfs",
    "graph",
    "one",
    "starting",
    "note",
    "3",
    "okay",
    "course",
    "called",
    "graph",
    "data",
    "graph",
    "graph",
    "working",
    "need",
    "check",
    "graph",
    "data",
    "okay",
    "start",
    "node",
    "3",
    "see",
    "three",
    "first",
    "causes",
    "1",
    "2",
    "four",
    "get",
    "inserted",
    "one",
    "causes",
    "two",
    "get",
    "inserted",
    "okay",
    "bfs",
    "pretty",
    "much",
    "done",
    "point",
    "would",
    "also",
    "helpful",
    "maybe",
    "keep",
    "track",
    "distance",
    "node",
    "right",
    "also",
    "track",
    "also",
    "keep",
    "track",
    "distance",
    "let",
    "say",
    "distance",
    "initially",
    "said",
    "none",
    "yeah",
    "initially",
    "said",
    "none",
    "track",
    "distance",
    "node",
    "distance",
    "initially",
    "going",
    "set",
    "distance",
    "root",
    "zero",
    "course",
    "root",
    "zero",
    "distance",
    "distance",
    "means",
    "number",
    "edges",
    "right",
    "something",
    "discovered",
    "discovering",
    "node",
    "node",
    "already",
    "previously",
    "discovered",
    "means",
    "distance",
    "node",
    "one",
    "distance",
    "current",
    "node",
    "caused",
    "discovered",
    "right",
    "distance",
    "example",
    "starting",
    "three",
    "distance",
    "one",
    "1",
    "three",
    "caused",
    "one",
    "discovered",
    "distance",
    "zero",
    "going",
    "1",
    "1",
    "caused",
    "zero",
    "discovered",
    "distance",
    "great",
    "also",
    "tracked",
    "distance",
    "one",
    "thing",
    "would",
    "nice",
    "called",
    "parent",
    "see",
    "go",
    "back",
    "see",
    "would",
    "nice",
    "know",
    "led",
    "carro",
    "discovered",
    "manheim",
    "verburg",
    "castle",
    "work",
    "way",
    "backwards",
    "find",
    "path",
    "frankfurt",
    "car",
    "room",
    "okay",
    "keep",
    "track",
    "dictionary",
    "list",
    "called",
    "parent",
    "parents",
    "default",
    "parent",
    "none",
    "whenever",
    "find",
    "node",
    "node",
    "already",
    "discovered",
    "set",
    "parent",
    "node",
    "current",
    "node",
    "caused",
    "discovered",
    "okay",
    "return",
    "que",
    "distance",
    "parent",
    "let",
    "see",
    "works",
    "okay",
    "seems",
    "like",
    "order",
    "nodes",
    "visited",
    "see",
    "three",
    "first",
    "node",
    "visited",
    "three",
    "want",
    "check",
    "distance",
    "three",
    "see",
    "distance",
    "three",
    "zero",
    "distance",
    "given",
    "order",
    "nodes",
    "order",
    "original",
    "numbering",
    "node",
    "see",
    "three",
    "distance",
    "zero",
    "obviously",
    "1",
    "2",
    "4",
    "want",
    "check",
    "distance",
    "one",
    "check",
    "index",
    "number",
    "one",
    "one",
    "distance",
    "one",
    "want",
    "check",
    "distance",
    "two",
    "distance",
    "one",
    "well",
    "check",
    "want",
    "check",
    "distance",
    "four",
    "four",
    "also",
    "distance",
    "one",
    "right",
    "1",
    "2",
    "four",
    "distance",
    "one",
    "root",
    "node",
    "3",
    "also",
    "see",
    "parent",
    "one",
    "remember",
    "0",
    "1",
    "2",
    "3",
    "4",
    "indices",
    "nodes",
    "parent",
    "one",
    "three",
    "parent",
    "two",
    "three",
    "well",
    "parent",
    "four",
    "three",
    "three",
    "parent",
    "none",
    "finally",
    "last",
    "node",
    "visit",
    "zero",
    "distance",
    "two",
    "see",
    "distance",
    "indeed",
    "highest",
    "parent",
    "0er",
    "one",
    "right",
    "one",
    "first",
    "node",
    "caused",
    "z",
    "visited",
    "could",
    "42",
    "case",
    "implemented",
    "one",
    "first",
    "node",
    "caused",
    "visited",
    "one",
    "parent",
    "zero",
    "want",
    "find",
    "path",
    "3",
    "0",
    "look",
    "parent",
    "0",
    "would",
    "one",
    "look",
    "parent",
    "one",
    "would",
    "three",
    "done",
    "work",
    "backwards",
    "target",
    "keep",
    "checking",
    "parent",
    "parent",
    "target",
    "give",
    "us",
    "entire",
    "path",
    "path",
    "distance",
    "order",
    "nodes",
    "visited",
    "may",
    "get",
    "asked",
    "brett",
    "search",
    "different",
    "variations",
    "roughly",
    "code",
    "looks",
    "like",
    "see",
    "code",
    "long",
    "created",
    "additional",
    "additional",
    "lists",
    "really",
    "need",
    "code",
    "15",
    "lines",
    "code",
    "10",
    "15",
    "12",
    "15",
    "lines",
    "code",
    "bfs",
    "working",
    "bfs",
    "problem",
    "always",
    "helps",
    "first",
    "state",
    "simple",
    "words",
    "work",
    "example",
    "start",
    "coding",
    "make",
    "mistakes",
    "coding",
    "one",
    "question",
    "work",
    "check",
    "nodes",
    "graph",
    "connected",
    "may",
    "always",
    "case",
    "example",
    "see",
    "nodes",
    "graph",
    "connected",
    "sometimes",
    "may",
    "situation",
    "nodes",
    "connected",
    "instance",
    "edges",
    "one",
    "1",
    "2",
    "3",
    "two",
    "present",
    "two",
    "would",
    "connected",
    "zero",
    "maybe",
    "two",
    "connected",
    "five",
    "six",
    "etc",
    "one",
    "graph",
    "nodes",
    "connected",
    "see",
    "nine",
    "nodes",
    "eight",
    "edges",
    "look",
    "carefully",
    "see",
    "0",
    "1",
    "2",
    "3",
    "0",
    "1",
    "2",
    "3",
    "connected",
    "connection",
    "nodes",
    "four",
    "four",
    "5",
    "six",
    "connected",
    "separately",
    "seven8",
    "connected",
    "one",
    "another",
    "right",
    "use",
    "breadth",
    "first",
    "search",
    "determine",
    "nodes",
    "graph",
    "connected",
    "would",
    "reckon",
    "yes",
    "look",
    "q",
    "q",
    "gives",
    "nodes",
    "starting",
    "source",
    "node",
    "connected",
    "source",
    "node",
    "0",
    "1",
    "2",
    "3",
    "many",
    "steps",
    "something",
    "connected",
    "show",
    "queue",
    "simply",
    "check",
    "length",
    "queue",
    "see",
    "less",
    "total",
    "number",
    "nodes",
    "use",
    "determine",
    "nodes",
    "connected",
    "another",
    "related",
    "question",
    "question",
    "may",
    "get",
    "asked",
    "find",
    "number",
    "connected",
    "components",
    "graph",
    "connected",
    "component",
    "take",
    "set",
    "notes",
    "connected",
    "one",
    "component",
    "remove",
    "look",
    "next",
    "set",
    "notes",
    "connected",
    "two",
    "components",
    "remove",
    "take",
    "next",
    "set",
    "nodes",
    "connected",
    "connected",
    "gives",
    "uh",
    "third",
    "connected",
    "component",
    "case",
    "example",
    "one",
    "connected",
    "component",
    "check",
    "drawing",
    "graph",
    "would",
    "one",
    "connected",
    "component",
    "would",
    "form",
    "one",
    "connected",
    "component",
    "0",
    "1",
    "2",
    "3",
    "would",
    "one",
    "connected",
    "component",
    "4",
    "56",
    "would",
    "another",
    "78",
    "would",
    "another",
    "find",
    "number",
    "connected",
    "components",
    "even",
    "list",
    "connected",
    "components",
    "graph",
    "using",
    "bfs",
    "yes",
    "simple",
    "way",
    "pick",
    "first",
    "node",
    "perform",
    "bfs",
    "first",
    "node",
    "gives",
    "connected",
    "component",
    "contains",
    "first",
    "node",
    "find",
    "first",
    "index",
    "first",
    "node",
    "yet",
    "visited",
    "start",
    "bfs",
    "node",
    "give",
    "connected",
    "component",
    "second",
    "node",
    "find",
    "keep",
    "keep",
    "repeating",
    "till",
    "nodes",
    "visited",
    "okay",
    "another",
    "question",
    "might",
    "get",
    "find",
    "number",
    "connected",
    "components",
    "find",
    "list",
    "connected",
    "components",
    "graph",
    "bfs",
    "versatile",
    "algorithm",
    "applied",
    "solve",
    "pretty",
    "much",
    "graph",
    "problems",
    "may",
    "get",
    "asked",
    "interview",
    "work",
    "bfs",
    "problems",
    "get",
    "practice",
    "okay",
    "another",
    "way",
    "work",
    "graph",
    "look",
    "graph",
    "called",
    "dfs",
    "way",
    "would",
    "normally",
    "explore",
    "maze",
    "start",
    "one",
    "direction",
    "keep",
    "going",
    "example",
    "started",
    "kept",
    "going",
    "till",
    "hit",
    "end",
    "right",
    "see",
    "kept",
    "going",
    "hit",
    "end",
    "turned",
    "back",
    "tried",
    "next",
    "path",
    "turned",
    "back",
    "tried",
    "next",
    "path",
    "go",
    "like",
    "turn",
    "back",
    "try",
    "five",
    "go",
    "like",
    "turn",
    "back",
    "try",
    "eight",
    "turn",
    "back",
    "try",
    "9",
    "10",
    "okay",
    "another",
    "way",
    "go",
    "cases",
    "cases",
    "bfs",
    "makes",
    "sense",
    "cases",
    "dfs",
    "makes",
    "sense",
    "cases",
    "work",
    "fine",
    "problems",
    "implement",
    "either",
    "one",
    "faced",
    "graph",
    "problem",
    "let",
    "implement",
    "dfs",
    "depth",
    "first",
    "search",
    "okay",
    "depth",
    "first",
    "search",
    "pretty",
    "straightforward",
    "pick",
    "node",
    "pursue",
    "node",
    "next",
    "node",
    "next",
    "node",
    "among",
    "edges",
    "pick",
    "one",
    "node",
    "youve",
    "exhausted",
    "path",
    "along",
    "one",
    "edge",
    "come",
    "back",
    "try",
    "next",
    "edge",
    "come",
    "back",
    "try",
    "next",
    "edge",
    "two",
    "ways",
    "write",
    "way",
    "write",
    "recursively",
    "way",
    "write",
    "without",
    "recursion",
    "leave",
    "exercise",
    "write",
    "recursively",
    "write",
    "without",
    "recursion",
    "write",
    "without",
    "recursion",
    "use",
    "something",
    "called",
    "stack",
    "use",
    "stack",
    "stack",
    "another",
    "data",
    "structure",
    "simple",
    "list",
    "like",
    "data",
    "structure",
    "like",
    "q",
    "different",
    "instead",
    "first",
    "first",
    "que",
    "stack",
    "perform",
    "last",
    "first",
    "works",
    "start",
    "empty",
    "stack",
    "think",
    "like",
    "container",
    "cookie",
    "jar",
    "start",
    "putting",
    "things",
    "jar",
    "put",
    "one",
    "put",
    "two",
    "put",
    "three",
    "remove",
    "element",
    "stack",
    "want",
    "access",
    "element",
    "stack",
    "element",
    "access",
    "element",
    "inserted",
    "recently",
    "last",
    "first",
    "stack",
    "going",
    "useful",
    "pretty",
    "straightforward",
    "think",
    "node",
    "start",
    "source",
    "add",
    "three",
    "let",
    "say",
    "add",
    "three",
    "stack",
    "add",
    "three",
    "uh",
    "let",
    "add",
    "order",
    "start",
    "note",
    "add",
    "add",
    "three",
    "stack",
    "last",
    "value",
    "two",
    "okay",
    "extract",
    "two",
    "insert",
    "everything",
    "two",
    "connected",
    "stack",
    "insert",
    "three",
    "stack",
    "last",
    "value",
    "three",
    "insert",
    "take",
    "three",
    "insert",
    "four",
    "stack",
    "last",
    "value",
    "four",
    "take",
    "four",
    "nothing",
    "left",
    "insert",
    "entire",
    "path",
    "exhausted",
    "end",
    "five",
    "end",
    "five",
    "insert",
    "neighbors",
    "8",
    "six",
    "stack",
    "six",
    "gets",
    "inserted",
    "stack",
    "uh",
    "take",
    "six",
    "put",
    "seven",
    "stack",
    "right",
    "see",
    "depth",
    "search",
    "working",
    "using",
    "stack",
    "roughly",
    "procedure",
    "process",
    "looks",
    "like",
    "start",
    "stack",
    "empty",
    "push",
    "push",
    "current",
    "source",
    "let",
    "say",
    "root",
    "node",
    "starting",
    "push",
    "root",
    "stack",
    "stack",
    "empty",
    "pop",
    "stack",
    "get",
    "last",
    "value",
    "stack",
    "gets",
    "removed",
    "soon",
    "call",
    "pop",
    "node",
    "already",
    "discovered",
    "mark",
    "discovered",
    "edges",
    "v",
    "w",
    "neighbors",
    "simply",
    "push",
    "stack",
    "right",
    "neighbors",
    "already",
    "visited",
    "simply",
    "push",
    "push",
    "stack",
    "okay",
    "let",
    "let",
    "implement",
    "dfs",
    "keep",
    "picture",
    "mind",
    "let",
    "grab",
    "picture",
    "well",
    "one",
    "nice",
    "things",
    "jupiter",
    "take",
    "images",
    "simply",
    "include",
    "within",
    "jupyter",
    "notebook",
    "coding",
    "make",
    "mistakes",
    "let",
    "say",
    "writing",
    "define",
    "dfs",
    "let",
    "assume",
    "going",
    "start",
    "three",
    "picture",
    "graph",
    "one",
    "let",
    "say",
    "starting",
    "three",
    "define",
    "dfs",
    "graph",
    "root",
    "note",
    "want",
    "start",
    "first",
    "thing",
    "want",
    "want",
    "create",
    "stack",
    "use",
    "list",
    "stack",
    "adding",
    "simply",
    "add",
    "things",
    "end",
    "pop",
    "end",
    "create",
    "stack",
    "find",
    "discovered",
    "mark",
    "discovered",
    "false",
    "every",
    "node",
    "l",
    "graph",
    "data",
    "say",
    "stack",
    "dot",
    "insert",
    "stack",
    "append",
    "simply",
    "add",
    "number",
    "three",
    "end",
    "root",
    "number",
    "end",
    "stack",
    "aend",
    "root",
    "mark",
    "discovered",
    "yet",
    "interesting",
    "thing",
    "dfs",
    "remember",
    "start",
    "three",
    "want",
    "want",
    "mark",
    "4",
    "1",
    "two",
    "discovered",
    "want",
    "put",
    "stack",
    "come",
    "want",
    "mark",
    "discovered",
    "want",
    "discover",
    "four",
    "want",
    "discover",
    "zero",
    "discover",
    "one",
    "put",
    "stack",
    "really",
    "mark",
    "discovered",
    "yet",
    "marking",
    "root",
    "discovered",
    "lens",
    "stack",
    "greater",
    "zero",
    "get",
    "current",
    "value",
    "current",
    "value",
    "would",
    "stack",
    "popop",
    "interestingly",
    "python",
    "list",
    "support",
    "pop",
    "operation",
    "list",
    "l1",
    "pop",
    "see",
    "value",
    "v",
    "get",
    "l1",
    "pop",
    "value",
    "two",
    "l1",
    "value",
    "5a",
    "6",
    "okay",
    "use",
    "dictionary",
    "use",
    "python",
    "list",
    "like",
    "stack",
    "fact",
    "even",
    "try",
    "append",
    "see",
    "entire",
    "process",
    "let",
    "say",
    "appending",
    "three",
    "popping",
    "three",
    "get",
    "back",
    "three",
    "562",
    "remains",
    "pop",
    "current",
    "node",
    "mark",
    "discovered",
    "mark",
    "discovered",
    "discovered",
    "current",
    "true",
    "may",
    "also",
    "want",
    "store",
    "result",
    "may",
    "also",
    "want",
    "create",
    "result",
    "list",
    "every",
    "time",
    "pop",
    "something",
    "also",
    "going",
    "add",
    "result",
    "list",
    "let",
    "say",
    "result",
    "append",
    "current",
    "finally",
    "going",
    "return",
    "result",
    "okay",
    "main",
    "logic",
    "nodes",
    "graph",
    "data",
    "current",
    "simply",
    "going",
    "push",
    "notes",
    "stack",
    "simply",
    "going",
    "say",
    "stack",
    "append",
    "node",
    "okay",
    "start",
    "three",
    "pop",
    "three",
    "add",
    "result",
    "put",
    "1",
    "2",
    "four",
    "stack",
    "mark",
    "discovered",
    "yet",
    "pop",
    "one",
    "put",
    "0",
    "2",
    "3",
    "4",
    "stack",
    "mark",
    "discovered",
    "yet",
    "mark",
    "one",
    "discovered",
    "pop",
    "zero",
    "sorry",
    "pop",
    "four",
    "one",
    "insert",
    "one",
    "four",
    "four",
    "last",
    "inserted",
    "value",
    "pop",
    "four",
    "mark",
    "discovered",
    "insert",
    "0",
    "1",
    "three",
    "see",
    "repetition",
    "also",
    "inserting",
    "three",
    "avoid",
    "say",
    "discovered",
    "node",
    "add",
    "stack",
    "right",
    "point",
    "adding",
    "something",
    "stack",
    "already",
    "discovered",
    "mind",
    "let",
    "see",
    "start",
    "three",
    "insert",
    "one",
    "2",
    "four",
    "great",
    "four",
    "last",
    "value",
    "inserted",
    "three",
    "discovered",
    "four",
    "last",
    "value",
    "inserted",
    "pop",
    "four",
    "insert",
    "0",
    "1",
    "insert",
    "three",
    "visited",
    "one",
    "last",
    "value",
    "inserted",
    "pop",
    "one",
    "try",
    "insert",
    "values",
    "seems",
    "like",
    "everything",
    "already",
    "inserted",
    "nothing",
    "get",
    "inserted",
    "thing",
    "remains",
    "zero",
    "pop",
    "zero",
    "pop",
    "popped",
    "zero",
    "going",
    "pop",
    "four",
    "order",
    "expect",
    "see",
    "things",
    "3",
    "4",
    "1",
    "02",
    "believe",
    "let",
    "see",
    "dfs",
    "graph",
    "one",
    "starting",
    "node",
    "three",
    "okay",
    "looks",
    "like",
    "0",
    "1",
    "looks",
    "like",
    "made",
    "mistake",
    "got",
    "repeated",
    "values",
    "may",
    "want",
    "check",
    "discovered",
    "current",
    "may",
    "want",
    "add",
    "check",
    "put",
    "everything",
    "inside",
    "check",
    "older",
    "values",
    "inserted",
    "stack",
    "already",
    "visited",
    "later",
    "sometime",
    "another",
    "value",
    "stack",
    "gets",
    "ignored",
    "end",
    "3",
    "1",
    "3",
    "41",
    "2",
    "0",
    "right",
    "goes",
    "like",
    "first",
    "go",
    "3",
    "4",
    "1",
    "two",
    "go",
    "3",
    "4",
    "zero",
    "goes",
    "challenge",
    "also",
    "implement",
    "distance",
    "case",
    "distance",
    "really",
    "make",
    "sense",
    "shortest",
    "distance",
    "anymore",
    "want",
    "get",
    "shortest",
    "distance",
    "one",
    "note",
    "another",
    "want",
    "use",
    "bfs",
    "dfs",
    "track",
    "distance",
    "may",
    "end",
    "going",
    "dfs",
    "3",
    "4",
    "1",
    "2",
    "going",
    "give",
    "distance",
    "4",
    "distance",
    "three",
    "getting",
    "two",
    "although",
    "shorter",
    "distance",
    "one",
    "maybe",
    "distance",
    "make",
    "sense",
    "may",
    "want",
    "put",
    "parent",
    "may",
    "want",
    "track",
    "parent",
    "node",
    "simple",
    "enough",
    "whenever",
    "popping",
    "something",
    "may",
    "want",
    "track",
    "parent",
    "okay",
    "exercise",
    "another",
    "exercise",
    "try",
    "write",
    "function",
    "detect",
    "cycle",
    "graph",
    "performing",
    "dfs",
    "let",
    "say",
    "going",
    "performing",
    "dfs",
    "starting",
    "1",
    "end",
    "back",
    "one",
    "right",
    "go",
    "1",
    "two",
    "2",
    "zer",
    "notice",
    "0",
    "points",
    "one",
    "already",
    "visited",
    "gives",
    "indication",
    "cycle",
    "graph",
    "cycle",
    "simply",
    "path",
    "leads",
    "node",
    "1",
    "2",
    "0",
    "1",
    "path",
    "path",
    "something",
    "path",
    "sequence",
    "edges",
    "1",
    "2",
    "edge",
    "two",
    "0",
    "edge",
    "01",
    "edge",
    "path",
    "1",
    "2",
    "2",
    "4",
    "edge",
    "1",
    "2",
    "4",
    "valid",
    "path",
    "right",
    "cycle",
    "simply",
    "path",
    "leads",
    "node",
    "leads",
    "node",
    "challenge",
    "write",
    "function",
    "detect",
    "cycle",
    "graph",
    "another",
    "challenge",
    "detect",
    "maybe",
    "number",
    "cycles",
    "graph",
    "okay",
    "another",
    "thing",
    "try",
    "move",
    "another",
    "problem",
    "talk",
    "weighted",
    "graphs",
    "get",
    "closer",
    "example",
    "railway",
    "map",
    "looked",
    "initially",
    "nodes",
    "nodes",
    "numbered",
    "0",
    "8",
    "total",
    "nine",
    "nodes",
    "edges",
    "edges",
    "also",
    "weights",
    "could",
    "distances",
    "example",
    "railway",
    "line",
    "could",
    "represent",
    "information",
    "value",
    "right",
    "decide",
    "edge",
    "weights",
    "mean",
    "abstract",
    "representation",
    "simply",
    "call",
    "weights",
    "weighted",
    "graph",
    "example",
    "convey",
    "information",
    "weighted",
    "graph",
    "give",
    "number",
    "nodes",
    "give",
    "list",
    "edges",
    "first",
    "two",
    "elements",
    "edge",
    "tell",
    "nodes",
    "connected",
    "like",
    "nodes",
    "zero",
    "one",
    "connected",
    "last",
    "element",
    "list",
    "third",
    "element",
    "list",
    "tells",
    "weighted",
    "weight",
    "associated",
    "edge",
    "okay",
    "0",
    "1",
    "3",
    "0",
    "3",
    "2",
    "0",
    "connected",
    "three",
    "weight",
    "two",
    "verify",
    "10",
    "edges",
    "10",
    "edges",
    "10",
    "weights",
    "one",
    "variation",
    "see",
    "graphs",
    "another",
    "variation",
    "called",
    "directed",
    "graph",
    "case",
    "edges",
    "certain",
    "direction",
    "corresponds",
    "example",
    "hyperlinks",
    "pages",
    "web",
    "pages",
    "internet",
    "one",
    "page",
    "link",
    "page",
    "may",
    "necessarily",
    "link",
    "back",
    "may",
    "case",
    "may",
    "bidirectional",
    "edge",
    "cases",
    "would",
    "single",
    "unidirectional",
    "edge",
    "0",
    "1",
    "1",
    "2",
    "2",
    "3",
    "directed",
    "graphs",
    "represented",
    "way",
    "undirected",
    "graphs",
    "need",
    "need",
    "provide",
    "information",
    "directed",
    "graph",
    "right",
    "simply",
    "say",
    "uh",
    "directed",
    "equals",
    "true",
    "simply",
    "provide",
    "information",
    "specify",
    "person",
    "going",
    "data",
    "directed",
    "graph",
    "right",
    "uh",
    "exactly",
    "normal",
    "undirected",
    "graph",
    "create",
    "adjacency",
    "list",
    "graph",
    "node",
    "0",
    "1",
    "put",
    "0o",
    "adjacency",
    "list",
    "one",
    "way",
    "direct",
    "edge",
    "1",
    "zero",
    "direct",
    "edge",
    "0",
    "1",
    "keep",
    "mind",
    "similarly",
    "adjacency",
    "list",
    "set",
    "values",
    "0",
    "1",
    "1",
    "02",
    "1",
    "set",
    "one",
    "corresponding",
    "one",
    "direction",
    "unless",
    "course",
    "bir",
    "directional",
    "edge",
    "even",
    "combine",
    "directed",
    "graphs",
    "weighted",
    "graphs",
    "define",
    "class",
    "represent",
    "weighted",
    "directed",
    "graphs",
    "python",
    "use",
    "represent",
    "undirected",
    "graphs",
    "directed",
    "graphs",
    "weighted",
    "graphs",
    "take",
    "information",
    "constructor",
    "capture",
    "detail",
    "let",
    "say",
    "let",
    "create",
    "class",
    "graph",
    "create",
    "constructor",
    "self",
    "object",
    "gets",
    "created",
    "always",
    "first",
    "argument",
    "method",
    "class",
    "python",
    "take",
    "num",
    "nodes",
    "take",
    "edges",
    "take",
    "couple",
    "arguments",
    "take",
    "argument",
    "direct",
    "default",
    "value",
    "false",
    "take",
    "argument",
    "weighted",
    "default",
    "value",
    "false",
    "okay",
    "going",
    "store",
    "information",
    "self",
    "directed",
    "let",
    "store",
    "self",
    "num",
    "nodes",
    "num",
    "nodes",
    "self",
    "directed",
    "directed",
    "self",
    "weighted",
    "weighted",
    "okay",
    "come",
    "edges",
    "edge",
    "edges",
    "edge",
    "either",
    "two",
    "values",
    "three",
    "values",
    "weighted",
    "unweighted",
    "two",
    "values",
    "weighted",
    "three",
    "values",
    "need",
    "condition",
    "self",
    "weighted",
    "include",
    "weights",
    "else",
    "work",
    "without",
    "weights",
    "okay",
    "may",
    "want",
    "also",
    "need",
    "create",
    "adjacency",
    "list",
    "create",
    "self",
    "data",
    "far",
    "self",
    "dat",
    "create",
    "list",
    "empty",
    "lists",
    "done",
    "underscore",
    "range",
    "num",
    "edges",
    "along",
    "self",
    "data",
    "also",
    "create",
    "something",
    "called",
    "self",
    "weight",
    "self",
    "weight",
    "store",
    "corresponding",
    "value",
    "adjacency",
    "list",
    "store",
    "weight",
    "edge",
    "two",
    "elements",
    "see",
    "works",
    "moment",
    "num",
    "edges",
    "okay",
    "self",
    "dat",
    "self",
    "make",
    "easier",
    "another",
    "way",
    "instead",
    "storing",
    "single",
    "values",
    "store",
    "tuples",
    "inside",
    "self",
    "data",
    "correspond",
    "node",
    "also",
    "contain",
    "weight",
    "right",
    "ways",
    "way",
    "way",
    "well",
    "store",
    "tuples",
    "directly",
    "inside",
    "self",
    "data",
    "suppose",
    "weighted",
    "first",
    "get",
    "values",
    "edge",
    "node",
    "one",
    "node",
    "two",
    "weight",
    "edge",
    "remember",
    "edge",
    "tuple",
    "first",
    "set",
    "self",
    "data",
    "node",
    "one",
    "upend",
    "node",
    "two",
    "also",
    "set",
    "self",
    "weight",
    "node",
    "one",
    "exact",
    "location",
    "node",
    "two",
    "exact",
    "index",
    "store",
    "weight",
    "edge",
    "node",
    "one",
    "node",
    "two",
    "weight",
    "okay",
    "stored",
    "one",
    "direction",
    "node",
    "one",
    "node",
    "two",
    "may",
    "also",
    "need",
    "store",
    "second",
    "direction",
    "directed",
    "graph",
    "directed",
    "need",
    "store",
    "second",
    "direction",
    "say",
    "self",
    "data",
    "node",
    "2",
    "append",
    "node",
    "one",
    "self",
    "data",
    "node",
    "upend",
    "weight",
    "okay",
    "case",
    "weighted",
    "weighted",
    "well",
    "code",
    "actually",
    "simpler",
    "simply",
    "get",
    "node",
    "one",
    "node",
    "two",
    "edge",
    "say",
    "self",
    "data",
    "node",
    "one",
    "append",
    "node",
    "2",
    "directed",
    "weight",
    "simply",
    "check",
    "graph",
    "directed",
    "self",
    "data",
    "node",
    "2",
    "append",
    "node",
    "one",
    "okay",
    "bit",
    "code",
    "code",
    "fairly",
    "straightforward",
    "couple",
    "things",
    "take",
    "care",
    "whether",
    "whether",
    "weighted",
    "whether",
    "directed",
    "done",
    "fairly",
    "generic",
    "representation",
    "graph",
    "right",
    "take",
    "graph",
    "remember",
    "graph",
    "one",
    "graph",
    "one",
    "information",
    "similarly",
    "take",
    "create",
    "graph",
    "use",
    "graph",
    "class",
    "represent",
    "graph",
    "one",
    "also",
    "use",
    "represent",
    "one",
    "directed",
    "gra",
    "graph",
    "weights",
    "graph",
    "directed",
    "edges",
    "graph",
    "graph",
    "weights",
    "directed",
    "edges",
    "see",
    "moment",
    "one",
    "thing",
    "also",
    "create",
    "nice",
    "representation",
    "let",
    "create",
    "representation",
    "going",
    "get",
    "code",
    "roughly",
    "want",
    "want",
    "showing",
    "graph",
    "weight",
    "also",
    "want",
    "show",
    "weight",
    "show",
    "weight",
    "alongside",
    "node",
    "let",
    "see",
    "create",
    "result",
    "result",
    "uh",
    "empty",
    "string",
    "return",
    "result",
    "going",
    "say",
    "comma",
    "nodes",
    "comma",
    "weights",
    "enumerate",
    "self",
    "data",
    "self",
    "weight",
    "exercise",
    "figure",
    "exactly",
    "apply",
    "exact",
    "technique",
    "take",
    "create",
    "new",
    "create",
    "new",
    "cell",
    "put",
    "data",
    "cell",
    "put",
    "zip",
    "cell",
    "see",
    "represents",
    "able",
    "show",
    "something",
    "try",
    "converting",
    "list",
    "using",
    "loop",
    "put",
    "enumerate",
    "around",
    "see",
    "represents",
    "understand",
    "nodes",
    "weights",
    "represent",
    "simply",
    "going",
    "write",
    "see",
    "final",
    "result",
    "okay",
    "let",
    "take",
    "nom",
    "nodes",
    "one",
    "edges",
    "one",
    "called",
    "nom",
    "nodes",
    "edges",
    "initial",
    "data",
    "data",
    "working",
    "let",
    "create",
    "graph",
    "one",
    "course",
    "want",
    "weighted",
    "self",
    "weighted",
    "weighted",
    "different",
    "case",
    "comma",
    "nodes",
    "enumerate",
    "self",
    "data",
    "result",
    "plus",
    "equals",
    "okay",
    "let",
    "see",
    "graph",
    "one",
    "going",
    "use",
    "graph",
    "going",
    "pass",
    "num",
    "nodes",
    "edges",
    "default",
    "weighted",
    "directed",
    "false",
    "need",
    "specify",
    "let",
    "say",
    "graph",
    "one",
    "n",
    "nodes",
    "see",
    "life",
    "coding",
    "always",
    "make",
    "mistakes",
    "almost",
    "always",
    "bound",
    "happen",
    "jupyter",
    "notebooks",
    "helpful",
    "always",
    "helpful",
    "test",
    "function",
    "writing",
    "okay",
    "created",
    "graph",
    "one",
    "graph",
    "one",
    "see",
    "undirected",
    "graph",
    "see",
    "0",
    "points",
    "1",
    "1",
    "points",
    "to0",
    "let",
    "look",
    "graph",
    "two",
    "going",
    "grab",
    "data",
    "contains",
    "let",
    "call",
    "num",
    "nodes",
    "2",
    "edges",
    "2",
    "graph",
    "weights",
    "let",
    "create",
    "graph",
    "graph",
    "pass",
    "num",
    "nodes",
    "2",
    "edges",
    "two",
    "weighted",
    "equals",
    "true",
    "let",
    "say",
    "graph",
    "two",
    "okay",
    "small",
    "change",
    "yeah",
    "see",
    "graph",
    "two",
    "graph",
    "looking",
    "graph",
    "let",
    "grab",
    "image",
    "well",
    "yeah",
    "graph",
    "looking",
    "see",
    "zer",
    "connected",
    "1",
    "3",
    "zer",
    "connected",
    "1",
    "3",
    "8",
    "1",
    "3",
    "8",
    "also",
    "weights",
    "associated",
    "01",
    "weight",
    "three",
    "uh",
    "03",
    "weight",
    "2",
    "08",
    "weight",
    "4",
    "seems",
    "something",
    "z",
    "one",
    "seems",
    "connected",
    "zero",
    "think",
    "may",
    "made",
    "mistake",
    "somewhere",
    "code",
    "okay",
    "may",
    "debug",
    "code",
    "seems",
    "like",
    "may",
    "made",
    "made",
    "small",
    "mistake",
    "somewhere",
    "0",
    "1",
    "one",
    "seems",
    "connected",
    "0",
    "one",
    "also",
    "connected",
    "7",
    "see",
    "show",
    "curse",
    "life",
    "coding",
    "created",
    "working",
    "working",
    "code",
    "simply",
    "going",
    "grab",
    "working",
    "code",
    "right",
    "replace",
    "see",
    "detect",
    "bug",
    "code",
    "okay",
    "version",
    "require",
    "specify",
    "weighted",
    "simply",
    "skip",
    "weighted",
    "detects",
    "automatically",
    "graph",
    "weighted",
    "still",
    "something",
    "wrong",
    "let",
    "quickly",
    "verify",
    "going",
    "wrong",
    "going",
    "list",
    "edges",
    "pending",
    "maybe",
    "let",
    "print",
    "graph",
    "2",
    "dot",
    "graph",
    "two",
    "data",
    "maybe",
    "issues",
    "representation",
    "code",
    "graph",
    "2",
    "dot",
    "edges",
    "uh",
    "seems",
    "issue",
    "weight",
    "may",
    "inserted",
    "weights",
    "correctly",
    "see",
    "called",
    "weight",
    "called",
    "weight",
    "called",
    "weight",
    "oh",
    "syntax",
    "error",
    "e",
    "okay",
    "think",
    "fixed",
    "finally",
    "let",
    "see",
    "called",
    "weight",
    "ed",
    "many",
    "values",
    "unpack",
    "ah",
    "simply",
    "pass",
    "weighted",
    "equals",
    "true",
    "finally",
    "need",
    "make",
    "list",
    "finally",
    "done",
    "good",
    "hardcore",
    "live",
    "debugging",
    "finally",
    "get",
    "see",
    "coding",
    "fa",
    "make",
    "issues",
    "need",
    "clear",
    "idea",
    "written",
    "code",
    "easier",
    "narrow",
    "issues",
    "looking",
    "errors",
    "let",
    "see",
    "graph",
    "zero",
    "connected",
    "1",
    "3",
    "8",
    "see",
    "1",
    "3",
    "8",
    "zero",
    "connected",
    "1",
    "38",
    "weights",
    "3",
    "2",
    "4",
    "three",
    "connected",
    "0",
    "2",
    "4",
    "three",
    "connected",
    "0",
    "2",
    "4",
    "six",
    "connected",
    "five",
    "8",
    "see",
    "six",
    "connected",
    "five",
    "value",
    "eight",
    "great",
    "represented",
    "graph",
    "properly",
    "representation",
    "really",
    "useful",
    "check",
    "implementation",
    "correct",
    "go",
    "implement",
    "graph",
    "algorithms",
    "check",
    "representation",
    "correct",
    "let",
    "try",
    "one",
    "let",
    "us",
    "also",
    "try",
    "directed",
    "graph",
    "going",
    "grab",
    "code",
    "put",
    "let",
    "call",
    "num",
    "nodes",
    "3",
    "edges",
    "3",
    "director",
    "three",
    "let",
    "grab",
    "graph",
    "code",
    "well",
    "working",
    "graph",
    "let",
    "create",
    "graph",
    "three",
    "graph",
    "three",
    "graph",
    "pass",
    "num",
    "nodes",
    "3",
    "pass",
    "edges",
    "three",
    "verify",
    "edges",
    "set",
    "correctly",
    "specify",
    "directed",
    "equals",
    "true",
    "really",
    "need",
    "point",
    "say",
    "directed",
    "true",
    "weighted",
    "default",
    "automatically",
    "false",
    "graph",
    "three",
    "see",
    "zero",
    "connected",
    "one",
    "one",
    "connected",
    "two",
    "zero",
    "inserted",
    "opposite",
    "edge",
    "two",
    "connected",
    "three",
    "four",
    "three",
    "connected",
    "zero",
    "four",
    "connected",
    "two",
    "great",
    "imple",
    "set",
    "another",
    "graph",
    "sim",
    "similarly",
    "check",
    "weighted",
    "directed",
    "graph",
    "code",
    "still",
    "going",
    "work",
    "fine",
    "okay",
    "exercise",
    "size",
    "point",
    "let",
    "us",
    "save",
    "notebook",
    "using",
    "jin",
    "commit",
    "next",
    "question",
    "going",
    "look",
    "called",
    "shortest",
    "path",
    "question",
    "really",
    "started",
    "let",
    "say",
    "bunch",
    "nodes",
    "taken",
    "directed",
    "graph",
    "need",
    "directed",
    "graph",
    "undirected",
    "graph",
    "exercise",
    "need",
    "weights",
    "whenever",
    "talking",
    "shortest",
    "paths",
    "terms",
    "weights",
    "algorithm",
    "makes",
    "sense",
    "weights",
    "graph",
    "shortest",
    "path",
    "found",
    "simply",
    "performing",
    "breadth",
    "first",
    "search",
    "okay",
    "whenever",
    "asked",
    "find",
    "shortest",
    "path",
    "first",
    "question",
    "asking",
    "weight",
    "involved",
    "weights",
    "weights",
    "involved",
    "simply",
    "concerned",
    "length",
    "path",
    "number",
    "nodes",
    "path",
    "case",
    "simply",
    "perform",
    "breadth",
    "first",
    "breadth",
    "first",
    "search",
    "weights",
    "whether",
    "directed",
    "undirected",
    "bread",
    "first",
    "search",
    "alone",
    "may",
    "enough",
    "right",
    "may",
    "turn",
    "certain",
    "paths",
    "instance",
    "go",
    "0",
    "three",
    "go",
    "go",
    "via",
    "0",
    "2",
    "4",
    "3",
    "length",
    "path",
    "2",
    "3",
    "5",
    "4",
    "9",
    "sorry",
    "yeah",
    "total",
    "size",
    "total",
    "size",
    "length",
    "path",
    "2",
    "3",
    "5",
    "4",
    "9",
    "number",
    "nodes",
    "4",
    "0",
    "2",
    "3",
    "4",
    "hand",
    "go",
    "via",
    "013",
    "case",
    "number",
    "nodes",
    "smaller",
    "one",
    "0",
    "1",
    "3",
    "three",
    "nodes",
    "total",
    "length",
    "path",
    "14",
    "far",
    "higher",
    "right",
    "could",
    "represent",
    "go",
    "far",
    "place",
    "via",
    "train",
    "take",
    "train",
    "something",
    "actually",
    "closer",
    "even",
    "though",
    "stops",
    "different",
    "route",
    "okay",
    "going",
    "implement",
    "going",
    "implement",
    "algorithm",
    "identify",
    "shortest",
    "path",
    "given",
    "node",
    "given",
    "target",
    "okay",
    "time",
    "going",
    "focus",
    "search",
    "node",
    "target",
    "shortest",
    "path",
    "terms",
    "total",
    "weight",
    "path",
    "terms",
    "number",
    "nodes",
    "path",
    "keep",
    "mind",
    "shortest",
    "path",
    "terms",
    "total",
    "weight",
    "find",
    "starting",
    "node",
    "end",
    "node",
    "roughly",
    "strategy",
    "goes",
    "like",
    "strategy",
    "called",
    "algorithm",
    "roughly",
    "strategy",
    "goes",
    "like",
    "source",
    "node",
    "source",
    "node",
    "distance",
    "zero",
    "nothing",
    "really",
    "first",
    "thing",
    "know",
    "first",
    "thing",
    "know",
    "one",
    "siblings",
    "one",
    "neighbors",
    "source",
    "node",
    "direct",
    "edge",
    "shortest",
    "path",
    "example",
    "one",
    "two",
    "directed",
    "direct",
    "edges",
    "direct",
    "edges",
    "0",
    "2",
    "direct",
    "edge",
    "0",
    "1",
    "0",
    "to2",
    "weight",
    "two",
    "0",
    "1",
    "weight",
    "four",
    "case",
    "suppose",
    "edge",
    "2",
    "1",
    "edge",
    "weight",
    "1",
    "could",
    "go",
    "0",
    "two",
    "weight",
    "two",
    "go",
    "0",
    "2",
    "1",
    "weight",
    "one",
    "total",
    "weight",
    "would",
    "incur",
    "get",
    "one",
    "would",
    "simply",
    "three",
    "would",
    "smaller",
    "short",
    "smaller",
    "direct",
    "edge",
    "right",
    "even",
    "looking",
    "direct",
    "connections",
    "root",
    "ca",
    "say",
    "direct",
    "edge",
    "shortest",
    "path",
    "except",
    "one",
    "nodes",
    "right",
    "look",
    "node",
    "edge",
    "weight",
    "smallest",
    "start",
    "root",
    "look",
    "edge",
    "smallest",
    "weight",
    "say",
    "sure",
    "shortest",
    "path",
    "root",
    "next",
    "node",
    "node",
    "two",
    "direct",
    "edge",
    "direct",
    "edge",
    "smaller",
    "smaller",
    "equal",
    "direct",
    "edge",
    "path",
    "comes",
    "indirectly",
    "contain",
    "another",
    "direct",
    "edge",
    "edges",
    "right",
    "length",
    "greater",
    "equal",
    "direct",
    "edge",
    "right",
    "key",
    "insight",
    "every",
    "point",
    "maintain",
    "group",
    "visited",
    "nodes",
    "case",
    "initially",
    "two",
    "z",
    "visited",
    "find",
    "first",
    "node",
    "closest",
    "distance",
    "node",
    "within",
    "visited",
    "group",
    "okay",
    "example",
    "start",
    "zero",
    "look",
    "one",
    "look",
    "two",
    "see",
    "smallest",
    "edge",
    "two",
    "add",
    "two",
    "visited",
    "group",
    "know",
    "shortest",
    "path",
    "0",
    "two",
    "point",
    "take",
    "siblings",
    "neighbors",
    "two",
    "update",
    "weights",
    "know",
    "0",
    "two",
    "direct",
    "shortest",
    "path",
    "update",
    "distance",
    "four",
    "four",
    "could",
    "potential",
    "distance",
    "2",
    "3",
    "5",
    "could",
    "shorter",
    "path",
    "yet",
    "added",
    "update",
    "four",
    "similarly",
    "edge",
    "one",
    "update",
    "distance",
    "one",
    "say",
    "distance",
    "one",
    "either",
    "four",
    "direct",
    "edge",
    "2",
    "1",
    "direct",
    "edge",
    "one",
    "get",
    "know",
    "1",
    "distance",
    "three",
    "smaller",
    "right",
    "case",
    "suppose",
    "direct",
    "edge",
    "2",
    "one",
    "weight",
    "1",
    "would",
    "get",
    "know",
    "one",
    "distance",
    "three",
    "time",
    "add",
    "new",
    "node",
    "mark",
    "node",
    "visited",
    "update",
    "weights",
    "update",
    "distances",
    "neighbors",
    "simply",
    "find",
    "next",
    "node",
    "smallest",
    "distance",
    "right",
    "find",
    "next",
    "node",
    "smallest",
    "distance",
    "case",
    "four",
    "update",
    "neighbors",
    "four",
    "one",
    "neighbor",
    "next",
    "node",
    "smallest",
    "distance",
    "three",
    "update",
    "weights",
    "three",
    "shortest",
    "path",
    "directed",
    "graph",
    "let",
    "see",
    "shortest",
    "path",
    "undirected",
    "graph",
    "cases",
    "let",
    "watch",
    "beginning",
    "let",
    "wait",
    "animation",
    "start",
    "start",
    "zero",
    "check",
    "two",
    "okay",
    "mark",
    "two",
    "updated",
    "check",
    "nine",
    "mark",
    "three",
    "updated",
    "update",
    "distance",
    "14",
    "see",
    "another",
    "path",
    "go",
    "two",
    "go",
    "three",
    "track",
    "finally",
    "get",
    "two",
    "mark",
    "two",
    "visited",
    "considering",
    "three",
    "using",
    "three",
    "updating",
    "weights",
    "graph",
    "nodes",
    "marking",
    "three",
    "visited",
    "using",
    "three",
    "mark",
    "six",
    "visited",
    "right",
    "point",
    "group",
    "visited",
    "nodes",
    "distances",
    "nodes",
    "connected",
    "visited",
    "nodes",
    "pick",
    "first",
    "unvisited",
    "node",
    "smallest",
    "distance",
    "okay",
    "let",
    "read",
    "algorithm",
    "first",
    "mark",
    "nodes",
    "unvisited",
    "create",
    "set",
    "unvisited",
    "nodes",
    "call",
    "universal",
    "set",
    "set",
    "unvisited",
    "nodes",
    "called",
    "un",
    "call",
    "unvisited",
    "set",
    "assigned",
    "every",
    "node",
    "tentative",
    "distance",
    "value",
    "set",
    "zero",
    "initial",
    "node",
    "initial",
    "node",
    "distance",
    "zero",
    "set",
    "infinity",
    "nodes",
    "set",
    "distance",
    "infinity",
    "yet",
    "visited",
    "nodes",
    "know",
    "distance",
    "set",
    "initial",
    "node",
    "current",
    "node",
    "always",
    "current",
    "node",
    "looking",
    "case",
    "start",
    "initial",
    "node",
    "current",
    "node",
    "consider",
    "unvisited",
    "neighbors",
    "calculate",
    "tentative",
    "distances",
    "current",
    "node",
    "right",
    "current",
    "node",
    "current",
    "node",
    "connected",
    "lot",
    "unvisited",
    "nodes",
    "look",
    "unvisited",
    "node",
    "know",
    "distance",
    "current",
    "node",
    "current",
    "node",
    "visited",
    "using",
    "calculate",
    "distances",
    "unvisited",
    "nodes",
    "unvisited",
    "nodes",
    "distances",
    "set",
    "infinity",
    "know",
    "distance",
    "current",
    "node",
    "distance",
    "going",
    "current",
    "node",
    "going",
    "small",
    "going",
    "smaller",
    "distance",
    "infinity",
    "set",
    "hand",
    "distance",
    "already",
    "set",
    "unvisited",
    "node",
    "node",
    "simply",
    "compare",
    "whether",
    "better",
    "go",
    "current",
    "node",
    "whether",
    "better",
    "retain",
    "retain",
    "distance",
    "obtained",
    "node",
    "maintain",
    "right",
    "way",
    "simply",
    "update",
    "distances",
    "unvisited",
    "nodes",
    "neighbors",
    "current",
    "node",
    "okay",
    "example",
    "current",
    "node",
    "marked",
    "distance",
    "six",
    "edge",
    "connecting",
    "neighbor",
    "b",
    "edge",
    "weight",
    "length",
    "two",
    "distance",
    "go",
    "b",
    "source",
    "6",
    "2",
    "8",
    "right",
    "source",
    "6",
    "b",
    "2",
    "distance",
    "want",
    "go",
    "b",
    "6",
    "2",
    "8",
    "hand",
    "b",
    "already",
    "previously",
    "marked",
    "distance",
    "right",
    "visited",
    "marked",
    "distance",
    "greater",
    "8",
    "know",
    "found",
    "shorter",
    "path",
    "wia",
    "update",
    "distance",
    "8",
    "hand",
    "value",
    "let",
    "say",
    "value",
    "visiting",
    "b",
    "bya",
    "another",
    "node",
    "7even",
    "keep",
    "distance",
    "7",
    "right",
    "simply",
    "updating",
    "distance",
    "yet",
    "marking",
    "new",
    "yet",
    "marking",
    "b",
    "visited",
    "done",
    "updating",
    "distances",
    "current",
    "node",
    "mark",
    "current",
    "node",
    "visited",
    "course",
    "remove",
    "unvisited",
    "set",
    "right",
    "mark",
    "current",
    "node",
    "visited",
    "visited",
    "node",
    "never",
    "checked",
    "visited",
    "node",
    "found",
    "shortest",
    "paths",
    "used",
    "update",
    "distances",
    "neighbors",
    "never",
    "need",
    "visit",
    "find",
    "first",
    "unvisited",
    "node",
    "find",
    "first",
    "unvisited",
    "node",
    "marked",
    "smallest",
    "distance",
    "right",
    "bunch",
    "visited",
    "nodes",
    "bunch",
    "unvisited",
    "nodes",
    "many",
    "unvisited",
    "nodes",
    "marked",
    "distance",
    "simply",
    "get",
    "first",
    "unvisited",
    "node",
    "smallest",
    "distance",
    "make",
    "current",
    "node",
    "repeat",
    "process",
    "okay",
    "start",
    "zero",
    "see",
    "mark",
    "two",
    "mark",
    "distances",
    "1",
    "two",
    "one",
    "gets",
    "distance",
    "four",
    "two",
    "gets",
    "distance",
    "two",
    "mark",
    "zero",
    "visited",
    "see",
    "node",
    "least",
    "unvisited",
    "node",
    "least",
    "distance",
    "two",
    "get",
    "two",
    "mark",
    "mark",
    "edges",
    "two",
    "mark",
    "distance",
    "four",
    "2",
    "3",
    "5",
    "suppose",
    "two",
    "edge",
    "one",
    "would",
    "mark",
    "distance",
    "one",
    "2",
    "1",
    "1",
    "weight",
    "edge",
    "let",
    "say",
    "would",
    "mark",
    "distance",
    "one",
    "minimum",
    "4",
    "2",
    "1",
    "three",
    "mark",
    "distance",
    "1",
    "3",
    "uh",
    "remove",
    "two",
    "unvisited",
    "set",
    "next",
    "find",
    "next",
    "unvisited",
    "node",
    "lowest",
    "distance",
    "edge",
    "existed",
    "would",
    "one",
    "since",
    "edge",
    "exist",
    "would",
    "four",
    "get",
    "four",
    "mark",
    "distances",
    "neighbors",
    "four",
    "okay",
    "create",
    "create",
    "graph",
    "contains",
    "okay",
    "graph",
    "look",
    "yeah",
    "create",
    "graph",
    "contains",
    "uh",
    "0",
    "six",
    "contains",
    "six",
    "nodes",
    "0",
    "5",
    "graph",
    "creating",
    "let",
    "put",
    "graph",
    "yeah",
    "graph",
    "work",
    "let",
    "start",
    "writing",
    "shortest",
    "path",
    "algorithm",
    "shortest",
    "path",
    "graph",
    "start",
    "node",
    "let",
    "call",
    "source",
    "target",
    "node",
    "node",
    "want",
    "get",
    "want",
    "go",
    "0",
    "5",
    "soon",
    "soon",
    "mark",
    "target",
    "node",
    "visited",
    "algorithm",
    "done",
    "right",
    "first",
    "mark",
    "everything",
    "unvisited",
    "setting",
    "visited",
    "false",
    "time",
    "l",
    "graph",
    "data",
    "marked",
    "visited",
    "distance",
    "take",
    "take",
    "distance",
    "infinity",
    "way",
    "create",
    "infinity",
    "python",
    "say",
    "float",
    "inf",
    "set",
    "distances",
    "infinity",
    "going",
    "maintain",
    "q",
    "first",
    "first",
    "kind",
    "structure",
    "going",
    "maintain",
    "q",
    "first",
    "thing",
    "mark",
    "distance",
    "source",
    "node",
    "zero",
    "insert",
    "source",
    "node",
    "q",
    "q",
    "insert",
    "append",
    "source",
    "set",
    "index",
    "keep",
    "track",
    "uh",
    "next",
    "element",
    "need",
    "dq",
    "first",
    "element",
    "need",
    "dq",
    "index",
    "less",
    "0er",
    "visited",
    "target",
    "index",
    "less",
    "length",
    "q",
    "target",
    "visited",
    "need",
    "get",
    "need",
    "get",
    "current",
    "element",
    "q",
    "simply",
    "get",
    "q",
    "idx",
    "increment",
    "increment",
    "idx",
    "one",
    "increment",
    "idx",
    "one",
    "need",
    "take",
    "neighbors",
    "q",
    "neighbor",
    "also",
    "need",
    "finally",
    "mark",
    "visited",
    "let",
    "put",
    "visited",
    "current",
    "equals",
    "true",
    "need",
    "need",
    "update",
    "distances",
    "neighbors",
    "also",
    "need",
    "find",
    "next",
    "node",
    "find",
    "first",
    "unvisited",
    "node",
    "smallest",
    "distance",
    "okay",
    "update",
    "distance",
    "neighbors",
    "written",
    "function",
    "called",
    "update",
    "distance",
    "call",
    "function",
    "update",
    "distance",
    "update",
    "distances",
    "pass",
    "graph",
    "pass",
    "current",
    "node",
    "pass",
    "distance",
    "matrix",
    "distance",
    "array",
    "pass",
    "way",
    "update",
    "distances",
    "let",
    "look",
    "let",
    "look",
    "always",
    "good",
    "idea",
    "extract",
    "specific",
    "pieces",
    "logic",
    "separate",
    "functions",
    "calling",
    "update",
    "distances",
    "current",
    "node",
    "graph",
    "distance",
    "get",
    "neighbors",
    "current",
    "node",
    "using",
    "graph",
    "data",
    "graph",
    "data",
    "current",
    "give",
    "us",
    "neighbors",
    "current",
    "nodes",
    "get",
    "weights",
    "neighbors",
    "edges",
    "connecting",
    "current",
    "node",
    "neighbors",
    "get",
    "weights",
    "well",
    "go",
    "list",
    "neighbors",
    "common",
    "node",
    "enumerate",
    "neighbors",
    "check",
    "get",
    "weight",
    "node",
    "weight",
    "edge",
    "node",
    "connected",
    "weight",
    "edge",
    "check",
    "distance",
    "node",
    "distance",
    "node",
    "let",
    "say",
    "already",
    "said",
    "infinity",
    "case",
    "distance",
    "current",
    "node",
    "source",
    "plus",
    "weight",
    "edge",
    "current",
    "node",
    "next",
    "node",
    "less",
    "distance",
    "distance",
    "fl",
    "current",
    "plus",
    "weight",
    "less",
    "distance",
    "simply",
    "update",
    "distance",
    "node",
    "hand",
    "distance",
    "node",
    "already",
    "set",
    "via",
    "node",
    "less",
    "distance",
    "via",
    "current",
    "node",
    "update",
    "distance",
    "okay",
    "ignore",
    "come",
    "back",
    "performing",
    "exactly",
    "update",
    "distances",
    "function",
    "talked",
    "next",
    "want",
    "find",
    "next",
    "unvisited",
    "node",
    "function",
    "called",
    "pick",
    "next",
    "node",
    "list",
    "distances",
    "visited",
    "want",
    "track",
    "minimum",
    "distance",
    "first",
    "set",
    "variable",
    "called",
    "minimum",
    "distance",
    "value",
    "infinity",
    "set",
    "variable",
    "min",
    "node",
    "node",
    "minimum",
    "distance",
    "value",
    "none",
    "iterate",
    "list",
    "nodes",
    "graph",
    "0",
    "n",
    "minus1",
    "check",
    "node",
    "visited",
    "distance",
    "node",
    "less",
    "minimum",
    "distance",
    "obtained",
    "far",
    "set",
    "node",
    "minimum",
    "node",
    "set",
    "minimum",
    "distance",
    "value",
    "okay",
    "track",
    "minimum",
    "distance",
    "running",
    "minimum",
    "distance",
    "going",
    "nodes",
    "graph",
    "keep",
    "track",
    "node",
    "minimum",
    "unvisited",
    "node",
    "minimum",
    "distance",
    "finally",
    "pick",
    "next",
    "node",
    "gives",
    "us",
    "first",
    "next",
    "unvisited",
    "node",
    "okay",
    "get",
    "next",
    "node",
    "pick",
    "next",
    "node",
    "give",
    "distance",
    "give",
    "visited",
    "okay",
    "next",
    "node",
    "possible",
    "next",
    "node",
    "probably",
    "already",
    "visited",
    "everything",
    "visit",
    "next",
    "node",
    "nq",
    "say",
    "append",
    "next",
    "node",
    "pretty",
    "much",
    "shortest",
    "path",
    "algorithm",
    "create",
    "visited",
    "list",
    "create",
    "distance",
    "list",
    "create",
    "que",
    "add",
    "things",
    "nodes",
    "visited",
    "go",
    "go",
    "one",
    "one",
    "q",
    "order",
    "give",
    "us",
    "list",
    "nodes",
    "order",
    "distance",
    "source",
    "node",
    "need",
    "return",
    "simply",
    "need",
    "return",
    "distance",
    "target",
    "since",
    "asked",
    "let",
    "also",
    "mark",
    "current",
    "visited",
    "true",
    "soon",
    "enough",
    "end",
    "visiting",
    "current",
    "right",
    "let",
    "run",
    "shortest",
    "path",
    "algorithm",
    "graph",
    "graph",
    "see",
    "create",
    "graph",
    "graph",
    "7",
    "weighted",
    "directed",
    "pass",
    "graph",
    "pass",
    "num",
    "nodes",
    "7",
    "pass",
    "edges",
    "7",
    "pass",
    "weighted",
    "equals",
    "true",
    "directed",
    "equals",
    "true",
    "graph",
    "7",
    "okay",
    "seems",
    "like",
    "worked",
    "right",
    "0er",
    "connected",
    "1",
    "two",
    "weights",
    "four",
    "two",
    "respectively",
    "five",
    "connected",
    "nothing",
    "four",
    "connected",
    "three",
    "connected",
    "five",
    "four",
    "connected",
    "three",
    "okay",
    "looks",
    "fine",
    "say",
    "shortest",
    "path",
    "graph",
    "let",
    "say",
    "0",
    "5",
    "graph",
    "7",
    "says",
    "length",
    "shortest",
    "path",
    "20",
    "2",
    "3",
    "4",
    "11",
    "2",
    "3",
    "5",
    "5",
    "4",
    "9",
    "9",
    "11",
    "20",
    "seems",
    "right",
    "would",
    "also",
    "nice",
    "get",
    "see",
    "path",
    "introduce",
    "something",
    "called",
    "parent",
    "simply",
    "another",
    "thing",
    "called",
    "parent",
    "set",
    "none",
    "element",
    "visited",
    "let",
    "call",
    "parent",
    "let",
    "set",
    "none",
    "default",
    "need",
    "whenever",
    "enqing",
    "node",
    "need",
    "track",
    "got",
    "inced",
    "right",
    "node",
    "getting",
    "enced",
    "probably",
    "getting",
    "enced",
    "soorry",
    "whenever",
    "queing",
    "whenever",
    "updating",
    "distance",
    "node",
    "need",
    "track",
    "distance",
    "got",
    "updated",
    "inside",
    "update",
    "distances",
    "whenever",
    "update",
    "distance",
    "node",
    "also",
    "set",
    "node",
    "parent",
    "node",
    "current",
    "node",
    "distance",
    "got",
    "updated",
    "right",
    "need",
    "update",
    "distance",
    "node",
    "need",
    "track",
    "update",
    "distance",
    "node",
    "come",
    "update",
    "distance",
    "way",
    "tracked",
    "parent",
    "let",
    "return",
    "distance",
    "target",
    "let",
    "also",
    "return",
    "q",
    "let",
    "return",
    "let",
    "return",
    "parent",
    "think",
    "fine",
    "okay",
    "parent",
    "one",
    "look",
    "fifth",
    "element",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "see",
    "parent",
    "five",
    "three",
    "seemed",
    "like",
    "arrived",
    "five",
    "three",
    "look",
    "parent",
    "three",
    "0",
    "1",
    "3",
    "parent",
    "three",
    "four",
    "seemed",
    "like",
    "arrived",
    "three",
    "four",
    "look",
    "parent",
    "two",
    "seems",
    "like",
    "arrived",
    "four",
    "two",
    "look",
    "parent",
    "two",
    "looks",
    "like",
    "arrived",
    "zero",
    "zero",
    "source",
    "path",
    "simply",
    "going",
    "reverse",
    "0",
    "2",
    "4",
    "3",
    "5",
    "okay",
    "get",
    "shortest",
    "path",
    "shortest",
    "path",
    "distance",
    "notice",
    "zero",
    "parent",
    "source",
    "repeat",
    "another",
    "graph",
    "let",
    "say",
    "take",
    "graph",
    "graph",
    "two",
    "let",
    "grab",
    "image",
    "let",
    "get",
    "graph",
    "two",
    "let",
    "say",
    "shortest",
    "path",
    "graph",
    "two",
    "let",
    "get",
    "shortest",
    "path",
    "maybe",
    "0",
    "7",
    "seems",
    "like",
    "two",
    "paths",
    "one",
    "goes",
    "via",
    "one",
    "one",
    "goes",
    "via",
    "six",
    "2",
    "3",
    "3",
    "2",
    "7",
    "let",
    "get",
    "shortest",
    "part",
    "0",
    "7",
    "okay",
    "started",
    "zero",
    "uh",
    "end",
    "7",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "seems",
    "like",
    "parent",
    "7",
    "1",
    "parent",
    "1",
    "0",
    "clear",
    "picked",
    "path",
    "017",
    "total",
    "length",
    "path",
    "7",
    "sounds",
    "good",
    "try",
    "another",
    "one",
    "try",
    "2",
    "8",
    "couple",
    "ways",
    "go",
    "2",
    "8",
    "one",
    "go",
    "via",
    "three",
    "go",
    "six",
    "three",
    "ways",
    "actually",
    "6",
    "2",
    "uh",
    "6",
    "go",
    "3",
    "0",
    "8",
    "go",
    "3",
    "4",
    "8",
    "let",
    "see",
    "one",
    "picks",
    "okay",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "parent",
    "for8",
    "5",
    "oh",
    "sorry",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "parent",
    "8",
    "4",
    "came",
    "8",
    "bya",
    "4",
    "parent",
    "4",
    "0",
    "1",
    "2",
    "3",
    "4",
    "parent",
    "four",
    "three",
    "came",
    "4",
    "bya",
    "3",
    "parent",
    "three",
    "0",
    "1",
    "2",
    "3",
    "parent",
    "three",
    "2",
    "came",
    "3",
    "6",
    "uh",
    "2",
    "2",
    "3",
    "4",
    "path",
    "length",
    "8",
    "1",
    "9",
    "6",
    "15",
    "great",
    "seems",
    "like",
    "figured",
    "shortest",
    "path",
    "time",
    "undirected",
    "graph",
    "okay",
    "long",
    "weights",
    "apply",
    "algorithm",
    "algorithm",
    "called",
    "dias",
    "algorithm",
    "going",
    "cover",
    "today",
    "one",
    "thing",
    "looked",
    "closely",
    "running",
    "time",
    "complexities",
    "let",
    "quick",
    "look",
    "let",
    "quick",
    "look",
    "let",
    "say",
    "bfs",
    "see",
    "identify",
    "guess",
    "running",
    "time",
    "complexity",
    "full",
    "proof",
    "left",
    "exercise",
    "roughly",
    "looks",
    "like",
    "main",
    "main",
    "loop",
    "going",
    "q",
    "number",
    "times",
    "may",
    "happen",
    "n",
    "number",
    "n",
    "number",
    "nodes",
    "number",
    "times",
    "might",
    "happen",
    "inside",
    "node",
    "inside",
    "bfs",
    "remember",
    "check",
    "full",
    "list",
    "noes",
    "inside",
    "node",
    "bfs",
    "number",
    "times",
    "may",
    "happen",
    "equal",
    "number",
    "node",
    "may",
    "perform",
    "additional",
    "number",
    "steps",
    "equal",
    "number",
    "nodes",
    "connected",
    "right",
    "n",
    "nodes",
    "n",
    "loops",
    "total",
    "edges",
    "let",
    "say",
    "edges",
    "split",
    "across",
    "count",
    "number",
    "edges",
    "node",
    "number",
    "edges",
    "e1",
    "e2",
    "e3",
    "e4",
    "size",
    "loop",
    "node",
    "n1",
    "e1",
    "size",
    "loop",
    "node",
    "n2",
    "e2",
    "size",
    "loop",
    "node",
    "n3",
    "e3",
    "add",
    "list",
    "edges",
    "e1",
    "e2",
    "plus",
    "e3",
    "plus",
    "e4",
    "total",
    "number",
    "iterations",
    "inside",
    "loop",
    "turns",
    "see",
    "total",
    "number",
    "iterations",
    "inside",
    "loop",
    "turn",
    "total",
    "sum",
    "adjacency",
    "lists",
    "okay",
    "total",
    "sum",
    "adjacency",
    "list",
    "equal",
    "twice",
    "number",
    "edges",
    "see",
    "number",
    "edges",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "verify",
    "number",
    "elements",
    "adjacency",
    "lists",
    "put",
    "together",
    "14",
    "edge",
    "represented",
    "twice",
    "right",
    "end",
    "n",
    "uh",
    "n",
    "ed",
    "n",
    "vertices",
    "edges",
    "end",
    "n",
    "2",
    "operations",
    "right",
    "n",
    "operations",
    "start",
    "loop",
    "2",
    "operations",
    "iterate",
    "adjacency",
    "list",
    "right",
    "talking",
    "complexities",
    "ignore",
    "number",
    "edges",
    "ignore",
    "factor",
    "two",
    "associated",
    "end",
    "order",
    "n",
    "order",
    "n",
    "complexity",
    "breadth",
    "first",
    "search",
    "point",
    "able",
    "work",
    "looking",
    "code",
    "try",
    "clear",
    "ask",
    "forum",
    "order",
    "complexity",
    "bread",
    "first",
    "search",
    "find",
    "similar",
    "complexity",
    "depth",
    "first",
    "search",
    "well",
    "order",
    "n",
    "shortest",
    "path",
    "algorithm",
    "however",
    "complexity",
    "different",
    "shortest",
    "path",
    "algorithm",
    "let",
    "see",
    "shortest",
    "path",
    "algorithm",
    "go",
    "vertices",
    "insert",
    "vertex",
    "node",
    "q",
    "take",
    "contributes",
    "factor",
    "n",
    "saying",
    "update",
    "distances",
    "also",
    "contributes",
    "factor",
    "picking",
    "next",
    "node",
    "may",
    "visit",
    "vertices",
    "right",
    "performing",
    "n",
    "operations",
    "inside",
    "picking",
    "next",
    "node",
    "gives",
    "us",
    "order",
    "n",
    "n",
    "uh",
    "n",
    "sare",
    "yeah",
    "something",
    "like",
    "order",
    "n",
    "square",
    "n",
    "n",
    "plus",
    "n",
    "complexities",
    "see",
    "reported",
    "shortest",
    "path",
    "way",
    "improve",
    "way",
    "improve",
    "picking",
    "next",
    "node",
    "use",
    "called",
    "min",
    "heap",
    "look",
    "entire",
    "list",
    "nodes",
    "time",
    "pick",
    "next",
    "node",
    "simply",
    "pick",
    "next",
    "node",
    "short",
    "time",
    "data",
    "structure",
    "called",
    "min",
    "heap",
    "look",
    "min",
    "heap",
    "allows",
    "used",
    "keep",
    "track",
    "bunch",
    "numbers",
    "easily",
    "track",
    "minimum",
    "keep",
    "bunch",
    "numbers",
    "around",
    "binary",
    "tree",
    "like",
    "root",
    "always",
    "minimum",
    "numbers",
    "left",
    "right",
    "always",
    "larger",
    "root",
    "true",
    "sub",
    "tree",
    "well",
    "insertion",
    "heap",
    "order",
    "login",
    "deletion",
    "heap",
    "order",
    "login",
    "well",
    "min",
    "max",
    "case",
    "fetching",
    "min",
    "maximum",
    "value",
    "order",
    "one",
    "instead",
    "maint",
    "instead",
    "looping",
    "entire",
    "list",
    "nodes",
    "time",
    "simply",
    "insert",
    "nodes",
    "min",
    "heap",
    "delete",
    "nodes",
    "min",
    "heap",
    "become",
    "visited",
    "getting",
    "next",
    "node",
    "simple",
    "fetching",
    "minimum",
    "value",
    "okay",
    "okay",
    "check",
    "something",
    "generally",
    "get",
    "asked",
    "advanced",
    "concept",
    "fact",
    "even",
    "shortest",
    "path",
    "algorithm",
    "unlikely",
    "get",
    "asked",
    "review",
    "try",
    "exercise",
    "want",
    "go",
    "try",
    "implementing",
    "improving",
    "algorithm",
    "using",
    "binary",
    "heap",
    "take",
    "complexity",
    "plus",
    "n",
    "n",
    "n",
    "log",
    "n",
    "okay",
    "may",
    "better",
    "check",
    "obviously",
    "going",
    "better",
    "larger",
    "graphs",
    "try",
    "implement",
    "fact",
    "inside",
    "python",
    "heap",
    "called",
    "heap",
    "q",
    "data",
    "structure",
    "optimize",
    "pick",
    "next",
    "node",
    "operation",
    "dias",
    "algorithm",
    "okay",
    "concludes",
    "discussion",
    "graphs",
    "lot",
    "graphs",
    "graph",
    "theory",
    "entire",
    "course",
    "since",
    "course",
    "particularly",
    "concentrated",
    "data",
    "structures",
    "algorithms",
    "perspective",
    "coding",
    "interviews",
    "coding",
    "assessments",
    "far",
    "need",
    "go",
    "practice",
    "graph",
    "problems",
    "related",
    "breadth",
    "first",
    "search",
    "depth",
    "first",
    "search",
    "really",
    "something",
    "need",
    "become",
    "familiar",
    "breadth",
    "first",
    "depth",
    "first",
    "search",
    "shortest",
    "path",
    "maybe",
    "sometimes",
    "really",
    "hard",
    "interviews",
    "may",
    "get",
    "asked",
    "shortest",
    "path",
    "well",
    "familiarize",
    "apart",
    "really",
    "need",
    "lot",
    "algorithms",
    "look",
    "minimum",
    "spanning",
    "trees",
    "look",
    "topological",
    "sorting",
    "look",
    "connected",
    "components",
    "another",
    "path",
    "look",
    "detection",
    "cycles",
    "something",
    "called",
    "disjoint",
    "sets",
    "huge",
    "huge",
    "number",
    "topics",
    "cover",
    "graphs",
    "stop",
    "discussion",
    "next",
    "review",
    "lecture",
    "video",
    "execute",
    "jupiter",
    "notebook",
    "complete",
    "assignment",
    "attempt",
    "optional",
    "questions",
    "finally",
    "participate",
    "forum",
    "discussions",
    "important",
    "stuck",
    "point",
    "go",
    "forum",
    "ask",
    "question",
    "also",
    "share",
    "code",
    "long",
    "working",
    "get",
    "help",
    "also",
    "join",
    "start",
    "study",
    "group",
    "learn",
    "together",
    "friends",
    "also",
    "find",
    "us",
    "twitter",
    "chian",
    "ml",
    "akash",
    "ns",
    "next",
    "lesson",
    "data",
    "structures",
    "algorithms",
    "data",
    "structures",
    "algorithms",
    "python",
    "interview",
    "tips",
    "tricks",
    "practical",
    "advice",
    "thank",
    "hello",
    "welcome",
    "data",
    "structures",
    "algorithms",
    "python",
    "online",
    "certification",
    "course",
    "conducted",
    "jovian",
    "today",
    "lesson",
    "six",
    "python",
    "interview",
    "tips",
    "tricks",
    "practical",
    "advice",
    "final",
    "lesson",
    "course",
    "hope",
    "excited",
    "name",
    "akash",
    "instructor",
    "find",
    "akash",
    "ns",
    "following",
    "along",
    "course",
    "working",
    "assignments",
    "complete",
    "course",
    "project",
    "well",
    "earn",
    "certificate",
    "accomplishment",
    "course",
    "find",
    "jovan",
    "profile",
    "also",
    "add",
    "linkedin",
    "download",
    "pdf",
    "let",
    "get",
    "started",
    "first",
    "thing",
    "go",
    "course",
    "website",
    "python",
    "course",
    "website",
    "python",
    "1",
    "2",
    "3",
    "course",
    "project",
    "well",
    "let",
    "open",
    "lesson",
    "six",
    "lesson",
    "6",
    "able",
    "find",
    "video",
    "recording",
    "video",
    "watching",
    "right",
    "code",
    "look",
    "today",
    "today",
    "something",
    "different",
    "simulate",
    "experience",
    "interview",
    "given",
    "problem",
    "solving",
    "template",
    "recommend",
    "follow",
    "template",
    "project",
    "notebook",
    "work",
    "coding",
    "problem",
    "work",
    "problem",
    "solving",
    "template",
    "also",
    "method",
    "something",
    "applying",
    "throughout",
    "course",
    "different",
    "kinds",
    "problems",
    "different",
    "kinds",
    "data",
    "structures",
    "algorithms",
    "interview",
    "obviously",
    "template",
    "see",
    "apply",
    "method",
    "interview",
    "let",
    "revise",
    "method",
    "recall",
    "memory",
    "working",
    "interview",
    "problem",
    "systematic",
    "strategy",
    "applying",
    "far",
    "solving",
    "problems",
    "check",
    "previous",
    "lessons",
    "seen",
    "examples",
    "apply",
    "detail",
    "step",
    "one",
    "state",
    "problem",
    "clearly",
    "words",
    "identify",
    "input",
    "output",
    "format",
    "second",
    "step",
    "come",
    "example",
    "inputs",
    "outputs",
    "try",
    "cover",
    "edge",
    "cases",
    "think",
    "want",
    "think",
    "possible",
    "scenarios",
    "help",
    "write",
    "code",
    "properly",
    "step",
    "three",
    "come",
    "correct",
    "solution",
    "problem",
    "state",
    "solution",
    "plain",
    "english",
    "step",
    "four",
    "implement",
    "solution",
    "test",
    "using",
    "example",
    "input",
    "important",
    "practicing",
    "initially",
    "come",
    "correct",
    "solution",
    "simple",
    "solution",
    "often",
    "called",
    "brute",
    "force",
    "solution",
    "interview",
    "setting",
    "may",
    "time",
    "implement",
    "scratch",
    "may",
    "skip",
    "brute",
    "force",
    "solution",
    "straightforward",
    "step",
    "five",
    "analyze",
    "algorithm",
    "complexity",
    "identify",
    "inefficiencies",
    "algorithm",
    "interviewers",
    "come",
    "correct",
    "solution",
    "describe",
    "interviewer",
    "analyze",
    "complexity",
    "directly",
    "start",
    "identifying",
    "inefficiencies",
    "move",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "need",
    "identify",
    "one",
    "techniques",
    "learned",
    "course",
    "need",
    "apply",
    "binary",
    "search",
    "problem",
    "divide",
    "conquer",
    "problem",
    "related",
    "binary",
    "search",
    "trees",
    "something",
    "solve",
    "similar",
    "way",
    "solve",
    "sorting",
    "important",
    "look",
    "worst",
    "case",
    "average",
    "case",
    "complexity",
    "graph",
    "problem",
    "recursion",
    "dynamic",
    "programming",
    "memorization",
    "problem",
    "things",
    "something",
    "think",
    "practice",
    "problems",
    "lessons",
    "try",
    "practice",
    "5",
    "10",
    "problems",
    "start",
    "recognize",
    "patterns",
    "step",
    "six",
    "trying",
    "come",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "ideas",
    "automatically",
    "come",
    "practice",
    "important",
    "succeed",
    "step",
    "six",
    "determined",
    "overcome",
    "inefficiency",
    "right",
    "data",
    "structure",
    "algorithm",
    "state",
    "solution",
    "implement",
    "analyze",
    "complexity",
    "right",
    "coding",
    "assessment",
    "interview",
    "proceed",
    "let",
    "see",
    "let",
    "pick",
    "coding",
    "problem",
    "let",
    "go",
    "coding",
    "problem",
    "python",
    "subarray",
    "given",
    "sum",
    "read",
    "problem",
    "see",
    "notebook",
    "fairly",
    "empty",
    "trying",
    "trying",
    "simulate",
    "situation",
    "call",
    "somebody",
    "interviewing",
    "typically",
    "would",
    "using",
    "platform",
    "like",
    "collab",
    "edit",
    "maybe",
    "platform",
    "also",
    "run",
    "code",
    "platform",
    "question",
    "somewhere",
    "let",
    "say",
    "right",
    "already",
    "printed",
    "database",
    "right",
    "left",
    "right",
    "type",
    "code",
    "experiment",
    "using",
    "third",
    "platform",
    "simply",
    "simulate",
    "jupiter",
    "notebook",
    "okay",
    "notebook",
    "running",
    "clicked",
    "run",
    "button",
    "jovian",
    "notebook",
    "question",
    "question",
    "asked",
    "coding",
    "interview",
    "amazon",
    "course",
    "lot",
    "companies",
    "may",
    "ask",
    "similar",
    "questions",
    "given",
    "array",
    "numbers",
    "numbers",
    "negative",
    "need",
    "find",
    "continuous",
    "sub",
    "array",
    "list",
    "adds",
    "given",
    "sum",
    "interviewer",
    "might",
    "state",
    "problem",
    "may",
    "also",
    "tell",
    "example",
    "sometimes",
    "always",
    "good",
    "idea",
    "ask",
    "example",
    "might",
    "sometimes",
    "feel",
    "maybe",
    "ask",
    "many",
    "questions",
    "interviewer",
    "might",
    "think",
    "know",
    "dumb",
    "way",
    "true",
    "actually",
    "opposite",
    "questions",
    "ask",
    "better",
    "interview",
    "better",
    "interviewer",
    "able",
    "convey",
    "want",
    "right",
    "busy",
    "five",
    "interviews",
    "day",
    "entire",
    "day",
    "work",
    "sometimes",
    "may",
    "fail",
    "state",
    "question",
    "entirety",
    "ask",
    "clarifications",
    "may",
    "assume",
    "wrong",
    "thing",
    "go",
    "ahead",
    "implement",
    "something",
    "completely",
    "wrong",
    "completely",
    "derails",
    "interview",
    "trust",
    "happens",
    "often",
    "might",
    "think",
    "okay",
    "one",
    "example",
    "let",
    "say",
    "interviewer",
    "provide",
    "example",
    "ask",
    "please",
    "give",
    "example",
    "problem",
    "come",
    "back",
    "say",
    "suppose",
    "array",
    "1",
    "7",
    "4",
    "2",
    "1",
    "3",
    "11",
    "5",
    "numbers",
    "negative",
    "could",
    "zero",
    "well",
    "suppose",
    "array",
    "give",
    "number",
    "10",
    "want",
    "find",
    "large",
    "want",
    "find",
    "continuous",
    "sub",
    "array",
    "list",
    "adds",
    "given",
    "sum",
    "10",
    "might",
    "also",
    "tell",
    "case",
    "solution",
    "subarray",
    "starting",
    "position",
    "four",
    "uh",
    "starting",
    "number",
    "4",
    "going",
    "way",
    "three",
    "check",
    "ways",
    "create",
    "10",
    "like",
    "took",
    "1",
    "7",
    "would",
    "8",
    "1",
    "74",
    "would",
    "12",
    "hand",
    "742",
    "would",
    "12",
    "4",
    "2",
    "1",
    "3",
    "turns",
    "10",
    "right",
    "able",
    "create",
    "total",
    "10",
    "subarray",
    "return",
    "mean",
    "return",
    "subarray",
    "return",
    "subarray",
    "means",
    "return",
    "indexes",
    "index",
    "starting",
    "term",
    "index",
    "ending",
    "term",
    "sometimes",
    "know",
    "python",
    "working",
    "ranges",
    "typically",
    "end",
    "index",
    "outside",
    "actual",
    "data",
    "could",
    "return",
    "index",
    "four",
    "index",
    "11",
    "index",
    "four",
    "0",
    "1",
    "2",
    "2",
    "index",
    "4",
    "3",
    "4",
    "5",
    "6",
    "index",
    "11",
    "6",
    "return",
    "2",
    "six",
    "try",
    "access",
    "2",
    "six",
    "2",
    "colon",
    "6",
    "range",
    "list",
    "get",
    "get",
    "list",
    "4",
    "to13",
    "fact",
    "something",
    "quickly",
    "verify",
    "let",
    "say",
    "l1",
    "1",
    "7",
    "4",
    "2",
    "1",
    "3",
    "say",
    "start",
    "index",
    "start",
    "index",
    "end",
    "index",
    "j",
    "2",
    "6",
    "respectively",
    "see",
    "l1",
    "2",
    "6",
    "4",
    "2",
    "1",
    "3",
    "right",
    "although",
    "j",
    "outside",
    "get",
    "included",
    "put",
    "range",
    "put",
    "42",
    "13",
    "also",
    "verify",
    "sum",
    "10",
    "okay",
    "right",
    "problem",
    "explained",
    "lot",
    "detail",
    "interviewer",
    "would",
    "process",
    "apply",
    "mind",
    "sometimes",
    "also",
    "repeat",
    "problem",
    "back",
    "interviewer",
    "great",
    "idea",
    "stated",
    "problem",
    "theyve",
    "may",
    "given",
    "example",
    "state",
    "problem",
    "simple",
    "words",
    "remember",
    "step",
    "one",
    "way",
    "state",
    "problem",
    "figure",
    "inputs",
    "outputs",
    "input",
    "array",
    "array",
    "also",
    "list",
    "python",
    "let",
    "say",
    "arr",
    "zer",
    "let",
    "create",
    "let",
    "make",
    "first",
    "example",
    "first",
    "input",
    "would",
    "1",
    "7",
    "4",
    "2",
    "1",
    "3",
    "target",
    "target",
    "sum",
    "10",
    "input",
    "output",
    "want",
    "want",
    "output",
    "zero",
    "would",
    "2a",
    "6",
    "verified",
    "input",
    "output",
    "format",
    "always",
    "makes",
    "sense",
    "create",
    "variables",
    "start",
    "start",
    "coding",
    "next",
    "step",
    "think",
    "cases",
    "function",
    "able",
    "handle",
    "actually",
    "also",
    "write",
    "function",
    "signature",
    "know",
    "input",
    "looks",
    "like",
    "know",
    "output",
    "going",
    "look",
    "like",
    "know",
    "know",
    "function",
    "look",
    "like",
    "say",
    "def",
    "let",
    "call",
    "subarray",
    "sum",
    "going",
    "take",
    "array",
    "going",
    "take",
    "target",
    "going",
    "logic",
    "inside",
    "okay",
    "right",
    "step",
    "one",
    "sorry",
    "forgot",
    "function",
    "signature",
    "always",
    "helps",
    "write",
    "function",
    "signature",
    "misunderstood",
    "problem",
    "still",
    "interviewer",
    "immediately",
    "correct",
    "tell",
    "hey",
    "taken",
    "certain",
    "input",
    "assumed",
    "input",
    "provided",
    "okay",
    "right",
    "function",
    "signature",
    "step",
    "two",
    "remember",
    "step",
    "two",
    "come",
    "exhaustive",
    "list",
    "test",
    "cases",
    "test",
    "problem",
    "comments",
    "create",
    "comments",
    "say",
    "thinking",
    "problem",
    "trying",
    "think",
    "cases",
    "need",
    "handle",
    "great",
    "quality",
    "something",
    "people",
    "often",
    "indicates",
    "called",
    "test",
    "driven",
    "development",
    "means",
    "thinking",
    "ways",
    "code",
    "code",
    "might",
    "used",
    "accounting",
    "writing",
    "code",
    "kind",
    "working",
    "backwards",
    "useful",
    "way",
    "avoid",
    "errors",
    "first",
    "one",
    "could",
    "generic",
    "array",
    "sub",
    "array",
    "center",
    "somewhere",
    "center",
    "right",
    "already",
    "seen",
    "sub",
    "array",
    "could",
    "center",
    "sub",
    "array",
    "could",
    "start",
    "sub",
    "array",
    "could",
    "end",
    "possible",
    "sub",
    "array",
    "subarray",
    "sub",
    "array",
    "adds",
    "10",
    "may",
    "also",
    "situation",
    "zeros",
    "zeros",
    "list",
    "one",
    "option",
    "one",
    "thing",
    "happen",
    "could",
    "multiple",
    "sub",
    "arrays",
    "sum",
    "might",
    "want",
    "clarify",
    "interviewer",
    "hey",
    "happens",
    "get",
    "two",
    "sub",
    "arrays",
    "add",
    "uh",
    "number",
    "target",
    "inter",
    "interviewer",
    "might",
    "say",
    "find",
    "shortest",
    "one",
    "find",
    "first",
    "one",
    "find",
    "one",
    "always",
    "good",
    "clarify",
    "next",
    "one",
    "option",
    "could",
    "could",
    "also",
    "ask",
    "happens",
    "subarray",
    "adds",
    "10",
    "may",
    "tell",
    "return",
    "none",
    "none",
    "return",
    "minus",
    "one",
    "whatever",
    "assume",
    "always",
    "sub",
    "array",
    "help",
    "write",
    "code",
    "obviously",
    "may",
    "work",
    "empty",
    "array",
    "may",
    "also",
    "work",
    "sub",
    "array",
    "single",
    "element",
    "whenever",
    "say",
    "aray",
    "also",
    "mean",
    "list",
    "python",
    "practically",
    "speaking",
    "thing",
    "purposes",
    "okay",
    "listed",
    "quite",
    "test",
    "cases",
    "process",
    "come",
    "across",
    "questions",
    "clarified",
    "ready",
    "start",
    "solving",
    "problem",
    "point",
    "may",
    "want",
    "maybe",
    "ask",
    "couple",
    "minutes",
    "keep",
    "pen",
    "paper",
    "close",
    "going",
    "use",
    "tool",
    "instead",
    "yes",
    "going",
    "use",
    "tool",
    "instead",
    "keep",
    "pen",
    "paper",
    "close",
    "work",
    "problem",
    "let",
    "come",
    "simplest",
    "possible",
    "solution",
    "right",
    "2",
    "3",
    "minutes",
    "come",
    "solution",
    "often",
    "simplest",
    "solution",
    "pretty",
    "obvious",
    "case",
    "one",
    "simple",
    "solution",
    "could",
    "could",
    "simply",
    "try",
    "every",
    "subarray",
    "find",
    "least",
    "one",
    "adds",
    "10",
    "one",
    "need",
    "sub",
    "array",
    "defined",
    "start",
    "index",
    "first",
    "element",
    "array",
    "n",
    "index",
    "end",
    "index",
    "next",
    "next",
    "index",
    "first",
    "index",
    "array",
    "right",
    "defined",
    "sub",
    "array",
    "remember",
    "need",
    "try",
    "values",
    "values",
    "comma",
    "j",
    "goes",
    "0",
    "n",
    "minus",
    "one",
    "j",
    "goes",
    "remember",
    "could",
    "start",
    "empty",
    "sub",
    "array",
    "means",
    "j",
    "also",
    "value",
    "saying",
    "j",
    "value",
    "two",
    "l1",
    "2",
    "two",
    "becomes",
    "empty",
    "array",
    "j",
    "grows",
    "way",
    "beyond",
    "last",
    "element",
    "means",
    "last",
    "element",
    "index",
    "n",
    "minus",
    "one",
    "j",
    "go",
    "way",
    "n",
    "right",
    "goes",
    "0",
    "n",
    "minus1",
    "j",
    "goes",
    "n",
    "time",
    "start",
    "check",
    "j",
    "check",
    "jal",
    "0",
    "j",
    "1",
    "j",
    "2",
    "j",
    "3",
    "4",
    "5",
    "move",
    "start",
    "say",
    "start",
    "jal",
    "0",
    "jal",
    "1",
    "jal",
    "2",
    "3",
    "4",
    "okay",
    "keep",
    "till",
    "find",
    "array",
    "exhaust",
    "way",
    "test",
    "sub",
    "aray",
    "problem",
    "solved",
    "brute",
    "force",
    "solution",
    "first",
    "explain",
    "brute",
    "force",
    "solution",
    "may",
    "seem",
    "obvious",
    "solution",
    "point",
    "explaining",
    "mention",
    "point",
    "interviewer",
    "knows",
    "nothing",
    "know",
    "even",
    "come",
    "solution",
    "problem",
    "right",
    "trying",
    "assess",
    "think",
    "problems",
    "trying",
    "assess",
    "write",
    "code",
    "tell",
    "brute",
    "force",
    "solution",
    "even",
    "know",
    "figured",
    "brute",
    "force",
    "solution",
    "tell",
    "brute",
    "force",
    "solution",
    "generally",
    "code",
    "analysis",
    "memory",
    "uh",
    "mind",
    "sort",
    "write",
    "code",
    "mind",
    "picture",
    "code",
    "based",
    "come",
    "complexity",
    "analysis",
    "directly",
    "say",
    "brute",
    "force",
    "algorithm",
    "complexity",
    "okay",
    "write",
    "code",
    "right",
    "clear",
    "case",
    "yet",
    "clear",
    "write",
    "code",
    "interview",
    "part",
    "skip",
    "interest",
    "time",
    "subarray",
    "think",
    "called",
    "subarray",
    "sum",
    "subarray",
    "sum",
    "let",
    "call",
    "subar",
    "su",
    "one",
    "first",
    "approach",
    "taking",
    "array",
    "one",
    "array",
    "target",
    "saying",
    "remember",
    "start",
    "goes",
    "0",
    "nus",
    "1",
    "first",
    "thing",
    "range",
    "0",
    "n",
    "minus1",
    "n",
    "well",
    "n",
    "simply",
    "len",
    "array",
    "length",
    "array",
    "j",
    "goes",
    "n",
    "oops",
    "made",
    "small",
    "error",
    "say",
    "0",
    "n",
    "even",
    "range",
    "last",
    "value",
    "taken",
    "j",
    "goes",
    "0",
    "n",
    "j",
    "range",
    "n",
    "1",
    "want",
    "j",
    "go",
    "way",
    "n",
    "okay",
    "simply",
    "check",
    "sum",
    "array",
    "j",
    "seen",
    "array",
    "j",
    "going",
    "give",
    "us",
    "indexes",
    "starting",
    "ending",
    "g",
    "sum",
    "array",
    "j",
    "equals",
    "target",
    "found",
    "answer",
    "return",
    "comma",
    "j",
    "check",
    "subarray",
    "sum",
    "equals",
    "target",
    "let",
    "return",
    "non",
    "none",
    "maybe",
    "agreed",
    "let",
    "return",
    "n",
    "none",
    "code",
    "1",
    "2",
    "3",
    "4",
    "five",
    "lines",
    "code",
    "maybe",
    "six",
    "brute",
    "force",
    "solution",
    "really",
    "short",
    "hurt",
    "write",
    "going",
    "sit",
    "least",
    "reference",
    "something",
    "discuss",
    "interviewer",
    "mean",
    "clear",
    "brute",
    "force",
    "solution",
    "tell",
    "complexity",
    "write",
    "one",
    "tip",
    "whenever",
    "coding",
    "always",
    "helpful",
    "simply",
    "add",
    "small",
    "comment",
    "even",
    "interviewer",
    "able",
    "follow",
    "code",
    "follow",
    "comments",
    "tell",
    "general",
    "strategy",
    "correct",
    "right",
    "reading",
    "code",
    "hard",
    "especially",
    "familiar",
    "coding",
    "best",
    "practices",
    "industry",
    "code",
    "write",
    "sometimes",
    "difficult",
    "read",
    "learn",
    "write",
    "good",
    "code",
    "meantime",
    "always",
    "helps",
    "mention",
    "comments",
    "makes",
    "makes",
    "job",
    "easier",
    "makes",
    "easier",
    "makes",
    "easier",
    "evaluate",
    "otherwise",
    "may",
    "spend",
    "5",
    "10",
    "minutes",
    "talking",
    "something",
    "code",
    "either",
    "misunderstood",
    "made",
    "typo",
    "etc",
    "okay",
    "subarray",
    "sum",
    "one",
    "implemented",
    "brute",
    "force",
    "solution",
    "maybe",
    "let",
    "also",
    "check",
    "cases",
    "see",
    "root",
    "force",
    "solution",
    "works",
    "correctly",
    "interview",
    "ability",
    "run",
    "code",
    "run",
    "samples",
    "let",
    "say",
    "simply",
    "take",
    "array",
    "z",
    "target",
    "0",
    "get",
    "value",
    "26",
    "remember",
    "output",
    "0",
    "also",
    "value",
    "26",
    "great",
    "seems",
    "like",
    "technique",
    "work",
    "let",
    "test",
    "cases",
    "sure",
    "subarray",
    "end",
    "subarray",
    "start",
    "let",
    "see",
    "fix",
    "array",
    "zero",
    "take",
    "remember",
    "4",
    "to13",
    "oops",
    "think",
    "completed",
    "let",
    "also",
    "put",
    "11a",
    "5",
    "yeah",
    "remember",
    "4",
    "13",
    "solution",
    "simply",
    "take",
    "4",
    "21315",
    "call",
    "sub",
    "array",
    "sum",
    "put",
    "number",
    "put",
    "target",
    "zero",
    "10",
    "oh",
    "one",
    "okay",
    "yeah",
    "see",
    "4",
    "13",
    "01",
    "1",
    "2",
    "3",
    "range",
    "0",
    "4",
    "seems",
    "worked",
    "correctly",
    "let",
    "thing",
    "let",
    "time",
    "let",
    "put",
    "end",
    "1",
    "7",
    "4",
    "2",
    "1",
    "3",
    "115",
    "works",
    "fine",
    "2",
    "2",
    "six",
    "let",
    "try",
    "another",
    "one",
    "let",
    "try",
    "maybe",
    "17",
    "probably",
    "found",
    "oh",
    "1",
    "2",
    "let",
    "see",
    "1",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "probably",
    "sum",
    "4",
    "2",
    "4",
    "10",
    "okay",
    "maybe",
    "problem",
    "seems",
    "like",
    "17",
    "right",
    "sum",
    "1",
    "7",
    "8",
    "8",
    "4",
    "12",
    "12",
    "2",
    "14",
    "14",
    "4",
    "18",
    "okay",
    "seems",
    "like",
    "mistake",
    "even",
    "check",
    "l1",
    "let",
    "call",
    "l2",
    "l",
    "2",
    "oh",
    "says",
    "1",
    "six",
    "think",
    "misread",
    "ignoring",
    "zeroth",
    "element",
    "add",
    "17",
    "okay",
    "17",
    "show",
    "let",
    "try",
    "18",
    "takes",
    "entire",
    "array",
    "works",
    "fine",
    "let",
    "try",
    "maybe",
    "four",
    "take",
    "single",
    "number",
    "works",
    "fine",
    "let",
    "try",
    "19",
    "none",
    "none",
    "okay",
    "tested",
    "extensively",
    "overall",
    "solution",
    "seems",
    "correct",
    "process",
    "whenever",
    "write",
    "code",
    "also",
    "test",
    "also",
    "gives",
    "confidence",
    "interviewer",
    "option",
    "test",
    "able",
    "run",
    "code",
    "right",
    "simply",
    "walk",
    "example",
    "like",
    "look",
    "example",
    "walk",
    "example",
    "okay",
    "brute",
    "force",
    "solution",
    "next",
    "step",
    "analyze",
    "brute",
    "force",
    "solution",
    "let",
    "analyze",
    "one",
    "loop",
    "know",
    "counting",
    "loops",
    "helps",
    "us",
    "count",
    "number",
    "operations",
    "another",
    "loop",
    "one",
    "loop",
    "go",
    "0",
    "n",
    "may",
    "run",
    "end",
    "times",
    "another",
    "loop",
    "goes",
    "n",
    "let",
    "approximate",
    "say",
    "run",
    "n",
    "minus",
    "one",
    "times",
    "n",
    "times",
    "n",
    "inside",
    "n",
    "inside",
    "second",
    "loop",
    "sum",
    "important",
    "always",
    "carefully",
    "observe",
    "operation",
    "inside",
    "loop",
    "sum",
    "array",
    "j",
    "remember",
    "zero",
    "j",
    "value",
    "n",
    "means",
    "largest",
    "array",
    "work",
    "approximately",
    "size",
    "n",
    "well",
    "right",
    "n",
    "inside",
    "n",
    "loops",
    "inside",
    "loop",
    "work",
    "n",
    "additions",
    "right",
    "n",
    "additions",
    "roughly",
    "gives",
    "going",
    "n",
    "n",
    "n",
    "going",
    "order",
    "cube",
    "solution",
    "okay",
    "able",
    "arrive",
    "order",
    "cube",
    "solution",
    "order",
    "cube",
    "complexity",
    "without",
    "implementing",
    "solution",
    "great",
    "learned",
    "able",
    "arrive",
    "um",
    "order",
    "n",
    "cube",
    "sol",
    "order",
    "n",
    "cube",
    "complexity",
    "brute",
    "force",
    "solution",
    "probably",
    "need",
    "little",
    "practice",
    "become",
    "second",
    "nature",
    "looking",
    "problem",
    "identifying",
    "simplest",
    "solution",
    "finding",
    "complexity",
    "simplest",
    "solution",
    "okay",
    "right",
    "implemented",
    "tested",
    "identified",
    "complexity",
    "remember",
    "next",
    "step",
    "find",
    "inefficiency",
    "overcome",
    "inefficiency",
    "applying",
    "right",
    "technique",
    "let",
    "find",
    "inefficiency",
    "let",
    "say",
    "position",
    "let",
    "say",
    "looking",
    "742",
    "let",
    "say",
    "value",
    "1",
    "start",
    "equal",
    "1",
    "j",
    "equal",
    "1",
    "inner",
    "loop",
    "increment",
    "j",
    "1",
    "calculate",
    "sum",
    "sum",
    "7",
    "increment",
    "j",
    "1",
    "calculate",
    "loop",
    "sum",
    "sum",
    "7",
    "4",
    "11",
    "increment",
    "window",
    "calculate",
    "sum",
    "7",
    "4",
    "2",
    "7",
    "4",
    "11",
    "2",
    "13",
    "move",
    "check",
    "many",
    "many",
    "times",
    "right",
    "time",
    "7",
    "4",
    "2",
    "1",
    "7",
    "4",
    "4",
    "2",
    "1",
    "3",
    "seems",
    "like",
    "lot",
    "additional",
    "work",
    "maybe",
    "avoid",
    "start",
    "j",
    "keep",
    "running",
    "sum",
    "time",
    "simply",
    "incrementing",
    "j",
    "add",
    "upcoming",
    "element",
    "j",
    "element",
    "running",
    "sum",
    "right",
    "way",
    "entire",
    "sum",
    "inside",
    "inner",
    "loops",
    "one",
    "optimization",
    "explain",
    "one",
    "optimization",
    "come",
    "second",
    "optimization",
    "come",
    "moment",
    "sum",
    "running",
    "sum",
    "calculating",
    "moment",
    "sum",
    "becomes",
    "greater",
    "target",
    "value",
    "skip",
    "right",
    "know",
    "7",
    "4",
    "greater",
    "10",
    "know",
    "array",
    "contains",
    "negative",
    "number",
    "means",
    "7",
    "4",
    "plus",
    "numbers",
    "always",
    "going",
    "greater",
    "10",
    "right",
    "obviously",
    "see",
    "number",
    "going",
    "decrease",
    "keep",
    "adding",
    "positive",
    "numbers",
    "soon",
    "running",
    "sum",
    "crosses",
    "value",
    "break",
    "inner",
    "loop",
    "need",
    "continue",
    "look",
    "higher",
    "values",
    "g",
    "two",
    "optimizations",
    "helps",
    "write",
    "maintain",
    "running",
    "sum",
    "forget",
    "fin",
    "second",
    "optimization",
    "exceeds",
    "target",
    "break",
    "inner",
    "loop",
    "okay",
    "applied",
    "optimization",
    "simply",
    "looking",
    "data",
    "lot",
    "cases",
    "straightforward",
    "even",
    "apply",
    "special",
    "technique",
    "case",
    "found",
    "couple",
    "optimizations",
    "let",
    "apply",
    "define",
    "def",
    "subarray",
    "sum",
    "two",
    "array",
    "target",
    "time",
    "get",
    "length",
    "array",
    "goes",
    "value",
    "goes",
    "0",
    "nus1",
    "nothing",
    "changes",
    "range",
    "0",
    "nus1",
    "want",
    "start",
    "running",
    "sum",
    "equal",
    "0",
    "run",
    "sum",
    "j",
    "range",
    "remember",
    "start",
    "go",
    "way",
    "well",
    "keep",
    "making",
    "mistakes",
    "time",
    "way",
    "called",
    "one",
    "errors",
    "wanted",
    "go",
    "address",
    "n",
    "minus",
    "one",
    "ranges",
    "include",
    "final",
    "value",
    "put",
    "put",
    "nus",
    "one",
    "wrong",
    "putting",
    "n",
    "make",
    "mistakes",
    "time",
    "even",
    "even",
    "many",
    "years",
    "coding",
    "always",
    "watch",
    "one",
    "errors",
    "anyway",
    "j",
    "j",
    "take",
    "range",
    "zero",
    "n",
    "put",
    "n",
    "1",
    "first",
    "want",
    "check",
    "running",
    "sum",
    "equal",
    "target",
    "right",
    "assume",
    "calculating",
    "running",
    "sum",
    "step",
    "step",
    "write",
    "current",
    "point",
    "sum",
    "become",
    "equal",
    "target",
    "sum",
    "become",
    "equal",
    "target",
    "simply",
    "return",
    "comma",
    "j",
    "sum",
    "includes",
    "sum",
    "index",
    "way",
    "j",
    "initially",
    "j",
    "also",
    "value",
    "sum",
    "zero",
    "makes",
    "sense",
    "case",
    "check",
    "greater",
    "target",
    "possible",
    "sum",
    "already",
    "exceeded",
    "target",
    "case",
    "need",
    "continue",
    "inner",
    "loop",
    "break",
    "inner",
    "loop",
    "way",
    "simply",
    "typing",
    "break",
    "neither",
    "held",
    "true",
    "neither",
    "true",
    "sum",
    "equal",
    "target",
    "greater",
    "means",
    "still",
    "less",
    "target",
    "means",
    "need",
    "add",
    "array",
    "j",
    "sum",
    "say",
    "sum",
    "plus",
    "equal",
    "oops",
    "sum",
    "plus",
    "equals",
    "array",
    "j",
    "sum",
    "equal",
    "sum",
    "plus",
    "array",
    "j",
    "case",
    "array",
    "sum",
    "plus",
    "equal",
    "array",
    "j",
    "added",
    "jth",
    "element",
    "remember",
    "pointer",
    "j",
    "added",
    "jth",
    "element",
    "set",
    "j",
    "j",
    "1",
    "happen",
    "automatically",
    "come",
    "next",
    "iteration",
    "next",
    "iteration",
    "check",
    "sum",
    "equal",
    "target",
    "equal",
    "return",
    "comma",
    "j",
    "otherwise",
    "check",
    "greater",
    "target",
    "break",
    "break",
    "still",
    "less",
    "increment",
    "move",
    "j",
    "add",
    "one",
    "move",
    "j",
    "check",
    "right",
    "running",
    "sum",
    "looks",
    "good",
    "found",
    "would",
    "returned",
    "somewhere",
    "since",
    "seems",
    "like",
    "probably",
    "found",
    "uh",
    "come",
    "end",
    "return",
    "none",
    "none",
    "okay",
    "let",
    "test",
    "let",
    "try",
    "subar",
    "sum",
    "2",
    "gives",
    "2",
    "six",
    "subar",
    "sum",
    "2",
    "none",
    "okay",
    "seems",
    "like",
    "issue",
    "yes",
    "need",
    "test",
    "cases",
    "seems",
    "arj",
    "took",
    "invalid",
    "value",
    "well",
    "j",
    "go",
    "point",
    "n",
    "maximum",
    "value",
    "j",
    "take",
    "n",
    "means",
    "already",
    "arrived",
    "position",
    "longer",
    "increase",
    "sum",
    "right",
    "arrived",
    "position",
    "still",
    "reached",
    "total",
    "10",
    "means",
    "may",
    "need",
    "increase",
    "ca",
    "increase",
    "number",
    "add",
    "add",
    "check",
    "j",
    "less",
    "n",
    "since",
    "j",
    "go",
    "way",
    "n",
    "small",
    "bug",
    "fixed",
    "something",
    "work",
    "pen",
    "paper",
    "even",
    "optimization",
    "ask",
    "couple",
    "minutes",
    "play",
    "around",
    "pen",
    "paper",
    "write",
    "examples",
    "relax",
    "even",
    "take",
    "four",
    "five",
    "minutes",
    "getting",
    "ideas",
    "simply",
    "talk",
    "interviewer",
    "speak",
    "loud",
    "explain",
    "thought",
    "process",
    "lot",
    "cases",
    "give",
    "hint",
    "want",
    "see",
    "succeeding",
    "okay",
    "second",
    "implementation",
    "let",
    "see",
    "okay",
    "time",
    "worked",
    "none",
    "none",
    "4",
    "213",
    "let",
    "put",
    "10",
    "give",
    "value",
    "2a",
    "6",
    "let",
    "put",
    "0a",
    "3",
    "let",
    "test",
    "0a",
    "4",
    "yeah",
    "0a",
    "4",
    "seems",
    "like",
    "working",
    "fine",
    "yeah",
    "seems",
    "like",
    "working",
    "pretty",
    "well",
    "second",
    "optimized",
    "solution",
    "let",
    "look",
    "optimized",
    "solution",
    "analyze",
    "one",
    "loop",
    "second",
    "loop",
    "two",
    "inside",
    "second",
    "loop",
    "simply",
    "constant",
    "operation",
    "comparisons",
    "one",
    "addition",
    "n",
    "additions",
    "complexity",
    "goes",
    "order",
    "n",
    "cub",
    "order",
    "n",
    "squ",
    "maintaining",
    "running",
    "sum",
    "great",
    "point",
    "described",
    "solution",
    "interviewer",
    "maybe",
    "also",
    "coded",
    "might",
    "ask",
    "good",
    "enough",
    "see",
    "thought",
    "found",
    "solution",
    "tested",
    "tests",
    "well",
    "point",
    "may",
    "say",
    "happy",
    "solution",
    "good",
    "enough",
    "may",
    "say",
    "better",
    "say",
    "better",
    "time",
    "suggests",
    "better",
    "solution",
    "let",
    "see",
    "let",
    "think",
    "little",
    "let",
    "see",
    "better",
    "solution",
    "better",
    "apply",
    "exact",
    "technique",
    "analy",
    "complexity",
    "need",
    "look",
    "inefficiency",
    "okay",
    "removed",
    "inefficiency",
    "side",
    "move",
    "j",
    "reuse",
    "previous",
    "sum",
    "compute",
    "next",
    "sum",
    "removed",
    "inefficiency",
    "side",
    "also",
    "added",
    "also",
    "added",
    "condition",
    "j",
    "goes",
    "certain",
    "point",
    "course",
    "worst",
    "case",
    "j",
    "may",
    "always",
    "go",
    "way",
    "end",
    "least",
    "lot",
    "cases",
    "j",
    "ex",
    "j",
    "go",
    "beyond",
    "point",
    "sum",
    "becomes",
    "larger",
    "target",
    "good",
    "optimizations",
    "left",
    "window",
    "look",
    "74",
    "let",
    "start",
    "way",
    "one",
    "one",
    "first",
    "start",
    "empty",
    "empty",
    "subar",
    "sum",
    "zero",
    "increment",
    "j",
    "sum",
    "becomes",
    "one",
    "increment",
    "j",
    "sum",
    "becomes",
    "8",
    "increment",
    "j",
    "sum",
    "becomes",
    "12",
    "okay",
    "sum",
    "become",
    "12",
    "problem",
    "saying",
    "take",
    "set",
    "next",
    "value",
    "bring",
    "j",
    "back",
    "z",
    "back",
    "value",
    "start",
    "empty",
    "subarray",
    "seven",
    "value",
    "seven",
    "add",
    "7",
    "4",
    "something",
    "could",
    "done",
    "instead",
    "soon",
    "value",
    "became",
    "larger",
    "target",
    "value",
    "could",
    "simply",
    "moved",
    "make",
    "sense",
    "let",
    "think",
    "till",
    "point",
    "total",
    "less",
    "10",
    "soon",
    "added",
    "number",
    "right",
    "total",
    "became",
    "10",
    "know",
    "total",
    "became",
    "10",
    "means",
    "slide",
    "window",
    "slide",
    "left",
    "window",
    "forward",
    "one",
    "step",
    "total",
    "may",
    "become",
    "less",
    "10",
    "right",
    "may",
    "still",
    "became",
    "stay",
    "larger",
    "case",
    "stays",
    "larger",
    "may",
    "become",
    "less",
    "10",
    "total",
    "becomes",
    "less",
    "10",
    "move",
    "total",
    "become",
    "less",
    "10",
    "move",
    "instead",
    "total",
    "less",
    "10",
    "move",
    "total",
    "still",
    "less",
    "10",
    "move",
    "total",
    "still",
    "less",
    "10",
    "move",
    "encountered",
    "10",
    "suppose",
    "encountered",
    "10",
    "suppose",
    "number",
    "four",
    "instead",
    "would",
    "move",
    "right",
    "number",
    "becomes",
    "less",
    "10",
    "always",
    "go",
    "always",
    "try",
    "maintain",
    "window",
    "size",
    "less",
    "10",
    "moment",
    "window",
    "becomes",
    "greater",
    "10",
    "keep",
    "trying",
    "reduce",
    "sides",
    "less",
    "10",
    "right",
    "exactly",
    "10",
    "well",
    "possible",
    "size",
    "may",
    "become",
    "exactly",
    "10",
    "problem",
    "solved",
    "keep",
    "trying",
    "reduce",
    "size",
    "value",
    "till",
    "becomes",
    "less",
    "10",
    "revise",
    "algorithm",
    "start",
    "j",
    "z",
    "z",
    "increment",
    "j",
    "running",
    "single",
    "running",
    "loop",
    "single",
    "loop",
    "essentially",
    "increment",
    "j",
    "sum",
    "less",
    "10",
    "moment",
    "becomes",
    "greater",
    "10",
    "start",
    "incrementing",
    "moment",
    "sum",
    "becomes",
    "less",
    "10",
    "less",
    "target",
    "start",
    "incrementing",
    "j",
    "encounter",
    "point",
    "sum",
    "equals",
    "10",
    "found",
    "answer",
    "algorithm",
    "let",
    "write",
    "wr",
    "sub",
    "array",
    "sum",
    "three",
    "array",
    "target",
    "j",
    "sum",
    "let",
    "call",
    "sum",
    "reserved",
    "word",
    "python",
    "existing",
    "function",
    "value",
    "zero",
    "say",
    "less",
    "len",
    "array",
    "let",
    "call",
    "n",
    "let",
    "create",
    "n",
    "equal",
    "len",
    "ar",
    "rr",
    "less",
    "n",
    "j",
    "less",
    "n",
    "1",
    "remember",
    "j",
    "take",
    "value",
    "n",
    "well",
    "exclusive",
    "end",
    "index",
    "point",
    "want",
    "check",
    "first",
    "sum",
    "current",
    "sum",
    "running",
    "sum",
    "equal",
    "target",
    "simply",
    "return",
    "comma",
    "j",
    "l",
    "sum",
    "less",
    "target",
    "simply",
    "increment",
    "j",
    "okay",
    "move",
    "window",
    "forward",
    "incrementing",
    "j",
    "sum",
    "less",
    "target",
    "increment",
    "j",
    "increment",
    "j",
    "add",
    "j",
    "element",
    "maintain",
    "running",
    "sum",
    "say",
    "plus",
    "equals",
    "j",
    "array",
    "j",
    "remember",
    "j",
    "take",
    "value",
    "n",
    "well",
    "j",
    "less",
    "n",
    "indeed",
    "element",
    "us",
    "add",
    "error",
    "faced",
    "last",
    "time",
    "discover",
    "write",
    "test",
    "anyway",
    "say",
    "l",
    "greater",
    "target",
    "also",
    "say",
    "else",
    "clarity",
    "let",
    "say",
    "l",
    "case",
    "want",
    "want",
    "move",
    "forward",
    "suppose",
    "end",
    "situation",
    "like",
    "want",
    "move",
    "forward",
    "need",
    "subtract",
    "array",
    "first",
    "say",
    "minus",
    "equals",
    "equal",
    "minus",
    "minus",
    "array",
    "increment",
    "move",
    "left",
    "window",
    "forward",
    "well",
    "repeat",
    "first",
    "move",
    "j",
    "point",
    "soon",
    "cross",
    "target",
    "start",
    "increasing",
    "keep",
    "till",
    "match",
    "target",
    "finally",
    "return",
    "none",
    "comma",
    "none",
    "found",
    "subarray",
    "sum",
    "three",
    "seems",
    "like",
    "optimized",
    "solution",
    "let",
    "test",
    "subar",
    "sum",
    "3",
    "let",
    "test",
    "subar",
    "three",
    "well",
    "seems",
    "like",
    "worked",
    "let",
    "see",
    "put",
    "10",
    "get",
    "2a",
    "6",
    "let",
    "say",
    "4",
    "213",
    "0a",
    "4",
    "let",
    "put",
    "12",
    "show",
    "let",
    "put",
    "17",
    "0a",
    "5",
    "13",
    "1a",
    "5",
    "let",
    "try",
    "19",
    "3a",
    "6",
    "let",
    "see",
    "1",
    "3",
    "7",
    "9",
    "yeah",
    "value",
    "19",
    "let",
    "throw",
    "zero",
    "see",
    "works",
    "zeros",
    "3a",
    "7",
    "works",
    "fine",
    "let",
    "see",
    "work",
    "yeah",
    "okay",
    "great",
    "solution",
    "correct",
    "option",
    "run",
    "code",
    "simply",
    "pick",
    "one",
    "example",
    "walk",
    "working",
    "example",
    "subarray",
    "sum",
    "three",
    "ready",
    "analyze",
    "complexity",
    "case",
    "complexity",
    "would",
    "somewhat",
    "tricky",
    "little",
    "bit",
    "unusual",
    "loop",
    "two",
    "variables",
    "remember",
    "loop",
    "either",
    "exit",
    "best",
    "case",
    "ignore",
    "either",
    "increment",
    "j",
    "increment",
    "right",
    "increment",
    "j",
    "increment",
    "increment",
    "uh",
    "j",
    "go",
    "value0",
    "n",
    "go",
    "values",
    "0",
    "n",
    "minus",
    "one",
    "total",
    "number",
    "increments",
    "sum",
    "number",
    "possible",
    "values",
    "number",
    "possible",
    "values",
    "j",
    "right",
    "remember",
    "product",
    "time",
    "nested",
    "loop",
    "value",
    "rather",
    "incrementing",
    "one",
    "one",
    "time",
    "total",
    "number",
    "values",
    "take",
    "n",
    "total",
    "number",
    "values",
    "j",
    "take",
    "n",
    "1",
    "total",
    "becomes",
    "number",
    "iterations",
    "becomes",
    "2",
    "n",
    "1",
    "course",
    "verify",
    "constant",
    "amount",
    "work",
    "done",
    "finally",
    "end",
    "conclusion",
    "order",
    "n",
    "algorithm",
    "okay",
    "finally",
    "order",
    "n",
    "algorithm",
    "good",
    "example",
    "problem",
    "step",
    "solution",
    "coming",
    "simple",
    "solution",
    "thinking",
    "inefficiency",
    "problem",
    "applying",
    "case",
    "common",
    "sense",
    "solve",
    "inefficiency",
    "step",
    "step",
    "leads",
    "perfect",
    "solution",
    "good",
    "solution",
    "fact",
    "start",
    "order",
    "n",
    "cube",
    "solution",
    "order",
    "cube",
    "going",
    "pretty",
    "slow",
    "start",
    "hitting",
    "let",
    "say",
    "even",
    "thousand",
    "even",
    "elements",
    "elements",
    "take",
    "forever",
    "take",
    "maybe",
    "hour",
    "million",
    "elements",
    "take",
    "hundreds",
    "years",
    "hand",
    "order",
    "n",
    "work",
    "fine",
    "way",
    "billion",
    "element",
    "right",
    "huge",
    "difference",
    "subar",
    "sum",
    "1",
    "2",
    "three",
    "subar",
    "sum",
    "3",
    "work",
    "instantly",
    "billion",
    "elements",
    "sub",
    "one",
    "take",
    "forever",
    "even",
    "elements",
    "sub",
    "add",
    "math",
    "technique",
    "almost",
    "certainly",
    "tell",
    "next",
    "next",
    "step",
    "really",
    "related",
    "algorithms",
    "data",
    "structures",
    "talked",
    "called",
    "greedy",
    "approach",
    "know",
    "optimal",
    "strategy",
    "problem",
    "case",
    "know",
    "calculate",
    "sums",
    "maintaining",
    "running",
    "sum",
    "also",
    "know",
    "soon",
    "becomes",
    "greater",
    "target",
    "need",
    "break",
    "know",
    "next",
    "thing",
    "becomes",
    "greater",
    "target",
    "rather",
    "simply",
    "update",
    "called",
    "greedy",
    "approach",
    "somehow",
    "know",
    "fix",
    "right",
    "real",
    "technique",
    "applied",
    "problems",
    "somewhat",
    "tricky",
    "get",
    "hang",
    "problems",
    "well",
    "search",
    "greedy",
    "problems",
    "online",
    "get",
    "hang",
    "solving",
    "practice",
    "exercises",
    "okay",
    "first",
    "interview",
    "problem",
    "solved",
    "45",
    "minutes",
    "approximately",
    "long",
    "interview",
    "typical",
    "45",
    "minute",
    "1",
    "hour",
    "interview",
    "couple",
    "minutes",
    "introduction",
    "maybe",
    "minutes",
    "talking",
    "project",
    "interviewer",
    "asking",
    "questions",
    "next",
    "30",
    "40",
    "minutes",
    "dedicated",
    "towards",
    "solving",
    "problem",
    "roughly",
    "process",
    "look",
    "like",
    "let",
    "one",
    "example",
    "let",
    "pick",
    "another",
    "interview",
    "question",
    "let",
    "see",
    "solve",
    "one",
    "slightly",
    "different",
    "gives",
    "us",
    "one",
    "variation",
    "study",
    "way",
    "run",
    "simply",
    "click",
    "run",
    "button",
    "select",
    "run",
    "binder",
    "okay",
    "interview",
    "question",
    "asked",
    "coding",
    "interview",
    "google",
    "question",
    "given",
    "two",
    "strings",
    "b",
    "find",
    "minimum",
    "number",
    "steps",
    "required",
    "convert",
    "b",
    "perform",
    "operations",
    "operation",
    "counted",
    "one",
    "step",
    "operations",
    "perform",
    "word",
    "either",
    "insert",
    "character",
    "word",
    "delete",
    "character",
    "word",
    "instance",
    "see",
    "trying",
    "convert",
    "intention",
    "execution",
    "either",
    "insert",
    "character",
    "example",
    "could",
    "insert",
    "c",
    "delete",
    "character",
    "example",
    "delete",
    "replace",
    "character",
    "take",
    "n",
    "replace",
    "e",
    "take",
    "replace",
    "x",
    "e",
    "need",
    "replaced",
    "inserted",
    "c",
    "substituted",
    "n",
    "right",
    "taken",
    "word",
    "intention",
    "performing",
    "changes",
    "character",
    "character",
    "either",
    "inserting",
    "deleting",
    "replacing",
    "character",
    "converted",
    "string",
    "execution",
    "number",
    "steps",
    "required",
    "1",
    "2",
    "3",
    "4",
    "5",
    "challenge",
    "try",
    "work",
    "paper",
    "prove",
    "best",
    "solution",
    "need",
    "find",
    "minimum",
    "number",
    "steps",
    "required",
    "convert",
    "b",
    "okay",
    "problem",
    "moderately",
    "hard",
    "problem",
    "variations",
    "show",
    "well",
    "let",
    "start",
    "applying",
    "method",
    "hear",
    "problem",
    "solution",
    "may",
    "strike",
    "front",
    "perfectly",
    "right",
    "panic",
    "sometimes",
    "able",
    "immediately",
    "come",
    "solution",
    "identify",
    "solve",
    "problem",
    "enter",
    "sort",
    "panic",
    "unable",
    "think",
    "remember",
    "faith",
    "method",
    "apply",
    "method",
    "come",
    "solution",
    "step",
    "step",
    "first",
    "thing",
    "state",
    "problem",
    "words",
    "given",
    "two",
    "strings",
    "need",
    "perform",
    "operations",
    "series",
    "operations",
    "first",
    "string",
    "operations",
    "could",
    "deletion",
    "character",
    "substitution",
    "character",
    "another",
    "character",
    "insertion",
    "character",
    "operations",
    "need",
    "convert",
    "second",
    "string",
    "okay",
    "understood",
    "problem",
    "interviewer",
    "given",
    "example",
    "either",
    "state",
    "example",
    "ask",
    "example",
    "whatever",
    "makes",
    "works",
    "stated",
    "problem",
    "inputs",
    "problem",
    "inputs",
    "two",
    "strings",
    "inputs",
    "strings",
    "like",
    "intention",
    "execution",
    "let",
    "see",
    "maybe",
    "let",
    "call",
    "str",
    "str1",
    "intention",
    "str2",
    "execution",
    "one",
    "thing",
    "careful",
    "want",
    "capitalize",
    "sometimes",
    "might",
    "happen",
    "may",
    "match",
    "proper",
    "solution",
    "python",
    "obviously",
    "treats",
    "small",
    "capital",
    "letters",
    "differently",
    "python",
    "know",
    "lower",
    "case",
    "uppercase",
    "able",
    "compare",
    "keep",
    "things",
    "simple",
    "either",
    "make",
    "everything",
    "uppercase",
    "make",
    "everything",
    "lowercase",
    "yeah",
    "input",
    "looks",
    "like",
    "output",
    "going",
    "single",
    "number",
    "output",
    "simp",
    "simply",
    "going",
    "edit",
    "distance",
    "let",
    "call",
    "output",
    "one",
    "going",
    "number",
    "five",
    "something",
    "verify",
    "input",
    "output",
    "function",
    "signature",
    "course",
    "term",
    "edit",
    "distance",
    "problem",
    "described",
    "edit",
    "concept",
    "edit",
    "distance",
    "mentioned",
    "give",
    "function",
    "name",
    "makes",
    "sense",
    "problem",
    "find",
    "minimum",
    "number",
    "steps",
    "required",
    "convert",
    "b",
    "okay",
    "let",
    "call",
    "min",
    "steps",
    "function",
    "definition",
    "would",
    "min",
    "steps",
    "would",
    "take",
    "str1",
    "would",
    "take",
    "str2",
    "would",
    "return",
    "output",
    "put",
    "pass",
    "right",
    "already",
    "clarified",
    "problem",
    "questions",
    "would",
    "good",
    "time",
    "ask",
    "interviewer",
    "make",
    "sure",
    "clear",
    "understanding",
    "stated",
    "input",
    "output",
    "function",
    "signature",
    "problem",
    "communicated",
    "back",
    "forth",
    "properly",
    "first",
    "step",
    "done",
    "next",
    "step",
    "list",
    "test",
    "cases",
    "right",
    "good",
    "quality",
    "listing",
    "test",
    "cases",
    "say",
    "going",
    "list",
    "cases",
    "want",
    "function",
    "cover",
    "help",
    "help",
    "writing",
    "code",
    "one",
    "general",
    "case",
    "uh",
    "listed",
    "would",
    "intention",
    "execution",
    "take",
    "examples",
    "like",
    "one",
    "example",
    "could",
    "change",
    "required",
    "given",
    "strings",
    "one",
    "case",
    "could",
    "characters",
    "need",
    "changed",
    "two",
    "extreme",
    "cases",
    "one",
    "changes",
    "required",
    "second",
    "characters",
    "need",
    "changed",
    "maybe",
    "added",
    "removed",
    "deleted",
    "lots",
    "things",
    "check",
    "strings",
    "equal",
    "length",
    "case",
    "fact",
    "equal",
    "length",
    "unequal",
    "length",
    "check",
    "strings",
    "unequal",
    "length",
    "one",
    "strings",
    "empty",
    "function",
    "able",
    "handle",
    "may",
    "check",
    "things",
    "like",
    "something",
    "requires",
    "deletion",
    "something",
    "requires",
    "addition",
    "something",
    "requires",
    "swapping",
    "right",
    "things",
    "guess",
    "pretty",
    "good",
    "point",
    "probably",
    "move",
    "forward",
    "stated",
    "test",
    "cases",
    "need",
    "create",
    "test",
    "cases",
    "right",
    "interview",
    "take",
    "take",
    "bit",
    "time",
    "let",
    "move",
    "ahead",
    "next",
    "step",
    "come",
    "simplest",
    "solution",
    "problem",
    "also",
    "called",
    "brute",
    "force",
    "solution",
    "lot",
    "information",
    "problem",
    "meantime",
    "probably",
    "sunk",
    "may",
    "able",
    "think",
    "brute",
    "force",
    "solution",
    "worry",
    "simple",
    "trick",
    "tell",
    "apply",
    "whenever",
    "stuck",
    "ca",
    "think",
    "brute",
    "force",
    "solution",
    "looking",
    "looking",
    "intention",
    "execution",
    "going",
    "going",
    "start",
    "left",
    "right",
    "check",
    "one",
    "know",
    "going",
    "supposed",
    "inserted",
    "executed",
    "replaced",
    "substituted",
    "deleted",
    "simple",
    "trick",
    "whenever",
    "doubt",
    "think",
    "recursion",
    "see",
    "way",
    "solve",
    "problem",
    "recursively",
    "mean",
    "solving",
    "problem",
    "recursively",
    "reduce",
    "overall",
    "problem",
    "combination",
    "one",
    "sub",
    "problem",
    "take",
    "portion",
    "input",
    "solve",
    "problem",
    "portion",
    "input",
    "use",
    "solve",
    "overall",
    "problem",
    "okay",
    "let",
    "see",
    "let",
    "see",
    "recursive",
    "solution",
    "possible",
    "thing",
    "intention",
    "execution",
    "recursive",
    "solutions",
    "normally",
    "either",
    "start",
    "looking",
    "first",
    "character",
    "last",
    "character",
    "let",
    "look",
    "first",
    "character",
    "character",
    "string",
    "right",
    "given",
    "two",
    "strings",
    "need",
    "find",
    "number",
    "operations",
    "change",
    "string",
    "string",
    "let",
    "look",
    "first",
    "character",
    "suppose",
    "first",
    "characters",
    "fact",
    "equal",
    "suppose",
    "intention",
    "intention",
    "execution",
    "compare",
    "first",
    "characters",
    "know",
    "first",
    "characters",
    "equal",
    "okay",
    "first",
    "characters",
    "equal",
    "obviously",
    "neither",
    "needs",
    "deleted",
    "removed",
    "obviously",
    "character",
    "need",
    "deleted",
    "removed",
    "switched",
    "already",
    "matching",
    "ignore",
    "first",
    "characters",
    "simply",
    "look",
    "remaining",
    "string",
    "okay",
    "intention",
    "execution",
    "first",
    "characters",
    "already",
    "equal",
    "let",
    "write",
    "forget",
    "recursive",
    "solution",
    "take",
    "moment",
    "work",
    "pen",
    "paper",
    "perfectly",
    "right",
    "helps",
    "us",
    "talk",
    "keep",
    "talking",
    "recursion",
    "first",
    "thing",
    "know",
    "first",
    "character",
    "equal",
    "ignore",
    "ignore",
    "charact",
    "first",
    "character",
    "strings",
    "simply",
    "recursively",
    "solve",
    "problem",
    "sub",
    "list",
    "sub",
    "string",
    "without",
    "first",
    "characters",
    "strings",
    "right",
    "exclude",
    "e",
    "exclude",
    "e",
    "solve",
    "problem",
    "two",
    "perfect",
    "suppose",
    "first",
    "character",
    "equal",
    "another",
    "case",
    "right",
    "case",
    "intention",
    "execution",
    "sub",
    "first",
    "character",
    "equal",
    "either",
    "first",
    "character",
    "deleted",
    "first",
    "character",
    "swapped",
    "may",
    "may",
    "swap",
    "e",
    "first",
    "charact",
    "maybe",
    "something",
    "needs",
    "added",
    "first",
    "character",
    "okay",
    "let",
    "see",
    "one",
    "one",
    "first",
    "character",
    "equal",
    "either",
    "deleted",
    "swapped",
    "character",
    "inserted",
    "three",
    "possibilities",
    "right",
    "course",
    "possible",
    "may",
    "things",
    "insert",
    "characters",
    "position",
    "applying",
    "operation",
    "either",
    "first",
    "character",
    "get",
    "deleted",
    "first",
    "character",
    "get",
    "swapped",
    "changed",
    "e",
    "first",
    "character",
    "change",
    "something",
    "else",
    "first",
    "original",
    "first",
    "character",
    "become",
    "second",
    "character",
    "okay",
    "let",
    "look",
    "case",
    "first",
    "case",
    "deleted",
    "power",
    "beauty",
    "recursion",
    "need",
    "guess",
    "solution",
    "try",
    "three",
    "recursively",
    "simply",
    "pick",
    "best",
    "one",
    "suppose",
    "choose",
    "delete",
    "first",
    "character",
    "suppose",
    "say",
    "deleting",
    "first",
    "character",
    "means",
    "performed",
    "one",
    "operation",
    "deleted",
    "first",
    "character",
    "left",
    "end",
    "second",
    "string",
    "remained",
    "first",
    "string",
    "changed",
    "lost",
    "first",
    "character",
    "end",
    "sub",
    "problem",
    "need",
    "find",
    "minimum",
    "number",
    "steps",
    "change",
    "n",
    "tension",
    "n",
    "n",
    "n",
    "execution",
    "okay",
    "case",
    "deleted",
    "recursively",
    "find",
    "recursively",
    "solve",
    "ignoring",
    "first",
    "character",
    "str",
    "str1",
    "okay",
    "one",
    "possibility",
    "get",
    "recursive",
    "solution",
    "simply",
    "add",
    "one",
    "tells",
    "solution",
    "delete",
    "first",
    "character",
    "next",
    "option",
    "change",
    "first",
    "character",
    "e",
    "change",
    "first",
    "character",
    "e",
    "one",
    "operation",
    "performed",
    "two",
    "become",
    "equal",
    "two",
    "become",
    "equal",
    "move",
    "forward",
    "move",
    "forward",
    "simply",
    "recursively",
    "solve",
    "problem",
    "end",
    "tension",
    "execution",
    "find",
    "minimum",
    "edit",
    "distance",
    "two",
    "simply",
    "add",
    "one",
    "get",
    "number",
    "steps",
    "required",
    "change",
    "intention",
    "execution",
    "swapping",
    "first",
    "character",
    "right",
    "e",
    "case",
    "recursively",
    "solve",
    "ignoring",
    "first",
    "character",
    "right",
    "1",
    "plus",
    "cases",
    "one",
    "plus",
    "recursive",
    "solution",
    "ignoring",
    "first",
    "character",
    "one",
    "operation",
    "something",
    "performed",
    "okay",
    "final",
    "case",
    "final",
    "case",
    "intention",
    "exec",
    "ution",
    "decide",
    "going",
    "shift",
    "string",
    "forward",
    "going",
    "include",
    "going",
    "introduce",
    "e",
    "going",
    "introduce",
    "e",
    "happens",
    "e",
    "matching",
    "e",
    "gone",
    "first",
    "position",
    "gone",
    "next",
    "position",
    "effectively",
    "happened",
    "need",
    "recursively",
    "solve",
    "problem",
    "original",
    "string",
    "intention",
    "second",
    "string",
    "first",
    "character",
    "remove",
    "mod",
    "inserted",
    "something",
    "first",
    "character",
    "first",
    "string",
    "going",
    "match",
    "first",
    "character",
    "second",
    "string",
    "hence",
    "simply",
    "need",
    "recursively",
    "solve",
    "problem",
    "two",
    "case",
    "solution",
    "1",
    "plus",
    "recursively",
    "solve",
    "ignoring",
    "first",
    "character",
    "st",
    "str2",
    "okay",
    "sounds",
    "good",
    "looks",
    "like",
    "done",
    "end",
    "solution",
    "going",
    "look",
    "like",
    "end",
    "case",
    "remember",
    "recursion",
    "well",
    "good",
    "point",
    "going",
    "hit",
    "kind",
    "end",
    "let",
    "see",
    "let",
    "see",
    "define",
    "end",
    "scenario",
    "maybe",
    "let",
    "say",
    "performing",
    "recursion",
    "ended",
    "situation",
    "like",
    "nothing",
    "left",
    "second",
    "string",
    "still",
    "characters",
    "left",
    "first",
    "string",
    "right",
    "position",
    "gone",
    "nothing",
    "left",
    "uh",
    "second",
    "string",
    "case",
    "change",
    "recursive",
    "change",
    "ti",
    "empty",
    "string",
    "need",
    "delete",
    "four",
    "character",
    "second",
    "string",
    "becomes",
    "empty",
    "simply",
    "find",
    "number",
    "remaining",
    "characters",
    "first",
    "string",
    "delete",
    "number",
    "operations",
    "four",
    "possibility",
    "second",
    "string",
    "still",
    "characters",
    "run",
    "characters",
    "first",
    "string",
    "run",
    "characters",
    "first",
    "string",
    "second",
    "string",
    "still",
    "characters",
    "case",
    "need",
    "obviously",
    "empty",
    "string",
    "need",
    "take",
    "convert",
    "empty",
    "string",
    "n",
    "recursive",
    "problem",
    "solving",
    "adding",
    "n",
    "great",
    "add",
    "n",
    "going",
    "four",
    "steps",
    "number",
    "characters",
    "remaining",
    "second",
    "string",
    "okay",
    "two",
    "end",
    "cases",
    "course",
    "empty",
    "answer",
    "zero",
    "either",
    "empty",
    "answer",
    "number",
    "remaining",
    "elements",
    "one",
    "let",
    "write",
    "solution",
    "figured",
    "solution",
    "took",
    "time",
    "straightforward",
    "problem",
    "cases",
    "figure",
    "identifying",
    "case",
    "either",
    "say",
    "loud",
    "instructor",
    "write",
    "comment",
    "whatever",
    "feel",
    "convenient",
    "interviewer",
    "see",
    "work",
    "paper",
    "important",
    "able",
    "convey",
    "course",
    "saying",
    "need",
    "express",
    "solution",
    "simple",
    "words",
    "need",
    "tell",
    "person",
    "know",
    "solution",
    "able",
    "understand",
    "saying",
    "without",
    "looking",
    "work",
    "without",
    "looking",
    "images",
    "youve",
    "drawn",
    "great",
    "way",
    "either",
    "wrting",
    "writing",
    "speaking",
    "let",
    "define",
    "def",
    "called",
    "steps",
    "steps",
    "takes",
    "str",
    "str1",
    "str",
    "str2",
    "great",
    "recursion",
    "recursion",
    "tracking",
    "character",
    "currently",
    "could",
    "zeroth",
    "character",
    "first",
    "character",
    "second",
    "character",
    "string",
    "one",
    "could",
    "zeroo",
    "character",
    "second",
    "charact",
    "first",
    "character",
    "second",
    "character",
    "string",
    "two",
    "right",
    "starting",
    "point",
    "window",
    "determines",
    "sub",
    "string",
    "solving",
    "problem",
    "ideally",
    "want",
    "solve",
    "problem",
    "two",
    "substrings",
    "simply",
    "pass",
    "substrings",
    "creating",
    "sub",
    "subl",
    "list",
    "substrings",
    "cost",
    "copy",
    "uh",
    "characters",
    "allocate",
    "memory",
    "put",
    "new",
    "place",
    "easier",
    "way",
    "simply",
    "keep",
    "pointer",
    "keep",
    "two",
    "pointers",
    "i1",
    "i2",
    "signify",
    "skipping",
    "computing",
    "steps",
    "skipping",
    "first",
    "i1",
    "characters",
    "starting",
    "i1",
    "index",
    "starting",
    "i2th",
    "index",
    "str2",
    "okay",
    "window",
    "i1",
    "windex",
    "starting",
    "starting",
    "index",
    "equal",
    "length",
    "string",
    "one",
    "end",
    "case",
    "remember",
    "end",
    "case",
    "coding",
    "always",
    "written",
    "first",
    "equal",
    "length",
    "str1",
    "known",
    "seen",
    "need",
    "perform",
    "many",
    "additions",
    "simply",
    "return",
    "case",
    "str",
    "str",
    "len",
    "str",
    "str2",
    "minus",
    "i2",
    "right",
    "verify",
    "amount",
    "number",
    "additions",
    "required",
    "l",
    "hand",
    "i2",
    "equal",
    "len",
    "strr",
    "2",
    "means",
    "exhausted",
    "second",
    "string",
    "first",
    "string",
    "still",
    "values",
    "left",
    "case",
    "need",
    "remove",
    "delete",
    "return",
    "remaining",
    "values",
    "first",
    "string",
    "type",
    "len",
    "str1",
    "minus",
    "i1",
    "great",
    "solved",
    "trivial",
    "cases",
    "let",
    "see",
    "l",
    "str",
    "str1",
    "i1",
    "str",
    "str2",
    "i2",
    "means",
    "first",
    "characters",
    "substring",
    "working",
    "right",
    "remember",
    "using",
    "arrays",
    "using",
    "indices",
    "optimization",
    "really",
    "want",
    "work",
    "substring",
    "first",
    "character",
    "substring",
    "str1",
    "i1",
    "str2",
    "i2",
    "equal",
    "first",
    "character",
    "equal",
    "e",
    "equal",
    "simply",
    "ignore",
    "solve",
    "problem",
    "remaining",
    "string",
    "simply",
    "say",
    "return",
    "main",
    "steps",
    "pass",
    "pass",
    "str1",
    "pass",
    "str2",
    "simply",
    "pass",
    "i1",
    "1",
    "pass",
    "i2",
    "1",
    "saying",
    "want",
    "recursively",
    "solve",
    "problem",
    "substring",
    "starting",
    "i1",
    "1",
    "ignored",
    "first",
    "string",
    "current",
    "substring",
    "similarly",
    "ignored",
    "first",
    "character",
    "current",
    "substring",
    "second",
    "string",
    "okay",
    "ignore",
    "first",
    "characters",
    "steps",
    "required",
    "operations",
    "required",
    "right",
    "first",
    "characters",
    "equal",
    "finally",
    "final",
    "case",
    "else",
    "want",
    "return",
    "one",
    "perform",
    "one",
    "operation",
    "either",
    "insertion",
    "deletion",
    "swap",
    "recursively",
    "check",
    "cost",
    "number",
    "minimum",
    "steps",
    "required",
    "case",
    "insertion",
    "deletion",
    "swapping",
    "simply",
    "pick",
    "minimum",
    "one",
    "add",
    "one",
    "get",
    "total",
    "minimum",
    "number",
    "steps",
    "need",
    "perform",
    "entire",
    "list",
    "right",
    "recursion",
    "useful",
    "simply",
    "assume",
    "function",
    "solves",
    "problem",
    "simply",
    "need",
    "take",
    "result",
    "sub",
    "problem",
    "combine",
    "take",
    "minimum",
    "first",
    "option",
    "first",
    "character",
    "str1",
    "deleted",
    "let",
    "say",
    "choose",
    "delete",
    "choose",
    "delete",
    "means",
    "solve",
    "problem",
    "two",
    "say",
    "1",
    "plus",
    "rec",
    "cursively",
    "solve",
    "problem",
    "ignoring",
    "first",
    "character",
    "str",
    "str1",
    "solve",
    "main",
    "steps",
    "str",
    "str1",
    "str2",
    "since",
    "deleted",
    "first",
    "character",
    "str1",
    "skip",
    "ahead",
    "next",
    "solving",
    "problem",
    "starting",
    "next",
    "index",
    "i2",
    "remains",
    "right",
    "remember",
    "affected",
    "i2",
    "need",
    "solve",
    "problem",
    "recursively",
    "case",
    "deletion",
    "next",
    "option",
    "swapped",
    "first",
    "character",
    "taken",
    "e",
    "converted",
    "taken",
    "converted",
    "e",
    "say",
    "okay",
    "two",
    "characters",
    "matching",
    "simply",
    "recursively",
    "solve",
    "problem",
    "next",
    "character",
    "onwards",
    "ignoring",
    "current",
    "character",
    "becomes",
    "str1",
    "plus",
    "str2",
    "i1",
    "1",
    "i2",
    "1",
    "great",
    "swap",
    "replace",
    "might",
    "notice",
    "turns",
    "recursive",
    "call",
    "except",
    "add",
    "one",
    "done",
    "swap",
    "finally",
    "adding",
    "add",
    "inserting",
    "finally",
    "inserting",
    "something",
    "inserting",
    "e",
    "let",
    "say",
    "case",
    "recursively",
    "solve",
    "problem",
    "intention",
    "execution",
    "without",
    "e",
    "front",
    "skip",
    "first",
    "character",
    "second",
    "string",
    "main",
    "steps",
    "str",
    "str1",
    "str",
    "str2",
    "i1",
    "i2",
    "1",
    "rather",
    "nice",
    "symmetric",
    "let",
    "run",
    "okay",
    "syntax",
    "error",
    "perfectly",
    "fine",
    "needs",
    "comma",
    "fine",
    "make",
    "lot",
    "syntax",
    "errors",
    "time",
    "course",
    "one",
    "errors",
    "sure",
    "yeah",
    "minimum",
    "number",
    "steps",
    "recursive",
    "function",
    "bad",
    "2",
    "4",
    "6",
    "around",
    "eight",
    "lines",
    "code",
    "let",
    "test",
    "test",
    "cases",
    "going",
    "copy",
    "test",
    "cases",
    "let",
    "test",
    "general",
    "case",
    "intention",
    "exception",
    "let",
    "see",
    "steps",
    "intention",
    "exception",
    "says",
    "five",
    "four",
    "okay",
    "say",
    "four",
    "maybe",
    "let",
    "test",
    "uh",
    "let",
    "test",
    "simpler",
    "case",
    "first",
    "one",
    "strings",
    "empty",
    "let",
    "say",
    "intention",
    "one",
    "strings",
    "empty",
    "need",
    "delete",
    "let",
    "say",
    "int",
    "one",
    "strings",
    "empty",
    "looks",
    "fine",
    "need",
    "delete",
    "three",
    "way",
    "tests",
    "case",
    "sorry",
    "tests",
    "second",
    "case",
    "second",
    "string",
    "empty",
    "test",
    "case",
    "case",
    "also",
    "case",
    "also",
    "solution",
    "three",
    "great",
    "looks",
    "fine",
    "let",
    "test",
    "case",
    "str1",
    "i1",
    "str2",
    "i2",
    "equal",
    "integer",
    "let",
    "say",
    "india",
    "n",
    "would",
    "would",
    "get",
    "skipped",
    "recursion",
    "would",
    "kick",
    "would",
    "changed",
    "would",
    "add",
    "okay",
    "looks",
    "fine",
    "let",
    "check",
    "intention",
    "exception",
    "know",
    "wrong",
    "let",
    "see",
    "pos",
    "possible",
    "four",
    "know",
    "may",
    "possible",
    "four",
    "changes",
    "change",
    "delete",
    "delete",
    "n",
    "delete",
    "delete",
    "substitute",
    "two",
    "think",
    "possible",
    "four",
    "changes",
    "probably",
    "music",
    "issue",
    "know",
    "wrong",
    "possible",
    "may",
    "made",
    "mistake",
    "let",
    "try",
    "another",
    "saturday",
    "sunday",
    "okay",
    "saturday",
    "sat",
    "needs",
    "changed",
    "sunday",
    "n",
    "ur",
    "needs",
    "changed",
    "u",
    "n",
    "u",
    "remains",
    "probably",
    "delete",
    "delete",
    "take",
    "replace",
    "r",
    "n",
    "seems",
    "fine",
    "right",
    "probably",
    "unless",
    "seeing",
    "intention",
    "exception",
    "unless",
    "seeing",
    "something",
    "seems",
    "like",
    "may",
    "made",
    "mistake",
    "one",
    "one",
    "thing",
    "could",
    "simply",
    "print",
    "strings",
    "checking",
    "let",
    "see",
    "str1",
    "i1",
    "onwards",
    "str",
    "2",
    "i2",
    "onwards",
    "first",
    "checking",
    "intention",
    "exception",
    "check",
    "let",
    "also",
    "print",
    "result",
    "okay",
    "point",
    "would",
    "probably",
    "look",
    "loop",
    "see",
    "see",
    "correct",
    "coming",
    "properly",
    "intention",
    "exception",
    "first",
    "delete",
    "delete",
    "n",
    "delete",
    "n",
    "delete",
    "delete",
    "okay",
    "compare",
    "e",
    "e",
    "come",
    "back",
    "n",
    "exception",
    "think",
    "might",
    "take",
    "time",
    "fix",
    "come",
    "back",
    "intention",
    "exception",
    "supposing",
    "solved",
    "yeah",
    "supposing",
    "written",
    "recursive",
    "solution",
    "correctly",
    "recursive",
    "solution",
    "let",
    "grab",
    "put",
    "let",
    "see",
    "different",
    "okay",
    "probably",
    "answer",
    "four",
    "still",
    "getting",
    "four",
    "supposing",
    "recursive",
    "solution",
    "min",
    "edit",
    "distance",
    "recursive",
    "solution",
    "need",
    "need",
    "find",
    "complexity",
    "recursive",
    "solution",
    "find",
    "complexity",
    "recursive",
    "solution",
    "simply",
    "look",
    "recursive",
    "calls",
    "worst",
    "case",
    "start",
    "start",
    "string",
    "length",
    "n1",
    "let",
    "say",
    "string",
    "length",
    "n2",
    "one",
    "string",
    "length",
    "n1",
    "one",
    "string",
    "length",
    "n2",
    "call",
    "either",
    "call",
    "eded",
    "distance",
    "i1",
    "1",
    "i2",
    "1",
    "str",
    "str1",
    "str",
    "str2",
    "call",
    "i1",
    "1",
    "i2",
    "1",
    "one",
    "possibility",
    "call",
    "three",
    "recursive",
    "calls",
    "one",
    "recursive",
    "call",
    "good",
    "case",
    "two",
    "match",
    "want",
    "look",
    "worst",
    "case",
    "two",
    "things",
    "match",
    "case",
    "make",
    "three",
    "recursive",
    "calls",
    "right",
    "make",
    "three",
    "recursive",
    "calls",
    "recursive",
    "call",
    "going",
    "reduce",
    "problem",
    "size",
    "one",
    "either",
    "going",
    "decrease",
    "i2",
    "either",
    "going",
    "decrease",
    "size",
    "first",
    "string",
    "going",
    "decrease",
    "size",
    "second",
    "string",
    "going",
    "decrease",
    "sizes",
    "strings",
    "right",
    "keep",
    "things",
    "simple",
    "let",
    "assume",
    "three",
    "decreasing",
    "size",
    "either",
    "one",
    "strings",
    "one",
    "decreasing",
    "total",
    "problem",
    "size",
    "n1",
    "n2",
    "one",
    "right",
    "number",
    "levels",
    "recursion",
    "going",
    "total",
    "number",
    "total",
    "length",
    "two",
    "strings",
    "let",
    "maybe",
    "draw",
    "graph",
    "well",
    "let",
    "take",
    "n1",
    "comma",
    "n2",
    "let",
    "assume",
    "lengths",
    "two",
    "strings",
    "n1",
    "n2",
    "happens",
    "n1",
    "plus",
    "n2",
    "calls",
    "three",
    "recursive",
    "functions",
    "three",
    "recursive",
    "functions",
    "let",
    "draw",
    "three",
    "recursive",
    "functions",
    "three",
    "recursive",
    "functions",
    "let",
    "take",
    "two",
    "three",
    "recursive",
    "functions",
    "either",
    "reduce",
    "either",
    "reduce",
    "size",
    "first",
    "string",
    "reduce",
    "size",
    "second",
    "string",
    "reduce",
    "size",
    "strings",
    "either",
    "end",
    "n1",
    "ns2",
    "let",
    "reduce",
    "size",
    "end",
    "n1",
    "n2",
    "minus1",
    "end",
    "n1",
    "n2",
    "minus1",
    "okay",
    "three",
    "recursive",
    "calls",
    "make",
    "three",
    "recursive",
    "calls",
    "depth",
    "overall",
    "depth",
    "recursive",
    "call",
    "see",
    "time",
    "size",
    "problem",
    "reduces",
    "one",
    "size",
    "problem",
    "n1",
    "plus",
    "n2",
    "case",
    "reduces",
    "one",
    "case",
    "reduces",
    "one",
    "case",
    "reduces",
    "two",
    "simplification",
    "let",
    "say",
    "reduces",
    "one",
    "total",
    "size",
    "problem",
    "total",
    "number",
    "levels",
    "tree",
    "going",
    "n1",
    "n2",
    "three",
    "problems",
    "first",
    "layer",
    "second",
    "layer",
    "three",
    "square",
    "problems",
    "third",
    "layer",
    "three",
    "cube",
    "problems",
    "3",
    "3",
    "3",
    "similarly",
    "go",
    "ahead",
    "find",
    "last",
    "layer",
    "3",
    "nl",
    "plus",
    "n2",
    "minus",
    "one",
    "layers",
    "right",
    "add",
    "together",
    "layers",
    "end",
    "total",
    "total",
    "number",
    "sub",
    "problems",
    "3",
    "n1",
    "n2",
    "right",
    "total",
    "3",
    "n1",
    "n2",
    "sub",
    "problems",
    "end",
    "creating",
    "complexity",
    "3",
    "n1",
    "n2",
    "case",
    "okay",
    "complexity",
    "recursive",
    "solution",
    "complexity",
    "recursive",
    "solution",
    "exponential",
    "3",
    "3",
    "n1",
    "n2",
    "point",
    "make",
    "sense",
    "add",
    "memorization",
    "whenever",
    "see",
    "recursive",
    "solutions",
    "see",
    "repeated",
    "problems",
    "example",
    "see",
    "repeated",
    "problem",
    "see",
    "problem",
    "get",
    "repeated",
    "inside",
    "problem",
    "inside",
    "problem",
    "lot",
    "repetitions",
    "need",
    "remove",
    "repetitions",
    "remove",
    "repetitions",
    "use",
    "memorization",
    "happens",
    "memorized",
    "solution",
    "exactly",
    "recursive",
    "solution",
    "computation",
    "check",
    "memo",
    "check",
    "dictionary",
    "already",
    "solution",
    "changing",
    "variables",
    "i1",
    "i2",
    "solutions",
    "need",
    "return",
    "directly",
    "solutions",
    "need",
    "compute",
    "solutions",
    "put",
    "memo",
    "return",
    "value",
    "memo",
    "let",
    "write",
    "memoized",
    "version",
    "min",
    "edit",
    "distance",
    "st",
    "str1",
    "str",
    "str2",
    "calling",
    "memo",
    "okay",
    "calling",
    "memo",
    "memo",
    "memo",
    "going",
    "dictionary",
    "dictionary",
    "empty",
    "define",
    "function",
    "recurse",
    "say",
    "memorization",
    "normally",
    "write",
    "recursive",
    "helper",
    "function",
    "either",
    "write",
    "outside",
    "inside",
    "like",
    "writing",
    "inside",
    "well",
    "access",
    "str2",
    "need",
    "passed",
    "i1",
    "i2",
    "first",
    "thing",
    "create",
    "key",
    "key",
    "i1a",
    "i2",
    "key",
    "memo",
    "means",
    "already",
    "computed",
    "solution",
    "simply",
    "return",
    "memo",
    "key",
    "cases",
    "lf",
    "check",
    "i1",
    "equals",
    "len",
    "str1",
    "case",
    "return",
    "set",
    "memo",
    "key",
    "len",
    "str2",
    "minus",
    "i2",
    "lf",
    "i2",
    "equals",
    "len",
    "sdr2",
    "return",
    "memo",
    "key",
    "len",
    "str1",
    "minus",
    "i1",
    "lf",
    "okay",
    "case",
    "check",
    "first",
    "elements",
    "equal",
    "exact",
    "logic",
    "see",
    "cas",
    "coming",
    "str1",
    "i1",
    "equals",
    "str2",
    "i2",
    "case",
    "mem",
    "e",
    "equals",
    "simply",
    "ignore",
    "first",
    "character",
    "increment",
    "i1",
    "i2",
    "exactly",
    "done",
    "simply",
    "call",
    "recurse",
    "time",
    "i1",
    "1",
    "i2",
    "1",
    "right",
    "always",
    "call",
    "recursive",
    "function",
    "inside",
    "recursive",
    "function",
    "already",
    "computed",
    "return",
    "memo",
    "finally",
    "final",
    "case",
    "equal",
    "memo",
    "key",
    "becomes",
    "1",
    "min",
    "let",
    "see",
    "recurse",
    "insertion",
    "cases",
    "ignore",
    "first",
    "element",
    "sorry",
    "deletion",
    "cases",
    "ignore",
    "first",
    "element",
    "current",
    "range",
    "first",
    "string",
    "call",
    "recurse",
    "i1",
    "1",
    "i2",
    "otherwise",
    "call",
    "recurse",
    "i1",
    "1",
    "i1",
    "i2",
    "1",
    "case",
    "swap",
    "first",
    "element",
    "first",
    "string",
    "recursively",
    "check",
    "ignoring",
    "first",
    "element",
    "recurse",
    "i1",
    "comma",
    "i2",
    "1",
    "i2",
    "1",
    "go",
    "stored",
    "memo",
    "simply",
    "return",
    "memo",
    "key",
    "end",
    "finally",
    "call",
    "recurse",
    "0",
    "0",
    "solution",
    "okay",
    "syntax",
    "error",
    "fix",
    "fix",
    "syntax",
    "errors",
    "easy",
    "fix",
    "realized",
    "solution",
    "case",
    "might",
    "actually",
    "four",
    "change",
    "n",
    "p",
    "one",
    "step",
    "replace",
    "exc",
    "replace",
    "exc",
    "three",
    "changes",
    "change",
    "e",
    "replace",
    "n",
    "p",
    "solution",
    "four",
    "solution",
    "correct",
    "issue",
    "fact",
    "best",
    "solution",
    "suboptimal",
    "solution",
    "output",
    "four",
    "okay",
    "something",
    "happens",
    "time",
    "miss",
    "something",
    "assume",
    "say",
    "going",
    "come",
    "back",
    "end",
    "move",
    "forward",
    "assuming",
    "code",
    "right",
    "realize",
    "either",
    "correct",
    "mistake",
    "probably",
    "going",
    "happen",
    "one",
    "five",
    "interviews",
    "anyway",
    "okay",
    "written",
    "memo",
    "solution",
    "great",
    "start",
    "checking",
    "memo",
    "solution",
    "minimum",
    "edit",
    "distance",
    "memo",
    "let",
    "call",
    "main",
    "edit",
    "distance",
    "memo",
    "get",
    "back",
    "value",
    "four",
    "looks",
    "fine",
    "let",
    "try",
    "saturday",
    "sunday",
    "three",
    "leave",
    "change",
    "un",
    "n",
    "removing",
    "changing",
    "r",
    "n",
    "seems",
    "fine",
    "let",
    "test",
    "cases",
    "like",
    "okay",
    "3",
    "68",
    "characters",
    "seems",
    "right",
    "simply",
    "delete",
    "characters",
    "let",
    "check",
    "also",
    "eight",
    "characters",
    "add",
    "eight",
    "character",
    "ctors",
    "let",
    "say",
    "ab",
    "c",
    "xyz",
    "three",
    "xy",
    "z",
    "k",
    "maybe",
    "four",
    "xy",
    "z",
    "case",
    "also",
    "four",
    "seems",
    "working",
    "fine",
    "taken",
    "recursive",
    "solution",
    "identified",
    "inefficiency",
    "calculated",
    "complexity",
    "exponential",
    "identified",
    "inefficiency",
    "repeated",
    "sub",
    "problems",
    "fix",
    "inefficiency",
    "calling",
    "main",
    "edit",
    "using",
    "memorization",
    "compute",
    "time",
    "complexity",
    "memorization",
    "well",
    "argument",
    "need",
    "compute",
    "solution",
    "key",
    "computation",
    "apart",
    "recursive",
    "calls",
    "simply",
    "involves",
    "comparison",
    "fixed",
    "number",
    "comparison",
    "addition",
    "time",
    "required",
    "compute",
    "assuming",
    "recursive",
    "solutions",
    "constant",
    "constant",
    "means",
    "simply",
    "count",
    "number",
    "memorizationscripture",
    "n1",
    "n2",
    "number",
    "keys",
    "constant",
    "amount",
    "time",
    "additional",
    "time",
    "required",
    "compute",
    "solution",
    "key",
    "also",
    "complexity",
    "complexity",
    "order",
    "n1",
    "n2",
    "gone",
    "3",
    "power",
    "n1",
    "n2",
    "grows",
    "quickly",
    "even",
    "3",
    "power",
    "3",
    "power",
    "10",
    "pretty",
    "high",
    "check",
    "3",
    "10",
    "something",
    "like",
    "3",
    "100",
    "n1",
    "n2",
    "e",
    "47",
    "going",
    "lot",
    "operations",
    "hand",
    "memorization",
    "going",
    "take",
    "let",
    "say",
    "100",
    "split",
    "two",
    "strings",
    "length",
    "50",
    "50",
    "going",
    "take",
    "operations",
    "taking",
    "10",
    "47",
    "operations",
    "takes",
    "operations",
    "pretty",
    "small",
    "still",
    "work",
    "lists",
    "size",
    "easily",
    "using",
    "memoized",
    "solution",
    "covers",
    "problem",
    "keep",
    "talking",
    "solution",
    "even",
    "stuck",
    "even",
    "confused",
    "helpful",
    "keep",
    "spend",
    "maybe",
    "2",
    "3",
    "minutes",
    "trying",
    "solve",
    "issue",
    "able",
    "solve",
    "issue",
    "say",
    "something",
    "fix",
    "later",
    "move",
    "assuming",
    "fixed",
    "keep",
    "talking",
    "keep",
    "continue",
    "keep",
    "working",
    "solution",
    "point",
    "later",
    "possible",
    "solution",
    "might",
    "strike",
    "okay",
    "point",
    "may",
    "asked",
    "sometimes",
    "implement",
    "dynamic",
    "pro",
    "programming",
    "iterative",
    "solution",
    "like",
    "talk",
    "interviewer",
    "telling",
    "thinking",
    "recursive",
    "solution",
    "first",
    "see",
    "maybe",
    "going",
    "sub",
    "problems",
    "going",
    "uh",
    "apply",
    "dynamic",
    "programming",
    "check",
    "cases",
    "accept",
    "memorization",
    "solution",
    "dynamic",
    "programming",
    "solutions",
    "take",
    "little",
    "bit",
    "time",
    "solve",
    "implement",
    "always",
    "one",
    "errors",
    "also",
    "difficult",
    "explain",
    "solution",
    "cases",
    "get",
    "away",
    "memorization",
    "ask",
    "iteratively",
    "dynamic",
    "programming",
    "go",
    "ahead",
    "implement",
    "dynamic",
    "programming",
    "solution",
    "take",
    "couple",
    "minutes",
    "work",
    "piece",
    "paper",
    "go",
    "back",
    "dynamic",
    "programming",
    "remember",
    "create",
    "table",
    "essentially",
    "table",
    "look",
    "like",
    "case",
    "let",
    "see",
    "simulate",
    "table",
    "table",
    "look",
    "like",
    "let",
    "create",
    "new",
    "sheet",
    "sheet",
    "let",
    "us",
    "put",
    "two",
    "words",
    "intention",
    "okay",
    "let",
    "put",
    "word",
    "exception",
    "well",
    "move",
    "let",
    "also",
    "put",
    "indexes",
    "ultimately",
    "dynamic",
    "programming",
    "looks",
    "like",
    "programming",
    "problem",
    "looks",
    "like",
    "ultimately",
    "going",
    "create",
    "table",
    "start",
    "filling",
    "table",
    "element",
    "let",
    "say",
    "element",
    "e",
    "ex",
    "c",
    "element",
    "represents",
    "eded",
    "distance",
    "number",
    "operations",
    "required",
    "convert",
    "te",
    "ex",
    "ex",
    "c",
    "check",
    "solution",
    "know",
    "e",
    "e",
    "equal",
    "final",
    "elements",
    "equal",
    "means",
    "look",
    "value",
    "value",
    "tell",
    "us",
    "minimum",
    "edit",
    "distance",
    "exe",
    "exe",
    "since",
    "simply",
    "add",
    "e",
    "string",
    "get",
    "solution",
    "means",
    "solution",
    "equal",
    "value",
    "equal",
    "value",
    "right",
    "case",
    "corresponding",
    "elements",
    "equal",
    "simply",
    "copy",
    "value",
    "diagonally",
    "left",
    "top",
    "left",
    "value",
    "onto",
    "current",
    "cell",
    "option",
    "equal",
    "let",
    "say",
    "n",
    "p",
    "three",
    "possibilities",
    "want",
    "find",
    "minimum",
    "ed",
    "distance",
    "n",
    "e",
    "ex",
    "c",
    "p",
    "n",
    "equal",
    "p",
    "original",
    "string",
    "either",
    "delete",
    "n",
    "delete",
    "n",
    "need",
    "find",
    "solution",
    "te",
    "ex",
    "c",
    "delete",
    "n",
    "value",
    "become",
    "1",
    "plus",
    "value",
    "one",
    "possibility",
    "another",
    "possibility",
    "swap",
    "n",
    "swap",
    "n",
    "p",
    "get",
    "becomes",
    "p",
    "becomes",
    "p",
    "value",
    "becomes",
    "become",
    "one",
    "plus",
    "value",
    "ignore",
    "p",
    "simply",
    "get",
    "previous",
    "solution",
    "e",
    "exce",
    "te",
    "value",
    "becomes",
    "one",
    "plus",
    "value",
    "final",
    "option",
    "insert",
    "something",
    "n",
    "insert",
    "something",
    "n",
    "going",
    "p",
    "insert",
    "p",
    "n",
    "sorry",
    "insert",
    "p",
    "n",
    "insert",
    "p",
    "n",
    "p",
    "already",
    "look",
    "value",
    "value",
    "going",
    "one",
    "value",
    "case",
    "insert",
    "something",
    "insert",
    "p",
    "n",
    "right",
    "three",
    "ways",
    "come",
    "value",
    "either",
    "deleting",
    "n",
    "inserting",
    "p",
    "changing",
    "n",
    "p",
    "take",
    "minimum",
    "three",
    "values",
    "three",
    "values",
    "add",
    "one",
    "obtain",
    "value",
    "logic",
    "roughly",
    "speaking",
    "start",
    "left",
    "see",
    "okay",
    "e",
    "unequal",
    "need",
    "one",
    "operation",
    "change",
    "nothing",
    "else",
    "consider",
    "done",
    "e",
    "n",
    "n",
    "unequal",
    "need",
    "either",
    "delete",
    "n",
    "delete",
    "n",
    "simply",
    "need",
    "check",
    "e",
    "know",
    "solution",
    "e",
    "one",
    "would",
    "two",
    "another",
    "another",
    "option",
    "could",
    "possibly",
    "insert",
    "something",
    "insert",
    "something",
    "length",
    "going",
    "increase",
    "going",
    "cause",
    "problem",
    "ca",
    "insert",
    "anything",
    "another",
    "change",
    "n",
    "e",
    "change",
    "n",
    "e",
    "longer",
    "able",
    "uh",
    "change",
    "n",
    "e",
    "longer",
    "able",
    "use",
    "solution",
    "right",
    "match",
    "empty",
    "list",
    "going",
    "one",
    "well",
    "overall",
    "end",
    "two",
    "start",
    "filling",
    "list",
    "start",
    "filling",
    "left",
    "right",
    "left",
    "right",
    "keep",
    "going",
    "top",
    "bottom",
    "fill",
    "list",
    "finally",
    "fill",
    "final",
    "value",
    "exception",
    "intention",
    "solution",
    "dynamic",
    "programming",
    "solution",
    "see",
    "getting",
    "tricky",
    "convey",
    "entire",
    "solution",
    "many",
    "cases",
    "involved",
    "typically",
    "find",
    "dynamic",
    "programming",
    "solutions",
    "requested",
    "interviews",
    "help",
    "stick",
    "memorization",
    "solutions",
    "right",
    "covered",
    "two",
    "common",
    "interview",
    "questions",
    "keep",
    "going",
    "idea",
    "apply",
    "method",
    "remember",
    "remember",
    "method",
    "problem",
    "solving",
    "template",
    "covered",
    "state",
    "problem",
    "identify",
    "input",
    "output",
    "formats",
    "write",
    "function",
    "signature",
    "come",
    "example",
    "inputs",
    "outputs",
    "least",
    "scenarios",
    "come",
    "correct",
    "solution",
    "stated",
    "plain",
    "english",
    "implement",
    "solution",
    "test",
    "using",
    "example",
    "inputs",
    "fix",
    "bugs",
    "face",
    "analyze",
    "algorithm",
    "complexity",
    "identify",
    "inefficiencies",
    "finally",
    "apply",
    "right",
    "technique",
    "overcome",
    "inefficiency",
    "repeat",
    "process",
    "going",
    "back",
    "stating",
    "solution",
    "implementing",
    "analyzing",
    "repeating",
    "cases",
    "need",
    "implement",
    "root",
    "force",
    "solution",
    "time",
    "working",
    "recursive",
    "solutions",
    "always",
    "helps",
    "implement",
    "brute",
    "force",
    "first",
    "memorization",
    "dynamic",
    "programming",
    "tips",
    "ask",
    "questions",
    "many",
    "questions",
    "many",
    "need",
    "clarify",
    "problem",
    "show",
    "example",
    "follow",
    "method",
    "panic",
    "get",
    "stuck",
    "certain",
    "point",
    "give",
    "couple",
    "minutes",
    "sometimes",
    "even",
    "ask",
    "interviewer",
    "may",
    "able",
    "tell",
    "maybe",
    "error",
    "maybe",
    "stuck",
    "simply",
    "assuming",
    "something",
    "incorrectly",
    "beyond",
    "minutes",
    "want",
    "say",
    "let",
    "fix",
    "later",
    "assuming",
    "correct",
    "let",
    "move",
    "talk",
    "complexity",
    "optimization",
    "okay",
    "important",
    "state",
    "brute",
    "force",
    "solution",
    "interviewer",
    "unable",
    "figure",
    "optimal",
    "solution",
    "best",
    "thing",
    "uh",
    "offer",
    "implement",
    "brute",
    "force",
    "solution",
    "least",
    "demonstrate",
    "able",
    "write",
    "code",
    "right",
    "lot",
    "cases",
    "able",
    "figure",
    "optimal",
    "solution",
    "cases",
    "may",
    "optimal",
    "way",
    "certain",
    "problems",
    "one",
    "way",
    "hard",
    "way",
    "brute",
    "way",
    "typically",
    "true",
    "family",
    "problems",
    "called",
    "backtracking",
    "something",
    "really",
    "covered",
    "lot",
    "detail",
    "also",
    "another",
    "form",
    "recursion",
    "next",
    "next",
    "step",
    "review",
    "lecture",
    "video",
    "solve",
    "problems",
    "take",
    "problems",
    "ideally",
    "want",
    "want",
    "take",
    "five",
    "different",
    "techniques",
    "covered",
    "let",
    "quickly",
    "review",
    "five",
    "techniques",
    "first",
    "one",
    "binary",
    "search",
    "looked",
    "linear",
    "search",
    "binary",
    "search",
    "form",
    "divide",
    "conquer",
    "along",
    "also",
    "understood",
    "complexity",
    "big",
    "notation",
    "homework",
    "link",
    "list",
    "python",
    "classes",
    "binary",
    "search",
    "something",
    "comes",
    "often",
    "hint",
    "detect",
    "binary",
    "search",
    "simply",
    "look",
    "order",
    "whenever",
    "see",
    "something",
    "something",
    "metion",
    "mentioned",
    "sorted",
    "indication",
    "may",
    "binary",
    "search",
    "sometimes",
    "may",
    "may",
    "get",
    "things",
    "sorted",
    "form",
    "maybe",
    "taking",
    "replacing",
    "elements",
    "sum",
    "values",
    "till",
    "element",
    "get",
    "things",
    "sorted",
    "form",
    "maybe",
    "binary",
    "search",
    "one",
    "way",
    "go",
    "five",
    "10",
    "problems",
    "binary",
    "search",
    "able",
    "identify",
    "pretty",
    "much",
    "binary",
    "search",
    "question",
    "interview",
    "next",
    "topic",
    "looked",
    "binary",
    "search",
    "trees",
    "traversals",
    "something",
    "uh",
    "generally",
    "asked",
    "directly",
    "given",
    "question",
    "like",
    "binary",
    "search",
    "tree",
    "something",
    "binary",
    "search",
    "tree",
    "answer",
    "question",
    "directly",
    "covered",
    "lot",
    "different",
    "things",
    "check",
    "lesson",
    "two",
    "different",
    "things",
    "binary",
    "search",
    "trees",
    "traversals",
    "balancing",
    "recursive",
    "solutions",
    "also",
    "good",
    "exercise",
    "recursion",
    "also",
    "looked",
    "b",
    "binary",
    "trees",
    "optimize",
    "assignment",
    "hash",
    "tables",
    "hashing",
    "common",
    "question",
    "often",
    "asked",
    "built",
    "hash",
    "tables",
    "scratch",
    "python",
    "also",
    "handled",
    "collisions",
    "using",
    "technique",
    "called",
    "linear",
    "probing",
    "something",
    "check",
    "assignment",
    "may",
    "get",
    "asked",
    "implement",
    "hash",
    "table",
    "python",
    "implement",
    "collision",
    "resolution",
    "hash",
    "table",
    "case",
    "use",
    "linear",
    "probing",
    "sorting",
    "algorithms",
    "looked",
    "bubble",
    "sort",
    "insertion",
    "sort",
    "merge",
    "sort",
    "using",
    "divide",
    "conquer",
    "quick",
    "sort",
    "quadratic",
    "worst",
    "case",
    "complexity",
    "logarithmic",
    "average",
    "complexity",
    "good",
    "thing",
    "merge",
    "sort",
    "although",
    "logarithmic",
    "worst",
    "case",
    "still",
    "takes",
    "lot",
    "space",
    "space",
    "allocation",
    "slow",
    "may",
    "also",
    "memory",
    "sometimes",
    "use",
    "prefer",
    "quick",
    "sort",
    "merge",
    "sort",
    "constraint",
    "space",
    "assignment",
    "three",
    "pretty",
    "interesting",
    "implement",
    "optimal",
    "algorithm",
    "polinomial",
    "multiplication",
    "using",
    "divide",
    "conquer",
    "check",
    "assignment",
    "3",
    "well",
    "looked",
    "dynamic",
    "programming",
    "looked",
    "recursion",
    "memorization",
    "subsequence",
    "aback",
    "problems",
    "finally",
    "also",
    "cover",
    "backtracking",
    "pruning",
    "questions",
    "lesson",
    "notebook",
    "try",
    "use",
    "backtracking",
    "pruning",
    "well",
    "looked",
    "graph",
    "algorithms",
    "last",
    "time",
    "graphs",
    "adjacency",
    "list",
    "adjacency",
    "matrices",
    "looked",
    "depth",
    "first",
    "bread",
    "first",
    "search",
    "implement",
    "also",
    "looked",
    "shortest",
    "paths",
    "directed",
    "weighted",
    "graphs",
    "important",
    "topic",
    "bread",
    "first",
    "depth",
    "first",
    "search",
    "get",
    "many",
    "questions",
    "related",
    "solve",
    "maybe",
    "five",
    "questions",
    "topics",
    "good",
    "graph",
    "problems",
    "asked",
    "interviews",
    "project",
    "course",
    "project",
    "seen",
    "seen",
    "already",
    "pick",
    "coding",
    "problem",
    "pick",
    "coding",
    "problem",
    "online",
    "source",
    "like",
    "lead",
    "code",
    "hacker",
    "rank",
    "geeks",
    "geeks",
    "etc",
    "use",
    "problem",
    "solving",
    "template",
    "shared",
    "problem",
    "solving",
    "template",
    "starting",
    "point",
    "give",
    "name",
    "write",
    "problem",
    "statement",
    "implement",
    "solution",
    "step",
    "step",
    "use",
    "problem",
    "solving",
    "template",
    "solve",
    "problem",
    "using",
    "method",
    "learned",
    "course",
    "document",
    "solution",
    "add",
    "explanations",
    "wherever",
    "required",
    "perform",
    "complexity",
    "analysis",
    "add",
    "jupyter",
    "notebook",
    "publish",
    "notebook",
    "jovian",
    "profile",
    "finally",
    "submit",
    "link",
    "jovan",
    "notebook",
    "submit",
    "link",
    "jovan",
    "notebook",
    "check",
    "discussion",
    "change",
    "uh",
    "post",
    "working",
    "post",
    "notebook",
    "well",
    "finally",
    "today",
    "looked",
    "couple",
    "real",
    "interview",
    "questions",
    "amazon",
    "google",
    "go",
    "solving",
    "also",
    "addressed",
    "issues",
    "faced",
    "along",
    "way",
    "helpful",
    "exercise",
    "review",
    "lecture",
    "video",
    "execute",
    "jupiter",
    "notebooks",
    "complete",
    "assignments",
    "attempt",
    "optional",
    "questions",
    "topics",
    "covered",
    "get",
    "consolidated",
    "ever",
    "look",
    "lecture",
    "right",
    "practice",
    "really",
    "reinforces",
    "consolidates",
    "learning",
    "complete",
    "assignments",
    "attempt",
    "optional",
    "questions",
    "practice",
    "participate",
    "forum",
    "discussions",
    "also",
    "useful",
    "participate",
    "forum",
    "discussions",
    "answering",
    "questions",
    "lot",
    "doubts",
    "get",
    "cleared",
    "participate",
    "forum",
    "discussions",
    "join",
    "start",
    "study",
    "group",
    "possible",
    "getting",
    "together",
    "group",
    "four",
    "five",
    "people",
    "great",
    "really",
    "helps",
    "focus",
    "uh",
    "improve",
    "understanding",
    "discussion",
    "data",
    "structures",
    "algorithms",
    "python",
    "thank",
    "much",
    "joining",
    "us",
    "journey",
    "learn",
    "data",
    "structures",
    "algorithms",
    "python",
    "useful",
    "topic",
    "improve",
    "coding",
    "skills",
    "also",
    "something",
    "almost",
    "certainly",
    "encounter",
    "one",
    "interviews",
    "matter",
    "company",
    "applying",
    "hope",
    "helpful",
    "let",
    "us",
    "know",
    "forum",
    "course",
    "helped",
    "let",
    "us",
    "know",
    "youtube",
    "comments",
    "well",
    "questions",
    "something",
    "clear",
    "post",
    "make",
    "sure",
    "come",
    "clearer",
    "explanations",
    "clearer",
    "examples",
    "next",
    "time",
    "feedback",
    "us",
    "post",
    "comments",
    "send",
    "us",
    "email",
    "support",
    "take",
    "leave",
    "see",
    "forums",
    "end",
    "journey",
    "stay",
    "active",
    "jo",
    "lot",
    "great",
    "activity",
    "happening",
    "check",
    "forums",
    "newsletter",
    "stay",
    "tuned",
    "next",
    "course",
    "thank",
    "goodbye"
  ],
  "keywords": [
    "common",
    "data",
    "structures",
    "algorithms",
    "python",
    "course",
    "akash",
    "jovian",
    "coding",
    "online",
    "help",
    "programming",
    "solve",
    "interviews",
    "also",
    "learn",
    "using",
    "get",
    "practice",
    "interview",
    "questions",
    "project",
    "profile",
    "basic",
    "follow",
    "along",
    "new",
    "work",
    "little",
    "access",
    "forum",
    "ask",
    "working",
    "created",
    "platform",
    "really",
    "today",
    "lesson",
    "one",
    "binary",
    "search",
    "link",
    "lists",
    "complexity",
    "name",
    "find",
    "6",
    "four",
    "process",
    "use",
    "let",
    "need",
    "go",
    "open",
    "page",
    "video",
    "still",
    "every",
    "either",
    "run",
    "code",
    "right",
    "list",
    "see",
    "able",
    "version",
    "used",
    "first",
    "set",
    "look",
    "called",
    "linear",
    "well",
    "part",
    "total",
    "12",
    "notebooks",
    "assume",
    "know",
    "bit",
    "instance",
    "things",
    "like",
    "variables",
    "functions",
    "already",
    "click",
    "take",
    "half",
    "couple",
    "high",
    "want",
    "read",
    "required",
    "cover",
    "additional",
    "written",
    "library",
    "function",
    "two",
    "computer",
    "going",
    "top",
    "binder",
    "second",
    "source",
    "looking",
    "actually",
    "something",
    "jupiter",
    "notebook",
    "contain",
    "outputs",
    "time",
    "button",
    "line",
    "jupyter",
    "great",
    "way",
    "change",
    "example",
    "inside",
    "root",
    "value",
    "soon",
    "clear",
    "output",
    "remove",
    "numbers",
    "away",
    "execute",
    "thing",
    "might",
    "instead",
    "plus",
    "cell",
    "pretty",
    "anything",
    "done",
    "takes",
    "solving",
    "problem",
    "efficient",
    "solution",
    "specific",
    "technique",
    "apply",
    "problems",
    "come",
    "goes",
    "cards",
    "decreasing",
    "order",
    "face",
    "sequence",
    "table",
    "looks",
    "number",
    "bob",
    "pick",
    "card",
    "containing",
    "given",
    "could",
    "say",
    "seven",
    "possible",
    "us",
    "many",
    "write",
    "locate",
    "put",
    "target",
    "tell",
    "general",
    "strategy",
    "maybe",
    "try",
    "figure",
    "start",
    "thinking",
    "may",
    "simple",
    "especially",
    "think",
    "uh",
    "talk",
    "whether",
    "certain",
    "asked",
    "balancing",
    "okay",
    "important",
    "step",
    "different",
    "inputs",
    "edge",
    "cases",
    "kind",
    "users",
    "input",
    "often",
    "property",
    "clearly",
    "convert",
    "coming",
    "back",
    "hand",
    "writing",
    "optimal",
    "end",
    "longer",
    "errors",
    "whenever",
    "state",
    "identify",
    "three",
    "correct",
    "plain",
    "english",
    "optional",
    "sometimes",
    "implement",
    "test",
    "fix",
    "five",
    "analyze",
    "algorithm",
    "finally",
    "six",
    "overcome",
    "inefficiency",
    "comes",
    "method",
    "talking",
    "terms",
    "understand",
    "case",
    "represent",
    "structure",
    "position",
    "sorted",
    "element",
    "zero",
    "always",
    "otherwise",
    "good",
    "starting",
    "elements",
    "minimum",
    "particular",
    "times",
    "finding",
    "would",
    "7",
    "5",
    "4",
    "left",
    "better",
    "best",
    "defined",
    "words",
    "make",
    "interviewer",
    "long",
    "query",
    "array",
    "simply",
    "signature",
    "without",
    "actual",
    "call",
    "single",
    "statement",
    "pass",
    "empty",
    "least",
    "true",
    "variable",
    "track",
    "represents",
    "b",
    "minutes",
    "lines",
    "even",
    "keep",
    "mind",
    "answer",
    "getting",
    "simplest",
    "reduce",
    "wrong",
    "taken",
    "information",
    "expected",
    "point",
    "result",
    "nothing",
    "none",
    "compare",
    "obviously",
    "easier",
    "dictionaries",
    "dictionary",
    "keys",
    "key",
    "argument",
    "arguments",
    "passing",
    "values",
    "calling",
    "enough",
    "probably",
    "handle",
    "valid",
    "helps",
    "fact",
    "useful",
    "middle",
    "question",
    "special",
    "last",
    "contains",
    "another",
    "interesting",
    "eight",
    "generic",
    "comments",
    "create",
    "occur",
    "store",
    "creating",
    "tests",
    "minus",
    "repeat",
    "happens",
    "sure",
    "verify",
    "idea",
    "move",
    "forward",
    "return",
    "easy",
    "issue",
    "final",
    "10",
    "much",
    "seconds",
    "um",
    "within",
    "2",
    "3",
    "steps",
    "place",
    "mean",
    "lies",
    "checking",
    "brute",
    "force",
    "till",
    "becomes",
    "check",
    "index",
    "equals",
    "since",
    "beginning",
    "increment",
    "found",
    "seems",
    "straightforward",
    "1",
    "passed",
    "far",
    "discussion",
    "implemented",
    "statements",
    "quick",
    "next",
    "everything",
    "together",
    "fill",
    "loop",
    "gets",
    "continue",
    "0",
    "yeah",
    "match",
    "small",
    "evaluate",
    "give",
    "print",
    "execution",
    "become",
    "nice",
    "directly",
    "lot",
    "fine",
    "error",
    "range",
    "exactly",
    "default",
    "issues",
    "add",
    "initially",
    "equal",
    "trying",
    "slightly",
    "less",
    "length",
    "n",
    "save",
    "h",
    "makes",
    "bunch",
    "skip",
    "implementation",
    "original",
    "iteration",
    "size",
    "worst",
    "condition",
    "suppose",
    "means",
    "amount",
    "perform",
    "space",
    "complete",
    "notation",
    "longest",
    "constant",
    "c",
    "operations",
    "running",
    "phone",
    "sense",
    "similarly",
    "memory",
    "iterate",
    "iterations",
    "commit",
    "else",
    "yet",
    "moment",
    "random",
    "greater",
    "rather",
    "edges",
    "assignment",
    "representation",
    "current",
    "entire",
    "low",
    "len",
    "returns",
    "made",
    "count",
    "mid",
    "remember",
    "l",
    "based",
    "works",
    "8",
    "gives",
    "sort",
    "logic",
    "define",
    "string",
    "level",
    "strings",
    "class",
    "factor",
    "character",
    "append",
    "roughly",
    "ignore",
    "k",
    "log",
    "taking",
    "login",
    "exercise",
    "larger",
    "million",
    "display",
    "100",
    "divide",
    "graph",
    "looked",
    "side",
    "increasing",
    "template",
    "mark",
    "copy",
    "easily",
    "intention",
    "previous",
    "adding",
    "operation",
    "9",
    "rotated",
    "include",
    "nums",
    "rotations",
    "smallest",
    "insert",
    "smaller",
    "comparison",
    "show",
    "option",
    "comparisons",
    "paper",
    "p",
    "sub",
    "subarray",
    "trees",
    "username",
    "user",
    "update",
    "insertion",
    "object",
    "self",
    "str",
    "database",
    "barage",
    "inserting",
    "hon",
    "pointer",
    "inserted",
    "solutions",
    "tree",
    "nodes",
    "node",
    "jades",
    "subtree",
    "balanced",
    "child",
    "height",
    "path",
    "pairs",
    "connected",
    "tuple",
    "recursion",
    "calls",
    "recursive",
    "recursively",
    "traversal",
    "visited",
    "visit",
    "parent",
    "maximum",
    "max",
    "bst",
    "dynamic",
    "j",
    "remaining",
    "balance",
    "pair",
    "choose",
    "delete",
    "x",
    "hash",
    "tables",
    "sorting",
    "comma",
    "characters",
    "e",
    "idx",
    "capacity",
    "likes",
    "swap",
    "bubble",
    "merge",
    "pivot",
    "partition",
    "onwards",
    "n1",
    "memorization",
    "subsequence",
    "sequences",
    "lcs",
    "idx1",
    "id",
    "x2",
    "compute",
    "memo",
    "stack",
    "n2",
    "row",
    "zeros",
    "graphs",
    "weight",
    "profit",
    "weights",
    "profits",
    "bfs",
    "shortest",
    "distance",
    "directed",
    "adjacency",
    "neighbors",
    "direct",
    "q",
    "discovered",
    "weighted",
    "distances",
    "unvisited",
    "sum",
    "str1",
    "i1",
    "i2"
  ]
}