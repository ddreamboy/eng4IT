what is up guys faris here yesterday in
uh the live stream i was talking a
little bit about how i
kind of wanted to connect the dots for
any newcomers and even for more advanced
people
for the later on steps when it comes to
software development basically take you
everywhere from
downloading the ide which is basically
like two seconds of this video
to creating a simple terminal
application within that ide
writing a few tests for that terminal
application because we're gonna be
pushing it up to github
creating our own github repository and
whatnot and then
going ahead and using circle ci to
integrate some continuous integration
and those tests are going to be run
through circle ci before it pushes it
over to our master branch
on our github repository that's why i
saved for beginners and
people who are a little bit further
along because if you have no experience
when it comes to
ci cd workflows that's something that
you're going to run into
one way or another if you plan to become
a professional software developer so i
think that
anybody of any skill level from beginner
to i mean maybe you've been doing this
for a while we'll take something away
from this video
at least that is my hope and plans quick
disclaimer i'm not sure how good of a
teacher i am sometimes i
tend to just gloss over some important
facts because i may assume that you
already know it
other times it may fall down a rabbit
hole because i don't think you know
anything about it so uh
we'll see how this goes all of this is
being done on windows 10
and i can make any argument in the world
is why maybe you want to be using linux
for a software developer but
i just want to break down the barrier to
entry there are so many different
questions when it comes to linux and the
distros and things of that nature so
we're going to be running it on windows
10 if you have mac os this should be the
same exact thing
and i also want to mention before we get
started is that circle ci is the sponsor
of this video and while we are going to
be going over
a little bit of uh i say a little bit
we're going to be setting up
you know a ci a continuous integration
workflow for a very simple
terminal application circle ci does a
whole lot more than that
i just want to read a few notes that i
took down on my experience in circle ci
that
for some of you who are a little bit
more advanced and want to do a little
bit more maybe hop into the continuous
deployment
side of things as well as the continuous
integration like we'll be doing in this
video
circle ci this my own notes professional
service something you'll see in top
companies like facebook
spotify kickstarter and gopro it allows
debugging in your
ci cd pipelines with ssh you can use
workflows to schedule jobs
share data among jobs where each
workflow has an associated workspace
which can be used to transfer files to
downstream jobs as a workflow progresses
caching dependencies is another big one
it makes jobs faster in circleci by
reusing the data from expensive fetch
operations from previous jobs and you
can use the circle
ci cli to split tests all of that that i
just mentioned is available for free
on their performance plan however they
offer even more like resource
classes scaling concurrency and docker
lane caching
if anything i mentioned or everything i
mentioned went right over your head i'm
going to be leaving links down
to this the appropriate circle ci page
for
everything i just listed so you can go
ahead and click down there and just
have fun falling down that rabbit hole
because there's a whole lot to learn
when it comes to cicd
workflows and things of that nature and
like i said professional software
development environment
you're going to be using continuous
integration and
or most likely and continuous deployment
so it's
definitely something worth learning if
that is your ultimate goal all right
first things first eclipse.org
downloads you're going to download
eclipse for this particular project
because we're going to be creating a
java terminal application caesar's
cipher i'll explain that in just a
second but basically all you do is at
eclipse.org
downloads download whatever it suggests
probably your 64-bit if you're on
windows 10
click download and you're going to be
downloading this right down here it's
going to be a
executable file and just follow the
prompt if
sometimes there's different options like
oh do you want to do custom settings or
just
stop default settings if you don't know
that you want either one of those just
do default eclipse knows what you need
better than you
if you don't know that you need
something specific
i'm very i really love cryptography and
puzzles and
just things of that nature and the fact
that caesar cipher is
a very very simple cipher something that
i think you'll be able to just catch on
to and
if you don't already know what it is and
the program itself is fairly simple
and i already know what i have in mind
when it comes to the tests
that's what we're going to be doing
today if you don't know what caesar
cipher is all in all caesar cipher is an
encryption technique a very very simple
encryption technique at that
what you do is you take the alphabet you
shift it down a certain amount of
letters and that is how you write your
message and what we'll be coding up is
the ability to take a message
throw it into our code and our code is
going to spit out the encrypted message
using caesar cipher all right so you
want to be able to pull up eclipse i'm
going to use this as the default and do
not ask again please this is
eclipse workspace this is where your
your project is going to be saved you're
going to get this page when you first
open eclipse because they're going to
try to recommend you
they're going to try to steer you in the
right direction and i do
after we go through this terminal
application through this video
you take a look at the overview or maybe
some tutorials or samples
because the more you're exposed to what
is going on within your ide
the better you'll be able to use it the
more useful it'll be for you
knowing your ide is just as important as
knowing your language is just as
important as knowing
how to write tests and all of this plays
into the part of being a software
developer but we're going to close out
of that and as you'll see it'll give you
a few options which you can do right
here
or you can come on up to file you click
on new and it has this window right here
now
normally what you would do potentially
is come up here and create a java
project but
since we're going to be creating a
continuous integration workflow
what we're going to need to do is come
down to other and we're going to be
creating
a gradle project so under here you'll
see gradle you'll see gradle project
going to click on that click next
we're going to name this project
caesar's cipher
just as such all right next i i think
everything else is just
fine now we're going to click finish
it's going to do a lot of work over here
don't seem too intimidated by what we
got going on over here so we have source
main java
directory we have our caesar cipher
package and we already have a
library.java file
don't worry about any of this we just
need to create it as a gradle project in
order for it to work properly when we
implement the continuous integration
with circle ci
so what you want to do is obviously
you'll see your source main java now you
can create it right in here or if you
want to
keep all this stuff closed you see you
have this source file right here
and then we're going to come on here
right click main we're going to hover
over new we're going to go down to class
this is your java class
we're going to name this now naming
conventions while they don't necessarily
matter too much when it comes to the
project itself when it comes to the java
classes
make sure you capitalize every single
word
just like that this is going to be
caesar cipher we don't need to make a
main right now we'll make that later and
finish now this is the part where most
people
can get to and think i don't know where
to go from here because
like what do you start typing like what
do you start typing here well you got to
think about whatever project you're
about to build we're going to be
building caesar cipher and obviously we
have an understanding of
caesar cipher this is when this notebook
come in handy you could write down
exactly what you need the objects in
which you'll be using so
let's just talk about it here so we're
going to need the alphabet
because in order to implement caesar
cipher we're going to have to shift it
down a certain amount
of characters down the alphabet so we're
going to need the alphabet
we'll start off there and then we're
also going to need to be able to
implement that shift or that offset
and then we're also going to have a
message in which we offset and that's
going to turn
into the ciphered message so
let's just start there and and i'll talk
about it towards the
end of me coding all of this up
all right this is a good place to pause
and that is because we have this
red underline right here and i say pause
by me explaining to you
what exactly i just did within our
public string
cipher so we have our input parameters
of our cipher
so this cipher when i say cipher this is
the message
encrypted this is the encrypted message
so what do we need within that we need
the original message and then we need
the offset
so the offset in which you are applying
to your message and here's the thing we
want to make sure that the offset
because it's going to be a it's going to
be an integer it's going to be a number
in which we offset by does not exceed
26 because we can only offset it by up
to 26 letters
all set module equals alphabet size and
that'll allow it to avoid
overflowing over 25
so basically another way to write this
emma
i'll just write it like this offset
equals offset
module alphabet size and if you're
wondering how i did that just there
let's take a step back where i typed in
the beginning of something i've already
declared
al alphabet size control or command
space alphabet size okay and so i don't
have to type it in every single time i
want to do that there's a lot of little
shortcuts like that
but this right here is the same exact
thing
as this right here so in case you want
to see it
where it makes a little bit more sense
in your head and more traditional manner
of looking at things but we're going to
take that out
and what we're what we have going over
here so we have our string we just
declared
a character array we called it character
and we have a string message and we're
going to take the message
the string message and we're going to
turn that into
characters and store all of the
characters
into our character array so if we have
25
characters within our string that is
stored within message
it could say how are you doing today
each one of those characters
h-o-w those will be stored as
characters in our character array that
we called
character and what we have going over
here is shift this is our shifting this
is the same as offset
uh in all honesty i could name this
offset by that's let's do that so we
stay consistent so offset by
this is going to be our method all set
by we're going to create a new method
there
it's going to be calling in the
parameters our character
from our character array and the offset
what this code is doing right now is
calling this method right here basically
so whatever i call
this method offset by it offsets our
message
to how we want it and then return new if
you notice that this if i took out
return new right here
it's yelling at us up here and that's
because we need a return statement with
this
so return new string character what
we're doing is
basically when we go through our string
cipher we go through this
all these statements right here what we
end up with is our character that we are
converting to a string
storing in a string now onto offset by
we just have to throw in the logic there
so whenever we call this method right
here
it actually does something
all right and this is our logic right
here so let me explain this for a second
one
this is yelling at us for the same
reason that the offset by was yelling at
us because we need to create a method
out of what we have going on right here
and then we're going to add a little bit
more logic
and and then we'll be we'll be done so
that is the offset char we'll get to
that in a second
but let me take you back to the fourth
so this is just a regular for loop i'm
going to take you through it anyway
but just know that hey it's regular for
them so we declared an integer i
we're going to be using this only in the
for loop and we equaled it to
zero and then we have while i which
right now equals zero is less than
character length we're going to be doing
whatever's in the for loop and every
time we do a rendition of what's in the
for loop
we're adding 1 to i so next time it
comes through it's going to
i is going to equal 1 and then it's
going to equal 2 and the thing is with
character
length character length that is the
value of how many characters
are within our character array that we
determined up here
which is obviously storing our message
as
each individual character in the array
as we previously discussed
and how many characters like i said if
it says
how is your day today however many
characters that is let's say it's 15
characters
this right here basically just equals
15. so
while i is less than 15
we're going to be keep on doing a for
loop and also within this for loop
what we're doing here we have our
character i and with i
we are running through each and every
character that is within our message
that's all that i represents so zero
while i equals zero
up here as we go through the for loop i
will equal zero
or i will equal one and then two and
then three and then four
and that will represent the position in
which the character is within our
character array
you you're with me in that and then
we're also running
this method that we just created and
we're about to throw logic into
in a second which this is our message
traversal this is us
implementing caesar cipher into our
character and to our message and we're
just storing it within this right so now
we need to do is our offset
character throw the logic into there
so i mentioned our previous method where
we're going to have letter a and letter
z and we're going to assume that every
character in our message
is lowercased we're representing a
lowercase a and a lowercase z we're not
we don't care about the uppercase
because we have control over the message
so that is what we have decided together
within this within our offset char we
are also
only allowing us to do a left rotation
we are going to be looking at the lower
bounds with this if statement right here
to to account for left rotation to
perspective
if you have the letter e if you want to
shift it the whole entire alphabet
around the
letter e three the amount of three
you could do e f g h
or you could do e d c
b so that's three but that's either way
we're only allowing for a left rotation
if we wanted to do a right rotation as
well well
let's just add that in there why not
it's basically the same exact thing we
got going on here but
we want to shift around the less than to
a greater than
and it's going to be greater than the
last character
of the alphabet and that is the letter z
that we have determined up here
and then we also want to do c minus
alphabet size
not c plus alphabet size so we just
change up a few things
and then we obviously change return zero
to return
c and this is
caesar cipher however since we're doing
everything in eclipse the way that we
want to
run this in order to make it cleaner we
want to create a
main.java file and we're going to be
creating a main method within that
main.java file and that is basically
going to be
our operations that is what we're going
to say hey
run this because whenever we click this
run button up here it's going to look
for our main method
it's going to run our main method and
then we'll start basically doing all of
this code
from our main method but we'll get into
that we come down under source
main right click new and we're going to
create a new java class
so under java class we're going to name
this main remember capital m and which
method stubs would you like to create
we're actually going to create a
main method we're going to check that
and click finish so this is what we're
going to do within main
while we are going to be calling our
cipher here
we're also going to be determining hard
coding in
for the purpose of this so you can
actually see how everything works we're
going to be hard-coding in
the message we're going to be
hard-coding in the offset
we could prompt the user actually
if we wanted to to type in the message
and then type in the offset
i don't know we'll figure that out here
in a second but what are we going to do
we're going to have
we're gonna have caesar's cipher so we
need caesar cipher here
let me let me take a second right here i
know i was previously going through the
whole entire code and then explaining at
the end but as i do it
i think it would make a little bit more
sense okay let me take it back a step
so caesar cipher this right here is a
whole entire representation
of this file right here this class
i should say so this class caesar cipher
we created an instance of this class
within our main with this line right
here
so caesar cipher that is obviously
referring to this class
we just named it caesar cipher we could
name this whatever we wanted to we could
name this
bob as long as we call it as bob it
doesn't matter but
conventions you name it the same exact
thing you just
lower case it and then it gives you the
ability to call
anything any object within that class
and it has a list right there but if you
have a lot of objects within your class
you can just start typing and then it'll
obviously filter out
hit enter and now it's asking us okay we
need to fill in the message and fill in
the offset
so what we can do here is we could
create a variable
that is message let's just do that
message and offset
everything is separate when it comes to
this particular class and the other one
so right up here let's just create
message um what is message messages
string
how are you doing today remember we
didn't take into account any of
any of this any any special symbols
and uppercase so what i'm doing right
now i think i'll just ignore the special
symbols not 100 sure but what we're
doing right now how are you doing today
and then we're going to throw that into
supersize
caesar's decipher we're going to have an
ant offset
and we're going to put an offset of
12. i'm gonna format this a little bit
better i'm gonna keep that there i'm
gonna keep that there
and this is what we got going on so if
we come on
up here we click run main java
it does all the work but it doesn't tell
us anything because we haven't
printed out any of the work so what do
we want to do here
right so let's take a second right here
because i made a mistake i made a
mistake obviously i didn't test my code
thoroughly
beforehand as you can see it ciphered
our message and i'll explain a little
bit as to why here in a second
but it suffered our message but it also
shifted
all of our spaces so you can see space
space space space so these are
after three characters after three
characters after three characters so
three characters space f three
characters
f three characters f five characters
five characters f capital f so what we
did here is we forgot to
basically ignore the spaces not within
our character array but within
our cipher so what we're going to do
here within our character we're going to
do an if statement
if
all right so what we've done here i'm
going to save that so if
character i does not equal space
then we're going to offset the character
by
what we're doing all within this method
that we call it up here
now it should work all right let's test
this out
cool all right now that we have
everything printing out exactly what we
want to we have our original message
we have our offset and we have our
ciphered message
we actually have a little bit of
redundant code so since we're printing
out
our ciphered message and we're running
the code right here we don't need this
code right here so we could delete it
we also could run this code and assign
it to
we could say string ciphered
message
and we can basically let let's do that
so it just so that it's a little bit
more clean
a little bit a little bit cleaner all
right and that should do the same exact
thing
that should do the same exact thing here
all right cool so
now that we have exactly what we want
printed out in our our code seems to be
working
as as planned allow me to take you
through basically the order of
operations that happens
that eclipse does when it runs our code
from the time we click this run button
to the time it prints out what we got
going on down in the console
so whenever we start off we click this
run button it looks for our main method
so our main method is right here in our
main class
and it runs this code but not all of it
at once it goes it goes line by line so
on line 7 we're declaring our message we
want our message to say how are you
doing today
this is the message that we want
ciphered and on line eight we are
determining the offset
of that of that message to be ciphered
and that is the value of 12. pretty
simple stuff
on line 10 what we are doing is we are
creating an instance
of the class caesar cipher and we are
giving it the name
caesar cipher so every time we call
caesar cipher which is right here
we are basically accessing putting our
hand down into
the the class that is caesar cipher so
now we are able to
access all of the code within these
curly brackets right here
which is all of the code so we can even
access letter a
or letter z or alphabet size all of
these are objects
creating an instance of caesar cipher
we're able to
access those objects and that is exactly
what we're doing on line 11. so on line
11
let's look at the code that is being
executed remember this code on the right
side of the equal sign
whatever the result of this is going to
be stored
into ciphered message just like the
value
how are you doing today is being stored
in the string
message or the value of 12 is being
stored
in offset every time you use offset that
is just a representation of 12 because
that is the value in which it's storing
every time you use ciphered message from
here on out which is right down here
you are accessing the value in which is
stored in there
after running this code but what this is
where we basically run all of the code
so caesar
cipher that is obviously the instance of
caesar cipher class
and what i say before we want to be
specific with what object we choose to
dip our hand down into
so we said hey we want to access the
method cipher so we're going to be
accessing the method cipher that is
within the class
caesar cipher we're going to be passing
in our own parameters
of our string message which is how we're
doing today
in our int offset which we have given at
the value of 12.
all right now let's get into it within
the cipher what are we doing here
so we have our offset now this is now
equal to 12.
and this message right here this is now
equal to how are you doing today so now
that it's in our method
cipher it's going to start running the
code so line 10 runs line 10
it runs line 11 and remember line 11
that is turning our string
called message which is how are you
doing today into a character array
called
character and then on line 12 we are
going to be calling offset by the method
offset by right down here and passing in
the parameters
character and offset and then basically
what in line 12 it is going to access
all of this code it's going to run all
this code it's going to run the for loop
as long as it allows it's going to
hop into the if statement as long as the
character i does not equal
a space and it's going to run line 19.
now remember on line 19
we are running this code and we're
actually going to be storing it
within character i so this code right
here this is
us uh calling the offset char method
down here
passing in our parameters so every time
we come through a letter we run
all of this code return the new letter
to be stored within character i so
basically it comes down to the h
the h is offset by 12 and now that
h equals a t we return t into our
character array
and then we go on to o and o it's offset
by 12
that is now an a we return a
and now that is being stored in our
character array so on and so forth you
get the idea until
we are at the end of our character array
and then on line 13 what we're doing is
we're returning new
string character which now no longer
equals a character array of our message
how are you doing today
it now equals a character array of our
ciphered message which is time mid cu
it's not supposed to mean anything
that's a whole point of ciphering a
message but
now this right here is stored
within this because this line 12
ran basically all of this code which ran
all of this code i just love it and then
with so now that we are out of our
cipher method and remember the last
thing we did in our cipher method was
return our character which is now this
and we are going to be storing it
because remember everything that we just
talked about
is this right here and we're going to be
storing it our character will be
returned in our cipher method
into our string ciphered message you
follow me here
and what we're doing down here is we're
printing out our original message which
is how are you doing today
we're printing out our offset which is
12. and we're printing out our ciphered
message
which that we ran all this code
is time mid q i'm not going to say all
that again but
that's what it is and that is exactly
how this code works
now let's write some tests we already
have our seizure cipher.java we already
have our main.java
and just as we created those down under
source main we're going to create the
test under source
test makes sense right we're going to
right click go over new
not go over class we're actually going
to come down here and we're going to
create a junit test case
since we're writing these tests for
caesar cipher.java we're actually going
to name this caesar
cipher test the only change i'm going to
make here is
select new junit jupiter test instead of
junit 4 test we're going to click finish
we're going to add the junit 5 library
to the build path okay
and now it's time for me to write some
tests and hope that they work i'll get
back to you
all right so we have two tests here that
should work they're telling us that they
should work but
let me explain a little bit of what
these tests are actually doing first so
first and foremost we have to create an
instance of caesar cipher within our
test just as we do with main
because we need to access that and then
our first test test ciphered message
with offset of 12. test names are
typically
very very specific to what they're
actually doing so you avoid any type of
confusion because maybe you want to test
separate message with offset of 11. you
want to make sure that it's very
specific
assert equals within our test this is
basically saying
that this on the left side of this comma
right here
is equal to this on the right side of
this comma here
we are asserting that these two values
are equal so let's actually take the
right side of it first
caesarcipher.cipher and we're passing in
the message
how are you doing today and we're
offsetting it by 12.
well we we've already done this we know
that if we pass in the message how are
you doing today and off setting it by 12
just as we see down here
our ciphered message is time mid cue
this and as you can see this is the same
exact as what we have right here
so yes this value is the same as this
value
this test should pass and then on our
second test we are testing an empty
stream we're
doing exactly that throwing in an empty
string within our cipher right here
we are saying offset this by 12 but
since there's no letters
and it's an empty string we should get
back the same exact thing which is an
empty string so in theory this test
should pass as well as a matter of fact
let's go ahead and test this we can
right click
come on down to run as we right now
we're going to run it as a junit test
all right cool very nice we tested it
all right test ciphered message with all
set of 12
passed test empty string passed now
let's let's do a let's do a failing test
all right well this is our failing test
very quick all we're doing is testing
ciphered message with offset of 11
we change the offset it's the same exact
thing as this we changed the offset
from 12 to 11 but we kept this
value the same meaning it should be
wrong
so we're going to come down here run as
j unit test
and boom it failed now there's two
reasons a test will fail
one is that obviously the test is
written incorrectly
but two and this is the main reason you
write tests it shows broken code
so if we know that this right right here
this 12 offset of 12 we
know that this value should be equal to
this value
but it's not that means our code is
wrong somewhere
that means the offset is incorrect maybe
the way you put in the array
maybe you added one and now the offset
is all weird because the array started
zero
it could be anything and that's when you
have to start digging into why is this
test failing
but for now i'm actually just going to
comment this out
highlight all of it control slash
comment it all out
save cool all right so cool we know our
tests work i'm going to run it one more
time just to make sure junit tests okay
those work i'm actually going to come
back on over to our main.java file
come over here and click run to make
sure that works okay that works exactly
how it should work
i just want to test that out because our
next step is creating a github repo
and pushing all this code up to the
github repo and you always want to make
sure you test your code
test your test before you push it up to
your remote repository so you want to
come to your github account i'm
obviously logged in as myself
github.com in case any of y'all want to
follow me
you want to come on up here you can
click new right here but this one's all
regardless of what screen you're on
hit the down new repository we're
creating a new repository repository
name
we're going to name this caesarscipher
youtube and now with you you could make
this public but since i'm creating a
video and you all won't be seeing this i
i will make this public eventually
probably whenever this video goes live
but for now i'm just going to make it
private
i'm not going to initialize readme if i
wanted to do the creator read me i could
just do that in eclipse
i'm going to create the repository this
is what an empty repository looks like
but for now we're going to hop on
it back into eclipse and we want to hop
on over to our package explorer window
right here this is obviously our cesar
saver project
we're going to right click on caesar
cipher come down to
team and over on team you'll see shared
project click on that
and right on here this is our configure
git repository basically what we're
doing right now is we're creating a
local git repository
that way it'll be consistent with a
remote git repository that we just
created on github
and for this particular instance we're
going to user create repository in
parent folder
project we're going to click on that
we're going to come down here we're
going to check this
we're going to create a repository right
here and we're going to click
finish we should be good to go now what
you want to do there are different ways
to do this there are different ways to
do all of
what is mentioned in this video but in
order to take full advantage of our
tools we have within eclipse
we're going to come right over here to
our upper right we're going to hover
over
open perspective click on that and we're
going to come on over here into git
we're going to click on it we're going
to open now this
is pre-installed on your eclipse but
just in case it's not for whatever
reason click on help
come down to eclipse marketplace type in
egit hit enter
and install this right here if it says
install then you have the option for
that perspective
so this right here this is our get
perspective and this is our project
our get repository that we actually just
created this is that's our project but
we want to come down here to get
staging see this is the middle tab get
staging you'll notice that all of these
are unstaged meaning that these are
inconsistent with our remote repository
we want to stage all of these we want to
type in this is our initial commit but
before you commit i do want to point out
something when you come down to author
and committer you may notice that it is
your actual pc
user that is your author and your
committer but you don't want it to be
your pc user
you want when you commit up to your
github repository to show up as your
github user otherwise it'll show as a
non-github user and it'll actually say
whatever your
pc name is you don't want that so in
order to fix that what you do is you
come up to window
you come down to preferences you type in
git and it'll say team get configuration
so you want to type on configuration
right here and it'll open up with this
table
if it doesn't open up with this table
click on user settings and actually your
table will be
empty won't have anything i've already
added my user but what you want to do is
you want to add entry
you want to type in user dot name and
your value is going to be your github
username
mine is obviously farsnite and you want
to add and then you add entry again you
do user.email
and your value is going to be your
github email click add
you want to apply apply and close and
then now you can change your author and
committer to what you just added so
exit out of that start typing in your
github username
mine as far as knight so i can click
right here and add it as far as night
same thing for committer same exact
thing for committer and just make sure
it is
consistent with whatever your github
username and user email is
if it doesn't show up under that drop
down just type in your username do a
less than sign type in your email
greater than sign
just as you see formatted like this and
we're going to commit and push to our
master branch
now now what you're doing is you're
going to connect this local get
repository right here
to your remote git repository right here
and how to do that
make sure that https is selected come on
over click
copy that's what that button does right
there go back on over to eclipse
and under location uri you want to paste
in what you just copied your user and
password will probably not autofill like
mine did
but for user type in your github email
and for password type in your github
password that is how your local
repository is going to be able to
communicate with your remote repository
within your github account okay
preview everything looks good to go
preview
okay and push cool and close now what
that just did it pushed all of your code
and all those files up into this
repository right here just
click f5 or refresh and now you can see
all of your files
cool now it is time to implement a
continuous integration workflow using
circle ci
now the link to this is going to be in
the top of the description
click on that and it'll take you to this
page right here obviously what you want
to do is sign up with github
i'm already signed up so i'm going to
log in with github wherever it ends up
taking you whether that be your project
dashboard or your workflow pipelines
wherever it may be
come on over to add projects and you'll
notice that
all of your github projects are listed
in here private and public obviously
this is our caesar cipher youtube
project you want to set up this project
obviously our project is a gradle java
project that is why we created the
project as a greater project instead of
just a java project
in order for all of this to work and
we're going to start building
but we need to make a change first back
going over into eclipse
you can change back into your java
perspective right here up in your upper
left
and we're going to come down to our
build.gradle file and we're going to add
two dependencies we're going to add a
new test implementation we're going to
add a new test
runtime only now we're going to keep
this old test implementation as well the
reason for this is because our junit
test that we wrote within
caesar cipher tests this is using as you
can see junit.jupiter.api
junit 5. i mean you can see that junit
five is right here
in our project we could have chosen
junit four i want to use the latest and
greatest so j unit five
and within our build.gradle file we just
need to ensure that test implementation
junit.jupiter version 5
is what we implement test runtime only
junit jupiter
version 5 same exact thing i also want
to note something that i previously
forgot to add
into our build.gradle file and that is
underneath our dependencies
we're going to add a test so within our
test we're going to have to use
junit platform otherwise when we when
circle ci
it does its job and runs our tests it
won't be using the junit platform so it
won't recognize a
failing test versus a passing test so we
need to make sure that we have that into
our build.gradle file
and what we're going to do is we're
going to stage our build.gradle change
so hit the plus sign okay it's staged
and we're just going to say
updated gradle file i'm going to commit
ambush
you'll notice back on over here that we
just updated greater file just now
cool everything is connected you can
just go into your get perspective with
any clips and you're good to go
now we're ready now we're going to come
back on over to our circle ci setup
and we're going to start building now
what this is going to do
add this config to your repo is to
create a new branch on the user's
project called circle ci
dash project setup and that is to add a
circle ci config template based on your
language which is located in a newly
made
dot circle ci directory called
config.yaml now this is done in a
separate branch so you can test your
configuration like you would
any other code add config it'll take you
over to our pipeline you'll see that it
is running
and we can only hope that it works and
it did wow cool
that took 25 seconds we can drill on
into this click on success right here
and you can see step by step
exactly what the config.yaml file is
doing for so it starts off with spinning
up the environment
which is creating a docker container and
running this image in here as you can
see
the image is cached as circle ci open
jdk 8 jdk
you can see where we told it to do that
in our config.yml file build.container
with this image and then it starts
preparing environment variables where
using build environment variables all of
these are environment variables
we specifically declared our working
directory as this repo where as you can
see our repository url is cesar set for
youtube on our github
repo name is usually set for youtube so
on and so forth and we're taken from
branch circle ci project setup
and then it checks out our code this
step right here we'll check out our
project source code into our working
directory
and then we're restoring cache whereas
we don't have anything
cached just yet because this is our
first build next up is gradle
dependencies
obviously if you recall we added in a
gradle dependency if i can find it right
here to run our junit tests
those along with the boilerplate gradle
dependency code
are being run right through here and
then we are saving cache to be used in
future builds
when we are going to be restoring the
cash so in build two
restoring cash will pull from our save
to cash and then we are running our
gradle tests our junit test
and how it's able to do that is because
we added those gradle dependencies for
our junit tests now we can come back
over and see
a little bit more in depth of what it
did so notice right here it says one
branch because right now we have
a master branch we refresh this and
you'll see now that we have two branches
we can view our two branches we have our
master branch but we also just created
that new circle ci dash project
setup branch via circle ci i'm actually
going to drill on into this
we'll obviously see that our latest
commit checks out
code builds test pass cool and if we
wanted to we can click on this compare
compare and pull requests and i am going
to create this pull request
merge it on over all right all checks
have passed that means our circle ci
jobs have passed and
this branch has no conflict with the
base branch we can look at all checks
and that is ci circle ci build your test
pass on circle ci that is our circle ci
job telling us
that our tests that we wrote passed and
this is safe to merge into our master
branch now what i'd like to do is merge
our pull request into our master branch
and this has taken everything from our
circleci project setup
that is different from our master branch
obviously that is our config.yml file
and we're going to merge
that pull request in other words that
code over
into our master branch that looks good
confirm
merge now you can see that we have our
config.yaml file merge on over to our
master branch now
something to note is that one of the
main reasons why you have multiple
branches well there's a few main reasons
one
you're implementing a new feature so you
have a ticket you're working on this
feature and before you push it into the
master branch for
all of production to see you push into
your feature branch for
circle ci to run all your tests do the
circle ci jobs and make sure that your
code is good
but also for code reviews to ensure that
you are writing the code in the best
possible way
and if not then your team can help you
write a little bit better code
another reason is you can have multiple
different branches you can have for
development
and that is what your development team
works on before it goes up to a
qa branch where you have people whether
that's end users or qa testers
testing it and then up into production
branch and of course that goes to a
production server so with this
what we just did is we just added our
config file to our master branch
we can delete that branch that we just
had because
once you merge it over into master
there's no reason to keep it other than
for
record sake and for this particular
instance we're just going to delete it
so you can just click on branches right
here
come on down you'll see your branches
active branches circle ci projects set
up
and we can trash that all right refresh
this page and you'll see that it is no
longer there as you can see
what we have left is our master branch
now what i want to do is show you what
happens when we
throw in a failing test remember the one
that we wrote earlier right here
into the mix to see exactly what circle
ci
will do now before we do actually before
we do anything what we're going to have
to do is
come over here right click and pull
we're going to pull down
the merge that code that we merged from
our circle ci branch over
into our master branch so we're going to
pull that down we're going to merge when
pulling okay
and good to go all right and that just
pulled down that config.yml file from
our remote repository up on github down
to our local repository repository here
on our local machine as you can see what
we can do now is stage our change but
we're going to hold off on that we need
to right click on our caesar cipher
git repository directory right here and
we're going to come down or right here
to switch to
new branch because we don't this is
technically a new feature writing a test
well
branch name could be feature test
one all right that worked for me we're
gonna check out new branch and
finish all right cool so now we're going
to be pushing up to a new branch we're
going to stage
these changes add a new test commit and
push we can ensure that our branches
feature test
1 next all right looks like everything
worked
and finished you can see that our
config.yml file that we had pulled down
from our master branch and pushed up to
our new feature test one branch is
running
and then right down here you can also
see that when we merged over our
config.yml file into our master branch
it also re-ran that did our circle ci
jobs
and obviously it was successful because
of the same exact code but obviously it
failed here because we introduced a
failing test so let's take a look into
that within our gradle test that is
where we expected it to fail
obviously when you are in the real world
you're not
knowingly introducing a failing test so
what you would want to do is come down
over here to gradle test and take a look
at what it's telling us so you can see
right down here task
test failed and it'll let you know
exactly what failed so within our caesar
cipher test class
we have our test ciphered message with
offset of 11
method that failed and obviously if we
come back on over here we can see that
our method within our caesar ciphertest
class
test ciphered message with offset of 11
failed but now we discussed earlier in
this video
why this was a failing test because
we're asserting that this value is equal
to this value
when in fact it is not and it gave us a
good look at
what it looks like when we introduce a
failing test
into our code and this is what it looks
like in our circle
ci workflow build now remember just a
second ago where
we had a successful circle ci build and
it told us that we were able to
merge our pull requests we can't do that
now because we have a
failing circle ci build therefore
they're not going to let you merge that
over to our master branch which is
i like that and that is how you go from
having nothing but a windows 10 laptop
to a
working running job application up on
your github repository
with a continuous integration workflow
thanks to a circle ci
hope you guys enjoyed this video it was
a lot of work so please if you did make
it this far if you did like the video if
you found
any useful information out of it
give it a big thumbs up share it with
your friends and don't forget to check
out
circle ci all the links are down in the
description
below
[Music]
you
