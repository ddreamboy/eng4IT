Software testing plays a very important
role in advancement of software those
poor software testing methods prompt to
unpredictable development times an
unstable software testing lifecycle it
is exceptionally fundamental to have
best software testing methodologies to
guarantee that the software product
convey to end-user is strong highly
reliable and stable. Hey guys this is
Archana from Edureka and I welcome you
all to this session on software testing
methodologies and techniques. But before
we proceed any further let's go ahead
and take a look at today's agenda we
will begin this session by discussing
importance of software testing and then
it will get started with our today's
topic which is software testing
methodologies we will learn different
methodologies their advantages and
disadvantages
moving on we will get started with our
second topic which is software testing
techniques we will discuss different
techniques their advantages and what
they mean we will also discuss different
techniques that come in the black box
model white box model and experience
based model and with that we will
conclude the session so I hope agenda
was clear to you guys let's get started
there every system has software bugs
well it's true it's impossible to design
and bring out a perfect software product
imperfections in software can sometimes
cause unbelievable disasters history
knows many examples of such situations
when software flaws have caused billions
of dollars in waste and even led to
casualties sometimes for example we have
Starbucks coffee shops they were forced
to give away free drinks because of a
register malfunction
the f-35 military aircraft was unable to
detect the target correctly because of a
radar failure a high voltage power line
in northern Ohio brushed against some
overgrown tees and it was shot on well
normally the problem would have tripped
an alarm in the control room but due to
some software glitches and issues the
alarm system failed and in 1985
therapy 25 radiation therapy machine
malfunction due to software bug and it
delivered lethal radiations to patients
living three people dead and critically
enjoying others well these are some
examples
apart from these you come across many
simple examples in your daily life
a website you find an internet might
seem fine at first but as you scroll
down go down at the page or try to send
a contact request it can start showing
some design flaws and errors this makes
quality control and software testing
very important in every field where an
end-user product is Invo so software
testing provides as lot of benefits it
gives confidence in the quality of the
final product it saves a lot of effort
time and money for the organizations
that are developing and selling the
product because once the product is
tested they can be sure that they'll be
no faults that would prove fatal to them
later on it even offers business
optimization it confirms that the
application is able to operate perfectly
under all required conditions and it's
supported on all other operating systems
and web browsers correctly this way it
enhances user experience and customer
satisfaction and obviously all this
factors benefit the company they
increase the money and the profit for
the company so these are some advantages
that software distinct avails to us so
like I said earlier it's exceptionally
fundamental to have best software
testing methodologies to guarantee that
the product conveyed is strong reliable
and stable so when I say testing
methodology I mean combinations of
principles ideas methods and concept
that help you during the testing process
testing methodologies are simply
strategies and approaches used to test a
particular product to make sure that it
fits the purpose so as software
applications get more and more complex
and get intervened with many different
platforms and devices it's more
important than ever to have a robust
testing methodology because a
methodology it manages user requirements
test cases bugs all in single integrated
test environment
it offers full traceability throughout
the testing lifecycle it acts as a
complete testing solution that includes
management requirements test case
designs release management and many
other things it provides a complete
picture of software product and its
health issues or you can say status it
leverages current technology investments
when many other automated testing
solutions and offers best testing
experience that is why when you start
with testing you need to have a proper
suitable testing methodology does Nava
days there are dozens of software
testing methodologies each with their
own starting points duration of
execution and methods that are used in
each step the more well-known among
those are we have waterfall model we
have V model agile model spiral model
you have something called RUP that's
rational unified process and rad model
that's nothing but rapid application
development model extreme programming
and many others choosing the proper one
can be a harsh experience that's why you
should know what each model mean what
has to offer what are the disadvantages
where they're applicable where they're
not applicable and their advantages so
in this session we're gonna discuss each
of these models in brief but before we
proceed any further I want to let you
know guys one thing people often combine
software development models with
software testing models because the
development of the software and the
testing most of the time are done in
parallel not exactly parallel but as
soon as the software is developed it's
Center testing so when they mean
software testing methodologies they're
almost same as software development
models itself
don't confuse anyway let's get started
with our first model which is what a
full model I'm sure you've heard of
waterfall models right it's one of the
most popular model in software
engineering
well the waterfall model is one of the
oldest models developed by Winston Royce
in 1970 it's also known as linear
sequential life cycle model the
traditional waterfall testing approach
it represents multiple stages in a
sequential manner that flows
progressively downward just like
waterfall
the name waterfall model it means that
you can move to the next phase of the
development or testing only after you
have completed the previous phase
successfully so once a face of
development is completed you can proceed
to the next phase and there's no turning
back
as in once you start with the design
phase you cannot go back to the
requirement phase this approach is
useful when requirements of well known
you sure about the technology and you
have understood the technology and all
the resources with required expertise
are available and there at hand
in such cases this model is highly
useful as you can see it has like five
phases first you begin with requirement
phase that's nothing but capture and
analyze all the requirements and make
sure whether they are testable or not
then you have system design you create
in document designs based on the
requirements which you collected in the
previous phase you define the hardware
and the software requirements as well
next up we have implementation you
create robust code for components as per
design and then integrate them and
obviously next we have verification
that's nothing but testing integrated
components they form a whole system here
you make sure if the system is working
as per the requirements you also keep
track and report the testing process you
also make sure that the system is stable
with zero bucks and it passes all the
tests criteria and environments at the
piste perfect
so basically in this step you're making
sure that your product is perfect and
lastly you have system maintenance you
make sure if the application is working
efficiently as for the requirement
within the suitable environment in a
case a defect is found then that should
be fixed and deployed or updated and
later on so that's all about waterfall
model talk about advantages and
disadvantages the main advantage of
waterfall model is that it allows for
departmentalization and managerial
control apart from that it's very easy
to understand and easy to manage because
it's easy to understand it allows for
easy testing in analysis it says
significant amount of time talking about
disadvantages the disadvantage of
waterfall model is that it does not
allow for much revision so once an
application is in the testing phase its
very difficult to go back and change
something like acid olio because of that
it's Chardon flexibility it lacks the
visibility of the current progress as in
you cannot see what's happening right
away and the most important thing is
changes in the business requirements or
new additions and functionality require
changing all the previous steps
lastly the end product is available only
at the end of the cycle so these are
some disadvantages next up we have V
model so V model is basically an
extension of waterfall model where the
process execution takes place in a
sequential manner but in V shape which
is clearly visible on the screen as you
can see there's an image so as you can
see in the image below there exists a
directly associated testing phase in
each phase of development cycle as you
can say the requirement analysis is
associated with operational testing and
acceptance testing then you have eye
level design which is associated with
integration testing
similarly detailed specification is
associated with unit testing so
basically using the sui model you can
perform started testing verification and
review that helps to prevent possible
defects in the latest issues well you
can say that this model is basically
divided into three phases we have
verification phase next up is the coding
phase and validation phase and
verification phase and validation phase
are done in parallel or you can say each
testing phase is associated with a phase
of development cycle so guys the phases
of the model are changeable but usually
they include the following phases as you
can see a requirement phase is
associated with acceptance testing its
main purpose is to evaluate if the
system is ready for the final usage then
you have high-level design phase which
relates to system testing and includes
evaluation of compliance of specified
requirements to the integrated system
and next up we have detailed design
phase which is in parallel to
integration testing that checks the
interactions between different system
components after that the coding stage
begins where you have another necessary
phase that's nothing but unit testing
it's important to make sure that the
behavior of individual parts and the
components of your software is correct
and it meets the requirement so
basically in coding this phase it
contains actual coding in the
development lifecycle so programming
languages should be chosen based on your
requirements talk about advantages and
disadvantages of this model like I said
it's just an extension of waterfall
model so the advantages and
disadvantages are almost similar apart
from that it's simple to use easy to
understand it's good for small projects
and it's highly cost effective and
compared waterfall model and there's no
overlapping between the faces because as
you can see the inter-process is
sequential talking about disadvantages
just like waterfall model no inherent
ability to respond to changes you have
to change all the steps and testing is
usually squeezed in then and the absence
of your solutions that eliminate the
software defects that's one of the most
important disadvantages of the model and
it's not suitable for large and complex
projects that's it about the V model
let's move on to next model which is
incremental model well everything is
said in the name itself you can consider
the incremental model as a multi
waterfall model of software testing the
whole incremental process here is
divided into various numbers of cycles
each of them is further divided into
smaller modules each iterations add a
specific functionality of the software
so an increment here actually includes
three cycles software designing and
development testing and implementation
as you can see in the diagram I have
build one which includes all the three
phases then I have built two a
functionality has been added in the
build one and then we move on to the
bill two and add another functionality
that way you develop a product in
incremental process another good thing
with this model is that simultaneous
development of different product
versions is possible for example the
first version can pass the testing phase
while the second one passes the
development phase the third version in
turn can pass the designing phase at the
same time so simultaneously you can
develop different product versions while
you can continue this until your product
is perfectly developed well it all says
in the name itself right incremental
model as you go on in every build you
add a new functionality
and at a single point of time you can
have multiple bills or multiple versions
being developed the advantage is that
it's more flexible and it's cheaper when
you have change of requirements also the
software testing process here is more
effective since it's easier to test and
debug if you are using smaller
iterations but the disadvantage is that
it's costlier when compared to waterfall
model that's all about the incremental
model it's simple next up we have agile
model agile as you guys know has become
one of the most popular software
development methodology in recent years
in parallel it's also known as software
testing methodology so majority of
phones use agile techniques in some
capacity or other for software
development and testing projects so with
agile developers build software
incrementally well you can say it's a
type of incremental software testing
technique so they pick the project down
into small segments of user
functionality which we call stories
prioritize them and then continuously
deliver them in two weeks cycles called
sprints the testing methodology is also
incremental each small release is
thoroughly tested to ensure quality as
you can see I have increment 1 I have
request phase after that it's tested
it's coded and design so you can see
that increment is a small release its
tested perfectly for each and every
defect and the quality is ensured and
then we move on to the next increment
and we have the same process being done
again but we add further more
functionalities to the previous
iteration so basically this entire
process of iteration allows testers to
work in parallel with the rest of the
project team throughout the process and
fix the flaws and errors immediately
after they occur so the main goal of
this approach is that they have to
deliver a new software feature fast and
that do with the best quality so it
focuses on responding to the change
rather than extensive planning like in
waterfall model waterfall model is all
about planning one phase after other and
not going back again but here if you
have a requirements change you interact
with other team or the other increment
and make the changes as soon as possible
and release the product in small cycles
so the
what's the profit of agile model next up
we have advantages so as you can see it
has a lot of advantages to offer it's an
adaptive approach that responds easily
to the changes unlike waterfall model
since flaws and defects are easily found
and corrected the quality of the product
will also be improved and it'll be best
it allows for the dyadic communication
between the testers and other people
involved in the testing process or the
software development process it's highly
suitable for the large and long-term
projects because you can release the
product in small iterations so that's
what makes it more suitable for large
and long-term projects it promotes
teamwork because it allows for direct
communication which directly affects the
team book it's easy to manage pickers we
are handling the small Willie cycles in
a variation and lastly it requires
minimum requirements or resources you
can say talk about disadvantages it's
highly dependent on customer feedback so
every small iteration you release it to
market you wait further customer
feedback and based on that you develop
the next iteration obviously there are
bugs in addition to that you also take
the customer feedback as well so it's
highly dependent on clear customer
requirements of trend and there's this
maintainability risk involved it's
difficult to predict time and effort for
large projects it lacks documentation
efficiency it's not suitable for complex
project and there are chances of getting
off-track as the outcome of each stage
is not bad here next we have spiral
model spiral model is similar to
incremental model with more emphasis
placed on risk analysis so basically
here the importance is given to risk
analysis the spiral model has four
phases you have planning risk analysis
engineering an execution and evaluation
a software project repeatedly passes
through these phases in iterations which
we call spirals here so once the first
cycle is completed the second cycle
starts software testing starts from
planning and it lasts until the
evaluation phase so the main advantages
of this spiral methodology is that
immediate test feedback that's ready at
the third stage of each cycle since the
feedback is
while I been in every sprint or spidel
in this model it helps to guarantee the
quality of the product just like your
agile model however it's important to
keep in mind that this model can be
pretty costly one and it's not suitable
for small projects so the thing that you
have to remember is that the main
emphasis here is on risk analysis and
since you get the customer feedback in
the third phase the quality of the
product is really high so we already
discuss the advantages the first one is
this lower amount of risk due to hide
risk analysis and obviously it ensures
rapid development of the product the
quality of the product is really high
because every time in every spiral in
the third phase you get a feedback it
offers strong documentation control a
requirement changes can be easily
accommodated at a later date because
this is an incremental model just like a
gen model requirement changes can be
easily accommodated talking about
disadvantages it can be costly to use
when compared to other models it's not
suitable for small projects you have
large number of intermediate stages
because you have different multiple
spirals right it requires a lot of
technical expertise it's highly
dependent on risk analysis phase I think
I just said that so that's all about
spiral model so the last model that
we'll be discussing in this session is a
rad model or you can say rapid
application development this rapid
application development model is also a
form of incremental model where
components are developed in panel so
with right the focus is mainly on
building the prototype that looks and
acts like a final product in this
approach a prototype is created by
assembling the different components of
the software product that have been
developed in PAL so once you create the
prototype which is nothing but the
components assembled it is used to
gather feedback from the customer so
this rad model spiral model and agile
model are different forms of incremental
model then as you can see in rad model
it's divided into five phases or it
includes five phases we have business
modeling the first phase it identifies
vital information flow between various
business
then we have data modeling information
gathered from previous phase is used to
define data objects then you have
process modeling data objects which you
got in the data modeling step are then
converted to get business objective in
the third phase then you have
application generation various
automation tools are used in this step
to process the models to actual source
code and lastly we have testing and turn
over new components and all the
connecting interfaces are tested and the
object or the cycle or the product is
released to market so as you can see the
entire process goes on for about 60 to
90 days the rad model is recommended
when the product is required to be
delivered within a short period of two
to three months and there's a high
availability of skilled resources
talking about advantages it reduces
development and testing cycle time it's
not that expensive and obviously since
it's an incremental model it enhances
the customer feedback due to customer
involvement throughout the cycle talking
about disadvantages it requires highly
skilled resources if you have highly
skilled resources and if you have two to
three months of time and you have a
product to develop then rad model is
highly suitable and what are the other
disadvantages well it requires a system
that can be modularized as in divided
and it's hard to use with legacy systems
so this brings us to the end of software
testing methodologies discussion each of
these models employ a different testing
methodology to test the quality and the
security of software in different ways
and different stages so choosing one
among them can be quite complex and I
hope that what you've learned today will
help you choose a proper methodology
according to your requirements so guys
that's all about software testing
methodologies let's get started with our
next topic as you guys already know the
main purpose of software testing is to
deliver an optimum quality product at
faster pace to helped us to achieve that
there are multitude of software testing
techniques each with its own strengths
and weakness but what exactly is a
software technique what do I mean when I
say a technique software testing
technique refers to the procedure or a
way to test the saw
we're on the test by comparing the
actual and they expected results a good
software testing technique helps tester
to design test case in such a way that
minimal steps of test cases are involved
so the two key points with software
testing techniques is that you need to
have minimal test cases but they should
be able to capture maximum
functionalities of the software so with
testing techniques you can develop
smarter test cases reduce the number of
steps required in test cases so guys in
this session we will be discussing some
of the popular techniques and I've
divided these techniques into different
categories so basically when it comes to
software testing techniques that are
divided into three main categories that
would be white box testing black box
testing and experience-based testing so
we cannot discuss each of these
techniques which come under different
categories in brief let's begin with
black box testing so what is black box
testing black box testing is also known
as specification based testing here are
the testers analyze the functionality of
the software or the application without
knowing much about the internal
structure or the design of the product
so the main purpose of this method is to
check the functionality of system as a
whole to make sure that it works
properly and it meets user demands
well the key point that you have to
remember is that the testers perform
testing without knowing much about the
product there are a lot of testing
techniques that come in a black box
testing let's discuss each of them in
reef so guys first in list we have
equivalence partitioning in equivalence
partitioning input values to the system
or the application which is on the test
are divided into different partitions or
groups or classes based on its
similarity in their outcome so instead
of using each and every input value you
can use a value from each class or
partition which covers all the possible
scenarios to execute the test cases so
that way you can easily identify valid
as well as invalid equivalence classes
you don't have to perform testing for
each and every possible input value that
would be really hectic so this
equivalence partitioning makes testing
lot easier and it saves a lot of time
and effort
you're part one let's try to understand
what equivalence testing is with a
simple example let's say I have a test
scenario where have to test input
conditions accepting numbers from 1 to
10 and 20 to 30 so how do I write test
cases how many test cases should I
involve should I check every number from
0 to 10 and then 20 to 30 and then in
between and all that that would be
really hectic so what do we do I've
divided the number of input values into
fight possible test cases I have taken
values before 1 that's from any number
of values to 0 that's just before 1
which should obviously come under
invalid class because we want to test
the values which comment of 1 to 10 and
20 to 30 and next up we have valid
values that's the values which come
under 1 to 10 then obviously the values
between 10 to 20
those are also invalid because we don't
want to test those values as and we
don't want those values after that we
have values from 20 to 30 which comment
a valid class
lastly the values from 31 to be on
instead of picking each and every input
value from these 5 divided classes you
pick up a value and perform a test case
or execute the test case since rest of
the values come in the same category
whatever the result you get for the
particular value which should take can
be applied to that other values as well
for example for a range between 11 to 19
and taking a value of 15 so I apply 15 I
get 2 results now I don't have to apply
the same thing for 16 18 19 and 9
because I'm sure they all belong under
the same category which is 11 to 19 so
the result would be same as 15 that way
we can reduce the number of input values
that we have to test and save lot of
time and effort I hope you have
understood it right let's move on to
next type then that's nothing with
boundary value analysis well you can say
boundary value analysis is next part of
equivalence party Schneck it's a well
observed truth that greater number of
errors usually occur at the boundaries
rather than in the center of the input
domain for a test it seems logical right
you can find more errors at the boundary
rather than the values which are at the
center so when I say boundary it means
the value near the limit where the
behavior of the system usually changes
so in this span
value analysis technique test cases are
designed to include values at the
boundaries if the input is within the
boundary value it's considered positive
testing if the input is outside the
boundary value it's considered negative
testing so it includes maximum minimum
inside or outside edge typical values as
in the values which come in the center
and their values so here's a simple
example to understand let's consider a
testing scenario here you have to test
input conditions accepting numbers from
1 to 10 so using boundary value analysis
we can define three classes of test
cases here that would be input boundary
values as an exact boundary values which
is nothing but one and ten we want to
test all the conditions accepting
numbers from one to ten so what are our
boundaries exact out boundary small
enter then you have values just below
the extreme edges of input to me that's
before one which is nothing but zero and
before ten which is nothing but nine
then you have values just above the
extreme edge of input to me that's the
value after one which is nothing but 2
and the value after ten that's starting
with 11 so what are the boundary values
that you can consider to test your zero
one and two and nine ten and eleven so
instead of considering all the input
values you can consider this boundary
values because it's at the boundaries
where the behavior of the system usually
changes and then perform testing so
that's nothing but boundary value
analysis next up we have decision table
based technique a decision table
basically is a tabular representation of
different possible conditions verses
test actions you can think of conditions
as inputs while actions can be
considered as outputs so in this
technique we deal with different
combinations of input values
this helps tester identify all the input
values if he or she has overlooked any
because of that very reason it's also
known as cause effect table technique as
well so the first task here is to
identify functionalities where the
output depends on a combination of
inputs if there are large input set of
combinations then you can divide them
into smaller subsets which are helpful
for managing a decision table and for
every function you need to create a
table let's down all type of combination
of inputs and respective outputs let's
consider a simple example suppose a
submit button should be enabled if the
user has entered all the required fields
so the test scenario here is that a
submit button
Mastan should be enabled only if the
user has entered all the required fields
and when I say required fields that
would be name email and message as you
can see I have eight rules here or eight
possible combination of inputs the user
has given name and email but he has not
given message that would be a rule for
then the output would definitely come
and a negative case right submit button
will not been able suppose if the user
has not given anything that's name email
message he hasn't given anything
so obviously the submit button can't be
enabled nothing happens when you click
on the submit button
but suppose let's say user has given a
valid name valid email and the valid
message then when you click on the
submit button something happens that's
nothing but action so that way we
consider different possible combination
of inputs you would draw a table and we
point out what's the possible output for
that particular combination of input
next up we have state transition diagram
well in this approach the tester
analyzes the behavior of an application
on to test for different input
conditions in a sequence so you can
provide positive as well as negative
values to check how the application
responds your you can apply this
technique when an application how the
system gives a different output for same
input depending on what has happened in
the earlier state so the concept here is
you can use this technique when your
system is giving our different input but
for the same input and what do you call
such a system you call it system as a
finite state system you can follow three
simple steps to perform this testing
first of all you go ahead and create a
state transition diagram which as you
can see is there on the screen then you
build the state table to review the
state transition diagram that can cause
errors lastly your design test cases
from the state table which you have
created in the step two and the state
transition diagram which you have
created in the step one if you guys are
not familiar with what our state
transition diagrams let's
go ahead and check out an example let's
say you have to book a room you have
initiated a booking but right now if the
room is available the room count will be
decremented by one and the room is
assigned to you user moves in but let's
say the room is not available your name
will be added to the waiting list and
from the waiting list when once the
rooms become empty you will be assigned
a room if there is a room which is
available if not if you are a user gives
up then he'll be removed from the
waiting list that's it the process ends
there when you request a room for the
same input the input is what you are
requesting for a room we have two
different outputs one the room is
available you're getting a room and the
room count is dictum nted to Roo is not
available and you put on the waiting
list
so for the same input we have multiple
output that's what we call a finite
state system now once after confirming
the room the customer want to cancel the
room booking so what he does he cancels
and after that the room count is
incremented if there are anyone who is
in the waiting list
they're resigned with this canceled room
and suppose if the user has moved in and
he is done with it and he's reached the
agreement a date handy vacates through
the room count will be incremented and
it will be archived and into added to
the available room list that's how
everything happens in a sequence so guys
this state transition technique is
really unique approach for testing
highly complex applications which would
increase text execution productivity
without compromising on the test
coverage the last type under black box
technique is use case testing so first
of all a use case is basically a tool
for defining the required user
interaction it depends on user actions
and the response of the system to those
user actions this technique is
completely functional testing approach
as in there is no programming skill
required unlike other techniques you can
follow simple three steps to perform use
case testing first of all you need to
identify all the possible scenarios from
a use case for each scenario you define
a test case and a condition for that
test case to be executed and lastly for
each scenario you need to determine the
test data for the test for example you
can see a ATM system here so that's an
use case diagram which is
representing a typical ATM system
functionality and use cases that you can
consider the first thing is you have
operator who is responsible for starting
the system and shutting down the system
on responsible time then you have a
customer so when a customer comes to ATM
and he starts with whatever is doing in
ATM that's when our session begins
he's either withdrawing the money
depositing the money transferring the
money or inquiring about the balance in
some times it's quite possible that when
he's performing all that he might enter
an invalid PIN that is all try and use
keys which you can add to your use case
diagram and the transaction obviously
has to happen from the bank so that is
also a part of use case diagram as you
can see there's no programming here in
wall you just imagine the scenario and
you create a use case diagram so this
use case diagram is also one of the most
popular blackbox testing techniques next
up we have white box testing techniques
so white box testing is also known as
structure based testing unlike black box
testing this method requires a profound
knowledge of code as it includes testing
of some structural part of the
application so the main purpose of this
white box techniques is to enhance
security check the flow of input and
output through the application to
improve design and usability just like
black box we have lot of techniques that
command a white box testing let's
discuss each of them in detail so you
have something called statement coverage
or line coverage in this technique every
statement in the source code is executed
at least once so each line of the code
is tested which helps in pointing faulty
good in case of a flowchart every node
is to be traversed and tested at least
once so basically this entire statement
coverage your line coverage is based on
the assumption that the more the code
covered the better is the testing of
functionality however the problem here
is that with these technique we cannot
actually find the false condition in the
source code so for example you have a
certain set of code where it takes value
a and B and they're added in the values
put to see if the C is greater than
hundred then print it's done so in
statement or line coverage what are you
doing you checking exactly that you're
not going to check what happens if C is
hundred so what do you do if you have a
case where a and B are in such a way
that then added the value is less than
hundred so this is where the next type
of testing technique comes in that's
nothing but decision coverage or branch
coverage in this technique test cases
are designed so that each branch from
all decision points are traversed at
least once so if we consider the
previous example which we did earlier if
C is greater than 100 is the decision
point if C is greater than 100 print
it's done that's what we checked in the
statement coverage and line coverage but
we didn't check what happens if C is
less than 100 so at that particular
decision point you have two ways that
are being traversed so indecision
coverage of branch coverage you check
both the possibilities if C is greater
than hundred print that's done L
splendid spinning so basically this
method is helpful to invalidate all the
branches in the code to make sure that
no branch leads to any abnormal behavior
and obviously decision coverage includes
much more than line coverage so it's
highly powerful than statement coverage
or you can say a line coverage and next
up we have something called condition
coverage our predicate coverage
condition coverage is basically for
boolean expressions it ensures whether
all individual boolean expressions have
been covered and evaluated to both true
and false so I have a simple code here
which reads X & Y value compares them
checks if the value is 0 and if either
one of them is 0 it prints 0 so
basically we have two conditions here X
is equal to 0 and Y is equal to 0 now
these test condition get true or false
as their values so one possible test
case or one possible example that we can
consider here is it should have two test
cases in test K is 1 let's consider X 0
Y some random value but not 0 in that
case it'll print 0 right the program
because X is 0 similarly in test case 2
you put some value to X but consider Y
is 0 so again it prints 0 so in first
test condition X is evaluated to true Y
is evaluated to false in the second
condition X is evaluated to false and
vice evaluated to - so basically you're
checking every
individual boolean expression as covered
and evaluated to both true or false now
a little bit extension of condition
coverage is that multiple condition
coverage
unlike condition coverage in multiple
condition coverage every possible
combination of true or false for the
conditions relate to a decision has to
be tested if we consider the same
example which we did for the condition
coverage
I even have four test cases here in
first test case I have both x and y a 0
in the second disc case I have X is
equal to 0 in the third test case I have
Y is equal to 0 and in the fourth test
case I have both of them evaluating the
false that both of them are not 0 so
these are the four possible test cases
that I can write right so all possible
test cases I'll consider in multiple
condition coverage hence four test cases
required for two individual conditions
similarly if there are n conditions then
2 to the power n test cases would be
required just for your information so
that's all about white box techniques
next up we have experience based testing
as the name indicates these techniques
are logically drawn from experience in
designing test cases and test conditions
they are based on the experience
background and skills of a person in the
field of testing so basically here the
tester makes use of proper strategy and
documentation flying along with the
gained experience now let's discuss some
techniques that come on experience based
technique well there are about 4 to 5
but in this session we'll discuss the
most important ones which is nothing but
exploratory testing and error guessing
so first up we have exploratory testing
this technique is all about discovery
investigation and learning here the
tester constantly studies analyzes the
product and accordingly applies the
skills traits and experience to develop
test strategy and test cases to perform
necessary testing so the key words that
you remember here ha he studies analyzes
the product and according to skills
traits and experience he performed the
testing it's a very suitable technique
when testing team has inadequate number
of specifications requirements and
severely limited time error guessing
well it's a simple technique of guessing
and detecting potential defect
bugs and errors that are most likely to
occur in software product so in error
guessing no specific rules are applied
the new rules and conditions as to
tester should do this hope that it takes
advantage of tester skills intuition
trades and expertise to find defects
that might not be identified when other
blackbox techniques are used so this
technique totally depends on testers
experience again the more experienced
the tester is the more errors he can
identify well another way to actually
perform error guessing is that to
regularly create defect and failure list
this list can be further used to design
test cases and counter tagged the box so
guys with error guessing we've come to
the end of the session so that's all
about software testing techniques each
one of them serves best for the specific
type of problems in the software if you
use one more than others our test
coverage will suffer guys so remember to
choose the most suitable technique for
your projects not the most popular one
to conclude in this session we have
learnt about different testing
methodologies and techniques the
disadvantages advantages well there's no
such thing as one suitable methodology
for all project types the choice of
testing methodology or a technique
actually depends on the type of project
that you're working on customer
requirements schedule and many of the
factors so the same goes for the
techniques as well so choose wisely
thank you guys if you have liked the
video please do click the like button if
you have any doubts or queries please do
post them in the comment section and we
will get back to you I'll meet you in
the next session guys. I hope you have
enjoyed listening to this video, please
be kind enough to like it and you can
comment any of your doubts and queries
and we will reply them at the earliest.
do look out for more videos in our
playlist and subscribe to Edureka
channel to learn more, Happy learning.
