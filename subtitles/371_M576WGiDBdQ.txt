hello everybody and welcome to the free
code camp blockchain and solidity
beginner to expert full course python
Edition we're going to go through
everything you need to know for
developing on a blockchain using
solidity and engaging in the future of
Finance we're going to cover topics that
will teach you all the skills you need
to become a smart contract expert that
you can take with you no matter which
blockchain you're developing on
blockchain Engineers are in extreme
demand and they're building billion
dooll applications almost every day at
this point at the time of filming
protocols like a ur. finance and
synthetics have billions of dollars of
locked value in them allowing people to
engage and decentralized finance or defi
this allows people to make censorship
resistant moves and so much more some of
these protocols with billions of dollars
are even less than a year old so whether
or not you're brand new to this space or
you've been in here a while hi my name
is Patrick Collins and I live in the
smart contract World I'll be taking you
through your journey to becoming a
blockchain and smart contract expert a
little bit of background on myself I'm
an engineer and developer Advocate on
the chain link protocol and I also have
my own blockchain infrastructure company
called Alpha chain where I run different
nodes and different infrastructure for
blockchains including one of the main
Technologies we're going to be talking
about today which is ethereum I love
being a Pioneer in the smart contract
ecosystem and I love taking new users
like yourself along to the journey with
us and we are going to teach you to
become a smart contract expert building
blockchain and solidity applications is
building a world of more trust and
accountability it means building a
financially free future and we get to be
the ones that will go down in the
history books as the pioneers of this
space additionally blockchain and smart
contract engineering skills are some of
the most sought after in the world with
an average salary of a solidity
developer being between $ 150 and
$175,000 in this video we're going to
teach you how to become one of these
developers and go out into the world and
participate in the world of smart
contracts and the world of blockchain
this course is ideally for engineers who
know a little bit of Python Programming
and you can have any level of smart
contract engineering whether you're a
complete beginner to blockchains and you
don't even know what one is or you're an
advanced solidity engineer and you're
looking to learn more this is the
perfect place for you having a little
bit of experience in other
objectoriented programming language like
JavaScript as well will be helpful here
too and if you're brand new to coding in
general that's a right because we're
going to take you step by step through
everything if you do want a little bit
more in-depth python coding video there
is a fantastic free code Camp video in
the description if you do prefer
JavaScript we will also be releasing a
JavaScript edition of this video as well
but everything that you learn here will
be applicable there and if you watch
both you'll learn even more you can find
the entire itinerary for this entire
course along with all of the code
associated with everything that we do
and additionally discussions and support
and everything else in this smart
contract Kit full blockchain solidity
course Pi GitHub repository it has a
table of contents and then the entire
itinerary of everything that we're going
to go over in this course and like I
said with helpful tips resources for
getting support and resources for
getting help now for your convenience
every single piece of code that we're
going to go over in this video has a
GitHub repository associated with it so
be sure to grab the link in the
description grab that GitHub repository
and look through all the different repos
that we're going to give you if you ever
get lost or need to refer to some code
or want to copy paste some code all of
it will be there for you it'll also be a
great place to reference in the future
when you're working on some project and
you want to remember how to do something
so be sure to start and refer back to it
as you watch this video so let's talk a
little bit about some best practices for
watching this video this space moves
really quickly so if we show you some
documentation it might be a good idea
for you to open that documentation up as
well read through it as we do so you can
stay up to speed now we've packed a ton
of information into this video and
Studies have shown if you try to digest
a massive amount of information in a
short period of time your retention
isn't as good so it's highly recommended
that every 25 minutes to half an hour
you take a 5 minute break and then every
two hours maybe you take an additional
30 minute or an hour long break you can
pause bookmark areas and come back later
and learn at your own speed there are
time stamps in the description that will
help you come back to where you left off
and you don't even have to go in order
if you want to bounce around from from
topic to topic you're absolutely free to
do so we're also going to get really
technical with the fundamentals of
blockchain and if you want to just jump
right into solidity you can jump down
the time stamps below and get right into
it and if you're watching this on
YouTube you can adjust the speed that I
talk and then I give this presentation
so if I'm talking way too quickly for
you you can slow it down or if I'm
talking too slowly for you you can have
me speed up so be sure to set me at the
pace that you like best we're highly
encouraged to pause come back and ask
questions the blockchain and smart
contract world is a very collaborative
community so if you have questions some
of the best places that you can go going
to stack Overflow and tagging your
question with the specific technologies
that you're working on make an issue on
the GitHub repo that we're working with
go to stack exchange eth and make a
question there as well jump into the
Discord of the technology that you're
working with or even on GitHub
discussions if those are there learning
to become a blockchain and solidity
engineer is actually a lot more than
just learning solidity becoming
comfortable with all the tools in the
space is going to be just as essential
as becoming familiar with solidity
itself and continuing the conversation
on maybe Twitter or Reddit or any of
these other channels and maybe even
showing your stuff in the next ethereum
or chain link hackathon are going to be
majorly beneficial to increasing your
skill as an engineer now before we get
actually coding a lot of people want to
understand what is actually happening
with all this blockchain stuff what is
blockch what is a smart contract how did
this all get started and understanding
these core fundamentals will actually
shape the way you code and architect
your smart contract applications so
learning these is really really critical
however if you're already familiar with
blockchain and you just want to jump
into the solidity feel free to grab a
timestamp from the description and jump
to that
section now since you're here though
you've probably heard of Bitcoin before
Bitcoin was one of the first protocols
to use this revolutionary technology
called blockchain the Bitcoin white
paper was released by The pseudo
Anonymous Satoshi Nakamoto and it
outlined how Bitcoin could be used to
make peer-to-peer transactions in a
decentralized network this network is
powered by cryptography and allows
people to engage in censorship resistant
Finance in a decentralized manner due to
some of the features of Bitcoin a lot of
people took it to be as a superior store
of value over another asset like let's
say gold and that's why it's commonly
referred to as digital gold similar to
Gold there is a scarce and set amount of
it on the planet and people use it to
buy and sell similar to other assets you
can read more about the original Vision
in the white paper and there's a link to
it in the description now this was a
fantastic breakthrough and in a little
bit we're actually going to look through
how blockchains can actually work and
how all of this is possible but some
people took this and and saw this
technology and thought that they could
do even more a few years later a man
named metallic butterin released a white
paper describing a new protocol called
ethereum which used this same blockchain
infrastructure but with an additional
feature and in 2015 they released this
project called ethereum him and a number
of other co-founders took this
blockchain technology and applied it in
ways that people can make entire
decentralized applications decentralized
organizations and build smart contracts
and engage in agreements without a
third-party intermediary or centralized
governing force their idea was to take
the same pieces that made Bitcoin great
and add smart contracts to it and in
fact this technically wasn't even a new
idea back in 1994 a man named Nick Zabo
proposed a technology called smart
contracts a smart contract is a
self-executing set of instructions that
is executed without a third-party
intermediary they come to life on a
blockchain and these smart contracts are
really going to be the core thing that
we're going to be working with and we're
going to be developing smart contracts
are similar to regular traditional
contracts that people make between each
other but instead of writing these
contracts down on pen and paper or
typing them on the computer it's
entirely written in code the terms of
the agreement are written in code and
automatically executed by the
decentralized blockchain network instead
of being written pen and paper and
executed by the two parties or three
parties or however many parties involved
this was one of the main differentiators
between the ethereum protocol and the
Bitcoin protocol now technically Bitcoin
does also have Smart contracts however
they're not touring complete meaning
that they don't have the full range of
capabilities as a touring complete
application like ethereum this was
actually an intentional move by the
Bitcoin developers they view the Bitcoin
Network as an asset whereas ethereum and
the ethereum developers viewed that acid
as an asset and also a utility for
people to build these smart contracts
now these smart contracts are
revolutionary Technologies and we're
going to talk a little bit more about
what their advantage is in a little bit
but they actually come with a fatal flaw
with what's known as the Oracle problem
these blockchains are deterministic
systems and will learn why they're
deterministic very soon and this
determinism means that they're a Walled
Garden meaning that everything that
happens in these smart contracts and on
this block blockchain happens in this
little box now of course if you want
these smart contracts to actually be
these digital Superior agreements then
they need some way to interact with the
real world and get real data and
external outside the blockchain
computation this is where oracles come
into play oracles are devices that bring
data into a blockchain or execute some
type of external computation so great so
oracles are the solution now blockchains
can talk to the real world right well
not quite are blockchains and smart
contct contracts are these decentralized
application and in order for them to
stay decentralized that means they would
also need to get their data and external
computation from a decentralized manner
as well your onchain logic will be
decentralized on the blockchain but
you'll also need your offchain data and
external computation decentralized as
well combining these onchain logic
settlement layers and these offchain
data and external computation builds
what's called hybrid smart contracts and
a large majority of defi applications
and the largest applications today are
these hybrid smart contracts this is
where the protocol chain link comes into
play chain link is a decentralized
modular Oracle Network that allows you
to bring data into your smart contracts
and do external computation and it's
these hybrid smart contracts that can
have this onchain settlement and
interact with the real world in some
meaningful way chain link is an
incredibly powerful Oracle Network
because it allows us to get data get
Randomness do some type of upkeep or
really customize our smart contracts in
any way we want and Elevate them to do
anything that we want them to do now
throughout the course when we're talking
about smart contracts often times we are
also talking about hybrid smart
contracts smart contracts is used a
little bit interchangeably with hybrid
smart contracts but just know that when
we say hybrid smart contract we're
talking specifically about smart
contracts with an offchain component now
throughout this video you'll hear people
say smart contract you'll hear people
say decentralized protocol decentralized
application or dap and they kind of all
are a little bit interchangeable a
decentralized application is usually a
combination of several smart contracts
and when we start coding some solidity
you'll see what a singular smart
contract or singular contract looks like
smart contracts are going to be what we
code write and deploy for the majority
of this video and learning some of these
fundamental concepts will allow us to be
better smart contract and better
solidity developers now since its
Inception the ethereum protocol has
given rise to many new pair paradigms
and industries including defi nfts Dows
or decentralized autonomous
organizations layer 2s and so much more
and a couple of other protocols have
taken this ethereum vision and gone in a
different direction with it like polygon
polka dot or Avalanche if we learn the
core basics of smart contract
development on the ethereum platform all
these skills translate to these other
chains as well so don't worry about
learning a specific tool or chain
because most of them work together
pretty seamlessly now there are a few
exceptions to this Rule and there are
some smart contract platforms AKA
blockchains that don't use solidity
however learning the fundamental skills
here will still translate to every
single other blockchain and ethereum is
by far the most popular and most used
smart contract blockchain or smart
contract protocol you'll also hear those
words used a little interchangeably as
well sometimes I'll say blockchain or
sometimes I'll say smart contract
platform smart contract protocol and the
like similarly chain link is the most
popular and Powerful decentralized
Oracle Network and it's going to be the
one that we're going to focus on here
chain link is also blockchain and smart
contract platform agnostic meaning it'll
work on ethereum Avalanche polygon polka
dot or really any blockchain or smart
contract platform out there even in this
introduction we've already learned a lot
so let's do a quick summary of what
we've talked about Bitcoin was the first
application to take the blockchain
technology into the Limelight in into a
meaningful way Bitcoin is a sort of
digital gold able to make transactions
between users as almost a sort of
currency ethereum takes this blockchain
technology one step further but you can
also build smart contract or
decentralized applications decentralized
autonomous organizations and more
because you can code with smart
contracts these smart contracts can then
access external data and external
computation outside the blockchain using
what's called oracles chain link is the
most powerful decentralized Oracle
Network and allows us to build these
hybrid smart contracts which is a
combination of decentralized onchain
logic settlement layer and any
decentralized external offchain data or
computation hybrid smart contracts and
smart contracts are often used
interchangeably now you're probably
asking yourself a lot of questions right
now like what makes Bitcoin so
interesting what makes it like a digital
gold and how are these smart contracts
going to add any value to the real world
and that's what we're going to go into
next now so before we get into the
nitty-gritty of how these blockchains
and how these smart contracts actually
work from a low level let's go high
level and talk about some of the
features and massive advantages that
blockchains and smart contracts have
over our traditional environments the
first feature that these have is they
are decentralized and you'll hear this
term used a lot because it has a massive
benefit blockchains are decentralized
meaning there's no centralized source
that controls the blockchain the
individuals that make up blockchain are
known as node operators and they are the
independent individuals running the
software that connects the whole
blockchain together it's all these
different independent individuals that
make the blockchain and blockchain like
networks decentralized we'll dive deeper
into that concept later a great example
of why this is so fundamentally
groundbreaking is if we go back to what
happened recently even with Robin Hood
and GameStop GameStop share were no
longer allowed to be bought because a
centralized entity didn't want them to
be bought anymore so they flipped a
switch and nobody could buy that stock
anymore essentially having a single
entity controlling the entire Financial
Market the fact that a single entity has
the power to make these choices for us
is a travesty and blockchain is here to
solve that there's a narrative here
called The bankless Narrative where
users can actually live in a world where
they don't have a bank bank Banks while
good in their own right have a history
of doing some shady things they also
have the power to potentially freeze
your funds not letting you withdraw or
move or do anything because they are a
centralized entity that again can flip a
switch and control how you interact with
your life every day being free of these
centralized entities have this much
power and this much control over your
life has widespread positive
ramifications transparency and
flexibility everything that's done on a
blockchain and all the rules that are
made can be seen by everyone there's no
backdoor deals there's no Shady
happenings everything that happens on
chain you can see this means that
there's no special information that a
few have everyone has to play by the
same rules and everyone can see exactly
what those rules are now additionally
this doesn't mean that everything you do
is tracked the blockchain is pseudo
Anonymous so you can create different
accounts in you can interact with it in
many different ways this leads me to my
freedom point but I'll get there in a
second speed and efficiency have you
ever tried to make a withdrawal from the
bank and it took 3 to five days all the
bank is doing is adding and subtracting
numbers basic first grade math so why
does it take so long because blockchains
are verified by a decentralized
collective the settlement or withdrawal
period in this case is substantially
faster and depending on the blockchain
that you're using it can be from 10
minutes all the way down to just a
couple of seconds in the stock trading
or hedphone World it can actually take
up to a week for your buy or sell of a
stock to go through security and
immutability blockchains are immutable
which means they can't be changed and
because of this it means that they can't
be tampered with or corrupted in any way
shape or form this allows us to have
massive Security on our data on our
transactions and anything of the like if
your computer goes down and your backup
computers go
down in the regular World your data is
gone if all your data is on those two
computers you're out of luck on a
blockchain if several nodes go down it
doesn't matter because as long as one
node in the entire system is running the
data is safe and secure there are
thousands or hundreds of thousands of
nodes running these blockchain softwares
meaning that everything that happens
happens and is immutable and won't
change
hacking the blockchain is nearly
impossible and substantially harder than
hacking a centralized entity and this is
also much more secure in the asset sense
as well instead of having gold in a
vault or a contract written on a piece
of paper or on your computer you have a
asset that is locked on the blockchain
forever and all you need to do to access
it is have a private key or
pneumonic which is essentially a
password so you don't have to lug your
gold around or lug your contracts around
with you it is always on the blockchain
smart contracts in particular remove a
massive conflict of interest in the
traditional world when we engage with
users or individuals they don't always
have our best interests at heart a lot
of them are usually self-motivated in
some sense and there's nothing wrong
with that that's how a lot of people are
however when we make an agreement with
them this agreement can have a massive
conflict of interest with the user who's
supposed to execute that agreement let's
take insurance for example if I pay an
insurance provider $100 a month I'm
paying them $100 and in the event that I
get hit by a bus we've made an agreement
or a contract that they're going to pay
my medical bills or bail me out however
they have this massive conflict of
interest insurance companies aren't in
the business of giving out money they're
in the business of making money so even
though they've signed this agreement
when this event occurs they still don't
want to pay this money out to me and if
they can find a loophole in the contract
they will because that is what they are
motivated to do so they sign this
agreement but it's not in their best
interest to do so so they have this
massive conflict of interest and this is
native in all the agreements that we
make today they are the ones who decides
whether or not they're going to execute
their agreement giving execution power
to the party that doesn't want to
execute something has often led to
frustration now the followup is you can
always sue them and go through these
process but now you're wasting all this
time going through this long process to
get something that you should have
originally gotten in the first place
this leads me to one of the biggest
value ads of smart contracts smart
contracts allow us to engage in
trustless and Trust minimized agreements
we currently live in a world of brand
based agreements if I engage in some
agreement and I don't like the service
that I'm provided
my alternative to this is to waltz down
the street to another brand to another
service who's going to make the exact
same set of promises to me and then I
have to trust them that they're going to
execute Faithfully smart contracts allow
us to move from this brand-based
agreements to math-based agreements
these math-based agreements we don't
even have to trust that they're going to
do the right thing hence the name
trustless 1+ one is always going to
equal two in a math World whatever the
code determines is the input output
that's exactly what's going to happen
every single time now for me these
really all add up to two major pieces
freedom and trustless all these pieces
allow us to live in a world that's more
accountable more trusting more friendly
and just better it allows us to work in
an environment in a universe where
things just work it allows us us to do
the freedom to engage with other people
how we wish because there's no
centralized controlling body influencing
every action that we make all the rules
are the same and no one's getting
special treatment this brings out this
new world of Economic Opportunity as
well and as our lives become more and
more digital we're constantly being
bombarded with centralized services that
want us to use their interface so they
can profit on how we interact and force
us or push us to making the decisions
that they're motivated for us to make
smart contracts decentralized
applications and blockchain allows us to
be free of these repressors and live in
an environment that's truly free and
trustless so with all that high level
being said let's do a quick summary of
what we just learned blockchains are
decentralized meaning that they are not
controlled by a single centralized
entity it is run by a network of
independent users transparency
blockchains are transparent everything
that happens on a blockchain everybody
else can see and everybody else can work
with and see that everyone's playing by
the same rules blockchains are quick and
efficient especially when it comes to
monetary policy settlement on
blockchains are fast and easy a
mutability and security blockchains
can't be changed or tampered with or
corrupted and are incredibly incredibly
secure smart contracts remove the
massive conflict of interest traditional
agreements have Smart contracts allow us
to move away from political brand-based
agreements to secure math-based
agreements smart contracts allow us to
engage in trustless and Trust minimized
agreements smart contracts are a set of
instructions which when placed on a
blockchain are self-executing pieces of
code not run by any centralized
intermediary in addition smart contracts
are typically paired with some type of
Oracle to get some information about the
real world when smart contracts are
paired with an oracle they're called
hybrid smart contracts chain link is a
secure decentralized modular Oracle
Network used to bring data into your
smart contracts and also make some type
of external computation I also briefly
want to mention Dows or decentralized
autonomous organizations you'll hear
this referred to a lot as well
decentralized autonomous organizations
are organizations that live online and
live in these smart contracts they're
similar to a regular organization in the
traditional World however they have
people who maybe hold governance tokens
to make voting decisions or they do all
their governance on chain on this
decentralized settlement layer giving us
the freedom to engage with each other as
we please so now that we've taken our
first dive into blockchain and smart
contracts and at least from a high level
understood why they're so advantageous
let's jump in let's get an ethereum
wallet and let's make our first
transaction on a live blockchain are you
ready now let's jump into ethereum we're
going to make our first interaction with
the ethereum blockchain and once we do
this interaction once we make this
transaction then we're going to go back
and look at what actually happened what
were the technical implications that
allowed this transaction to go through
so in order for us to interact with
blockchain the first thing that we're
going to need is an ethereum
wallet so I'm going to go ahead and go
to metamask because it's one of the most
popular wallets and one of the easiest
to use we're going to go ahead and
download it I am using the brave browser
but it works for Chrome Firefox or
really any other browsers and it's just
going to be a little extension in the
top right hand of your browser this way
we can really easily see at any times
what we have in our
wallet this will store all of our
ethereum based currencies so I'm going
to go ahead and install metamask for
brave
add to Brave ADD
extension and now we can go ahead and
get started with working with brave this
is the first step you absolutely need to
take when starting your journey and one
of the easiest steps to take so we're
going to go ahead and get started and
we're going to create a brand new wallet
so we're going to go ahead and hit
create wallet if you already have a
wallet you can actually import it via I
have a seed phrase and we'll talk about
this seed phrase or secret phrase in a
little bit so let's go ahead and create
create a new wallet and sure we'll agree
to help out metamask now we will create
our password make sure that this is
really secure for the purpose of this
demo my passwords are just going to be
password but please don't have that be
your password now when I'm doing my
testing and when I'm doing my coding I
actually use a separate account from the
account that I actually have real money
in however if you want to use this
account and actually put real ethereum
and put real money into it you
absolutely 100% need to back this up so
we're going to go ahead and click reveal
secret words I'm showing you guys here
because uh this is just a demo and I
don't really care however if you show
this secret phrase to anybody else they
will have access to all the funds in
your application so everything that
we're going to do in this tutorial we're
going to use fake money we're going to
use not real money so it doesn't matter
however if you're going to actually put
money in here you absolutely need to
have this written down because if you
lose access to this Andor your private
Keys which we'll talk about in a little
bit you will lose access to your wallet
and you will lose access to all your
funds so they give some tips like store
this phrase in a password manager like
one password write this phrase down on a
piece of paper put it in a secure uh
location memorize it whatever you want
to do just make sure you have this
backed up somewhere I'm just going to go
ahead and hit download this for now and
I'm going to save it on my computer it's
not best practice to save it to your
computer it is much better to use a
password manager or write it down on a
piece of paper or something but again
because we're just demoing here I'm
going I'm going to show you it here and
we're not going to put any real funds
into this so we're going to go ahead and
hit next and it's going to ask us
to make sure and it's going to ask us to
verify that we actually have it written
down and we're going to go ahead and hit
confirm and great and it gives us a
couple other tips remember definitely
take these tips very seriously
especially if you're going to use this
for real money like I said for this demo
we're just going to use test money so
it's not as big of a deal but if you put
real money in you absolutely need to
back up this seed phrase or secret
phrase or we're going to refer to it as
our pneumonic phrase awesome now we can
see the user interface of this wallet
and depending on your browser if you
actually go ahead and look in your
extensions you can pin it to your
browser and you can even just click it
and get the same interface here let's
take some inventory of what is actually
going on in here and what we actually
have our pneumonic phrase that secret
phrase that we got has given us access
to a new account and here's the address
of our account we can use a tool like
ether scan to view different addresses
and what's been going on with them so if
we look at this address that we just
created on ether scan we can see that no
transactions have happened it's empty it
has zero ether in it it has Zer doar
worth of value in it and this address
here is our unique address this address
represents
exclusively this single account that
we've just created we'll talk a a little
bit more about ether scan in a bit as
it's a tool that we're going to use more
and more now we can even click this
circle here and we can even create more
accounts and give it a different account
name we'll call it account
two this one has a different address so
if we go ahead go back to Ether scan and
look this up this one has a different
address here so we can have multiple
addresses in here and now if I click
this I have two accounts account one and
account two
the pneumonic that we've been given
gives us access to create multiple
accounts with that same pneumonic so
having that pneumonic will give us
access to every single account that's
ever created with that pneumonic this is
why securing your pneumonic is so
crucial especially if you create
multiple different accounts now each
account has a unique identifier with
them as well so so this right here is
the public address when we copy this
this is the public address of that
account
however there's also a private key to
work with this account a secret key and
we can go ahead and view it by clicking
these three dots go to Account Details
and Export private
key put our password in and confirm so
this is going to be our private key so
this is a single password associated
with this account if you give somebody
else access to this private key they
will have access to my account two they
won't have access to my account one
because the private key key of account
two is only associated with account two
the pneumonic however is associated with
all accounts and this is why when people
say store your private keys in a safe
place or store your keys in a safe face
they're usually referring to both your
pneumonic and your private keys if you
lose your private key you lose access to
this account if you lose your pneumonic
you lose access to all your accounts so
long story short back up your pneumonic
since it has access to everything and
back up your private Keys too but just
keep in mind that only have access to
the individual accounts and great those
are some of the main security pieces
here now what else is going on in
metamask is we can see this section here
that says ethereum main net if we click
it we actually see a bunch of other
networks in here so when you buy eth and
when you work with eth you're working on
the ethereum main net when you interact
with smart contracts or defi or anything
things that we're going to talk about
later on Main net with real value you're
going to be working on the main net
however since we're Engineers of often
times we're going to want to test our
applications or do some type of
integration tests or just make sure our
code actually works so there's also
what's called test Nets these are
networks that resemble ethereum and work
exactly the same way as ethereum does
however they're not with real money and
it's just for testing your applications
so we can even go to Ether scan and look
up rink be ether scan we can see the
rink be test on Explorer we look look up
at our address and it's the exact same
information here nothing has gone on on
rink B and this is totally different so
when we make a transaction these are all
different networks and if it says test
Network it's made to be made without
real money later on we're actually going
to show you how to work with other evm
compatible Chains Don't worry about what
evm compatible means for now but we can
work with avalanch polygon and other
applications through this networks
interface as well so remember a test N
blockchain is a blockchain where the
currency doesn't have any real value but
it resembles and acts exactly like the
ethereum main net so we can test our
applications so we can test and practice
our
applications in fact what we're going to
do right now is make our first
transaction on the rink B test net and
this will simulate exactly what it's
like to make a transaction on the
ethereum main net so we're going to go
to this application called the rink B
faucet this is where we're going to make
our first transaction rink B is going to
be one of two test Nets that we're
actually going to work with the other
test net that we're going to work with
is going to be Coen it's important to
know how to switch between test Nets and
evm compatible chains which is why we're
going to be working with both for now
we're just going to be working with rink
b a faucet is a test application that
gives us free test ethereum hence why it
has no value because anybody can get it
for free from one of these faucets so to
get testnet ethereum with this
application we actually have to post a
tweet or a Facebook post with this tweet
so I'm actually going to I'm going to
sign in real quick and now that I'm
signed in I can post this tweet
requesting faucet funds
into and this is where I'm going to put
my address on the rinky ethereum test
Network going to go ahead and tweet that
out now that I have this we're going to
copy link to tweet and we're going to
place it in here and we're going to hit
give me ether and we're going to say 18
75 ether for 3 days and it said funding
request accepted for Patrick Alpha C
into this and what we can do then is if
we take this address again we go over to
Rinky ether
scan we now see that the balance is
18.75 and we can even see that in our
wallet on the rink be Network we have
18.75 eth but again if we look at main
net we have nothing there if we look at
Robson we have nothing there we look at
rinky we have 18.75 right so these are
very different networks and we've just
made our first
transaction we've been given
18.75 eth and if we refresh this page we
also see that this is our first
transaction that was made some account
sent us 18.75 ether from this account to
us and we can actually even look at the
details of this transaction ether scan
is what's known as a block Explorer
block explorers are applications that
allow us to see details of things that
happen on a blockchain easily we can see
the transaction details of this
transaction here and whenever we work
with smart contracts we will also see
them in a transaction similar to what
we're seeing right here and again we'll
talk about that soon now we can see a
number of information here we see a
unique transaction hash this hash or
this unique identifier uniquely
identifies this transaction as the key
of what this transaction is we see that
it was a successful transaction this is
the block number which we'll talk about
in a little bit we see it was from this
unique account which looks like they've
done a ton of transactions because this
is the faucet account to our account
that we created value was 18.75 ether
and then we have these transaction fees
gas price gas limit and gas use now gas
refers to to the fee paid to node
operators for successfully including a
transaction in a blockchain now exactly
how this works is actually going to
change pretty soon but the concept is
basically anytime you want to change the
state of blockchain whether this is
sending some ethereum or making any type
of transaction you actually have to pay
a little bit of ethereum or a little bit
of that native blockchain token to
actually execute that transaction
whenever we do something on the
blockchain it costs gas and if we do
something that would take a lot of
energy for the blockchain to do it will
cost more gas so if I send a single
transaction that's going to cost 21,000
gas however if I were to do if I were to
send a transaction that called the smart
contract function and did a whole bunch
of other stuff it would cost more gas so
we see here when we got sent 18.75 eth
whoever sent us at eth also paid the
blockchain miners or the blockchain
validators a little bit of ethereum to
include our transaction now we actually
get to pick how much of a fee we want to
send with our transactions so let's look
at another example so in our accounts in
metamask let's even expand the view here
we have two different accounts we have
account one and account two account one
has
18.75 account two has
zero we can actually send money from
account one to account two and again
remember this is all fake money so so
we're going to go ahead and hit trans
transfer between my accounts so we're
going to send money to account two and
here's where we can see some transaction
details and we see the asset that we're
going to send which we only have
ethereum in this wallet so we're only
going to send ethereum later on we'll
learn how to get different assets into
this wallet we're going to choose an
amount I'm just going to choose to send
one and then we have these pieces here
uh associated with the transaction fee
so we have a gas price in guay and a gas
limit so when we send a transaction we
can choose a gas limit we can say hey if
this transaction is going to spend more
gas than 21,000 gas we're not going to
do it we also get to set a gas price in
guay but here's the quick example of
guay versus
[Music]
ethereum one ether is this many guay and
one guay is this much ether because if
we just said hey could you send me 0 0 1
ether that would be kind of really
obnoxious so we just say semi1 way or
semi1 guay so I know we've been throwing
this gas term around for a little bit
but here is it basically simplified gas
is going to be the measurement of how
much computation something uses the gas
price is going to be how much it costs
per unit of gas a gas limit is going to
be the maximum amount of gas that can be
used in a transaction so for example if
we make a trans action that uses 21,000
gas and each one gas is one guay in
price that means we're going to pay
21,000 guay in transaction fee so back
in our transaction we have we're saying
the gas price is going to be one gay the
transaction fee is going to be the gas
that we use which will be up to this gas
amount times the gas price so it'll be
21,000 gay will be the trans transaction
fee so then the question is well why
would we ever bump it up why would we
want to pay more gas price why do I even
have the option to pay more well and
this comes down to block space we'll
talk about this a little bit more when
we get into how the blockchain actually
works but the blockchain can only
process so many transactions at a time
and nodes and blockchain nodes can only
process so many at a time so when I make
a transaction a node has to decide why
they want to include my transaction into
the block and if there are a ton of
people looking to make these
transactions then the nodes are going to
be highly incentivized to pick the
transactions that are going to give them
a high price that are going to give them
a lot of money for including that
transaction so this is what's called eth
gas station and it is a a gas estimator
of the blockchain it currently says that
if you want to get your transaction in
right away it's going to cost you 31 gay
to do so
if you want to get it in less than 5
minutes it's going to take you maybe
about 21 gay so the gas prices of
ethereum fluctuate with how much people
use it and the gas prices of all these
blockchains fluctuate with how much
people use it so this is an important
concept so typically when you're setting
your gas price in a transaction you can
take a look see at you know gas station
and say okay if I want mine to go in
right away I'm going to do ASAP if I
want to go in fast maybe I'll do you
know this fast amount standard I'll do
this the standard amount but it all
depends on how many people are looking
to work with this blockchain at the same
time and and as you can see it
fluctuates pretty quickly right it just
went all the way up to 46 so maybe more
people are using the blockchain now this
is obviously for the eth main net and on
the test net there's not going to be
that same competition but we can still
change it anyway so if I go ahead and do
100 for the gas price and I hit next and
I hit confirm if I go to activity I now
have this transaction in my metamask but
I can go ahead and view this on ether
scan as
well and we can see this is what it
looks like when it's still processing
this transaction and now I can see that
it's passed and now if we look at the
gas price we see it's 100 gay and this
is what we set it as when we were
working with it before so gas price is
100 gay here versus our first original
transaction was just one guay and now if
we look at our metamask we can see that
the funds have indeed been subtracted
from this account
and they have been added to this account
now there's one eth in this account
awesome and you can see the activity
there's one eth in here so again the
reason that these gas prices exist is
because nodes can only put so many
transactions into a block so they're
highly incentivized to input the
transactions that are going to give them
a higher fee so in times when a lot of
people are looking to use a blockchain
prices will get very high and when very
few people are using a blockchain prices
will be very low this ether scan tool is
incredibly incredibly powerful and we
will be using it more and more as time
goes on now here's something that's
incredibly exciting with just this
little bit of information you now know
how to interact with blockchains and
interact with the ethereum protocol so
if you don't want to learn how to code
anything you can go and you can start
interacting with ethereum and
interacting with protocols with just
this much information however I know
most of you guys are here to learn how
to code so let's look under the hood of
ethereum and what is actually going on
with these transactions and with these
gas and with these blockchains and
what's really going on let's learn all
the fundamentals of a blockchain now if
you want to just go ahead and jump into
the coding go ahead and grab a timestamp
from the description however learning
exactly how the blockchain works is
going to make you an incredibly powerful
developer so let's take a look at that
first so we're going to be going through
this blockchain demo on this site right
here now the creator of the site has a
fantastic video and a fantastic walkthr
blockchain 101 it is right on their site
so if you're looking for another
explanation definitely check out his
video it is absolutely fantastic but the
first thing that we really need to do in
order to understand blockchain in order
to really anything and everything that's
going on here we first really need to
understand this shot 256 hash or hashing
just kind of in general let's first
understand what a hash is a hash is a
unique fixed length string meant to
identify any piece of data they are
created by putting some piece of data
into a hash function in this example uh
the hashing algorithm used is Shaw 256
now ethereum actually uses uh this this
right here for its hashing algorithm
which isn't quite um sha 256 but is in
kind of this sha family but it's it's
really just another way to Hash things
and uh the specific hash algorithm
doesn't matter uh so much so uh this
example uses sha 256 but you can imagine
it's the same as the ethereum hash
they're just going to you know result in
a different hash so what's going to
happen in this application here is
whatever data or whatever information we
put into this data section here as you
can see below this hash changes so
what's happening is this data is running
through this Shaw 256 hash algorithm and
it's outputting this unique hash so this
hash is a unique fixed length string
that's going to identify like a blank
data piece here right so if I put in you
know my name like you know Patrick
Collins this is the hash that's going to
represent Patrick holls right and you
can see even when I put you know
tons and tons of data in here the length
of the string doesn't change right so
it's always going to be the same amount
we can put almost any amount of data in
here there is an upper limit on the max
size of the data but for all intents and
purposes we can pretty much put any
length in here and you'll see too that
you know every time I type in Patrick
Collins this hash is always going to be
this 7 e5b right I'm going to delete it
I'm going to do Patrick colums again you
know 7 e 5B it's always this this unique
hash is always going to be unique right
it's always going to be this fixed
length string here so now we can take
this idea right of putting this data in
here and we can move on to uh this
concept of a block so with this block
concept we're going to take the exact
same thing with this hash this this data
section right but instead of having
everything just being in this this
singular data area right here we're
going to split this data up into block
nuns and data so all so what we're going
to do is we're actually G to hash all
three of these to get to get this hatch
right we're going to put all three of
these we're going to say all three of
these are combined uh together we're
going to put every all three of them
into this hashing algorithm uh to figure
it out so if I type a bunch of stuff
here we can see that block one with nuns
you know this nuns and this data we're
going to get this hash and as you can
see actually the screen turns red this
block turned red now what happens when I
hit this mind button when I hit this
mind button it's actually going to take
some time it's going to think for a
little bit and we can see that the nuns
here actually changed right the nuns is
different from what it was before and
this hash now starts with four zeros
okay and then it the the back turned
green when we're talking about mining
we're talking about miners solving some
type of very difficult problem that
takes a lot of time to do now in this
example here the problem that uh the
miners had to solve was they had to find
a nuns or or a value in this nun section
that when hashed with at block number
one with this data it would start with
four zeros so the problem here the
miners had to solve was to start with
four zeros and the only way for them to
really do that is kind of this Brute
Force you know trying stuff so they
tried one okay one didn't work okay two
nope two didn't work three no four five
six okay five well that started with one
zero but that's not four and they have
to keep trying all these numbers until
they uh get to this one where you know
let's hit mine again
where it has four zeros at the top at
the start now this specific problem
changes blockchain to blockchain right
ethereum has a different problem for
miners to solve um Bitcoin has different
problems for minor solve but this
concept is going to be the same so they
have to take um one block is going to be
this this uh this concept is going to be
all this data it's going to be the block
number and it's going to be this nuns
right and so this nuns is the solution
um is is going to be the the number that
they use to get like the solution to the
problem right so if I go to one here you
know and I do this
again going to hit mine and the nuns has
changed right it went from one to 33,105
that fulfills whatever the problem is so
that's really it actually so that's a
block and and that's really what's
happening when miners are mining they're
just looking there's trial and error
Brute Force trying to find this nun so
so now that we know what a block is
let's go to the next step and figure out
okay well what's a Block Chain so here
we have an example of what a block chain
is going to look like right we have a
combination you know we have back here
in the block section we have one what
one block looks like now here we have
multiple different blocks right each one
of these represents a different block
but we have an additional column here or
we have additional variable here so like
before you know we have block NS and
data right we have block nuns data but
we also have this thing called previous
right and so this is actually going to
be pointing to the previous hash of the
last block so for example if we go to
the the last block in this blockchain it
says previous is 00 A8 and if we look at
the hash of block number four it's
000000 a 8 and then we look at its
previous it's 4 Z's B9 we have 4 Z B9
and so on all the way back to our first
block which has previous of just all
zeros right and so the block with the
previous of all zeros is going to be
known as The Genesis block so You'
probably heard that before the Genesis
Block it's the first block in the
blockchain where the previous hash
points to a hash that uh doesn't
actually exist now as you can imagine
kind of the same as how this block
worked how the block NS and data all go
go through the hashing algorithm in the
blockchain the block nuns data and
previous hash all go through this
hashing algorithm to figure out you know
what the hash is okay so if we go to
over here you know for example if I type
in you know Patrick obviously this is
now no longer valid right because this
nuns uh combined with the block the data
and the previous hash aren't going to
solve you know our problem of having
four zeros of the at the start right so
I'm going to go and fix that and and
that's that's kind of an easy way to to
see it being broken but but let's take a
look if I break this block right here
what happens if I if I break the data in
here if I do like in here you can see
that both of these are now read both of
these are now invalid right because the
block hash with the nuns hash with the
new data which is my name Patrick hash
withe hashed with the previous block is
now a brand new hash right and this
block is still pointing to this previous
hash right here right is pointing to the
previous block and now it is wrong and
it is messed up and now um and now its
Nuns with this previous hash is also
wrong right and this is where when we
talk about uh blockchains being
immutable this is exactly how it's
immutable right because if I go back and
I change anything you know if I just
typed a right here the entire blockchain
is now invalidated because none of these
are going to have uh nses that solve
this equation anymore so this is why
blockchains are immutable is because
anytime you change one thing you ruin
the rest of the blockchain okay so
however though you know if if an a was
here originally we can go ahead and mine
these we can mine all these but as you
can see you know this is going to start
getting very uh computationally
expensive because I have to go redo uh
basically the entire blockchain uh and
the farther and farther down the line
you get the harder and hard it becomes
to you know rehash and and redo all
these different blockchains here now
this makes a lot of sense right so we
have this block it's really hard to
change something in the past but if we
do we can just go ahead and remine it
now if I'm the one who controls the
blockchain right if I'm the one who
controls this you know and I want to
change something in the past well okay
great all I got to do is change this
data here and then you know mine each
one of these you know obviously it's
going to be very computationally
expensive but it's something that I can
do right if I'm the one who owns the
blockchain now here's where the
decentralized nature or the distributed
nature really uh makes it incredibly
powerful so we're going to go to the
distributed tab here which I also refer
to as the decentralized tab here uh and
it's going to show us what a blockchain
looks like uh in a decentralized manner
so we have this exact same uh initial
setup here we have distributed
blockchain we have you know the our
first blockchain which is kind of
exactly as the one from here but we also
have more than one so we have Pier a
peer B and Pier C and when people are
talking about peer-to-peer peer-to-peer
transactions they're really talking uh
this is kind of that concept that
they're talking about right so we have a
number of of different peers who are
running this blockchain technology
they're all weighted equally right each
one of these peers or each one of these
nodes each one of these entities running
a
blockchain has the exact same power as
anybody else right so the way that we
can tell very easily which blockchain is
correct or which ones are correct are by
looking at this end hash here right are
by looking at where we are uh in the
blockchain because again remember
because again remember this hash that
this this in this last block here is
going to Encompass all of the blocks
from before right because this last hash
is going to have the previous hash here
which includes the previous hash here
which this hash includes the previous
hash here and which so this last hash is
encompasses everything in here right and
we can look we can look at the hash of
Pier C which is four zeros and then e4b
we can look at the latest hash of Pier B
which is 4 Z's e4b and then Pier a which
is 4 Z e4b so all of these peers all of
these nodes all of these decentralized
you know these independent um all these
independent users running this
blockchain software they're all matched
up it's very easy for their nodes to
look at each other and say hey great we
are all matched up now what let's say
that a decides that you know something
happened on the blockchain that they
didn't like and they wanted to go back
and change something right so let's say
they change here you know obviously uh
the rest of their blockchain is
invalidated and they have to spend a lot
of computational power to catch up to
speed so let's go ahead and humor it
let's say that they they did they ended
up catching up uh they ended up catching
up you know they ended up mining
everything and now they have a valid
blockchain right it solves the equation
awesome however in block number three
there's something new right this is here
and it shouldn't have been here this is
something that perer a put in by
themselves all that happens now is look
at all the blockchains that are running
the software and we're looking at all
the hashes at hash at block number five
so p a has this new hash now 009 BC but
Pier B has a different hash 00 e4b right
so who's right is it is it Pier a with
their new stuff or is it Pier B well
that's where the decentralized comes in
because then we can look at Pier C and
Pier C also has e4b so Pier B and Pier C
both say hey p a you're wrong get out
right and Pi a will stop being able to
participate in the mining rewards
because they have essentially forked uh
the blockchain and started their own
little blockchain right with their own
history because they're the only ones
with this this piece of data in block
three whereas Pier B and Pier C have
nothing in there so that really shows
why uh in these blockchain worlds in
this decentralized world there really is
no centralized entity you know per a you
know might have been maliciously
motivated to change you know this this
block number three however democracy
rules right the majority rules in the
blockchain pi b and Pier C both say Hey
you know that that's cute and all p a
but you're wrong right that that's not
right now it might be a little abstract
to just look at data and you know us
typing kind of random stuff in here and
think okay yeah that's that's data right
that makes sense you know just kind of
random strings in here doesn't really do
anything for us so if we actually go
over to the Token section here this is
where everything really starts to make a
lot of sense so we have the exact same
setup here uh with Pier a pier B Pier C
except the difference is instead of
having kind of this this data section we
have this uh TX this transaction section
right and this represents all the
transactions that are happening in this
block right so we're we're sending $25
from Darcy to Bingle or to Bingley uh
four uh $427 cents here uh 1922 right
and it's the exact same thing so this
all these transactions are going to get
hashed in the exact same way uh that the
data is going to get hashed and and this
is why it's so powerful because again
you know if I want to be malicious right
if uh if I wanted to say hey I I really
wanted to give Jane a lot more money
from Elizabeth so I'm p and I go back
and I change it to 100 well now you know
not only do I does my whole blockchain
uh get invalidated because that was so
far so long ago but I'm not going to
match any of these other chains right
and so my blockchain is going to be
excluded from the overall blockchain so
and let's let's go ahead and fix this
and it's the same thing if down here if
I I become malicious and I want to send
you know I want uh Miss Audrey to have
less money maybe I want to send a dollar
and I go ahead and M it the same thing
here this hash now this 2a1 is not going
to match
pib's pib's hash of BBA and it's not
going to match PC's hash of BBA as well
so the two of them are going to say hey
this your blockchain is invalid it's not
matching the majority you know you're
out right so that's really how uh these
blockchains work at a low level and it
all goes back to this this understanding
this hash idea and using it in this very
sophisticated manner uh to kind of
cryptographically prove um you know
where where stuff lies now the way the
blockchain works is you instead of
random stuff put in this data section
it's actually going to be solidity code
in here to finding ways to interact with
different blocks and different protocols
that are on chain or as we've said
before different smart
contracts now the next question that you
might be asking is okay well how do I
know how can I be sure that I'm the one
uh you know let's say this is let's say
I'm Darcy right how can I be sure that I
was that Darcy was the one to actually
send this money here how do we know that
Darcy sent $25 to uh Bingley well this
is where we get into uh private keys and
public keys and that's what we're going
to go into now let's just do a quick
recap of what we've learned in this
section so far right we've learned that
ethereum actually runs on this KCK 256
but you know we used sha to6 for this
demo it doesn't really matter we're just
talking about hashing algorithms so
again a hash is a unique fixed length
string meant to identify any piece of
data a hash algorithm or a hash function
is a function or algorithm that computes
any type of data into a unique hash
mining is the process of finding the
solution to the blockchain problem in
our example the problem was to find a
hash that starts with four zeros
whenever a node mines a block they get
paid a little bit of that gas we were
talking about earlier for doing so a
block in a blockchain is basically a
combination of a block nuns transaction
and a previous hash to create this
unique hash for this block and again
depending on the blockchain
implementation this might have a couple
other fields or might have different
fields but this is essentially what's
going on blockchains are decentralized
and distributed because many independent
users are going to run this blockchain
software and they will check and they
will compare against each other to see
which blockchains are acting honestly
and which ones are acting maliciously in
the blockchain world majority rules the
nuns here is the answer used or the
number used to get this hash now nuns is
kind of an overloaded term it's actually
used for a number of different reasons
in this case we're using it to solve
this problem of getting you know four or
five zeros at the stop of the hash
however in ethereum it'll also be often
used as the number of transactions from
a given address so now we're going to
talk a little bit about signing these
transactions and and private keys and
and some other cryptography pieces right
because in this blockchain demo here we
can see we have all these these
fantastic transactions right all these
things went through but how do we know
that it was Darcy who was the one to
send $25 uh to Bingley right how do we
know that actually happened and this is
where all those pieces that we just
learned about uh in our our test net in
our metamask account are really going to
start to to come to life here a little
bit here so here we have an example of
public and private Keys okay at the top
we have this private key right that was
that was randomly generated uh a private
key is is you know as it kind of states
is a key that you really want to keep
secret because you're going to be using
this uh as kind of your your secret
password for all your transactions right
I can really pick you know any any any
private key anything that I want and
with it uh this algorithm they're going
to use an algorithm you know for
ethereum and Bitcoin they both use this
elliptic curve digital signature uh
algorithm it's it's a variant of just a
digital signature algorithm and it's
going to create this this public key
right I'm really not going to go at all
into kind of this digital signature
algorithm but just know it does use some
of these uh some of the hash uh
knowledge that we just learned combined
with some other pieces uh to kind of get
this this public key here so I'm not
going to go too deep into it but we have
this private key that we create and we
get this public key now this public key
we want everybody to have access to
right this is yeah whole world can see
this this private key we really want it
to be uh private we don't want people to
see this we're going to use this private
key as like a password to quote unquote
digitally signed transactions and then
people can verify them with this public
key so let's let's see what this
actually looks like let's pick a a
random key a more secure key right cuz
the longer it is the the more secure
it's going to be and if we go to
signatures now right um let's say we
have this uh this message that we want
right we's say high world right we want
this to be the message what's going to
happen is this private key that we've
created we can use to sign this data
right remember how in the blockchain
demo you know we were kind of we were
hashing stuff right we were we're using
this shade 256 hash to to get this hash
well we're doing something similar but
instead of hashing we're we're using
this digital signature algorithm to
create this message signature now what's
really powerful about how this uh this
algorithm works is that you can create
this message signature with your private
key but somebody else can't derive your
private key from the message signature
and that's what makes this really really
powerful however if we go to verify
using this public key right uh and so
this is the this is that 0403 this is
that same public key using this uh using
this public key anybody can verify oh
let's go ahead and sign it again anybody
can verify that this signature is yours
right so you have a public a private key
just for you so you can sign things and
a public key that anybody can verify
something right so anybody can verify
this and let's say somebody tries to
fake a transaction from you they say Hey
you know this is this is this is their
transaction um all they have to do is
verify that this
signature against your public key and
very easily this whole thing turns red
because uh it isn't verified right the
the algorithm says Hey uhuh that's wrong
so we can go ahead and take that into
transactions in this exact same way so
if I want to send money you know if I
want to send $400 from you know my
address to another address using my key
I can sign that transaction and anybody
else in the world can then verif ify
this transaction right and this is why
when people say hide your keys you know
protect your keys this is what we're
talking about in our accounts here right
if we go to uh settings and again the
only reason that I'm showing you guys my
pneumonic and my private key is because
this is a uh this is a dumpster account
I'm going to throw this away at the end
of this video or I'm just not going to
put any real money in it um
but when we look at our our our metamask
here we have this pneumonic phrase which
allows us to easily get these different
private keys right so uh pneumonic
phrase combined uh with you know uh
whatever account number will get us a
private key so pneumonic phrase combined
with one we're going to get this private
key and this is when we look at Account
Details export private
key confirm this is going to be the
private key that we're going to use to
sign our transactions right this if
anybody else gets access to this private
key they then can sign transactions for
us and they can send transactions for us
and that's why we want to keep these
private so uh it works the exact same
way right so this is why it's so
important to hide your private keys and
hide your pneumonics now your ethereum
address is actually uh a
piece uh is actually a piece of your
public key now to get our address in
ethereum all we have to do is take this
public key that we've created with our
private key hash it using that same
ethereum hashing algorithm and then take
the last 20 bytes and that's how we'll
actually derive to our um to our address
here now knowing the exact methodology
of how to get the address doesn't really
matter because it could change
blockchain to blockchain and could even
change e to um but just know that that
is essentially how kind of these
addresses are derived right there's some
derivative of the public key right
because the public key is public and you
know uh using the public key in kind of
any public way is is totally fine um but
not the private game so that is how we
sign our transactions note though this
isn't how we send the transactions so so
this is just going to sign it create a
transaction for us to send uh we'll
learn later on how to send these
transactions so that was a lot of
information there too let's do a quick
recap your public key is derived by
using a digital signature algorithm on
your private key right and you want to
keep your private key private at all
times because you're going to use your
private key to sign transactions signing
transactions with your private key you
are the only one who can actually do
this because you can't get the private
key from a message signature however
using your public key you can anybody
can very easily verify that a signature
that's signed by you is in fact signed
by you in our metamask our private keys
are located in this Account Details
section you just hit uh show Private
keys and type in your password and
you'll get your your private key here a
quick note here often times when using
your private key somewhere they want it
in hexadecimal form so if we're going to
use our private key um for something
like brownie which we'll go into later
we need to actually append a zerox to
the front but we'll get into that later
and the address of your account is
derived from this so if you think about
it your private key creates your public
key which then can create your address
and there's a little barrier
here or a big barrier here because your
priv private key you want to keep
private and your public key and your
address can all be public information
awesome so now that we know all the
cryptography pieces and all the little
nitty-gritties of how the blockchain
actually works and how our signatures
work and how everything sticks together
let's talk a little bit about how this
works in actuality and what's really
going on now for a lot of this each
different blockchain has slightly
different algorithms and slightly
different metrics and criteria for doing
a lot of this stuff so when we're
talking about these specific
implementations keep in mind the exact
algorithm might be a little bit
different but the concepts are all still
going to be exactly the same hashing and
hash function is going to be the same no
matter where you look a decentralized
blockchain is going to be the same no
matter where you look how it's actually
implemented is going to be a little bit
different now traditionally when you run
an application you know be it a website
or something that connects to some
server you are interacting with a
centralized entity and unlike how we saw
with the blockchain with multiple
different peers it's going to be run by
a single centralized group now it still
could be run on many different servers
but all those servers are still going to
be controlled by the same centralized
group blockchains as we saw run on a
network of different independent nodes
when we saw Pier a pier B Pier C those
were different examples of different
independent users running the blockchain
technology on their own node now when I
use the term node I'm usually referring
to a single instance of a decentralized
system so when I say a single node what
I'm talking about about a blockchain I'm
talking about one of those perer A's
perer B's Pier C's running that
blockchain software I'm talking about
one server running this technology and
again it's this network it's this
combination of these nodes interacting
with each other that creates this entire
blockchain what makes these so potent
too is that anybody can join the network
and that's why there's decentralized the
barrier to entry is a little bit of
Hardware requirements you're getting the
correct materials to run the software
and then you running the software
anybody can join these networks and
participate and that's what makes it
truly decentralized in fact you can go
to GitHub right now and run your own
ethereum node in a few seconds now in
the traditional World applications are
run by centralized entities and if that
entity goes down or is maliciously
bribed or decides that they want to shut
off they just can't because they're the
ones that control everything blockchains
by contrast don't have this problem if
one node or one entity that runs several
nodes goes down since there are so many
other independent nod running that it
doesn't matter the blockchain and the
system will persist so long as there is
at least one node always running and
luckily for us most of the most popular
chains like Bitcoin and ethereum have
thousands and thousands of nodes and as
we showed in our demo if one node acts
maliciously all the other nodes will
ignore that node and kick that out or or
even punish it in some systems because
they can easily check everybody else's
note and see um okay this one is out of
sync with the majority and yes majority
rules when it comes to the blockchain
each blockchain keeps a full list of
every transaction and interaction that's
happened on that blockchain and we saw
if a node tries to act maliciously then
all their hashers are going to be way
out of whack and they're not going to
match everybody else this gives
blockchains this incredibly potent
immutability trait where nothing can be
changed or corrupted so in essence we
can think of a blockchain as a
decentralized database and with ethereum
it has an extra additional feature where
it also can do computation in a
decentralized manner now let's talk
consensus proof of work and proof of
stake because you've probably heard
these before and they're really
important to how these blockchains
actually work when we went through that
blockchain example and we did that
mining feature this is what's known as
proof of work proof of work and proof of
stake fall under this umbrella of
consensus and consensus is a really
important topic when it comes to
blockchains consensus is defined as the
mechanism used to reach an agreement on
the state or a single value on the
blockchain especially in a decentralized
system I briefly alluded to this
consensus mechanism in our blockchain
example when I said if one changes
something and the other two don't then
majority Will Rule and kick that one out
this is part of that consensus mechanism
now very roughly a consensus protocol in
a blockchain or decentralized system can
be broken down into two pieces a chain
selection algorithm and a civil
resistance mechanism that mining piece
that we were doing or or the proof of
work algorithm is what's known as a
civil resistance mechanism and this is
what ethereum and Bitcoin currently use
please note that depending on when
you're watching this if eth2 is out then
it's no longer proof of work now proof
of work is known as a civil resistance
mechanism because it defines a way to
figure out who is the block author which
node is going to be the node who did the
work to find that mine and be the author
of that block so all the other nodes can
verify that it's accurate civil
resistance is a blockchain's ability to
defend against users creating a large
number of pseudo Anonymous identities to
gain a disproportionately advantageous
influence over said system and in
layman's terms it's basically a way for
a blockchain to defend against somebody
making a bunch of fake blockchains so
that they can get more and more rewards
now there are two types of the Civil
resistance mechanisms that we're going
to talk about here namely proof of work
and proof of stake let's talk about
proof of work a little bit more in depth
first in proof of work this is silver
resistant because a single node has to
go through a very computational
expensive uh process called mining which
we demonstrated earlier to figure out
the answer to the blockchain's riddle of
finding that correct nuns or or whatever
the blockchain system has in place in
proof of work this works because no
matter how many pseudo Anonymous
accounts you make each one still has to
undergo this very computationally
expensive activity of finding the answer
to the proof of work problem or the
proof of work riddle which again in our
demonstration it was finding a Nuns with
that first four zeros but again each
blockchain might change the riddle or or
change the problem to be a little bit
different in fact some of these
blockchains make this riddle
intentionally hard or intentionally easy
to change What's called the block time
the block time is how long it takes
between blocks being published and it's
proportional to how hard these
algorithms are so these problems
actually can change depending on how
long they want the block time to be if a
system wants the block time to be very
very long they just make the problem
very very hard if they want to be very
short they make the problem a lot easier
we'll talk about Cil ATT in a little bit
and how they can affect the system but
with proof of work it's a verifiable way
to figure out who the block author is
and be civil resistant now you need to
combine this with a chain selection rule
create this consensus now there's some
consensus protocols that have more
features but very very roughly these are
the two pieces that we're going to look
at the second piece is going to be a
chain selection rule how do we know
which blockchain is actually the real
blockchain and the true blockchain now
on bitcoin and ethereum they both use a
form of consensus called Nakamoto
consensus and this is a combination of
proof of work and longest chain roll the
decentralized network decides that
whichever blockchain has the longest
chain or the most number of blocks on it
is going to be the chain that they use
this makes a lot of sense because every
additional block that a chain is behind
it's going to take more and more
computation for it to come up that's why
when we saw in our transaction we
actually saw confirmations the number of
confirmations is the number of
additional blocks added on after after
our transaction went through in a block
so if we see confirmations as two it
means that the block that our
transaction was in has two blocks ahead
of it in the longest chain now I do want
to point out that a lot of people use
proof of work as a consensus protocol
and I do want to say that this is a
little bit inaccurate but sometimes
people use it interchangeably proof of
work is a piece of the overall consensus
protocol which in Bitcoin and ethereum
1's current case is Nakamoto consensus
Nakamoto consensus is a combination of
proof of work and this longest chain
rule both equally and very very
important now proof of work also tells
us where these transaction fees and
these block rewards go to remember how
when we made this transaction we had to
talk about gas and a transaction fee so
who's getting paid who is getting this
transaction and this transaction fee is
going to the miners or the validators in
a proof of work Network they're called
Miners And in the proof of stake Network
they're called validators there are a
little bit and we'll get into that when
we talk about proof of stake in this
proof of Works system all these nodes
are competing against each other to find
the answer to the blockchain riddle
remember in our example it was to find a
hash that has four zeros at the start
and again depending on the blockchain
implementation that riddle is going to
be a little bit different but all the
nodes are trying as many as possible to
try to get this answer first why because
the first node to figure out the answer
to the blockchain r is going to get that
transaction fee they're going to get
paid paid from that now when a node gets
paid they actually get paid in two
different ways one is going to be with a
transaction fee and another piece is
going to be the block reward remember
how we talked about alternating the gas
price or the guay on our transaction
well that's the transaction fee that
we're going to pay to these blockchain
nodes for including our transaction the
block reward is given to these nodes
from the protocol from the blockchain
itself you've probably heard of the
Bitcoin having before the having is
referring to this block reward getting
cut in half and it's supposed to be cut
in half roughly every four years this
block reward increases the circulating
amount of whatever cryptocurrency that
is being rewarded for example on
ethereum the Block reward is giving out
ethereum and on bitcoin the block reward
is giving out Bitcoin so these nodes are
competing against each other to be the
first one to find this transaction to be
the first one to find the answer to this
problem so that they can be the ones to
win both this block reward and your
transaction fee some blockchains like
Bitcoin for example have a time when
they're no longer going to give out
block rewards and the miners or the
nodes are only going to get paid from
transaction fees now this gas fee again
is paid by whoever initialized the
transaction when we got our funds from
the faucet there was some server and
somebody else was paying the transaction
fee for us however when we sent ether
from one account to another our first
account actually paid some transaction
fee to send that ether in proof of stake
there's also a gas fee but it's paid out
to validators instead of Miners and
we'll talk about that in a little bit
now let's talk about two types of
attacks that can happen in these
blockchain worlds let's talk about the
first one being the cibil attack the
cibil attack is when a user creates a
whole bunch of pseudo Anonymous accounts
to try to influence a network now
obviously on bitcoin and ethereum this
is really really difficult because a
user needs to do all this work in proof
of work or have a ton of collateral in
proof of stake which again we'll talk
about in a bit the other more prevalent
attack is what's known as a 51 percent
attack now as we saw as part of our
consensus protocol these blockchains are
going to agree that the longest chain is
the one that they're going to go with so
long as it matches up with 51% of the
rest of the network this means that if
you have the longest chain and you have
more than 51% of the rest of the network
you can do what's called a fork in the
network and bring the network onto your
now longest chain now cibil attacks
obviously are when a single node or a
single entity tries to affect the
decentral of the network by tending to
be multiple different people although
they're just the same person or entity
and like I said it's really difficult to
do in proof of work and proof of stake
so you can see now that blockchains are
very Democratic whichever blockchain has
the most Buy in and is the longest is
the blockchain that the whole system is
going to corroborate when nodes produce
a new block and add it to the longest
chain the other nodes will follow this
longest chain that the rest of the
network is agreeing with ADD those
blocks to their chain and follow up so
very small reorganizations are actually
pretty common when a blockchain chain
picks a block from a different longest
chain puts it on and then has to swap it
out for another block and continue with
a different blockchain however if a
group of nodes had enough nodes or
enough power they could essentially be
51% of the network and influence the
network in whatever direction that they
wanted this is what's known as a 51%
attack and it's happened on blockchains
like ethereum classic which is not
ethereum this is why the bigger a
blockchain is the more decentralized and
the more secure it becomes so after you
watch this video you become a blockchain
engineering expert I definitely
recommend you run a note as well because
you are going to increase the security
of the network as a whole by running a
node so proof of work is fantastic
because it allows us to very easily
protect against these Cil attacks and
keep our blockchains decentralized and
secure however it has some drawbacks as
well proof of work costs a lot of
electricity because every single node is
running as fast as they can to win this
race to get the rewards this leads to
obviously an environmental impact now
since proof of work Nakamoto consensus a
lot of other protocols have taken this
idea and gone in a different direction
with a different civil resistance
protocol a lot of them with the
intention to be a lot more
environmentally friendly and the most
popular one right now is proof of stake
there are some chains that are already
using this proof of stake protocol and
that are live and thriving some of them
are like Avalanche salana polygon polka
dot and Tera and additionally ethereum
is decided to upgrade to eth2 which will
have this proof of stake algorithm as
well well it'll also have some other
features which we'll talk about in a bit
now as a quick aside all the tools that
we're going to learn here are still
going to work in e two so depending on
when you watch this everything here is
still valid so let's talk about proof of
stake now again this is a different
civil resistance mechanism instead of
solving this difficult problem proof of
stake nodes put up some collateral that
they're going to behave honestly AKA
they stake in the example of ethereum 2
nodes put up some ethereum as a stake
that they're going to behave honestly in
the network if they misbehave in the
network they are going to be slashed or
removed some of their state obviously
this is a very good civil resistance
mechanism because if you try to create a
whole bunch of anonymous accounts then
each one of those accounts you have to
put up some stake and if you misbehave
you're going to run the risk of losing
all the money that you put up as
collateral in this system miners are
actually called validators because
they're no longer binding anything
they're actually just validating other
nodes now unlike proof of work which
every node is ing to be the first one to
find the Block in proof of stake nodes
are actually randomly chosen to propose
the new block and then the rest of the
validators will validate if that node
has proposed the block honestly as we
saw with our cryptography lesson it's
usually very easy for other nodes to
verify if a proposal or a transaction is
honest now Randomness is a really
important topic when we're talking about
blockchains because keep in mind these
blockchains are deterministic systems
they're walled Gardens from the rest of
the world and as you you know a
determinate system by definition can't
have random numbers so how do we choose
the random validators in the system well
it changes from blockchain to blockchain
and actually choosing the node will
change blockchain to blockchain but in
E2 they're using what's called randow at
least for the original implementation
this is a decentralized autonomous
organization that collectively chooses
the random number and collectively
chooses which node is going to run next
we aren't going to dive too deep into
this because there's a good chance that
this might change in the future but we
will go into Randomness Solutions in
blockchain later on in this course now
proof of stake obviously has some pros
and cons as well Pros are that again it
is a great civil resistance mechanism
and a great way to figure out who the
author of a block should be the other
Pros are that it's way less
computationally expensive to figure out
the new block because instead of every
single node on the network trying to do
this only one node needs to do this and
then the rest of the nodes just need to
validate it the cons are that it's
usually considered a slightly less
decentralized Network due to the upfront
staking costs it costs to participate
now this gets into a little bit of a
philosophical battle on how
decentralized is decentralized enough
and I think that's up to the community
to decide and as we progress I think
we'll learn more and more about how
decentralized is decentralized enough
the general consensus amongst blockchain
Engineers though is that proof of stake
is very very decentralized and very
secure this massive environmental impact
Improvement is one of the two main
reasons why eth is Shifting to eth 2 it
reduces the environmental impact by up
to 99% now these are the main pieces of
proof of work and proof of stake but I
did want to talk about another concept
that's really important in these
ecosystems and that is scalability when
we were talking about gas prices we were
saying that the gas prices can get
really high if a lot of people want to
send a transaction because a block only
has so much block space and the nodes
can only add so many nodes so when a lot
of people want to use a blockchain the
gas price
skyrockets this is not very scalable
because if we want to add more and more
people to these blockchains it's going
to cost more and more to use the
blockchains because more people are
going to want to get into these blocks
this means that there's kind of a
ceiling to how many people can use the
system because of the financial
constraints that will get imposed as gas
prices keep Rising ethereum 2 is not
only attacking the environmental impact
of proof of work by switching to proof
of stake but they're also implementing
this new methodology called sharding and
sharding is a solution to this
scalability problem a sharded blockchain
really just means that it's going to be
a blockchain of blockchains there is a
main chain that's going to coordinate
everything amongst several chains that
hook into this main chain this means
that there's more chains for people to
make transactions on effectively
increasing the amount of block space
that there is sharding can greatly
increase the number of transactions on a
blockchain layer one now there's another
term that might be the first time you
heard it a layer one we're going to talk
about layer ones and layer twos in terms
of scalability really quickly as well a
layer one refers to any base layer
blockchain implementation bitcoin's a
layer one ethereum's a layer one
Avalanche is a layer one these are the
Bas layer blockchain Solutions a layer
two is any application that is added on
top of a layer one added on top of a
blockchain some examples of layer twos
are going to be chain link arbitrum or
optimism arbitrum and optimism are very
interesting because they are layer twos
that also look to solve this scalability
issue arbitrum and optimism are what's
known as rollups and they roll up their
transactions into a layer one like
ethereum we're not going to go too deep
into rollups and how they actually work
but all you really need to know is that
a rollup is kind of like a sharded chain
they derive their security from the Bas
layer from the layer one like ethereum
and they bulk send their transactions
onto the layer one they solve some of
the scalability issues by being another
blockchain that people can make
transactions on still on kind of this
base ethereum layer now there different
from side chains because side chains
derive their security from their own
protocols rollups derive their security
from the base layers so arbitrum and
optimism for example is going to be just
about as secure as ethereum there's some
fantastic guys in there that go a little
bit deeper into rollups and I've left a
link in the description for you all
right so we just talked about a lot of
stuff so let's do a quick recap before
moving on ethereum and Bitcoin are
currently both proof ofor blockchains
that follow Nakamoto consensus however
ethereum is moving to to ethereum 2
which will be a proof of stake sharded
blockchain civil attacks are prevented
due to protocols like proof of work and
proof of stake 51% attacks grow
increasingly harder with the size of
blockchain so you should run a node
consensus is the mechanism that allows a
blockchain to agree upon what the state
of the blockchain is sharding and
Roll-Ups are solutions to scalability
issues on layer ones a layer one is any
base blockchain implementation like
Bitcoin or ethereum a blockchain
scalability problem is that there's not
always enough block space for the amount
of transactions that want to get in them
this leads to very high gas prices and
again gas prices are how much it costs
to interact with a
blockchain so we've learned a ton in
this video so far everything that you
went over is going to make you 10 times
better as a developer because yes being
a good developer means you understand
the code at a very technical level but
if you can understand the overall
architecture as well you can make
informed decisions about how to
architect your design or how to build
your software in however you want to do
so so with all that being said it's
finally time to jump into some solidity
and jump into some code so let's do
this now again in the description of
this video there is a link to this
GitHub repository that's going to be the
home base for all the code that we work
with in this tutorial we scroll down to
this main section this read me there's a
table of contents in here
we can go to lesson one simple storage
and we'll have links helpful tips the
itinerary of what we're going to learn
and everything else that you need to
work with here all the code that we're
going to be working with is located in
this Syle storage link that we can go
ahead and click it's in its own
different repository we can go ahead and
click the file to see all the code that
we're going to be working with so let's
jump into it additionally back in our
full blockchain solidity course right at
the top there's this resources for this
course section if you have questions
engaging in GitHub discussions stack
exchange ethereum and stack Overflow are
going to be great places to get help and
get support I highly recommend making a
stack
overflow stack exchange
ethereum and a GitHub account so you can
participate and engage with the
community welcome to the remix IDE or
the remix integrated development
environment this is going to be where
we're starting to teach you how to work
with solidity and work with smart
contracts and deploy to blockchains
we're going to use remix to get us up to
speed as it has a lot of nice features
that allow us to really see and interact
with blockchains and really see what's
going on but eventually we're actually
going to move off of remix to another
platform but all the solidity that we're
going to learn here obviously is going
to apply everywhere as well when you
come to remix there's a whole lot of
different plugins like solidity learn
eth Soul hint linter and a whole bunch
of other plugins as well well I'm going
to go ahead and start by clicking the
solidity plugin but we're not going to
use any of these plugins for now but
later on you can kind of go back and and
learn a little bit more about what these
plugins do so let's start perusing let's
start coding some things on the left
hand side over here is where we're going
to interact with everything so let's go
ahead and click the files up here now
you can always go back and peruse this a
little bit more and in fact I highly
encourage you to because that's how
you're going to learn the most the
quickest but for us we're actually just
going to go ahead and start with our own
brand new file we're going to create a
little application that can store
information on the blockchain for us and
this is our first project that we're
going to do in solidity so we're
actually going to create a new file and
we're going to call
it simple storage doou all solidity has
an extension of do Soul at the end
stands for solidity now let's take
inventory of what we're going to be
working with here this is the solidity
compiler tab it compiles all the
solidity code down to machine
understandable code or machine language
here there's a whole bunch of different
parameters we can choose when working
with sidity we can choose the compiler
version we can choose the language which
we're only going to be working with
solidity the evm version don't worry
about this for now so let's code our
first solidity contract here now we are
going to use something a little bit
special here when we actually deploy
these we're going to use a JavaScript
virtual machine so we're going to use a
virtual machine that's going to simulate
actually deploying to a test net or a
real Network we're not actually going to
deploy on a real Network we will in a
little bit but just to get started we're
going to work with a JavaScript VM which
is kind of a fake environment for now
okay testing locally and understanding
how to test locally will make your
coding experience a lot faster as you
saw when we sent some transactions some
of them actually took some a lot of time
to actually deploy we don't want to have
to spend that much time waiting around
for our test to actually finish so we're
going to use a JavaScript VM to kind of
dummy it for now but let's just start
coding and go from there so the first
thing that you're going to need in any
solidity program is the solidity version
so that's always going to be at the top
of your solidity code it's defined by
doing pragma solidity and the version
we're going to be using some version
between 0.6.0
and
0.9.0 so we're saying we want to use
anything between 0.6 and 0.9 and and as
a force of habit I just automatically
hit command s whenever I write anything
so that's why you saw some of this pop
up here we can hitting command s or
controls depending on if you're windows
or not we'll hit this compile button and
we'll compile everything for us now if
we want a specific version of solidity
we can also do
0.6.0 and if I go ahead and hit command
s or compile
our compiler will automatically vert to
0.6.0 however if I try to do 0.8.0 with
my solidity at 0.6.0 it's going to give
us an error it's going to say the source
file requires a different compiler
version we're using
0.8.0 and this is 0.6.0 so we're going
to go ahead and hit compile and it's
going to automatically move down to
0.6.0 we can also do carrot 0.6.0
and this will allow us to work with
really any version of
0.6 it'll work all the way up to 0.7
where if we hit command s or contrl S
there it'll give us an error so this
only works with any version below 0.7
and above 0.6 we're going to be using
version
0.6.3 however in future contracts that
we work with we're actually going to
work with different versions of solidity
the reason we're going to be changing
versions throughout this course is that
solidity is a constantly updating
language being good at switching between
versions is going to make you an
incredibly powerful smart contract
engineer the next thing that we're going
to do is we're going to Define our
contract so contract is a key word in
solidity which stands for our smart
contract that we're going to create you
can think of a contract similar to a
class in Java or any other
object-oriented programming language so
we're going to give our contract a name
here we're going to call it simple
storage and we're going to add this
little curly bracket to say this is the
contents of our contract simple storage
and I went ahead and hit command s and
we can see it is compiling successfully
you could hypothetically deploy this
right now and this would be a valid
contract so great job for making it this
far now in solidity there are many
different types that we can work with
let's go into some of the types of
solidity we can have integers AKA whole
numbers they can be uint as an an
unsigned integer meaning they're not
positive or negative we can also have an
INT and we would Define a variable by
doing uint 256 favorite number equals 5
so we have an unsigned integer un 256
means this is an integer of size 256
bits so we can have this be up this
number be up to 256 you can also do uint
favorite number equals 5 but if you want
to be a little bit more precise a lot of
protols in a lar of smart contracts will
do the whole name like you
256 we can also have booleans booleans
are true false so we can have
Boolean favorite bull equals true so
this favorite pool would be true it
could also be
false we can have strings string
favorite string equals
string a string is a string of text here
right it's going to be some word or
phrase or really any these key strokes
here similar to the unsigned integer we
can have an INT
256 favorite int equals ne5 so it could
be positive or negative we can have an
address which is going to be some type
of ethereum
address so we could do
address favorite
address equals and then we can even copy
right from our metamask and just paste
it right in
here this is going to be a valid address
here you'll also notice that we end all
of our statements with a semicolon we
can have a bytes object size 32 bits
favorite btes for our example we're just
going to use the word cat because cat is
a string ring which can be converted
down into a bytes object bytes 32 means
that there's 32 bytes in this variable
favored bytes we can also do bytes 2
bytes 3 bytes 5 Etc with a maximum size
of bytes 32 for example we can't do
bytes 64 we're going to be talking about
some other variables as well like arrays
and mappings but let's just stick here
for now if you want to learn more about
the different types and the different
variables that you can use head over to
the solidity documentation and there's a
link in the G GitHub and that a
description to show you this section for
now for our simple storage let's say we
only want to store numbers we don't want
to store anything else so we're just
going to go ahead and delete everything
and just have ENT 256 favorite number at
the top now in solidity if I do this
favorite number actually does get
initialized even though I didn't have it
initialized to five if I leave it blank
it gets initialized to the null value in
this case it would be initialized to
zero so for now let's just not
initialize it to anything that way it'll
get automatically initialized to zero
this means that when we deploy this
contract as of right now favorite number
will start off as zero if you get
confused you can also make a comment on
this you could say this will get
initialized to zero this double slash
here is the way to make comments in
solidity and it won't get executed as
code so we can write whatever we want as
long as it's preceded by two
backslashes now let's go ahead and
create our first function functions or
methods are self-contain modules that
will execute some task for us and in
solidity it's the exact same thing
they're defined by the keyword function
let's make a function called
store that will change the value of this
favorite number here so we're going to
call store and we're going to allow it
to be passed a variable so we're going
to allow it to be passed a variable of
type unsigned integer
256 and we're going to call it
underscore fave or
RIT
number we're going to make this a public
function which we'll get to in a minute
and all we're going to do is we're going
to set favorite number equals to
whatever variable we passed in favorite
number so this in its simplest form is
how you can define a function now just
to visualize what we're working on so
far let's go ahead and deploy this
contract so we can actually start to
interact with it so if we hit this
button this will bring us to the deploy
Tab and will allow us to deploy our
smart contract here using our JavaScript
VM it's given us a fake account with
some ethereum in it it has 100 ethereum
in it to start and same as before
anytime we want to interact with the
blockchain we have to pay a little bit
of gas Even in our fake virtual machine
here and we want to simulate that so
you'll see it has some of the same
parameters here as making a transaction
like gas limit for example when we
deploy a contract it's going to cost a
little bit of ethereum or a little bit
of gas to do so so let's go ahead and
hit this deploy button and see what
happens so once we deployed with this
virtual machine a few things happened we
have remix kicking out this section down
here saying great job you've deployed
something and if we scroll down it says
transactions recorded one we can look at
all the transactions we've recorded and
we can see it says deployed contracts
and we have a contract here that we've
deployed now let's zoom out just a hair
here so we can see everything a little
bit better in this simple storage
contract we see this big store button
because there's one public function that
we can actually interact with so we can
add this number here and we'll hit store
and you'll see again we have a completed
transaction and if we look at our
contract we'll have paid a little bit
more gas right will have paid a little
bit more to interact with this function
because again anytime we want to make a
state change in the blockchain we have
to pay a little bit of gas the reason
metamask isn't popping up is because
we're kind of doing it in this simulated
environment so this is great however it
looks like we can't actually see what
our favorite number is we can't actually
look at it so how do we actually make
sure that we can view this favorite
number well let's add another parameter
to this as well if we add public
to our favorite
number we recompile by hitting command s
or hit the compile button we delete this
contract and we redeploy and scroll
down now we'll see two buttons pop up
this blue button to show us favorite
number which again is initialized to
zero and we have the store function so
let's talk a little bit about why this
public variable allowed us to see this
new button this new favorite number
button this public public keyword
defines the visibility of the variable
or the function there are currently four
different types of what's called
visibility in solidity there's external
public internal and private we're mostly
going to be working with public for now
but it's important to know how the rest
of these work public functions can be
called by anybody including variables so
oddly enough variables are a function
call to just look at them and return
whatever that variable is an external
function means it can't be called by the
same contract it has to be called by an
external contract so if in this contract
I had this be
external I couldn't call the store
function couldn't call the store
function inside this function because
the function is external it means
somebody outside of the contract has to
call this function internal functions
however can only be called by other
functions inside of this contract or in
its derived contract and then private is
the most restrictive as private
functions and state variables are only
visible for the contract they are
defined in and not derived contracts now
the reason that we didn't see favorite
numberers show up in our original
contract deployment is that if we don't
give a state variable a visibility it
will automatically get set to internal
so if we want other people to be able to
read it we have to change it to public
now let's see how this interaction
actually works if we hit the favorite
number button right now we'll get this
call thing that shows up and it'll show
us right here that the value of favorite
number is zero now this function however
is set so that whatever value we pass it
is going to change the favorite number
to whatever we pass it as so if we pass
1 two 3 hit store that transaction goes
through and then hit favorite number we
can see the value is now one two three
now I will also be using transactions
and smart contract interactions and
function calls a little bit
interchangeably that's because on a
blockchain whenever you call a function
or whenever you make some State change
to the blockchain you're actually also
making a transaction that's what makes
this whole thing so powerful and again
that's why making a function call or
deploying a contract costs a little bit
of gas now the reason we can access this
favorite number variable inside this
function is because favorite number has
This Global or contract scope so even if
we made un 256 test equals 4 or equals
equals 4 we wouldn't be able to use this
variable outside of this function right
because it's self-contained it's
self-contained inside this bracket and
if I were to make another
function store two
perhaps public
store two doesn't know that this test
variable exists functions only know
about the variables that are in the same
scope as them so favorite number is in
this Global scope because the only
bracket that's above them is simple
storage and test is in this store scope
because it has two brackets above it it
has it's inside of this store function
and inside of this contract simple
storage store two isn't inside of this
store function or this store scope so it
can't access this test
variable so let's go ahead and make this
back to public and we'll compile again
I'm hitting command s to compile but you
can go ahead and click the button if you
like and let's get this now as you saw
when we deploy this there's this button
here that we can click called favorite
number we can also make a function
called retrieve and make it a public
function that is of type view and
returns un went 256
and all this is going to do is
return favorite number so we're going to
talk about views and returns here so I'm
going to go ahead and
compile going to go ahead and delete
delete this contract going to go ahead
and deploy it
now and we can see now we have two
functions or two blue buttons here we
have retrieve and we have favorite
number and if I change favorite number
by calling the store function favorite
number number and retrieve will both now
say it's 1 2
3 so then the question might be well why
is this one orange and these two are
blue and the key relies in this view
function or this view keyword there are
two special keywords that Define
functions that you actually don't have
to make a transaction on and those
keywords are View and pure a view
function means that we want to read some
State off the blockchain so we're just
reading on the blockchain if we're
reading off the blockchain and we're not
actually making a state change then we
don't need to make a transaction these
blue buttons are blue because they are
view functions public variables also
have view functions that's why both of
these are blue this technically is a
view function and when I click it I get
to view and I get to read the state off
the
blockchain retrieve is the same way we
could have this without a return but it
wouldn't do anything pure function are
functions that purely do some type of
math we could have un 256 favorite
number public pure and just have
favorite number plus favorite number so
we're doing some type of math
here but we're not actually saving State
anywhere we're going to do this math but
we're not going to save this favorite
number anywhere we're not going to save
anything deploy this now this pure
function we would have this retrieve
function 1 two 3 it's blue as as well
because it's again not going to change
the state of blockchain so view
functions and pure functions are both
going to have this blue
color now the reason that nothing shows
up at the bottom is because we didn't
return anything all we're doing is we're
saying add these two numbers together
and that's it in order for this function
to give us something back we need to
have it return something so if we go
back to this retrieve
this retrieve function we have to Define
what we're going to return when we're
defining this function so we're going to
say this is a public function it's a
view function because we're going to
read some State and it's going to return
a u 256 so favorite number is a un 256
so that's what we're going to return our
public variable favorite name is also a
view function that returns a
un26 for now let's just remove that so
we can work with this retrieve function
so let's go ahead and deploy so now we
see we don't have this favorite number
button anymore because it is no longer a
public function because again it gets
initialized to internal so we can't
actually view it now keep in mind later
on we're going to talk about how
everything on chain you actually can see
and we'll talk about that a little bit
later though so retrieve is going to do
zero we can call store and now retrieve
is going to be one two three now this
application is great so far it allows a
single person to store a favorite number
and then go ahead and retrieve it later
which is fantastic but what if we want a
list of people or a group of people and
store their favorite numbers or what if
we want to associate a favorite number
with a single person well what can we
actually do now we have a whole number
of different choices but the one that
we're going to talk about is using a
struct structs are ways to Define new
types and solidity they're almost like
creating new objects as well so we can
create a struct called type people and
allow it to start storing a favorite
number associated with a certain people
so inside of our struct we can have
different types as well so we can have a
u
256 favorite number and we could also
have a
string name now we have a new type of
type people that has a favorite number
and a name inside of it now what we
could do with the struct is we could say
people
public person equals equals
people and then inside we add the
variables so we could say favorite
number favorite number is
two and name is
patri and of course the semicolon at the
end and again I'm hitting command as to
save but you can also go ahead head and
compile compil out so let's go ahead
delete this contract and see what this
looks like now so now we've deployed
this new contract and we have this
person struct which at the zero index is
the favorite number and the variable
stored in the first index is going to be
the name storing variables in solidity
always works in this numeric index
fashion in fact in contract simple
storage you wi 256 favorite number is at
index zero if we were to add another
object here like
Boolean favorite pool this would be at
index one we were to add buol favorite
pool two this would be at index two 0
one two and it works the same in structs
this is at index zero inside the struct
this is at index one inside the stru so
we can see the variables associated with
this person we're going to go ahead and
delete this for now because instead of
just creating one person we actually
want to create a whole list of people so
how do we create a list of people let's
delete that contract and what we can do
is we can make what's called an array an
array is a way of storing a list or a
group of some object so as you're
starting to see the way the syntax works
for defining any type of variable is
going to be the type of the
variable the visibility of the variable
like public or if you don't declare it
it gets initial Iz to
internal and then the name of the
variable it works the same with arrays
so we'll make a people array people
array is the
type we'll make it public and we'll call
it people now if we deploy this contract
we go and see we now have a people array
but if we click this button you'll see
that nothing shows up the reason is
because it's an empty array to start
with right we don't have anything inside
of it now this type of array that we
created is what's known as a dynamic
array it's a dynamic array because it
can change its size right now it's of
size zero and if we added something to
it it's of size one you can also create
arrays of a fixed size so if I were to
do people one public people this array
could only have a maximum of one person
inside of it so we're going to work with
a dynamic array though because we're
want to add an arbit number of people
into here so let's go ahead and create a
new function called add person where we
can add a person to this array so we'll
do function add
person string memory name I'll talk
about this memory keyword in a minute
you went
256
favorite
number and then we'll make this
a public function
and inside we'll do we'll add this
person to our array way to add a person
to your arrays is using the push method
so we're going to push a new people or a
new
person and we're going to give it those
variables again so we're going to give
it we're going to give it favorite
number is this variable that we passed
in here oops this needs a bracket
and then we're going to
give the name be this underscore
name and then end
bracket
oops zoom out again here just so I can
see
stuff just needs a
semicolon and perfect now in that last
clip we saw this little red box pop up
whenever a little red box like this pops
up after you compile it means you have a
compile error this means that there's
something wrong with your solidity code
or your solidity syntax and it won't
compile and deploy properly red is going
to be this compile error now we're going
to see a bunch of yellow warnings in the
future if you get a little yellow popup
these are okay to ignore but they
usually have some helpful tips about
something that might be going wrong in
your code so to summarize if it's red if
it's red it's broken if it's yellow you
might want to check it out but it could
be okay so we can see we have our new
function ad person where we pass a
string memory memory name and a un 256
favorite number and then we create this
people person this people object here
and then we push it onto our people
array and I'm going to show you another
way we can actually create a people
person is just by passing favorite
number and
name getting rid of this other by
passing favorite number and name because
we know that the zeroth index of people
is favorite number in the first index of
people is named so we can also create a
new person by adding it like this now
let's talk about this memory keyword
here now in solidity there's more or
less two ways to store information you
can store it in memory or in storage
when you store an object in memory it
actually means that it'll only be stored
during execution of the function or of
the contract call if we hold it in
storage that means that that data will
persist even after the function executes
string in solidity is actually
technically not a value type string is
actually an array of bytes a variable of
type string is actually a special type
of array that we can append text to so
because it's technically an object we
have to decide where we want to store it
in memory or in storage and since we
only need this name during the execution
we can have it be string memory name and
then when we create this new people
object we will create a new copy of this
this name variable into storage memory
means that after execution delete this
variable storage means keep it forever
this is a little bit confusing for you
just know that for now when you use a
parameter that's going to be a string
for one of your functions you need to
call it string memory so let's go ahead
and deploy this contract and see what
happens now now we have this new
function add person and since we are
making a state change here we can see
that this indeed is a orange button
instead of being a blue button so we can
add in here a string name We'll add
Patrick and we'll say his favorite
number is two again right now if we look
at people see people zero there's
nothing in here we retrieve there's
nothing in here so we're going to add
person Patrick and now if we hit people
of zero we can see that the person at
the zero withth index in this people
array is going to be string Patrick if
we try at one there's not nothing in
here let's add another person we'll add
Becca and her favorite number will be 24
let's add her now if we hit one we see
favorite number 24 string name is Becca
and retrieve is still showing up blank
because we haven't touched favorite
number awesome this is great we can just
keep adding people however there is kind
of an issue here what if I'm looking for
a person what if I'm looking to find
Becca and find her favorite number in
this array what if I know her name but I
don't know her favorite number is there
an easy way for me to find that favorite
number without having to triage the
entire array there's another data
structure called a mapping so let's
create this new data structure so this
data structure is going to be of type
mapping a mapping takes some type of key
and spits out whatever variable it's
mapped to so in this case if we're
saying we want to use the name Becca to
find her favorite number we would say
the string Becca is going to be mapped
to the U 256 favorite number and similar
to all the other variable declarations
the first part is going to be the typing
so this is going to be a type mapping of
string mapped to un 256 we're going to
give this public visibility and we'll
call it name to favorite number and
without adding any other functions that
work with it if we deploy this we can
see we have this blue button because
we're not making a state change name to
favorite number and if we type in Becca
in
here obviously nothing's going to happen
because we haven't added this mapping in
yet so in our ad person down here let's
even have this ad person also add to the
mapping so we can do name to favorite
number and then the key is going to be
this name so of Becca we're going to say
we're going to map the name Becca to the
favorite
number now we're going to go ahead and
compile again I'm hitting command s
deploy we can scroll down here if we
look up Becca in here we're going to get
nothing however if we
add
Becca and her favorite number being
24 this add person is going to add it
both to the array and to this mapping
now if we look up name to favorite
number you see that Becca returns 24 now
one other thing I want to show you guys
just because compilers are going to yell
at you if you don't have them is
typically at the top of these contracts
you want to add an SPX license
identifier basically solidity and the
ethereum community found out that trust
on a smart contract can be better
established if source code is available
and in terms of legality and copyright
it just makes life a lot easier if you
add that license identifier right at the
top of your solidity we're going to use
the MIT license identifier because it's
the most open license out there it means
hey anybody can use this code and we
don't care so you'll see a majority of
solidity contracts have this SPX license
identifier MIT at the top and compilers
will yell at you a lot less awesome we
now have a contract that we've decided
that we liked it's got mappings it
enables us to actually store people and
their favorite numbers this is fantastic
we've done all of our testing in this
JavaScript VM and we've decided you know
what we want to deploy this to an actual
test net or an actual main net how do we
actually deploy this so that other
people can interact with this contract
we are again going to use rink B because
that's what we use to make our first
transaction now again you will need some
type of test ethereum in your test net
wallet so again if you get lost you can
always just Google rink B faucet or rink
be tested faucet and find a faucet or a
better alternative would be to come to
the link token contracts in the chain
link documentation at docs. chain. link
and scroll down or just look up rink be
this link token contracts page has the
most up-to-date faucets for any test net
that it supports so for example we get a
test eth faucet right here which also
just happens to be that exact faucet
that we used earlier the only thing you
need to change in remix is we need to
change from JavaScript VM to injected
web 3
and metamask will actually pop up and
say hey would you like to connect to
this application anytime you're working
with a web3 application or a web
application that wants to access your
funds or work with your metamask
metamask will pop up and ask for
authorization first this is really good
so that we know which applications we're
actually connected to so we're going to
go ahead and say next connect and we can
see here that we've even connected here
and that our account on the main Network
at zero
eth and remix even tells us hey you're
on the main Network so let's go ahead
and switch to the rink B Network and we
can now
see we're on the rink B Network and we
have 17.74%
is if we want to use our own blockchain
node or our own web3 provider when we do
injected web 3 we're saying our web 3
provider is our metamask which will work
perfectly for what we're trying to do so
since we already have some test in
ethereum let's go ahead and deploy this
and see what this would actually look
like if we deploy to a main net the
process is going to be exactly the same
right the only difference was we would
be on the main net instead of rank B so
let's go ahead hit deploy we'll uncheck
published ipfs hit deploy as will pop up
asking if we want to do this transaction
because remember we are deploying a
contract we are changing the state of
the blockchain so we have to pay a
little bit of gas fee for it so we're
going to go ahead hit confirm and we get
a link to rink be ether scan similar
exactly as we saw before when we made a
transaction the difference here is that
instead of sending ethereum to somebody
we're actually making a transaction on
the blockchain to create a contract
after after a short while it will show
up here on ether scan with a success the
number of block confirmations which
again is the number of blocks appended
to the block that included our
transaction we see from which is our
account here and we see two is this new
contract that we just created and we can
even click it and we see that there's
this unique transaction hash that
created a new smart contract and same as
working with the VM we have all the
exact same functions in here and you can
see if I hit retrieve these three
functions since they're not making a
state change you can just click them and
no transactions will be made however
what do you think is going to happen if
I hit
store if you guess metamask will pop up
you guess correctly again we see the
familiar pieces here we have a gas price
gas limit go ahead and hit
confirm we get another transaction here
and once this transaction goes through
we should be able to call our retrieve
function and see a new number
if we call it now nothing shows up
because our original transaction hasn't
succeeded but I bet if we look at it
now okay it's still indexing but it
looks like it's been included if we hit
it now we do indeed see this value here
and we can do the same thing with adding
a person We'll add Becca we'll say her
favorite number is 24 menam mask will
pop up we'll go ahead and confirm the
transaction and if I look up Becca and
the name to favorite string right now
it's going to show nothing because our
transaction hasn't gone through yet but
if we wait a little bit I should
probably spell her name right we do see
24 and if we look at the zero withth
index we also see Becca's been added
here as well now all this solidity code
that we wrote and when we interacted
with this blockchain here all this
solidity was compiled down to the evm
also known as the ethereum virtual
machine a lot of the blockchains out
there today are what's called evm
compatible and that means that all this
solidity and all these functions that
we're creating can still compile down to
evm and deployed on their blockchain
you'll find out a little later when we
look to work on a non- ethereum based
chain that we could still deploy our
solidity smart contracts to these other
chains as well but that's a term you'll
hear more and more the ethereum virtual
machine or evm now take a break give
yourself a high five because you just
deployed your first smart contract and
you learned the basics the fundamentals
of solidity so huge congratulations on
how far you've gotten now in our second
project we're going to take the
fundamentals a step further and start
going into the more of the intricacies
of solidity but just as a quick recap
the first thing you always got to do in
your smart contracts is name the
solidity version then you'll have to
name your contract a contract in
solidity is like a class and defines all
the functions and parameters of your
contract there's many different types in
solidity like unsigned integer 256
Boolean and bytes we can create structs
in solidity we can create arrays in
solidity we can create mappings in
solidity we can create functions in
solidity view functions don't make a
state change memory and storage are two
different ways to initialize where a
variable is going to be saved all the
solidity code that we're working with
gets compiled down to the ethereum
virtual machine and last but not least
congratulations on taking your first
step in learning solidity let's move on
to the next project
all the code tips and links that we're
going to be working with can be found in
our course repository we can scroll down
to lesson two storage Factory click it
here and we can see all the code we're
going to be working with good luck all
right so we've done it we've got our
first contract out of the way we're
understanding some of the basics of
solidity now let's move onward let's get
a little bit more advanced with what
we're going to do with our smart
contracts and let's build What's called
the factory pattern of smart contracts
so we have our simple storage contract
here which is great it allows us to
store numbers and store favorite numbers
associated with different people and
this is great what if though I want to
have a lot of these simple storage
contracts deployed I want to give people
the ability to generate and deploy their
own lists based off of this contract
this is where the factory pattern comes
into play so let's go ahead and create a
new contract so in this contracts folder
I'm going to do new
file we're going to call this
storage Factory
doso and now we'll have a storage
factory. Soul now the way that we're
going to do this is that you need simple
storage and storage Factory in the same
folder I have both of them in this
contract folder but if you have them
outside or in a different folder that's
okay just make sure what wherever they
are they're in the exact same folder so
let's figure out how to get a contract
to actually deploy another contract
we're going to add those basic pieces
that we added in that simple storage.
soul we'll add the
spdx
license
identifier which will be
MIT we'll choose our solidity version
which will be
pragma solidity and we'll say anything
in the six range
and then we'll create our contract we'll
say
contract storage Factory and we'll
create our brackets here and I'm going
to do command s or compile whatever you
want to do things are looking good here
great so how can this contract deploy a
simple storage contract well the first
thing that we're going to need to do is
actually import this simple storage into
our storage Factory contract we need to
import it so that our storage Factory
contract knows what a simple storage
contract even looks like the way that we
can import it is by doing the command
import and then the file path that the
simple storage is located so the file
path for this is going to be
at/
simple storage.
Soul this means that simple storage is
in the exact same directory as storage
Factory doing this line is equivalent to
copying every everything in this
contract bit coming over to storage
Factory and pasting it
above you can even save and compile and
have two contracts in the same file now
what's interesting about having two
contracts in the same file is that when
you go to deploy you'll actually have a
choice of which one you want to deploy
and it's the same thing if I do that
import statement so if I delete all this
and I go back to
Imports simple storage do so in our
deploy tab still you'll see that we
still have our choice of which contract
we actually want to
deploy so this is how we actually import
a contract or import any type of file
that we want so that our contract knows
what that contract looks like and can do
so if we want this contract to then be
able to deploy a simple storage contract
we're of course going to have to create
a function that can do that so we'll do
function we'll call it create
simple storage contract we'll make this
a public function we'll do our little
open and close bracket in here the way
we can generate a contract of simple
storage type is by using a new keyword
so let's create a simple storage
variable we'll say a variable of
type simple storage contract we'll name
this variable simple
storage with a lowercase s equals new
simple
storage what this line is saying is
we're saying we're going to create an
object of type simple storage
contract we're going to name it simple
storage with a lowercase s and we're
going to say this is going to be a new
simple storage contract and we're saying
the simple storage contract takes no
input parameters of course if we deploy
this contract as is by going to our
deploy tab choosing the storage
Factory staying on a JavaScript VM
deploying scrolling
down we have this function that doesn't
return anything so we're creating new
contracts but we can't really read where
those contracts are being created we'd
have to look on a block Explorer like
ether scan or something so let's make a
way for us to keep track of all the
different simple storage contracts that
we deploy let's let's put them in a list
or in an array so what we can do is we
can
say simple
storage array of visibility public and
we'll call it simple storage
array we'll initialize this simple
storage array and every time we deploy
we create one of these new simple
storage contracts We'll add it to our
simple storage arid
so we'll do simple storage array. push
and we'll push this simple storage
variable so again I'm compiling or
hitting command s delete that most
recent contract we'll choose the storage
Factory and not the simple
storage and we'll hit
deploy now if we scroll down to our
storage Factory we have this blue button
which stands for our simple storage
array way if we try to see what's at
index zero we get an error of course
because we haven't added anything to it
yet if I click this create simple
storage contract orange button here now
I've created a transaction that's going
to create a new simple storage contract
and push it onto our simple storage
array now if I try to access the zero
withth index or the first index of this
array I'm going to get this address here
this is the address that this simple
storage contract was deployed to so
we've successfully deployed a contract
to the blockchain from another contract
and this of course is really exciting
now we can actually do more than just
deploy the contracts we can actually
deploy contracts from another contract
and then call those functions as well so
let's create a new function where we
call this
store function and we'll also create a
function where we call the retrieve
function from our storage Factory so
we'll do function storage Factory Store
we're going to short-and it by saying SF
store we'll have it take un
256
simple
storage index and a un
256 underscore
simple
storage number will make this a public
variable as well in our little brackets
here and the reason I'm choosing a
simple storage index is because we're
going to choose which simple storage
contract in our list that we want to
interact with and then we're also going
to pass a simple storage number to
call on the store function which of
course we need to pass a favorite number
to anytime that you interact with a
contract you need two things you need
the address of the contract you want to
interact with and you also need the ABI
for us we figured out that we're going
to push and get this address from this
simple storage array we can get the ABI
or the application binary interface from
this import we'll explain the
application binary interface a little
bit more later for now just know that in
order for us to interact with this
simple storage contract we can just do
simple storage
and
then we'll pass this simple storage the
address of that simple storage contract
to get the address of that simple
storage contract we'll say grab the
address inside the simple storage
array at index simple storage Index this
will return that contract that we want
to interact with so we could even
say simple storage
simple storage equals simple storage at
that address in the
array once we get this contract we can
then call any and all of its functions
so we could call Simple
storage.
store this simple storage number now if
we compile this we go to our deploy tab
deploy the Factory hit
deploy open this up we can see we have a
couple different functions here we of
course have our create simple storage
function which creates the contract and
adds it to our array we now have this SF
store which stores a number to one of
those contracts on this array and then
we have a lens into that simple storage
contract so if I create a simple storage
contract I can now
store on that zero withth contract on
that first contract any number that I
want like
55 of course I can't really see that 55
because we didn't add a retrieve
functionality we didn't add a way to
actually listen or read or retrieve that
favor number that we got so let's add
that now so we'll create a new
function called sfg and this will take
uint
256 simple storage
index and as a parameter and we'll
choose one of these contracts on this
array and
return its favorite number calling the
retrieve function on that
contract so since we're just going to be
reading State this can be a public view
function that will return a un
256 to do this we need to access that
contract once again so we'll say
simple
storage simple storage
equals simple
storage at that address of
simple storage
array at index uncore simple
storage
index and we can
return
return simple
storage
dot we call this retrieve
function I'm just going to copy paste it
so I don't spell it wrong simple storage
we'll put the semicolon here
too and
here now if we compile this go to our
deploy Tab delete the most
recent choose the storage Factory and
hit
deploy we can see we now has have an SF
get function so let's go ahead create a
simple storage contract we'll store a
function on the Zero withth contract
we'll store 55 as its favorite number
and we'll hit that and then for sfg
we'll see if we can get
the favorite number of the zero withth
contract and we do indeed get 55 awesome
we can actually even refactor this code
to be a little bit simpler here we don't
need to
save this simple storage contract as a
variable here we can actually just call
retrieve on this whole section here
paste retrieve at the end and just turn
like this
the same goes for our SF store we can
delete saving it as a
variable we can copy this do store paste
it at the end here and delete this as
well now we'll
compile delete the most recent we'll
deploy the storage
Factory and if we go into it create a
simple storage
store the number of
55 see what's at the zero with index and
we do indeed see 55 so this is really
cool this is a way for us to actually
deploy contracts and interact with
contracts from another contract now to
deploy a contract we do need all the
functionality of that contract imported
however to interact with the contract we
don't need all of the functionality we
learn about interfaces in the next
lesson which will allow us to actually
interact with contract without having
all of the functions defined and now I'm
going to show you something really cool
now I'm going to show you something
really cool simple storage has got a lot
of really cool functions and maybe I
want all these functions inside my
storage Factory I want my storage
Factory to be able to create simple
storage contracts and I want it to be a
simple storage contract
itself well what I can do
is my storage Factory can actually
inherit all the functions of simple
storage without me having to copy paste
all these functions and all these
variables over to storage Factory what I
can do is I can do solidities version of
inheritance I can say contract storage
Factory is of
type simple storage or is of contract
simple storage and just by doing this
line right here my storage Factory
contract now will have all of the
functions and variables of simple
storage so it'll have a store function a
retrieve function an ad person
function a people array a name to
favorite number mapping it'll have
everything because I will inherit it
with this is
syntax so if I go to my deploy tab
now let's look at what our last storage
Factory was
all we did to change this was add is
simple storage and we can see just the
four functions that we originally added
if I delete this
now if I save and compile the storage
Factory let's go ahead and deploy
storage
Factory if we open this up now we can
see not only do we have all the
functions originally defined in our
storage Factory but We additionally have
all the functions from our simple
storage and awesome you've completed the
second lesson we've learned about some
incredibly powerful tools here we've
learned how to import entire chunks of
code from other files into our files
we've learned how to do inheritance
we've learned how to deploy contracts
from our
contract and then we've learned how to
interact with different contracts from
outside of our contract well done now is
a great time to take a breath take a
breather and review what you've
learned the GitHub repository associated
with this course also has all the code
for this lesson so let's jump into it so
we're back in remix now and we're going
to go to contracts and same as before
we're going to create a new file we're
going to call this fundme doou now same
as last time we're actually going to add
this spdx license identifier MIT right
at the top and then we're going to
choose our solidity version
so we're going to go pragma
solidity and for this we're just going
to do greater than or equals to
0.6.3 and less than
0.9.0 and great this should look pretty
familiar now we're going to do contract
fundme and we're going to get start
working so what again do we want this
contract to do we want this contract to
be able to accept some type typ of
payment so let's create a new function
that can accept payment we'll call it
fund so we'll do function
fund public and we'll add a new keyword
in here called payable when we Define a
function as payable we're saying hey
this function can be used to pay for
things when you call a function every
single function call has an Associated
value with it whenever you make a
transaction you can always append a
value value this value is how much wey
or guay or finny or ether you're going
to send with your function call or your
transaction as we mentioned before whey
guay and ether are just different ways
to talk about how much eth you're going
to send so if we look at a way to
ethereum converter 1 e is this much way
one way is the smallest denomination of
ether you can't break up ethereum into
anything smaller than one way this is
why when you're talking about how much
something costs everything always
defaults to way or the smallest unit of
measure in theum so again for us to test
we're going to stick with the JavaScript
VM for now if we hit deploy we get a new
contract and this button is now red it's
red because it is a payable function so
now if I hit this fund
button I can add a value associated with
it so what do we want to do with this
funding what do we want to do when
people send us something well let's keep
track of who sent us some funding so
what we can do is we can create a new
mapping between addresses and value so
let's do a
mapping of
address to un 256 which will represent
the value we'll make this a public
mapping and we'll call it address to
amount funded
now in this fund function let's keep
track of all the people who sent us
money or all the addresses that sent us
some value to do this we can use some
key words that go along with every
transaction so we'll say address to
amount
funded of message.
sender
equals or plus equals message. Val
message. sender and message. Val are
keyword in every contract call and every
transaction message. sender is the
sender of the function call and message.
value is how much they
sent so whenever we call fund now
somebody can send some value because
it's payable and we're going to save
everything in this address to amount
funded mapping so if we deploy this now
in our JavaScript VM we now have again a
new view function called address to
amount funded and we can even hit the
drop down to see the full name now if I
hit fund nothing's going to happen right
because my address is going to be
sending zero in order for me to send
something I have to add some value along
with my transaction so let's send for
example one guay which is going to be
equal to one 1 2 3 4 5 6 7 8 n this much
way so before I hit fund here if I copy
this fake account which is up here and I
put it in this address to amount funded
it's going to return
zero but now if I
add one one 2 3 4 5 6 Seven 8 nine in
here and we go ahead and hit fund now
we've now just called this fund function
with a value of one guay associated with
it so if I call this address to amount
funded now with the same address I can
now see how how much we've funded this
smart contract and we can even add more
guay We'll
add We'll add 11 guay for example we'll
call fund and if we call this now we can
see that even more has been added when
we send our funds to a contract this
actually means that this contract
wherever this is deployed now is the
owner of this amount of ether so this is
fantastic we now have a way to fund our
smart contracts now here's the thing in
this smart contract in this funding that
we're doing we want to create a minimum
value for people to be able to fund our
endeavors which whatever they may be we
want to set some minimum value here and
ether is great but for whatever reason
we want to work in USD or maybe we want
to work in some other token so how are
we going to get the conversion rate from
that currency to a currency that we can
use in this smart contract well the
first thing that we're going to need to
do to set this value is we're going to
need to
know what the eth to USD conversion rate
is because if I want to accept ethereum
as the token but I want it in its USD
currency well then I'm going to need to
know what that conversion rate is so how
are we going to get this data into our
smart contract where are we going to get
this data from now remember how we
talked about blockchains being
deterministic systems and and oracles
being the bridge between blockchains and
the real world well this is exactly
where oracles come in when we're talking
about these systems you know these
blockchains they can't connect to real
word events they can't connect to
external systems they can't do external
computation they're intentionally these
deterministic systems these walled
Gardens so in order for us to make this
connection we need a blockchain or we
need some type of of network here now
just to get a little bit more uh
technical for you if we look at a
blockchain A blockchain can easily say 1
+ 1 equals 2 and every other node can
easily verify this
however a blockchain can't easily say
okay let's all grab the same random
number because each node is going to get
a different random number they also
can't say hey let's make an API call
because if one node calls the API at a
different time another node calls it or
specifically an HTTP get there could
potentially get very very different
results and if another node tries to
replay these transactions by calling
these apis again maybe 10 years in the
future there's a good chance that that
API is going to be
depreciated and they could be hacked
they could be malicious etc
etc the other reason that blockchains
intentionally can't make API calls is
because then they would be making
assumptions about the real world and
layer ones typically don't want to have
an opinion on any political or
geopolitical issue whereas an oracle
Network on the other hand can make those
assumptions the other main thing we need
to talk about here is centralized
oracles being main points of failures if
you or I say hey I'm just going to be
the Oracle I'm going to be the one to
put this data on chain we now have this
massive centralized point of failure
we've done all this work to make our
decentralized computation decentralized
in onchain but we ruin all the decentral
by having a single point of failure
remember one of the whole purposes of
blockchain is so that not a single
entity can flip a switch and restrict
our freedom to interact with a
centralized Oracle a single entity can
flip a switch and restrict our freedom
to interact with each other we also need
to get data from many different
decentralized sources or do any type of
computation in a decentralized manner
this is where chain link really shines
chain link is a modular decentralized
Oracle infrastructure and Oracle Network
that allows us to get data and do
external computation in a highly Cil
resistant decentralized manner it can be
as customizable as you want as you can
run with one node or many nodes or do as
many nodes as you like now currently one
of the most popular features of chain
link is their data feeds or their price
feeds we can even go check them out over
at
data. chain.
link we can see a number of different
price feeds and the networks that are
providing the prices for these specific
pricing points we can see here by
looking at the UI there's a whole number
of decentralized different or oracles
returning data for different price feeds
this one for example is FUSD and it's
also exactly the price feed that we're
looking for having a decentralized
network bring this data on chain and
have it as a reference point of
definitive truth allows users to all
collaborate and use this common good and
it will be cheaper more secure more
efficient than anybody even running
their own centralized Oracle so these
price feeds are incredibly powerful
additionally they're being used by some
of the top protocols in the def5 system
right now like synthetics which at the
time of recording is securing around two
billion do sushi swap for leveraging
trades set protocol commodity money a
for understanding the price of an
underlying collateral now this is an
example of an out-of-the-box
decentralized Solution that's already
been packaged in a decentralized manner
for you to consume and for you to use
this makes going to production a
thousand times easier than building
everything yourself however if you want
to make API calls and build your own
decentralized network you absolutely can
with the chain link API calls we're not
going to go into that here because using
the chain link price feeds chain link VF
keeper Network and all these other
pre-boxed decentralized services are
going to make going live and going
mainnet a lot easier you can always make
a chain link HTTP get call as well we're
not going to go over this though because
putting this into production is a little
bit trickier and working with chain link
VF if you ever want to try them out by
themselves you can always head over to
docs. chain. link and head over to get
the latest price feed there's usually a
remix button actually that we can click
and it will kick us out to a remix
Edition with all the code already ready
to go for us if we just hit this gist
right here this will include all of our
code which we'll go into in a second but
let's go ahead and compile it we're
going to deploy it to a real Network
here this one looks like it's actually
for Co so we're going to go ahead and
switch to Coen looks like I don't have
any Coen ethereum so we're going to gra
Coen faucet we can usually find
different Faucets in the chain link
documentation let's look up coven
herea there is a coven faucet here it
looks like in order for us to get some
Coen ethereum here we have to log in
with GitHub then we can add our address
in here and get the ethereum in the
interest of time I'm going to skip ahead
for me doing
that great it looks like I've got some
Co tesed now being able to switch
between test Nets is going to make you a
lot more effective as an engineer as
well because you're going to be able to
understand how each Network actually
works so now we've compiled this let's
deploy
this again minim mask is going to pop
up and let's go ahead and click the get
the latest price and we can see that
this function does indeed return the
latest price of ethereum now you might
be asking why does this number look so
big well remember how we talked about
way a and guay and ether well the reason
that those exist is because decimals
don't work in solidity so we actually
have to return a value that's multiplied
by 10 to some number so this value is
actually
2,614 times 10 raised to the E now the
next question you might ask is well why
did we work with this on a test net why
couldn't we do this on a local network
and the answer to this is because there
is a network of nodes looking at this
test net and delivering data onto this
test net when you spin up a local
network or do a simulated VM there are
no nodes actually doing that we'll learn
later how to actually mock these
interactions and mock a chainlink node
returning data onto our blockchain but
for now let's head back over to the
contract that we're working on so we can
learn how to implement this in any
contract that we ever want to another
contract called in this case called
price feed has a function called latest
round data which returns a lot of data
it returns a round ID which defines how
many times this price feed has been
updated it returns a price which is the
actual conversion rate between the two
assets it returns a started at which
defines when this was last updated it
returns a timestamp and it returns and
answered in round don't worry about
answered in round for now if you want to
dive a little bit deeper into what these
rounds mean and what answered in round
means you can definitely check out the
chain link documentation and some of the
FAQs to learn more now how do we
implement this data feed into our funme
application well the first thing we're
actually going to need to do is we're
going to need to import the chain link
code so we're going to do import at
chain link SLC
contracts SL Source
v0.6 SL
interfaces SL
agregator
E3
interface.
Soul now let's talk about what this is
actually doing oops looks like I spelled
aggregator V3 interface wrong all right
great now it's actually
confined so let's talk about what
imports actually do as we know an import
will take whatever code you're importing
and stick it at the top of your project
so when we import from at chainlink
contracts we're actually importing from
the at chainlink contracts mpm package
we can look up at chainlink
contracts in
mpm and we can see and read more about
this
repository this links us back to the
GitHub which will tell us a little bit
more about what's really going on if we
follow that import path that we got from
the documentation we'll end up on this
file in front of me now we have what's
called an interface you can see these
contracts don't start with the contract
keyword but they start with the
interface keyword they have the exact
same pragma solidity at the top but the
the main difference is that you can see
that their functions aren't completed
they just have the function name and
it's return type now just to be a little
bit more explicit here I'm actually
going to go ahead and delete this import
statement on the top and replace it with
that interface code from GitHub just to
show you exactly what's going on however
if you've already typed that at import
syntax feel free to leave it in there
and just remember that it's going to be
the exact same as me copy pasting the
interface code in in our code here
solidity doesn't natively understand how
to interact with another contract we
have to tell solidity what functions can
be called on another contract this is
where interfaces are actually going to
come in similar to strs what we can do
with interfaces to find a new type so if
we copy all this code from this section
and place it at the top of our code here
above where we're declaring a contract
we can actually then interact with
contract that have these functions if we
go ahead and even compile this we can
see this does indeed compile correctly
remember how we said before we talked a
little bit about abis well interfaces
actually compiled down to What's called
the ABI or the application binary
interface the application binary
interface tells solidity what functions
can be called on another
contract we need solidity to know what
fun functions it can use and what
functions it can call other contracts
with and if that was a little bit
confusing just know anytime you're going
to interact with another contract in
solidity or smart contract programming
in general you're going to need that
contract's ABI we'll go into what these
abis look like a little bit later
anyways to simplify it interface
compiles down to an ABI we always need
an ABI to interact with a contract so
how do we actually work with this
contract here to interact with an
interface contract it's going to work
the exact same way is interacting with a
struct or a variable let's define a new
function called get version and we're
going to call this version function on
this other
contract so we'll start out doing
function get
version public remember it needs to be a
view since we're just going to be
reading this state and even in the
interface it even defines it as a view
returns so we'll even grab this whole
bit right here few returns un 256 now
the exact same way we Define variables
and structs we Define working with other
contracts and interfaces so the first
thing is we name the type which in this
case is aggregator V3 interface then
we'd name the visibility but since again
we're inside of this contract we're
going to skip it then let's give it a
name we'll call it price feed since this
aggregator V3 interface Bas is going to
be giving us price fee then we can do
equals and this is where we're going to
initialize the contract so how do we
actually choose where to interact with
this contract well we just type
aggregated V3 interface and then we put
in here the address of where this
contract is located in order to find
where this FUSD price feed contract is
located on the rink be chain we can look
at the ethereum price feeds chain link
documentation it has a ton of different
price feeds and even more not price
related
data let's scroll down to rink be
because again on each different chain
the contract address that has all this
price feed information is going to be
different let's scroll down and find
FUSD which is right here and we'll copy
it and we'll paste it into
here now what is this line saying it's
saying that we have a contract that has
these functions defined in the interface
located at this address if that's true
then we should be able to call Price
feed dot
version and we should be able to return
it whoops looks like we forgot to
add those here and we need a semicolon
here I hit controls or command s
compiles it looks like we're compiling
successfully and we do need to deploy
this on a test net remember this address
here is located on an actual test it's
located on an actual Network it's not
going to be located on our simulated
chain here so we do need to deploy this
to injected web 3 we do need to deploy
our contract to rink B because the rink
be chain has this address we'll learn
later on how we actually can work with a
simulated chain and work with these
price feeds but that's much later in
this course so let's go ahead and save
we'll deploy make sure we're on injected
web 3 now we can go ahead and hit
deploy metamask is going to pop up per
usual confirm we're going to get a
transaction link to Ether scan showing
us our
contract and once it actually is
confirmed we can see we have our
contract right here now we have our
familiar functions with one additional
function we have our fund button which
is because it's payable we have our
address to amount funded mapping which
is blue because it's a view and we also
have this get version button that's also
blue if we go ahead and click it we can
see that the version of our aggregator
V3 interface is version 3 this is the
third version of the aggregator
interfaces hence the name aggregator V3
interface so we just made a contract
call to another contract from our
contract using an interface this is why
interfaces are so powerful because
they're a minimalistic view into another
contract so this is great we have a get
version function but this still isn't
the function that we want we want to
call the get price function which if we
look at our interface we can see there
is a latest round data function that
returns an answer this is the function
that we're going to want to call on this
contract so let's go ahead and make a
function that calls that instead so
we're going to do
function get
price public view returns uint
256 uh oh this latest round data
function though returns five variables
so how do we actually work with that
well let's find out to work with this
contract we're going to do the exact
same thing we're going to do aggregator
V3 interface because this is the type of
the
contract price feed equals
aggregator V3 interface we'll do this
same address in here because this is the
FUSD
address then we'll do price feed dot
latest round
data now since this is going to return
five different values we can actually
have our contract also return these five
different values we can copy paste like
this and literally do this
these five values equal Price feed.
latest round data and you can see that
even compiles correctly let's adjust the
formatting a little bit here so it looks
a little bit nicer a tupal is a list of
objects of potentially different types
this is the Syntax for getting a tupal
we can Define several variables inside
one of these tupal Although our compiler
is going to give us some warnings it's
saying unused local variable because
we're not actually using these for
anything we'll come back to this now we
can go ahead and do return and we can
pick one of these variables that we want
to return answer is going to be the
price so we're going to do return answer
but uh oh we're going to run into an
error return tight argument int 256 is
not implicitly convertible to expected
type answer is an INT 256 and we want to
return a uint 256 so how do we Rectify
this we can fix this by using what's
called type casting if we just return
answer we're going to be returning the
wrong type I however integers and
solidity are really easy to cast into
each other so we can just do uint
256 and wrap it around this answer and
then compile and save that instead as
you can see now our compiler is happy
because we've changed this answer into a
u 256 awesome so now this get price
should return the latest price of
ethereum in terms of USD let's go ahead
and deploy this new contract with this
new function so same thing we're going
to come to our deploy section hit the
deploy button oh remember we got to go
to the fund me.so let's deploy it
confirm with metamask
here and let's scroll down to our newly
deployed contract as you can see we have
our get version function which still
works exactly the same but we have a new
function too called get price and this
should return a un 256 answer let's go
ahead and click it amazing we've
actually returned an answer now again if
you're a little confused on why this
number looks so big you have to remember
that this actually has eight decimals we
could call this decimals function on the
contract to learn that 1 2 3 4 5 6 7 8
and we know that the current price of
ethereum in terms of USD is
2,482 awesome so now that we have the
price we can actually get the conversion
rate but let's clean up this function a
little bit before we go on up there as
you can see one thing that the compiler
is complaining about is we have a lot of
unused local
variables but latest round data returns
five different variables so how do we
actually return the five variables but
make our compiler happy with us well we
can actually just return blanks for each
one of these sections with commas in
between each other to say hey there is a
variable here but we're not going to use
it this will also make our code look a
lot cleaner
cleaner because now this function's a
lot smaller we say h something's here
we're ignoring it in 256 answer we're
going to use something's here ignore it
something here ignore it and ignore this
too and we can even test this out by
compiling
it deploying it checking on rank
B scrolling down hitting this and
hitting get price and you can see indeed
it's the exact same as before awesome so
now we're all done cleaning things up
right not quite yet see the other thing
that's really annoying here we have this
massive chunk of code at the top that is
probably a little redundant there's a
good chance that a lot of our contracts
are going to want to use this aggregated
V3 interface so let's just go ahead and
add that at chainlink Contract syntax
back in because it's going to look a lot
cleaner here and do at chainlink SLC
contracts if you ever get a little bit
confused with what you should be
importing to work with their contracts
we can see right in the documentation at
the top this at syntax is what this is
going to use now you can also go ahead
and browse that mpm package of chainlink
contracts to see what other applications
are in there and what other files are in
there or you can just peruse around the
GitHub now the third way we can actually
do Imports is we can import from
contracts that are in the same file
system as our contracts well awesome our
contract is starting to look more and
more put together now one other thing
that I usually like to do with these is
I usually like to put everything into
the gay way standard so as we saw this
get price had eight decimal places
however the smallest unit of measure AKA
way if you look at it has 18 1 2 3 4 5 6
7 8 nine 10 1 2 3 4 5 6
78 so typically in these I like to try
to make everything have 18 decimals as
well you don't have to do this and it'll
save some gas if you don't but I usually
like to multiply everything so that
everything has 18 decimal places so
since I know this has eight I can just
do 1 2 3 4 5 6 7 8 I 10 and now this
will return the price with 18 decimal
places instead of 10 now we have the
price of ethereum in US dollar which is
fantastic so we could set the price of
our fing function to anything that we
want here for example let's say $50 we
could convert whatever value that they
send us to its US dollar equivalent and
see if it's greater than or less than
$50 all we have to do is make a new
function that converts that value that
they send to its US dollar equivalent so
we could do
function get converion rate and and it
will take a un
256 F amount let's get this out of the
way for the rest of this it'll be a
public view function since again we're
not actually going to have it make any
state change we'll do returns you went
256 and then in this function we can do
uint 256 f price equals get price and we
can call this get price function up here
now we have the price in here what we
want to do is we want to convert
whatever value that they send as fth
amount let's say they send one g or
again that's going to be this much
way what how do we convert this to
FUSD well we can now do U 256 F amount
in
USD equals this F price times
the F amount that they sent this is
actually going
to result in a much bigger number than
we're looking for and then of course
we're going to return it let's test this
out and see why we have to do one more
thing here so let's again fundme we'll
deploy rank
B we'll scroll down and we have this new
function called get conversion rate
let's grab this one guay and put it in
here whoa this seems like it's a really
big number we're saying that one guay is
equal to 1 2 3 4 5 6 7 8 1 2 3 4 5 6 7 8
nine
10 this many
dollars now I don't know about you but I
don't think the price of even one
ethereum is that many dollars maybe in
the distant future but definitely not
right now the reason that it's off is we
have to then actually divide by this
number the reason that we have to do
this is because both f price and F
amount have an
additional 10 rais to the 18th tacked
onto them so now we have to divide it
out in order to get the right number so
we're going to
compile
compile deploy
confirm we can scroll down and now let's
try this one gu we get the conversion
right here and we can see we get a
number that makes a little bit more
sense now remember this has 18 decimals
as well so the real number is 1 2 3 4 5
6 7 8 1 2 3 4 5 6 7 8 9
10 and we know that this number is
actually accurate because we can go
ahead and pull up a
calculator pop that into here and we
know that this is one gay in US dollar
if we get the conversion rate we're
saying that this many guay equals 1 E so
we can check it back by multiplying this
number by that and we see that we do
actually get the price of one ethereum
in US
dollar so our math here checks out
awesome now since we're on the topic of
math I do want to talk briefly about
some of the pitfalls of solidity
especially when it comes to math prior
to solidity 0.8 if you added to the
maximum size a uint number could be it
would actually wrap around to the lowest
number that it would be and in fact you
can even demo this with the contract
here now you don't have to follow along
with this contract but just watch to see
the example we're going to call this
overflow do Soul now in here we're going
to add all kind of the normal stuff
contract
overflow and we're going to add a
function called overflow we'll make a
public View and we'll have a return a
uint 8 show you why in just a minute a
uint 256 is a really really big number
and it's hard to kind of Imagine going
over the maximum cap of a un
256 but a un 8 is a lot smaller with the
maximum number actually being 255 so if
we create a uint 8 and we call it Big
equals
255 and then we just do return big what
do we think we're going to get here for
this we can go ahead and use JavaScript
VM because we're not interacting with
any other contracts let's deploy this
and we'll see in our contract if we call
overflow now we're just going to get
255 however what happens if we add one
to this number or try to add one to this
number if we do it just like this
solidity actually knows that there's an
issue here and says Hey try not to do
this but if we typ cast this as a uint 8
slity gets a little bit more confused
and goes ahead and lets us do this now
what do we think big is going to be it
should be 200 56 right but big is a u in
8 and this is the maximum size that it
could be so what happens when we deploy
this we look down we actually get zero
what happens if we do 100 and we deploy
that we actually get 99 and this is
because integers can actually wrap
around once you reach their maximum cap
they basically reset this is something
we need to watch out for when working
with solidity if we're doing
multiplication on really big numbers we
can accidentally pass this cap luckily
as a version 0.8 of solidity it actually
checks for overflow and it defaults to
check for overflow to increase
readability of code even if at it comes
a slight increase of gas costs you can
use this unchecked if you want to have
it keep that wrapping functionality so
just be aware if you're using a lower
version than 0.8 you're going to have to
to do something to make up for this and
we could write a whole bunch of code
here basically to check all of our math
or we could just import something called
safe maath from another package similar
to how we imported chain link we can go
ahead and import a package called safem
maath from a tool called open
Zeppelin now open zeppin is an open
source tool that allows us to use a lot
of already pre-built contracts we can go
ahead to their documentation and go to
their utilities and see safe maath they
even have a little sticker here saying
safe math is no longer needed started
with solidity 0.8 safe math is a tool
and a way for us to avoid some of these
problems with doing math and solidity
now I'm not going to spend too much time
on the contracts that actually fix this
but we can actually import right from
the chain link directory as well a
solidity file called safe math chain
link and what we can do is right after
our contract we can do using
safe math chain
link for un
256 and what this will do is it'll use
safe maath chain link for all of our U
256 and safe maath chain link doesn't
allow for that overflow to occur
libraries are really similar to
contracts except that they're isolated
code that can be run in a reusable
context in this case where attaching the
safe math chainlink library to U 256 so
that these overflows are automatically
checked for just keep in mind if you
using anything less than 0.8 you're
going to want to use some type of safe
math just to check for your overflows
now this is for those of you who are
familiar with safe math and integer
overflows and underflows we are not
going to be calling the functions that
safe math provides us like div add mole
you know all those functions simply
because in 0.8 moving forward we no
longer have to use those and we can just
use our regular operators like plus and
minus so this is great our contract is
coming along really well we now have a
way to get the conversion rate of
whatever f is sent and turn it into US
dollar now we can set a threshold in
terms of US dollar but how do we
guarantee that whatever amount that the
users send when they call fund is going
to be at least $50 well first we might
want to set a minimum value so we can do
un 256 minimum
USD equals let's say
$50 and again since we're using
everything in guay terms we want to then
multiply this by 10 ra to the
18th and just wanted to take a pause for
a second because this line is actually
wrong this should be raised to the 18th
so this line should really look like
this where it has the double star so
apologies the rest of this has that
single star but it should be the double
star here if you do have the single star
though the rest of the contract will
still work fine so this will be the
minimum value it'll be $50 * 10 raised
to the 18th so that everything has 18
decimals now that we have a minimum
amount how do we actually make sure that
this minimum amount is met in the value
that they send us well if you're
familiar with if statements we could do
something like if message.
Val is less than minimum
USD then revert
or we could do something a lot easier
and better practice and much cleaner we
do what's called a require statement
when a function call reaches a requir
statement it'll check the truthiness of
whatever require you've asked so in our
case the converted rate of message.
value needs to be greater than or equal
to our minimum
USD this line says that if the
conversion rate of message. value to USD
if they didn't send us enough ether then
we are going to stop executing we're
going to kick it out we're going to say
hey this doesn't count and we're going
to do what's called a revert we're going
to revert the transaction this means
that the user is going to get their
money back as well as any unspent gas
and this is highly recommended we can
also then additionally add a revert
error message something like you need to
spend more eth
so now let's try this out as we saw one
guay is going to be way less than $50 so
if we send one guay along with this fund
contract call it should kick out and say
you need to spend more eth so let's
actually try this let's go to the deploy
tab we'll get rid of our overflow we use
injected web 3 because again we are
working with the chain link aggregated
contracts that are on chain we're going
to move to fundme and we're going to hit
deploy
met Mas going to pop off and we're going
to hit
confirm now if I try to hit fund let's
see what happens we're getting a gas
estimation failed says gas estimation
error failed with the following
message execution reverted you need to
spend more eth so the contract isn't
even letting us make the transaction we
can go ahead and try to send the
transaction but here's what's going to
happen on ether scan once this goes
through you can see that once this
transaction finished we got this status
fail with error you need to spend more
eth we don't want to force these
transactions to go through if we look at
our metamask we can even see this failed
bit here so whenever you see these gas
estimation failed errors usually that
means something reverted or you didn't
do something that was required however
if we go to Value here and we spend a
lot more let's say 0.1
ether which if we take out our
calculator
250 0.1 is going to be
$250 this should easily be well and
Beyond past our $50
threshold so let's add 0.1 ether and
remember we got 0.1 by adding it in the
converter and grabbing the way again the
way is the smallest denomination now if
we change this to way and hit fund this
should go through we go hit fund now
you'll see mamass pops up because mamass
goes oh yeah this transaction isn't
going to revert and that's what we want
so we can go ahead and hit
confirm and now we'll finally have sent
some funding to our
contract now that this is confirmed we
can go ahead and grab our address
here pop it into our address to amount
and we can see that indeed our funding
has gone through now we can be part of
this crowdsourcing application with our
minimum value which is fantastic awesome
great
job awesome so now we can fund this
contract with a certain minimum USD
value in this case it's going to be $50
now you'll notice though that right now
we don't do anything with this money so
we're going to fund this contract
however that's it and we don't have a
function in here to actually withdraw
the money so there's no way that even
though we just sent this contract some
money there's no way for us to get it
back so how do we fix this well we can
add a withdraw function in here so let's
go ahead and add that
function
withdraw and this is also going to be a
payable function because we're going to
be transferring eth we'll make this
public and we can do message. sender.
transfer transfer is a function that we
can call on any address to send eth from
one address to another this transfer
function sends some amount of ethereum
to whoever it's being called on in this
case we're transferring ethereum to
message. Sender so all we need to do now
is Define how much we want to send well
we're going to send all the money that's
been funded so to get all the money
that's been funded in this contract we
can do address
this.
balance now there's a couple of special
things going on with this line first
we're saying address of this
this is a keyword in solidity whenever
you refer to this you're talking about
the contract that you're currently in
and when we add address of this we're
saying we want the address of the
contract that we're currently in
whenever you call an address and then
the balance attribute you can see the
balance in ether of a contract so with
this line we're saying whoever called
the withdraw function because whoever
calls the function is going to be the
message. sender transfer them all of our
money so let's go ahead and try this
let's deploy
fundme and now let's fund this with a
lot of ether so that we can see it we'll
fund it with one whole
ether so that we can see it go into the
contract and get pulled out of the
contract we'll hit the fund
button and you'll see we're sending one
whole ether into this
contract now if we look at our balance
bance it's gone down from 17 to 16 or if
you're still at 18 it went down from 18
so let's try to get it back if we call
this withdraw function now
confirm once this transaction goes
through we should get all of our ether
back let's look at our metamask and boom
indeed we have got all of our e back
however looking at this contract we can
see that hm well maybe we don't want
anybody to be able to withdraw all the
funds in this contract that seems like
it might be a really bad idea maybe we
only want the funding admin to be able
to withdraw funds so how do we set this
up in a way that only the contract owner
can actually withdraw funds well we
learned before that the require function
can actually stop contracts from
executing unless some certain parameters
are met we can do the same thing here
with
require message. sender
equals the
owner but but we don't have an owner to
this contract yet so how do we get an
owner to this contract the instant that
we deploy it well we could have a
function called create owner what
happens if somebody calls this function
right after we deploy it well then we
wouldn't be the owner anymore so we
actually need a function to get called
the instant we deploy this smart
contract and that's actually exactly
what the Constructor does so typically
at the top of your smart contracts
you'll see a Constructor and this this
is a function that gets called the
instant your contract gets deployed we
don't even need to do add function here
we can literally just call
it Constructor because it's what
constructs the smart contract so we'll
make Constructor public and whatever we
add in here will be immediately executed
whenever we deploy this contract so one
thing that we could do so we could have
an owner be set the instant we deploy
the smart contract so in the top we
could add
address owner and in our Constructor we
could say owner equals message. sender
because the sender of this message is
going to be us it's going to be whoever
deploys this smart contract we can even
test this out in the JavaScript VM to be
a little bit quicker because we're not
actually going to be calling the fund or
the get price function for now oops
let's also make this public so that we
can interact and see this owner variable
so now if we go to fund me we deploy
this in the JavaScript VM we should be
able to see who the owner of this
contract is and it should be our address
because this Constructor function should
have been immediately called the instant
that we deployed the smart contract
awesome we can see the owner of this
smart contract is indeed our wallet
because remember when're working with
the JavaScript VM our wallet is these
fake wallets that they kind of give us
we can even try this with an injected
web 3 with deploying this
and the owner should be this Ox 757 Etc
address let's go ahead and look at funme
see the owner and we do indeed see the
owner is us okay great now we have an
owner we can go down to our withdrawal
function and use that same
require so we can
call
require message. sender equals
equals owner equals equals is the way
that solidity understands true false
we're saying that message us sender has
to equal owner now let's go ahead and
try this and we'll try with the
JavaScript VM again for Speed
reasons let's deploy this
fundme and if we go down here we try to
call the withdraw function and it looks
like it is successful because currently
this is the address that deployed the
contract and it's also the address that
is calling withdraw however if we switch
to a different account and call
withdraw you'll see that remix actually
freaks out down here it says uhoh
something wrong happened and this is
essentially the required statement
kicking out if you want to try it with
injected web 3 as
well we can absolutely do that too and
remember the way to switch accounts in
metamask is to either create account
right here or just switch like this and
then we'll connect with account two
so if I try to withdraw from this second
account that didn't call the contract
and I hit withdraw now it's going to
give us gas estimation failed because
the required statement is going to kick
out but again if we switch back to
account one and we call withdraw
metamask is going to pop up and it's
going to allow us to withdraw now
obviously there's nothing in this
contract right now so we're going to
withdraw nothing but we can still call
it it's going to do message. transfer
zero so this is great we can now require
this withdraw function is only callable
by the owner now what if we have a ton
of contracts that want to use something
like this they require the message.
Senter to be some owner or maybe it's
more complicated than this is there an
easier way to wrap our functions in some
require or some other executable well
this is where modifiers come in we can
use a modifier to write in the
definition of our function add some
parameter that allows it to only be
called by our admin contract modifiers
are used to change the behavior of
functions in a declarative way let's
create our first modifier we'll call it
modifier which is a key word only
owner and we'll add this require
statement in here require message.
sender equals owner then after this we
just add an underscore and a
semicolon what a modifier is going to do
is it's going to say hey before you run
this function do this require statement
first and then wherever your underscore
is in the modifier run the rest of the
code so we could also do a modifier
where the underscore is up here and then
this is afterwards but but we want to
run the require first so now what we can
do is we can make this function withdraw
payable only owner
public and what's going to happen is
before we do this transfer we're
actually going to check this modifier
we're actually going to run this require
message. sender equals owner and then
again where this underscore is that's
where we'll add the rest of the function
so again for Speed reasons and since
we're not actually going to be
interacting with the chain link data
contract we can go to JavaScript VM
switch to
fundme deploy
and we can call withdraw obviously we
can call withdraw from our account but
if we switch accounts and try to call
withdraw we're going to get an error
which is perfect because that means our
modifier is working correctly awesome
now we have a fantastically succinct
fundme contract here the only thing that
we're really missing is that when we
withdraw from this contract we're
actually not updating our balances of
people who funded this so even after
with we we withdraw this is always going
to be the same so we need to go through
all the funders in this mapping and
reset their balances to zero but how do
we actually do that we can't actually
Loop through all the keys in a mapping
when a mapping is initialized every
single key is essentially initialized
now we obviously can't go through every
single possible key on the planet
however what we can do is create another
data structure an array something we're
already familiar with so let's go ahead
and create a new funders array that way
we can Loop through them and reset
everyone's balance to zero we'll do an
address array because it's going to be
an array of all the funders
addresses we'll make it public and we'll
call it
funders now when somebody funds a
contract what we're going to do is we're
going to do funders now whenever a funer
funds this contract we can go ahead and
push them onto our funders array so we
can do funders push message. sender
now if somebody funds multiple times the
funders array is going to be a little
bit redundant but we're going to ignore
that for now now that we have an array
of funders when we withdraw everything
we're going to want to reset this to
zero when we withdraw everything we want
to reset everyone's balance in that
mapping to zero so we're going to do
what's called a for Loop for Loop is a
way to Loop through a range of numbers
to do something so we're going to say
four
un
256 funer
index equals zero because we want to
start with the zeroth
index we're going to give it a Max size
to go to we're going to say the funer
index has to be less than funders do
lengthlength is how we get the length of
our
array and then we're going to say
funders index Plus+ this means that we
have an index variable called funer
index and it's going to start from zero
this Loop is going to finish whenever a
funer index is greater than the length
of the funders every time we finish a
loop we're going to add one to the funer
index that's what that funer index Plus+
does it adds one to the funer index and
every time whatever code is in this for
loop executes we're going to restart at
the top and all we're going to do in
here is we're going to
grab the address of the fun
from our funders
array
funders so the
fun at the index in our funders array
we're going to use this as the key in
our
mapping so we're going to take address
to amount
funded of funer and we're going to set
it equal to zero so now our mapping is
going to be all updated to people having
zero funded in there we do have to do
one more thing as well we have to reset
our funer array as well now there's a
couple ways to do this but a really easy
way is just to set funders equal to a
new array so we could do
funders equals a new blank address
array so all right it looks like we've
got everything in here we need right
away when we deploy this we are set as
the owner we can allow anybody to fund
whatever public good that we're doing
and they have to fund it with the
minimum USD value that we actually set
whenever they fund we'll keep track of
how much they're funding and who's been
funding us we can get the price of the
ethereum that they send in the terms of
USD and we can convert it to check to
see if they're sending us the right
amount we have our only owner modifier
so that we're the only ones who can
withdraw from the contract and when we
do withdraw everything from the contract
we reset all of the funders who have
currently participated in our
crowdsourcing application awesome let's
see if everything works end to end so
we're going to go to fundme we're going
to deploy it we're going to confirm from
metamask and remember if you're ever
confused about what's going on or or
something weird is happening in your
transactions or your deployments you can
always go into ether scan and read more
about your transaction and what's going
on
now that our transaction has been
deployed let's go ahead and just take an
inventory as what's going on we have our
owner which is our address right here we
have the aggregator V3 interface version
which is version 3 which we can kind of
ignore we have the price of ethereum in
terms of USD with 18 decimals instead of
eight we have a function that allows us
to get the conversion rate of any
ethereum amount to its dollar
equivalent we have an array of funders
which right now starts out as empty we
have a mapping of addresses which also
right now starts out as empty let's go
ahead and try to fund this contract
we'll use way just so that we're always
on the same page and we'll fund it with
0.1 way remember everything has 18
decimal places so if we want to do 0.1
we just do 17 so we can do one 1 2 3
four 5 six seven eight 1 2 3 four 5 six
seven eight nine and that'll be 0.1
ethereum now we can go ahead and hit
fund and we're going to send 0.1 eth to
this
contract great so if we look at the zero
with index of funders we can see that
indeed we have funded this contract
let's even have our second account fund
this contract so all we got to do is
switch to this contract and metamask we
can go
ahead and put 0.1 eth back in here for
value and hit
fund now as you can see we're deploying
this from account two let's go ahead and
hit
confirm fun at index zero is going to be
our admin and the funer at index one is
going to be our second
account and if we go ahead and we
add this funer here we can see we've
indeed sent 0.1 ether with this account
if we go back to our account one and put
this in here we can see that that
address also has 0.1 ether
fantastic so let's try to be malicious
let's try to have account number two
actually withdraw all the funds in here
let's hit this withdraw function uh oh
the transaction has failed we're
relentlessly malicious we want to send
this transaction regardless so even
though I'm not the admin of this
contract I've gone ahead and still tried
to send it withdraw so what happens
now we can see that remix is saying hey
something went wrong and again if we
look at ether scan we can see that there
is a fail here since in our modifier we
didn't give a reason here nothing shows
up but we could have always put a reason
in there and something would show up so
all right let's go ahead back to the
actual
admin and now let's try to withdraw
everything so if we hit withdraw now we
can go ahead and confirm what should
happen is everything in here should be
back to zero and this array should be
back to zero as well and if we watch our
address we can see it literally just
went from 04 to 6 because it got 0.1
from the original funding that this
account put in and the 0.1 that our
second account put in so now if we look
at funer zero we can see it actually
errored because it is now a brand new
array and there is nothing at index zero
if we try to see how much this address
now has funded it's back down to zero
awesome you've now learned how to deploy
a relatively simple yet effective
crowdsourcing application where users
can fund and an admin can withdraw those
funds to go spend them on
things now we've been working with remix
so far to start our smart contract and
our solidity development Journey remix
is an incredibly powerful what's known
as a web IDE or an integrated
development environment and in my
opinion remix should always be the
starting ground for anybody looking to
start their smart contract Journey
because it is a wonderfully friendly way
to really show what's going on behind
the scenes and it's really easy to see
everything we're doing with ethereum
with chain link and with our smart
contracts now it does have some
limitations though it's really hard to
integrate other parts of different
projects it has some limited support for
testing or custom deployments it's a
little tricky to save files locally you
need an internet connection to actually
interact with it and it doesn't have
python so in order for us to deploy test
and automate everything about our smart
contract development cycle we want to
connect our solidity and our smart
contracts with a more traditional
programming language like python this
way we can customize our entire
development environment in any way that
we like we're first going to teach you
all how to work with what's known as web
3.pay which is an incredibly powerful
python package for doing everything that
we want to do with smart contracts then
once we learned some of the basics of
web 3. Pi then we'll move on to Browning
which is a smart contract development
framework built on top of web 3py which
makes our lives even easier however it's
still really important to learn web 3p
first because this will teach you what's
going on behind the scenes of
brownie now for the rest of this course
I'm going to be working with Visual
Studio code which is an incredible ibly
powerful text editor that will give us a
lot of formatting and a lot of really
nice tools to work with deploying and
interacting with our smart contracts if
you've already got vs code and Python
and your entire coding setup set up the
way that you like it feel free to use
the timestamps in the description to
skip ahead to the next section you'll
often hear people referring to this as
vs code or Visual Studio code but just
to point out this is not what you're
looking for right in front of you here
Visual Studio is a different application
make sure you're on Visual Studio code
if you want to be a total Hardo and just
work with Vim or emac or whatever else
you want to do you absolutely can but
I'm going to go through setting up
visual studio code the way that I like
it and if you guys want to follow along
I highly recommend it because it's going
to make your life a lot easier there's a
link to download visual studio code in
the GitHub repository basically all you
have to do is come to the site right
here and you can hit this big download
button it should recognize what
operating system that you're on be it
Windows be it Mac or some other
operating system and if it doesn't you
can go ahead and hit this little drop
down and pick one there so let's go
ahead and download visual studio code
and open it
up awesome once you've downloaded Visual
Studio code this is approximately what
you should be seeing there's a fantastic
getting started section here where if
you're brand new to vs code and you want
to learn a little bit more quickly you
absolutely can and we have some links as
well in our GitHub repository giving you
a crash course in vs code if you want to
learn more let's set this up though so
it's going to be really friendly for us
to be doing our smart contract
development here so first we want to go
to this extensions tab it looks like
these little blocks thing right here and
first we're going to look up Python and
you want to install this python
extension right here this is going to
make our lives a lot easier for
interacting with python and and doing a
lot of things with
python then you're going to want to go
ahead and download this and install this
solidity extension this is going to make
formatting our solidity a lot easier now
we want to download python if you
haven't already so go ahead to
python.org
let's go to downloads and it should
recognize what operating system that
you're on and you can just go ahead and
hit the download button and then follow
the steps to download this I've already
got it download so I'm not going to walk
through
this okay great now that we have python
installed one of the other amazing
things about VSS code is you can
actually open a terminal up inside a
visual studio code way you can open your
own terminal if this is your vs code you
can go over on this top bar to terminal
and select new terminal
and you'll see something that looks like
this it might be a bash it might be a
zch it might be a Powershell there's a
lot of different types of terminals that
you'll be able to see by looking right
here we can now test to see if python is
installed correctly we type in Python
space-- version we should get something
that looks like this the exact version
of python doesn't really matter here but
ideally you're at least on python 3.8 if
python D- version vers doesn't work you
can also try
python 3-- version now if neither one of
those works we actually have a number of
troubleshooting tips in the GitHub
repository for this course and often
times a quick Google search on whatever
error that you have you'll get a link
which will lead you to the answer but if
that Google search doesn't lead you to
the answer then just go ahead and drop
an issue or conversation associated with
your issue on the GitHub repo associated
with this course in particular there are
a couple of common errors that I've
definitely seen a number of times so if
you see an issue on your instance that
matches something on the screen here
definitely 100% be sure to check out
those troubleshooting tips sometimes
just installing some of these
applications is really the hardest part
of doing the entire coding Journey here
so please make sure you have Python and
vs code installed correctly before
moving on and don't be discouraged if
this doesn't work exactly the way that
it should right away now if you're on a
Mac you can actually hit control back
tick and it will toggle back and forth
between having the terminal open and
closing it I find this really helpful
and I use it all the time instead of
hitting buttons a key tip for
productivity is going to be using
keyboard shortcuts instead of clicking
around all the time you'll be much
faster okay great we have python
installed we have Python and solidity
extensions of Visual Studio code
installed let's start working on a new
project so in our terminal so in our
terminal we can create some folder I've
already created a demos folder here you
can create one as well if you'd like by
doing
mkdir demos since I've already done it
the file already already exists and then
CD into
demos you can type clear or if you're on
a Mac command K to clear the terminal
now here's what we're going to be doing
we're going to be working with simple
storage again the exact same contracts
but instead we're going to be using web
3.y so we're going to make a new
directory inside of our demos folder SL
directory called Web 3 Pi simple
storage and we're going to see
into this
new folder right here now again all the
completed code is going to be in our
GitHub and there's going to be a link to
everything that we do in this folder in
this GitHub so you can always refer to
that if you get lost and the next thing
that we want to do is we want to have
our Visual Studio code know that we're
in this folder so we can go ahead and
click this files icon and hit open
folder and I'm just going to go to this
web 3 Pi simple storage and hit open and
another vs code will actually pop up we
can see on the left hand side here we
have a folder this will show all the
different files and folders in our web 3
Pi simple storage directory let's go
ahead and create a
file. so we can rightclick on this area
and select new file and do
simple storage. soul and then we can go
back to our simple storage. and remix
copy everything and then paste it into
here if you don't have it up remember
you can always refer back to the GitHub
repository which will have it in there
for you awesome now we have our solidity
in its own file called Simple storage.
Soul you'll notice that some of the
words are actually highlighted different
colors this is known as syntax
highlighting and it's due to the fact
that we added the solidity extension in
it makes reading this code a lot easier
now that this file is in here we'll see
that we have this little Dot here
whenever you see this little dot this
means that your vs code file isn't saved
so we want to always save it otherwise
when we compile or we go to r a script
things might not work correctly so we
can save it by going up to file and then
selecting save or again you're going to
want to learn how to do the keyboard
shortcuts because you're going to want
to hit save often for Mac it's command s
and for Windows it's controls now the
other thing that you'll see is you get
this red line here this is vs code's way
of telling us it thinks that there's an
error at this position so this is really
just the extension being a little bit
confused here and we can safely ignore
this and normally when I'm coding I do
just ignore it we're often going to be
flipping back and forth between compiler
versions so often times this isn't
really a helpful warning here but if it
is really bothersome we could rightclick
it and do something like solidity change
Global compiler version or we can go to
code preferences settings let's close
this so we can see some more things in
here we'll look up solidity and we'll
come to this solidity extension config
what we can do then is scroll down and
we can see solidity compile using remote
version this will allow us to choose
what version we want to compile with if
we do
0.6.0 and hit save and go back to simple
storage you'll see the Red Line is now
gone while we have this up another
really helpful piece that we can do here
is we can add what's called a formatter
so if we scroll down to solidity format
you'll see that this enabl disables the
solidity formatter we can go from none
to prettier then we'll also look up
format on Save and we want to make sure
we have this editor format on Save check
marked what we can do then is we can
come over to simpl
storage. and maybe I've got some bad
formatting in here we'll move over
favorite number string name and put a
whole bunch of new spaces in here or
something now if I hit save it
automatically reformats our file to look
a lot nicer so to recap we want to turn
on format on Save and if you get issues
with a red line under pragma solidity
you can just change the compiler version
in your settings here now while we're in
here we're also going to go ahead and
set up our python formatting as well so
first thing that we're going to do is
we're going to install the black python
formatter so we're going to open up our
terminal here and whenever you install
python it comes pre-installed with this
package called hip to check to see if
you have Pip installed correctly run pip
D-
version now we can install the Black
formatter by running pip install
black I already have it installed so
it's going to be pretty quick for me
then we'll come to our settings and
we'll look up
python
formatting and we'll scroll
down to python formatting provider you
might have autop bait or none in here
you're going to want to change it to
Black this way whenever we save our
python files now they will also get
automatically formatted to be very
readable and really nice and just to
note for my Demos in solidity I don't
always have format on save for solidity
I do have format on save for my python
but I'm still going to highly recommend
you have format on save for both your
Python and for your solidity anyways so
how are we going to actually deploy this
well this is where our python is going
to come into play Let's go ahead and
create a new file on the left here and
we'll call it deploy dopy now let's go
into this deploy dopy file and let's
start actually figuring out how we can
deploy this in Python and this is the
part of the course where we start using
python here if you're unfamiliar with
python or a little bit weaker on python
there is a fantastic free code Camp
course that goes through all the basics
of python if you want to learn more I
definitely recommend checking it out
however we are going to walk you through
all the scripts that we write anyway so
don't be afraid to just jump in and
follow along with what we're doing here
even if you have no experience so the
first thing that we're going to want to
actually do is read this simple storage
solidity file we need to get this into
this deploy script so that our python
file knows what it's going to deploy so
how do we do this well we're going to
type with
open quote.
slash simpl storage. Soul comma r
as
file simple storage file equals file.
read now what is this actually doing
well it's saying that we're going to
execute some code inside this indented
area after the colon and then once this
code is finished we're actually going to
close this file because right now we're
opening it we're going to close it once
it's done the file that we're going to
open is going to be this simple storage.
Soul which is located right here in this
same directory that we're in we're going
to only read from it and we're going to
call it file and then we're going to
read all the contents of this file and
place it in a variable simple storage
file so then we can go ahead write a
print statement print simple storage
file and if you hit save here you'll see
that it automatically gets formatted
which is really nice if you want to run
black yourself you can just type black
dot and it'll automatically format all
the python files in your folder here
you'll know that you're doing it right
if you add a whole bunch of new lines
and then save it anyways enough fun
formatting let's head on down to the
terminal and let's call python
deploy and we can see our terminal
printed everything in simple storage
file which is perfect now our python
script has what it needs to actually get
started working with our solidity now
something you'll see I do a lot is I
save a lot and if you're looking for
some keyboard shortcuts you can always
do command P at little bracket here and
look up keyboard shortcuts reference and
click this it'll bring you to this
keyboard's reference page based off of
what operating system that you have all
right great so now that we can actually
read from our simple storage. file we
actually have to compile it because
remember back in remix every single time
we did anything with our files we had to
compile them first so we need some
compiler in Python luckily there is a
fantastic python package called py X
that does exactly this now I also want
to point out though that pyul X is
actually a fork of this package called
pulk now you can still use pyul however
I'm going to highly highly recommend
that you use pyul x instead as pulk X is
a lot more actively maintained than
ethereum pyk we can install it with Pip
install pyk X we could even hit this
little copy button move back on over
here paste it in and hit enter again
I've already installed it so it's pretty
quick for me the way that we can use it
now is by importing in it into our
python here so we'll say from Suk X
import
compile standard compile standard is
going to be this main function that we
actually use to compile this code so
let's go ahead and compile our
solidity we're going to save our
compiled code to a variable called
compiled
Soul this is going to be equal
to us calling this compile standard
function but we're going to add a lot of
variables and a lot of parameters into
this function here first thing we have
to add is a
language which in this case is solidity
we're going to add in some
sources which we're going to say our
sources is going to be
simple storage.
soul and it's going to have some
content which is equal to this simple
storage file variable that we me oh
excuse me this all has to be in a
a bracket piece as well and see if I hit
save here it auto formats which is
really nice and another quick tip you
can see how even my brackets are
highlighted in these fun colors if we go
down to extensions and look up bracket
you can add this bracket pair colorizer
which will help make the brackets look a
little bit nicer kind of as you see here
you can go ahead and install that as
well anyways then we'll add some
settings and a lot of this is a little
bit lower level stuff than what you're
really going to have have to know or use
so I'm not going to go too deep into
everything that's actually going on here
for now but in our settings we're going
to choose an output
selection which is going to choose what
we output when we compile this do a
little star
here in the star we're going to do
another
star we're going to choose our output
list we're going to get an ABI out
that's incredibly important which we've
talked about before we're going to get
some metadata we're going to get an evm
doite
code we going to get an evm do Source
map that's pretty much it again I'm not
going to go too deep into what this
output selection and what these settings
are actually doing but if you want to
learn more you can go to the homepage of
pyk X scroll down to the documentation
section and read more in the docs on
what you can actually put in all the
different features that this actually
has the last thing we're going to do is
we're going to add a Suk version or
solidity version version we're going to
say
sulk version equals and then we'll
choose the version that we want to use
so we'll put in
0.6.0 and then what we should be able to
do is print out this compiled
so and we'll see just a whole bunch of
really really lowlevel stuff so let's go
ahead and run this we'll run python
deploy pi and you'll see we get this
massive object here which has has a
whole bunch of basically unreadable
pieces but this is a lot of the low-l
code that actually gets compiled
whenever we use a compiler in remix or
now in Python remix actually does the
exact same thing once we compile
something on remix you can actually copy
the bite code if you hit this little
copy button and copy the bite code and
come back to your vs code and create a
new file a keyboard shortcut to create a
new file is command n and we paste
everything we can see there's a whole
bunch of stuff in here these op codes
are the low-level code that our contract
is actually doing that actually governs
how this code works this is what our
written code is getting compiled down to
so solidity can actually read it and
understand what's going on you'll also
see this thing called ABI which is in
remix and we're even going to Output it
right here we have this ABI thing now in
remix if you hit copy the button on the
ABI come back create a new file paste it
you can see we have this long Json
object this is that application binary
interface that we've talked about so
much you can see that it's actually
describing all the functions and
variables so for example we have a
function called add person and it takes
two parameters a name and a favorite
number so we have this input section for
the function and we have this section
that describes what the function can is
actually doing so the name is AD person
it doesn't have a return type it's non-p
payable and it's a function and we can
see that for pretty much everything in
here this is the lowest digestible way
to say hey here's where all the
functions are here's what the parameter
types are here's what the return types
are going to be and everything like that
so we're going to close it out for now
though so this is fantastic we've now
compiled our solidity typically I
usually also like to Output it and print
it out to a file as well so to do that
we'll do with
open compiled code.
Json and this time instead of reading
we're going to wrun right and we'll call
this as file as well instead of doing
file. right we're going to do what's
called adjacent do
dump piled Soul file we do need of
course to import Json also just a note I
know it says we're using sulk here but
please use sulk X still I ended up
filming a little bit of both versions so
I did a little bit of a a mix and match
but please use sulk X even if you see
Suk what this line is going to do is
it's going to take our compile Soul Json
variable and just dump it into this file
here but it's going to keep it in the
Json syntax so it's still going to be
Json e so now if we run python deploy
piy we'll see we have a new file in here
called compile code. Json the other
reason that I wanted to do this was
because if I hit contrl s it actually
formats this into a readable way now
again we can go into these settings here
we can look up Json
and we can do enable Json formatter and
this will automatically make it so that
we format this Json so it's a lot more
readable again the reason I like to
Output this is because this ABI is so
important and we're going to use it so
much that I like to kind of be able to
see it and and read through it really
quickly the rest of this lower level
stuff like evm and bite codes and op
codes we don't really work with so much
however as you learn more and more about
solidity you'll probably see more and
more of op code so if you really want to
learn a lot of really lowlevel stuffff
look into op codes but for the purpose
of this tutorial we're not going to be
going too deep into it okay awesome so
we've compiled our solidity we've even
stored our solidity code to this
compiled code. Json file now what do we
do we probably want to deploy it and
test it out so how do we actually do
that well first we actually have to get
the bite code we need the bite code of
the file so that we can actually deploy
it so we're going to do bite
code equals compiled
Soul
contracts simple storage.
Soul simple
storage
evm white
code object all right great there we go
so now we have our bite code we also
need to get our ABI so we need to get
the API so what we're doing here when
we're typing in all these words like
contract simple storage simple storage
is we're walking down the Json here so
when we say we want to get the bite code
in this compiled solidity Json we want
to go to contracts simple storage simple
storage evm bite code so contracts
inside this contracts Json you got to go
to simple storage inside this simple
storage. Soul there's another simple
storage inside that there's an AI but
that's not what we want we want the evm
so we're going to scroll down aha we're
going to get the evm then what do we
want then we want the bite code great
and then we want the object so this is
the bite code of our contract it's the
really lowlevel stuff that the ethereum
virtual machine or the evm is going to
understand now we also need the Avi when
we deploy this to a chain this is what
we're going to need we're going need the
bik code and the ABI the ABI we can of
course get from this kind of same method
here so to get this we can do
ABI equals compiled Soul same thing
contracts simple
storage. simple storage and as you can
see we're right here and then we can
just grab this ABI
object AI we can even do print ABI we'll
do python
developed up high and indeed our ABI is
printed here awesome so now that we have
our two main pieces to deploy this now
all we have to do is deploy it but the
question then becomes is where are we
going to deploy it to which blockchain
are we going to deploy it to in remix
when we were first playing around we
were using a JavaScript VM or a fake or
a simulated environment we absolutely
could and we absolutely will learn to
deploy this to a test net because that's
going to be the same way that we're
going to deploy it to a main net but
before we do that we should learn how to
deploy this on a simulated environment
or something similar to that JavaScript
VM so it's much faster and easier to
test things and this is where ganach is
going to come to the rescue ganach is a
simulated or a fake blockchain that we
can actually use to deploy our smart
contracts to and have it interact like
it's a real blockchain gach is going to
allow us to spin up our own local
blockchain
and it'll look something like this now
the user interface is really nice
because it allows us to kind of do this
oneclick blockchain to create our own
local blockchain that means that this
blockchain isn't connected to any other
blockchain out there but it'll act like
a blockchain but it'll be a lot faster
than us having to interact with a
testnet and we control the entire
blockchain because it's only one node
we're the only node so ganache great way
to test things quickly working us
I'm also going to show you how to work
with the ganach command line you can
really use either one depending on what
you want to do but a lot of the tools
actually have buil in ganach command
line so it's definitely really useful to
learn that as well so again ganach is
going to be our simulated environment
here so what we're going to do once we
get into ganach we can just go ahead and
hit quick start this will automatically
upload and get started with our own
local fake blockchain you can even see
it gives us some accounts this should
look pretty familiar should look very
metam Masky right we have an address
here and each one of these addresses has
a private key in your ganache you can go
ahead and just click the key and hit
show keys and it'll show you the account
address and the private key but of
course these are for development
purposes only each one of these accounts
has a balance associated with it we can
see a pneumonic or your secret phrase
you can see blocks transactions and a
whole lot of other really useful
features here and it even tells us
how to connect to this blockchain and
these are the connecting features that
we're going to want to use let's learn
how to connect to this ganach blockchain
from this user interface first and then
we'll learn how to do the command line
version this is when we finally start
working with web 3py we can just do
pip install web
3 and now we can start working with web
3p right at the top a little confusingly
we're going to do import web 3
from web 3 oops and this should be from
web 3 import web 3 sorry about that now
to connect to this blockchain we choose
what's called an HTTP provider if we
look at this ganach instance we have
this RPC server which has this URL HTTP
0.0.0.0
54 this is the URL that we're going to
use to connect to this blockchain in
remix we're actually using our metamasks
directly to connect to the blockchain
however we want to connect directly to
our simulated our fake blockchain right
here so what we're going to do is we're
going to do
W3 for connecting to
gach W3 equals web
3 web 3.
HTTP
provider of
HTTP
0.0.0.0
and it was on Port
845 Port 845 now with everything that we
show you you're probably going to want
to get really familiar with the
documentation because even after being a
pro you're going to want to use it more
and more if you want to learn more about
other providers you can go to the
provids page of the documentation the
next thing that we're always going to
need as well is we're going to need the
chain ID or the network ID what is the
ID of this blockchain and for ganach
it's
1337 it's supposed to be a funny Elite
reference so we'll do chain
ID
equals
1337
now we're also going to need an
address an address to deploy from we can
go ahead and grab one of these fake
addresses in here to work
with similar to how in remix when we
were working with the JavaScript BM we
were given a bunch of fake addresses
we're doing the same thing but with
ganach and then we're also of course
going to want a private key we need the
private key of course to sign our
transactions so we'll do private key
equals
this now just note whenever you import a
private key in Python you need to add an
ox to the front python is always going
to look for the hexadecimal version of
the private key awesome now we have all
the parameters that we need for
interacting with and connecting to our
ganache local chain it's time to finally
deploy our simple storage. Soul contract
let's do it so the credit contract that
we're going to deploy with web 3.i we're
going to do simple storage we're to call
this variable
w3f contract and we're going to give it
ABI equals ABI and bite code equals bite
code great does this mean we've deployed
it well no this just means we have a
contract down so we can do print simple
storage and you'll see if if we run
python
deploy we'll see we have a new type here
class web 3. u. datat type. contract
this is another type that if you want to
learn more you should definitely check
out the web 3.y documentation so we have
a contract object awesome how do we
actually deploy this well we need to
actually build our transaction because
again whenever we interact with the
blockchain whenever we make a state
change and in this case we'd be
deploying a contract we're going to make
a state change so we first need to build
a transaction sign a transaction and
then send a transaction and to do that
we need to talk about that nuns thing
again remember way back in our
blockchain demo when we used a nuns to
solve the answer to that really
difficult mining problem well the
definition of nuns is just a word coined
or used for just one occasion and in
cryptography it's an arbitrary number
that can be used just once in a
cryptographic communication so this nuns
that's used to find the answer is going
to be different from another nuns that
we're actually going to need to make our
transaction see if we look at our
metamask and we look at our activity and
we look at one of the transactions we've
made recently on ether scan if we scroll
down we'll see nuns here as well this
nuns is the number of transactions that
our account has actually made every time
we make another transaction our
transaction is hashed with a new nuts
this is what's going on behind the
scenes with our transaction and we need
this to send our transaction we can
actually get our nuns by just grabbing
our latest transaction count get
latest transaction we can do nuns equals
W3
do.get transaction count and we'll put
in my address this will give us the
number of transactions and it'll
effectively give us our
nuts we can even test it out with a
print python ploy
we can see we can see that the answer is
zero because on our local blockchain
this address that we're using hasn't
been used before we can even go to the
transactions tab we can see that there
are no transactions that have ever
occurred on our local blockchain now to
deploy this contract we need to make a
transaction remember everything that we
do every time we change the state of a
blockchain we're going to do it in a
transaction let's create a transaction
object to do this we can do
transaction equals simple storage which
again is this contract object dot
Constructor do build transaction now as
you might have pointed out our simple
storage. doesn't actually have a
Constructor every contract technically
has a Constructor this one's is just
blank we're not telling our simple
storage. soul to do anything we saw back
in our fundme example that the fundme
example does have a Constructor so now
we want to put in some parameters for
the transaction in web 3.i we always
have to give at least a couple of
parameters we always have to give the
chain ID which we already got from above
which is
1337 so we can just do chain
ID we need a from address in this
case my
address and then we need a
nuns which in our case is just nuts
great now we have a transaction object
let's even print this out and see what
it looks
like whoa what's this we can see there's
even more parameters in here than just
what we made so we have value which is
The Ether or the ethereum that we're
going to send we have gas we have our
gas price which we could arbitrarily set
if we'd like we have the chain ID we
have from address we have the nuns and
then we have this giant data object and
then two is just empty because it's
sending it to the blockchain this giant
data object here is encompassing
everything that's happening in this
simple storage. Soul now that's just a
transaction and anybody could actually
send this transaction as long as it's
signed by them so we have this
transaction but we need to sign it from
somebody since we're sending it from our
address our private key is going to be
the only key that's going to work to
sign this remember back when we were
talking about public and private Keys we
right now have a message that is
defining how to deploy simple storage
but it's not signed yet so we're going
to need to use our private key to sign
it to create this unique message
signature that we're the only ones that
can create the private key but anybody
else can verify that it was us who
signed it so now signed transaction
equals web 3.
e. account doign
transaction and the parameters it takes
are going to be transaction and then
private key
say the private key equals private key
because above we've actually gone ahead
and added our private key in here now
guys a really really important note
about putting a private key in your code
this is really bad practice if you push
this to Source or you push this to
GitHub somebody else can see a private
key and steal all your funds so we don't
want to hardcode our private keys in our
code like we're doing here so let's take
this time to talk about environment
variables and how to set them
environment variables are variables that
you can set and that we set in our
terminal and in our Command lines the
following is a way to set an environment
variable in Mac OS and Linux only don't
worry we'll show a way to make an
environment variable in Windows as well
you can set an environment variable by
running something like
export private key equals and then
adding whatever variable that you
want now if you type
Echo dollar sign private key
this variable actually shows up to set
environment variables with Windows the
process that we're going to do is
actually a little bit different I've
left a link in our GitHub to actually
set environment variables in a Windows
setting and we've left a couple of
really helpful links for working more
with environment variables you should
definitely check them out it's important
to note that this export method that
we're doing here for creating
environment variables only works for the
duration that our shell is live so if we
were to close out of our shell and then
reopen it our environment variable that
we set would be gone we'd have to rerun
that export command we're going to show
you a way to set environment variables
so that you don't have to keep doing
that now it's also not great to have in
PL text on your computer however it's a
lot better than hardcoding it into our
script here now remember if you're using
an account that has real money in it
which I highly recommend you do not do
don't send this environment variable or
this private key or any of this code
anywhere because then people can steal
all your funds once we move to brownie
we'll show you a more effective way for
private key management but for now be
cautious here but if you followed and
set up a brand new account that has no
real money and only test that money in
it then great who cares cuz it's test
that it's fake money
anyways I think I've talked about it
enough anyways let's get back to it we
can actually access this environment
variable in Python using os. getet
EnV we just need to import OS and now we
can access our private key in our script
without actually hardcoding it in let's
see what happens if we do print private
key python deploy Pi you can see our
python script was able to pull our
private key from our environment
variable the other thing that we can do
is create aemv file aemv file is
typically where people store environment
variables it's important to not push
these to Source if this is what you're
going to do in this EMV file in Python
we can just do
export private key and then same as what
we did before add the zerx at the start
and then private key so we could put 100
environment variables in here
export some other VAR equals 7 if you're
going to do it in this way please please
please always set a DOT get
ignore and make sure EMV is in here this
will help make it harder for you to
accidentally push your EnV folder or
your EnV file to GitHub python actually
has a way of loading directly from a EnV
file without having to export our
environment variables or run source. EnV
or export or really anything and we can
do it with this python.
package if we close our shell and then
reopen it if we run Echo some other VAR
we're going to get none here and in fact
if we
run python develop. piy when we print
this environment variable we're going to
get
none however we can use this EnV to have
it pull directly from ourv so we just do
pip install python. EnV I've already
downloaded it so it just says
requirement already satisfied and then
what we can do at the top of this we can
do
from
EnV import load. EnV and we can run
load. EnV function right at the top this
load. EnV looks for this EnV file and
automatically Imports it into our script
so if we run this now you'll see that
the environment variable was
successfully imported into our script
and now we can use it so let's let's use
it for example with our private key
private key equals os.
gmv private key now we can even print it
out just to
test we'll run our
script and awesome we can see our
private key is being successfully pulled
in and we didn't hardcode it into our
application all right let's get back
down to our signed transaction here now
now let's go ahead and print this out
and take a look at what this looks like
now we can run our script and great what
we see here is an example of a signed
transaction remember this is exactly
what's happening when we were looking
back at public private Keys we are
signing a transaction that is actually
deploying a contract to the blockchain
that anybody can easily verify all right
so we finally have our signed
transaction now we want to send this to
the blockchain so it actually can deploy
let's send this sign transaction
we can do transaction hash
equals web 3. eth here's a little
helpful tip if you see this little box
underneath with suggestions show up and
you just hit tab it'll autocomplete the
rest of your text here that's send raw
transaction and we'll give it our sign
transaction
dot BR transaction this will send our
transaction to the blockchain now if we
look at our ganach and we look at
transactions right now it'll be empty
but let's see what happens when we run
this
script okay so we didn't print anything
out but if we go to our ganache we can
see that a transaction actually did go
through it was from the address that we
put in here we created a contract at
this
address this is how much gas it used and
this is how much value was sent with it
we can even click on it to see more
information about this now this is the
other advantage of doing this locally is
that the transaction automatically went
through we've sent our first transaction
to a local blockchain and this
transaction is deploying a contract
great work you can already see how much
faster this is than working with a test
net one other thing that's really good
practice whenever sending a transaction
is we wait for some block confirmations
to happen so we can do
transaction receed equals web 3 .
ewe for transaction
receipt
TX this will have our code stop and wait
for this transaction hash to go through
awesome so I just ran it again and if we
go to
transactions we can now see that there
are two transactions here and our code
waited a little bit longer for this one
to complete so of course we've deployed
a contract but how do we actually
interact and work with the contract
let's start doing that so when working
with contracts and we're working with
onchain whenever we work with a contract
we always need two things we need the
contract address and the contract AI
often times if you're looking for a
specific ABI of a type of contract you
can usually just Google it so we need to
make a new contract object to work with
contracts let's go ahead and create this
simple storage contract so that we can
actually interact with it so we'll do
simple
storage equals W3 e. contract now we
need our address
which we can get from ganach but that
might be a little bit hard to always be
checking the blockchain for a
transaction it's actually also in this
transaction receipt address equals
transaction receipt. contract address
and then since we've compiled this we
also have our ABI
already ABI equals
ABI sometimes you'll see people have a
file called abis dopy or abis Json or
something like that and they'll load
abis in directly from there and great
now that we have the address and the ABI
we can start interacting with this
contract exactly as we did in remix so
let's do a print statement to get that
initial value that is returned from our
retrieve
function remember it should be
initialized to
zero so if we do print simple storage
functions.
retrieve let's see what happens
here huh what's this we get this
function retrieve bound to in these
parentheses here so what's going on when
making transactions on the blockchain
there's actually two different ways that
we can interact with them we can
interact with a
call or we can interact with a transact
when we use a call
this is just to simulate making the
call and getting a return value calls
don't make a state change to the
blockchain and it's similar to how in
remix we would call these blue buttons
and nothing on the blockchain would
actually change we can actually also
call these orange buttons or these non
view functions and just not actually
make a state change remix defaults these
blue buttons to be calls and these
orange buttons to be trans
in Python we can actually pick which one
we want to do a transact a transact call
is when we actually make a state
change and this is when we actually have
to build a transaction and send a
transaction you can always just call a
function no matter what that function is
but just keep in mind you won't make a
state change you can also always
transact on a function even if it's just
a view and this will attempt to make a
state
change something like retrieve even if
we transact on it it won't make a state
change so for something like retrieve
where we don't actually want to make a
state change we just Ed the call
function so we'll just do dot call now
if we try to run this you'll see we do
get the zero because now we're actually
calling this transaction awesome so now
we have our initial value for our
retrieve function let's keep going let's
try to update this favorite number using
this store function this we just keep
keep in mind is our
initial value of favorite number we know
that this store function is orange and
we'll actually make a transaction but if
we wanted to we can even just use call
on it we'll do simple
storage
functions
store we'll put that 15 in here. call
let's see what happens when we send
this you can see it returned a blank
that's because because this store
function has no return type if we give
this returns you went
256 and then we say
return favorite
number and now we go back
here and we run this again you'll see
now that we get a 15 back if we go to
ganach you'll see that we keep making a
whole bunch of different contracts but
none of these are contract interaction
that's because when we call a function
we just simulate working with it if we
call retrieve again right afterwards
you'll see that it's still
zero it's because calling is just a
simulation now let's delete all that so
let's actually build a new transaction
to actually store some value into this
contract since we want to make a
transaction we got to go through the
same process as when we deployed this
contract let's first create a
transaction
call it store transaction equals simple
storage
functions do
store and we'll give it some number in
this case 15 and then we have to do
dot build
transaction and we'll put those same
pieces in here from before we're going
to have chain ID be the chain
ID we're going to need front
from me my
address nuns is going to be the
nuns plus
one we're going to need to do nuns plus
one because we actually use this nuns
already when we create our initial
transaction remember a nuns can only be
used once for each transaction so this
transaction is going to have to have a
different nuns than the nuns we use to
deploy the contract now that we have the
transaction let's go ahead and sign it
do
signed
store
TX and we'll do web 3.
e.
count do sign
transaction store
transaction and then private key
equals private key and we'll go ahead
and save then of course we need to send
it so we'll do transaction hash equals
w3e send raw
transaction signed store
transaction.
raw transaction and let's grab that
transaction receipt Again by doing
transaction receipt equals
w3e wait for transaction receipt and
actually let's call
this send store
TX that wait for receipt send store TX
awesome it looks like we're following
the same steps here as we did
above we created the transaction we
signed the transaction and then we send
the
transaction down here we create a
transaction we signed the transaction we
sent the transaction and then we waited
for the transaction to
finish so let's run
this all right great we still have this
print function printing out the current
value of retrieve let's go over to
ganach and see if there's anything
different here there is instead of all
these contract Creations here we now
have a contract call we can see there's
some transaction data that was sent a
different amount of gas same gas
prices however ever this actually
updated and sent the transaction to our
blockchain now if we call this retrieve
function
again this should print out our newly
updated value which in this case was 15
let's go ahead and run Python
deployed. and we can see it started at
zero and then it turned to 15 awesome
we've made our first state change to a
contract that we've deployed on our
local blockchain great work sometimes
it's nice to put some lines in here to
tell you what's going on to make it a
little bit more clear so I'll put
something like
deploying contract dot dot dot right
before we deploy our
contract after we do it I my
two
deployed then right before we update our
contract we'll print out something
like updating
contract and then right after it's done
maybe something like
updated now if we run this
now you'll see as this goes along we'll
get these things printed out saying
deploying contract contract deployed
updating contract updated this will make
those moments when waiting for these
contracts to actually finish a lot
easier doing fantastic so ganache user
interface is really nice because we can
see a lot of things that are going on
here however it's a little tricky to do
a lot of programmatic stuff often times
engineer will use what's called a
command line interface of ganache
instead of the UI so we're going to go
ahead and close this out and we're going
to use the ganache CLI instead of that
user interface that we just saw and this
is what and this is what Brown is going
to use on the back end when we move to
brownie let's learn how to actually do
that so in order to use the ganach CLI
or command line interface the first
thing that we need to do is download
node.js yes I know this is a python
video however we do need to install
nodejs to work with the ganach CLI you
can come to this download page and
choose your operating system and
download it accordingly we have a link
to a video showing you how to do this in
the GitHub you'll know you've done it
right if you can run
node-- version in your command line and
you get a version it might be 12 might
be 14 might be something else depending
on what version you downloaded next
we're actually going to install yarn
yarn is a package manager similar to pip
and will allow us to actually download
pieces and packages like the ganach CLI
from package repository we can install
it with mpm install D- Global yarn and
you'll know you've done it right if you
can run yarn D- version in your command
line and you get the version outputed
here then we want to install the actual
ganach CLI we're going to be installing
it with yarn so to install this we're
going do yarn global
add ganach
CLI this will install our ganach CLI as
a global command in our terminal we can
test to see if we've done it right we
can run ganos
c-- version perfect we now have the
ganach CLI let's spin up a ganach chain
with the CLI if you have your ganach UI
open right now please close it otherwise
it'll conflict so to run a local
blockchain from the command line all you
need need to do is run
gach
CLI and the node will start running
directly in your terminal if you scroll
up you can see a lot of familiar pieces
we see the available accounts just like
on the UI these are the different
addresses and then we see a whole bunch
of different private keys this ganache
spins up with a bunch of random
addresses and random private keys if we
wanted to always spin up with the exact
same private keys so we don't have to
update our private key every time we can
do
ganach CLI Das Dash
deterministic this way we'll always get
the exact same private keys and the
exact same addresses you can check out
the documentation see a bunch of other
flags that you can use to run this and
you can see it's listening on
127.0.0.1
127.0.0.1 is also known as the loop back
address or Local Host now to work with
ganach in the command line all we need
to do now is update our private keys and
our addresses let's also update the HTTP
provider since now we're going to be
looking at the loop back address for my
address we'll scroll up to this top
address here and we'll place it in for
our private key we're going to copy
this put it into our EMV
file it already has the ox at the top
here great now let's open up a new
terminal you can open up a new terminal
by hitting this plus button here and you
can flip back and forth by hitting this
drop down and flipping back to the
ganache terminal now let's go ahead and
run python
deploy we can see the exact same output
as we got when working with the UI and
if we flip
over to the command line we can see
we've made a whole bunch of different
calls to our blockchain each one of
these calls is a specific Json RPC call
to our blockchain that we're making to
interact with it we can see information
about the transactions that we sent this
one creates our simple storage contract
this one updates our simple storage
contract and great you now know how to
work with the ganach CLI and the ganache
UI fantastic so how do we actually
deploy this to a test net or a real
Network we were working with remix all
we had to do was switch to injected web
3 and we used our metamask as our
blockchain connection well in our script
here we don't have metamask natively
with our script so we need some way to
connect to the blockchain we can see
that when we're connecting to our own
local blockchain we just use an RPC URL
that connects to our local blockchain to
connect to a test net or to a main net
we can actually do the exact same thing
all we have to do is Swap this out with
the URL that connects us to a main net
or a test net we can also run our own
blockchain node similar to how we're
running our own local blockchain node we
can run to know that actually connects
to a real blockchain however it's not
always practical or really easy to do
this so sometimes we want to use an
external or a thirdparty client that
actually will run our blockchain for us
let's learn a little about infura inf.
is an application that will give you a
blockchain URL for you to connect with
for you to run whatever you want to run
and you can get started for free let's
go ahead and
register then we just check our email
confirm email address and awesome now
we're inside of infura there's a couple
other services out there that you can
also check out like Alchemy which is
another fantastic blockchain as a
service platform fura is a premium
service it starts out as free if you
make too many API calls or too many
calls to the URL they'll start charging
you but we can create a project for free
for now let's go ahead hit the ethereum
tab hit create project we'll call this
free code
Camp brownie
hit create now we'll have a whole bunch
of project keys and project secrets we
also have this endpoint section as well
this is how we're going to be deploying
to the different networks we can see we
have an ethereum mainnet connection as
well as Robson Coen rink B and goril
test Nets there's also polygon in here
as well since we want to test and deploy
to a rink be chain we can go ahead and
move to rink be and then we can copy
this URL back in our application all we
have to do do is Swap this out for the
new URL we also have to change the chain
ID or address and the private key if you
ever are confused as to what is the
chain ID of the chain that you're
working on you can always check this
chain id. Network or you can usually ask
somebody let's look up rink be we see
the chain ID is four so we'll grab four
and we'll place that in our script now
this address in the private key that we
gave it now this address and the private
key that we gave it aren't going to have
any test net ring be in so we need to go
in our metamask and grab the address
place that in for address and then count
details export private
key type in our password and grab the
private key go into our EMV file leave
the ZX and replace the rest with our
private key since I have my private key
stored as an environment variable I need
to then run source. EnV so that my
private key is now updated the reason
we're using this is because again since
we're making transactions to a test net
we need some test net e all right so now
we have everything updated for deploying
to Rinke let's go ahead and run this
now as you can see it's going a lot
slower this is because we actually have
to wait for the contracts to get mined
and for everything to happen on the test
net deploying to a test net will result
in nearly the exact same experience that
you'll get when deploying to an actual
main net so it'll take a lot longer but
you can see we got the ex exact same
responses here now if we take this
address and we go to the rink be ether
scan we can verify what just
happened we can see that 38 seconds ago
we made this transaction and then 23
seconds ago we made this
transaction we can look at all the
different details of this transaction
that we just made from our python script
we can see it even tells us we created a
smart contract and then we made this
call which called this store function on
this contract we've learned a lot so far
this is fantastic now is a perfect time
to take a break and take a quick
breather and reflect back on what we've
just learned we've learned a lot about
python deploying to our own local
blockchain deploying to a test net and
deploying to a main net working more
with private Keys creating transactions
signing transactions and then sending
transactions
now as you can see there's going to be a
lot to actually managing all the
contracts that we work with having to
write our own compile code an ear
storage code is going to take a lot of
work and what if we wanted to interact
with one of the contracts that we
deployed in the past Well we'd have to
keep track of all those addresses and
manually update our address features
here with an address maybe we didn't
want to deploy a new contract every
single time maybe we wanted to work with
a contract that we've already deployed
what if we want to work with a whole
bunch of different chains what if we
want to work with rink B and Main net
and our own local network there seems to
be a lot to manage here and we still
haven't even talked about writing tests
this is where brownie is going to come
into play brownie is currently the most
popular smart contract development
platform built based on python it's used
by defi giants like .f finance curve.
and batter out each having billions of
dollars currently locked in value and
the reason that we learned a little bit
about web 3p first is because brownie
heavily relies on web 3. Pi so let's do
all this again but in Brownie and we'll
see how much easier it is to actually
interact with in our Shell let's go back
one directory and let's make a new one
we'll call it brownie simple
storage now another really cool trick
that VSS code has is instead of us
having to go to file and open up this
folder in this Explorer here what we can
do is we can type code and then type the
directory that we want to work with in
our case this directory so we can just
type code Dot and we'll get a new vs
code
popup inside of this brownie simple
storage folder let's get learning about
Brownie and this is where you're going
to spend the majority of your time move
forward brownie is incredibly powerful
and makes our lives fantastically easier
so get ready to learn one of the most
powerful tools in the smart contract
developing ecosystem let's go ahead and
open up our terminal and let's get
started installing brownie it's
recommended to install brownie via pipex
pipex installs brownie into a virtual
environment and makes it available
directly from the command line once
installed you'll never have to activate
a virtual environment prior to using
brownie which is really good to install
it with pipex we can go ahead and run
python DM pip install D- user
pipex once we've run that we can then
run python 3-m P pipex insure
path then we want to close the terminal
by hitting the little trash can and then
reopen it and then we just need to run
pipex install F brownie I've already got
it installed so that's why we see this
here and then just one more time we're
going to close and reopen the terminal
you can tell you have brownie installed
correctly if you run brownie Das Das
version and you get some output that
looks something like
this or you just run straight up
Brownie and it'll output a bunch of
commands that we can run let's create
our first brownie project we're going to
be using the exact same simple storage
code that we just went through except
for we're going to use it in brownie
this is going to make our lives a lot
easier when working with simple storage
to create a sample folder with
everything we need with brownie we can
just run Brownie and it and we will get
a new brownie project initialized in the
directory that we're currently in if you
type LS you'll be able to see all the
folders that are created or you can just
see them on your side panel in vs code
let's talk really quickly about what
each of these folders is going to do the
build folder tracks a lot of really
important low-level information it's
going to track any interfaces that we're
working with or deploying it's going to
keep track of all of our deployments
across all of the different chains so we
no longer have to manage that ourselves
and it's going to store all of the
compiled code remember how in our simple
storage code we actually saved
everything to this compil code. Json
well brownie is actually going to do all
of that for us into this contracts
directory so we can always reference it
later this contracts directory outside
the build folder is where we're going to
put all of our contracts brownie knows
to look inside of this folder when
looking for new contracts to compile
deploy or anything else interfaces is
where we can save and store different
interfaces remember how when we were
working with chain link working with
interfaces makes it really easy to
interact with a blockchain application
reports are to save any type of report
you run scripts are we can automate
tasks like deploying calling different
functions or really anything we want and
then we have a test folder which is
incredibly powerful and we're going to
be using a lot we also have git
attributes and G ignore which are
helpful when working with Version
Control like git so let's go ahead and
start working with Brownie and really
understand what's going on here so let's
go ahead and add our simple storage
contracts to the contracts folder so in
here we're just going to make a new file
we'll call it
simple storage. soulle and I'm just
going to copy and paste the code I have
from the simple storage that we've been
using this whole time let's go ahead
head can save that with command s okay
great now that we have our contract in
here we can already start working with
Brownie and even compile this code
without even having to write or work
with our own compiler all we need to do
is run brownie
compile brownie will automatically read
the version of solidity and then store
all of the compile information in this
build folder so if we go to contracts we
can see we have a simple storage. Json
and there's a lot of familiar pieces in
here for example we see the ABI op code
section which is the lowlevel language
we'll see a PC map and we'll see a lot
of useful information and great
obviously deployments and interfaces is
still empty so great we've already
compiled our smart contract so how do we
actually deploy this to a blockchain to
do this we do have to write a script
which will allow us to do whatever we
want so we're going to create a new file
and we're just going to call this
similar to last time deploy dopy this is
where we're going to Define working with
and deploying our code brownie can run
scripts by running brownie run in fact
if you want to take a quick minute to
familiarize yourself with all the
different commands that brownie has just
run Brownie and you'll see we can do a
lot of different things we can do
brownie init which will create a new
brownie project we will do brownie bake
which allows us to pull from the brownie
mix which we'll talk about later we can
compile we can go into a console test
run we can do a lot of wonderful things
in here if we do brownie run it'll run a
script for us and we can Define that we
want to run this deploy all we have to
do is add a def main So Def in Python is
the way to define a function we're going
to call this function Main and for now
let's just say print hello and we can
run brownie run scripts
deploy and as you can see it
automatically does this launching thing
so brownie defaults to always working
with a local ganach CLI blockchain it's
running the exact same command that we
ran earlier and it has a bunch of
different flags like counts 10 a certain
hard Fork a certain gas limit Etc so at
the beginning of all of our scripts if
we don't give brownie a network to use
it'll spin up a local ganache and at the
end of the script it'll tear it back
down typically what I like to do is
actually put all the logic of our
deployment in its own function def
deploy simple
storage and we'll do pass for now and
then our main function we can just call
deploy symbol storage now in order to
deploy our contract let's look back at
our web 3 Pi version of deploying this
and see what we did so first we compiled
it great brownie does that automatically
then we dumped to a file great brownie
does that
automatically we got a bite code and an
ABI great brownie does that
automatically we added a local
blockchain to use great brownie
automatically spins up a local ginach
we'll learn how to do test s in a little
bit aha we do need an address though and
a private key so how do we actually get
our private key get our account into
brownie brownie has an accounts package
that actually natively understands how
to work with accounts and we can import
it into our script here so we can do
from brownie import
accounts and with this accounts keyword
we can add an account a number of
different ways if we're going to work
with our local chain as you see here the
ganach CLI will spin up 10 fake accounts
for us and brownie automatically knows
that we can work with that account so we
could do something like account equals
account zero and then just do something
like print account so we're going to
take the account that's spun up at the
zero withth index because this accounts
object is just an array so if we run
this
now brownie run
scripts deploy it's going to spin up Us
in address and a private key that we can
just work with without having to define
a private key or do anything does all of
that for us which is fantastic we do of
course still want to know how to add our
own private keys so that we can work
with the test net so this is great and
works when we're working with a
development Network or working with
Brownie's automatic ganach CLI if we
want to work with a test net though we
have to do something else another way to
add your accounts in brownie is to use
the command line and actually add them
natively into brownie we can do brownie
accounts new and we'll give it a name
free code Camp account
account this will then prompt us and say
enter the private key that you wish to
add let's go ahead grab our private key
from metamask count details export
private key put your password in grab
the private key and then we just add ox
and paste it in brownie will actually
password encrypt your private key in
this way so we'll give it a password and
now we have a new account natively
integrated into brownie to see it we can
do brownie accounts list and you'll see
that we have a free code Camp account
with this address and also a testing
account I made this a little bit earlier
we can get rid of it by running
brownie accounts delete testing helpful
terminal tip time so if you hit up or
down on your keyboard you can actually
toggle through the history of the
commands that you've written so if you
hit up it'll actually bring you to the
most recently run command which can
allow you to run run previous commands a
little bit faster and if we run Browning
accounts list again we'll see it's now
just free code Camp if we want to work
with this free code Camp account that
we've added to brownie via the command
line we can get it with account equals
accounts.
load free code Camp account and then we
can do print account let's run this
script
again this time when we run the script
it's going to ask us for the password we
need to enter the password to decrypt
the account because right now it's
password encrypted so we're going to
type in the password and it's going to
go ahead and execute with our unlocked
private key we can see the address it
printed out was right here and if we
copy the address and we go back we can
see that that is correct now if we're
going to talk about safety and you want
to safely secure your keys this is one
of the safer ways to do it because it's
not going to stored in git you're not
going to accidentally push it up to
GitHub or show it to anybody and it's
going to be password in crypted this is
going to be one of the ways that I
highly recommend you store your keys
often times you're going to want to do a
mix of working with the local ganache
ones and your own keys and we'll learn
how to flip back and forth between them
in a little bit now the third way that I
like to use is still again using an
environment variable script often times
it's really easy just to have your
private key be an environment variable
this way you won't have to keep putting
the password in every single time you
run a script so it's a little bit less
secure and just another tip for myself I
never put my private Keys associated
with wallet that have real money in them
as environment variables or in a EnV
file just in case I accidentally do
something really stupid I don't trust
myself enough so I'm going to highly
recommend that whatever private key that
you use and you store as an environment
variable here always have it be just
kind of a test account that you're going
to use to test things and then for some
of your more serious accounts that's
what you'll use the encryption for so
let's go ahead and create an environment
variable file so we'll do a new file
call ITV and we'll do export private key
Ox this
now we have a private key set as an
environment variable so brownie has an
additional feature that allows us to
easily work with environment variables
in an environment variable folder we can
tell brownie to always pull from ourv
file in a brownie
config
yaml this is a special file that brownie
always looks for to grab information
about where you're going to build where
you're going to deploy and where you're
going to grab things in this config all
we need to do is add EnV
and
setv this is telling brownie hey when
you run scripts grab the environment
variables from the EnV file and what we
can do is after we import OS we'll do
account equals accounts. add os. get EnV
this is how we get that environment
variable uh private key then let's just
print out that account see if we did it
right brownie run scripts deploy
py and
great all right great so this seems to
work perfectly but I like to make this
method even more explicit so we're going
to take this version that we just
learned and improve it in our brownie
config we can actually add more
information about what wallets we want
to use and when we want to use them what
we can do is we can add a wallets
section and add in here a from Key
section and then add that environment
variable private key in your yo file if
you surround a string with dollar sign
and some curly brackets it will
automatically get transformed into the
environment variable so if we go back to
deploy we can actually change this we
can grab right from our config file so
we'll do from brownie import accounts
config and instead of using OS we can do
accounts. add
config and then we'll do wallets since
that's what we're defining right here
and then from Key
wallets
from Key and this will do the exact same
thing as our os. gmv the reason that
this is better is because now we have
one canonical place where we're always
going to pull our private key from
instead of having to go through all of
our scripts and update it based on
whatever we change an environment
variable now let's try this out brownie
run script
deploy and great we see our address
printed here for now let's just stick
with using accounts zero since we want
to just use the account that brownie
makes for us with ganach now brownie is
really intelligent and we can actually
go ahead and import a contract directly
into our script in a web 3. Pi version
we opened a contract and read from it
and that's how we were able to interact
with it after we deployed it in brownie
what we can do is from brownie
import and then just the
name of the contract simple storage then
we can do simple storage. deploy and
this is how we're going to deploy it to
a chain anytime you deploy to a chain or
you make a transaction you always need
to do a from and then say who you're
going to be deploying from what's the
account that's going to be deploying
this as you can see this step of just
deploying is much quicker
than what we did in web 3py in web 3py
we had to get the bite code and the ABI
then we had to get the nuns we had to
create the contract we had to create the
transaction sign the transaction and
then send the transaction remember how I
said before you can either make a
transaction or a call Brownie is smart
enough to know whether or not what
you're doing is going to be a
transaction or a call in this case since
we're deploying a smart contract brownie
is smart enough to know that ah we want
to make a state change so let's make a
state
change it'll return a contract object so
we can just add print simple storage and
we'll see what prints so let's run this
brownie run scripts deploy appp awesome
so what happened was brownie again per
usual it launched a local ganach chain
and then it sent a transaction to deploy
symbol storage and it says symbol
storage deploy at and then the address
it was deployed at and we can see how
much quicker this is to actually deploy
now let's go ahead and do exactly what
we did with web 3.i let's call this
initial retrieve function and then we'll
update it with a new value of 15 but
we'll do it in brownie now remember
here's how we did it back in web 3p in
brownie what we're going to do is first
we're going to do stored
value equals simple storage. retrieve
now since this is a view function we
don't have to add from account in here
again brownie is intelligent enough to
know if this is a call or a transaction
and we know that retrieve is a view
function so we know we don't actually
have to make a transaction here then we
can print out the value of stored value
print stored value let's go ahead and
try
this great we get zero right here
perfect now let's try updating this so
we can do transaction
equals simple
storage. store and in here we'd want to
do 15 but remember since we're doing a
transaction in brownie we always have to
add who we're going to transact from in
this case we're going to do from account
similar to web 3. Pi we can do
transaction. we for how many blocks we
want to wait and then let's call that
retrieve function again to see if it's
been updated so we're can do
updated stored value equals symbol
storage. retrieve and then we can
print the updated storage
value and if we run
this we now see we have two transactions
here one that deployed our original
simple storage contract and we called
the retrieve function and we returned
zero here then we updated with our store
function and then we call retrieve again
and we see we did indeed update it to 15
you see how much smaller and easier and
more intuitive this is in Brownie and
how much our lives are going to be much
better awesome now you've learned how to
deploy to a local chain now running
these scripts is fantastic but we need a
way to actually automate that our
contracts are doing what we want them to
do we don't want to always have to
manually check that all of our stuff is
doing what we want it to do right we
don't want to have to manually check
that 15 is actually updating
appropriately this is why running tests
are so important and automating your
tests is going to be crucial to becoming
a successful smart contract developer
now I do want to point out that you
actually can write tests directly in
solidity and this is a great way to
actually test your smart contracts is to
learn how to do it right in solidity
however a lot of the professional
developers code their tests in the smart
contract development framework language
like python or JavaScript doing it in
this way allows you to get a lot more
flexibility and customization with what
you're doing with your smart contracts
and not being confined to whatever only
solidity has so let's go ahead and learn
how to actually write our smart contct
contract tests in Python this is what
this test folder is for so we're going
to create a new file called
test simple
storage. piy make sure you do add test
to the front of these because this is
the syntax that Pi test is going to be
looking for and then in our test we can
actually set it up the exact same way we
set up our deploy function we can do
from browning import simple storage and
accounts
then we can start defining our tests we
want a test to see that when we deploy
our smart contract that it gets started
off with zero in that retrieve function
so we'll create our first test we do def
test
deploy and typically testing in smart
contracts or testing really in anything
is going to be separated into three
categories
arranging
acting and asserting we're going to
bounce around and be a little bit loose
with this definition for the duration of
our tutorials here however keep in mind
that typically this is the setup that
you want to use later on in one of our
later smart contract examples we're
going to go through a much better
testing setup so in our arrange stage
we're going to set up all the pieces
that we need to get set up so first
we're going to grab an account we're
going to say accounts equals account Z
and this is really all we need to do to
start getting setup now for our acting
stage we're going to deploy a simple
simple storage contract exactly as we
did with deploy so we're going to do
simple storage equals simple storage.
deploy from account then we're going to
get our starting
value starting value is going to be
equal to simple storage
dot retrieve and we're
[Music]
expecting this to be zero
so then all we have to do in our assert
stage is we have to run
assert starting value equals expected so
let's recap this in our arrange stage
we're just getting our account so that
we can actually make contracts then in
our act stage we're going to deploy this
simple storage smart contract we're
going to call the retrieve function to
see what its starting value is and we're
going to compare to see if that starting
value is what we expect and we expect it
to be zero we can then test this with
brownie
test and per usual brownie is going to
kick off a ganach and then it's going to
test this for every test you have you're
going to get a little Green Dot and
we're going to say one pass in 1.86
seconds which is perfect if we had
expected to be 15 and We R brownie test
we should get a fail
here awesome and that's exactly what we
get now let's go ahead and test updating
this with 15 and see if it works as we
want it to so we can do a new test in
here we'll do def test
update ding
storage and we'll do those three phases
arrange act and assert in our arrange
all we need to do is get our
account from account zero and in this
one arranging is also going to be
deploying our smart
contract since this is really just part
of the setup and not the act that we're
really testing now in our act we're
going to add
expected to be equal to 15 and we're
going to run simple storage.
store
expected and then from
account you'll notice this is nearly
exactly the same as this deploy function
here now same as last time all we have
to do is
assert
expected equals equals
simple storage
dot retrieve we're saying we want to
store 15 in our smart contract and then
when we call our retrieve function it is
stored correctly so let's go ahead and
run brownie
test awesome we can see two dots here
this means two have actually passed
correctly that's great now I do want to
quickly show you a couple of useful tips
that I pretty much always do when I'm
running my tests if if you want to test
just one function you can do- K Brownie
test- K test updating storage and we
will only test this test updating
storage we can run Brownie test-- pdb
and add something wrong in here like 5
equals simple storage.
retrieve and what will happen is once
this kicks out and is wrong will
actually get put into a python shell and
now we can check to see some variables
in here like if I see what expected is
expected is 15 if I try to run simple
storage. retrieve expected is 15 if I
run simple
storage I'll see this is the simple
storage contract pdb is a really useful
way to mess around and see okay well
what did I really go wrong why is my
test failing another important flag is
going to be dash s so you'll notice that
no print lines actually get sent out
when you're working with these tests
if you do-
s it'll be a little bit more robust in
telling you exactly what's going on and
if we had any print lines it would print
the lines out as well everything that
you can do with brownie test actually
comes directly from pest so if there's
some flag you want to use or some
awesome debugger you want to use you can
use it with brownie just by looking at
the pie test documentation all the tools
are exactly the same all right we're
coming along fantastically we have a
script to deploy we have some tests we
have our contract this is is great but
now we actually want to deploy to a test
net how are we going to do this let's
look at back how we did it with web 3.y
back in web 3. pi to deploy this to a
test net we just needed to add our HTTP
web 3 provider which was our infura
account and that was pretty much it and
add our address in our private key
brownie our lives are even easier
brownie comes prepackaged with a list of
networks that it's already compatible
with you can see all of the networks by
running
brownie
networks list
now mine has a couple more actually
because I've been playing around with
this for a long time but if you want to
see all the different networks you can
look at this list here something
important to note is that there's a
difference between the development
networks and the ethereum networks
whenever we deploy to a network we
default to this development Network any
network that you see under this
development section is going to be a
network that is temporary these are
networks such as the temporary ganache
Network that brownie automatically spins
up when we' run any of the scripts we've
written so far so this is really
important to note remember anything in
this development section is going to get
torn down after it's deployed however
the ethereum ones are going to be our
persistent networks anything under this
ethereum tab brownie is actually going
to keep track of our deployment and keep
track of everything in there these
networks under here represent persistent
networks like mainnet rink B koven Etc
now in our web 3.i we used an RPC URL or
an HTTP Provider from infura to connect
connect to a test net we're going to use
that exact same methodology here so how
do we actually get this RPC URL this
blockchain URL into our brownie smart
contract package well one of the easiest
ways is with an environment variable so
brownie actually already knows that
infura is the thing and can look
natively right away for infura web 3
infura project
ID and use our project ID from infura if
we go to our project back in infura and
we go to
settings you'll see the project ID is a
little bit different than the whole URL
it's just going to be this ID right here
we can then copy this and paste this
right into our EMV now that we have our
web3 INF fur product ID directly in our
project if we do
brownie networks list any Network that
infura has access to you'll see a little
infura in colons here these are networks
that brownie will automatically know
about if we're working with infura so we
can see here that rink B is one of these
infura keys if we wanted to deploy to
rink B we could then just
run brownie run scripts deploy piy and
then select the network with Das Network
rink
B now we're going to get an issue here
because remember account zero only works
when Brown works with a ganach CLI we
have to use our actual private key here
and that's where some of those other
versions of working with private Keys is
going to come into play sometimes I'll
even add a get account function so down
here we'll do def get
account and then in here I'll just
natively check if we're working on a
development chain we'll use account zero
and if not we'll use the method that
pulls from our config so we can check by
seeing if
network. show
active equals equals
development then
return accounts zero network is another
keyword that brownie actually has this
network keyword allows us to interact
with different
networks now if it's not on the
development Network we're going to pull
directly from our config so we'll
return accounts.
add
config
wallets from Key and instead of doing
account equals account zero we can just
do account equals get
account now if we run browny run scripts
deploy to Pi Network rinky it should
pull directly from from our config
file and great we can actually see
transactions being sent directly on the
rinky chain if we pull up ether scan the
rink be ether scan and we take this
transaction has and post it into the
rinky ether scan we can see this
transaction actually going through we've
deployed our simple storage contract and
it's initialized to zero then we're
going to go ahead and update it and it
gets updated to 15 now once we've
deployed to a blockchain you'll see our
build contract will actually change our
deployments folder will have a new
deployment every time you deploy to a
blockchain brownie will actually save
that deployment so you can always go
back and say hm where did I deploy that
or what happened with that deployment
you'll notice that it's separated by
Chain ID remember the chain ID of rinky
is four you'll also notice that none of
our development deployments are in here
again anything that's in this
development section isn't going to get
saved to the deployments area however
anything up here in these ones will get
saved that's going to be really powerful
because we can actually interact with
contracts we've already deployed onto a
chain so let's go ahead and even add a
new file in here called read value this
function is going to read directly from
the rink B blockchain and it's going to
read from a contract that we've already
deployed remember we did something
similar in web 3py by using the address
and the Abi we're going to do the exact
same thing but in brownie so in brownie
again we're going to do from
brownie
import simple
storage
accounts and
config we'll do
def read
contract and we'll just do pass for now
and then we'll def Main
it's going to be read contract oops
didn't mean to do that down here and if
we run browny run
scripts read value to
Pi Network rink B obviously right now
nothing's going to happen so how do we
actually interact with this simple
storage contract that we've already
deployed well this simple storage object
is actually just an array if we were to
print simple
storage let's see what we
get see we get this browning. network.
contract contract container object at
here this object works the same as an
array and we can access the different
indexes inside of it so what if we do
print simple storage at position
zero you'll see we get this address here
and if we check on ether scan we can see
that this is indeed the contract that we
just
deployed brownie knows that we just
deployed it because again in our build
section in the deployments on the rink B
chain which has the chain ID of for we
have this contract that we've deployed
now we can actually just directly
interact with this contract we can do
simple storage equals simple storage of
zero or if you're always looking to get
the most recent deployment minus one is
a little bit easier if we always do zero
we're just going to get the first
deployment that we made and if we make
deployments later we're never going to
get past it I want to always work with
the most recent employment so I can just
do minus one remember how I said
whenever we work with a smart contract
we need to know it's ABI and it's
address well brownie already knows what
the address of this contract is it's got
it saved in this deployments folder it
also knows what the ABI is because when
we compile it we get this big Json file
and one of the first inputs that it has
is the ABI so brownie automatically
knows what the ABI is and what the
addresses already so then we can just go
ahead and run simple
storage.
retrieve and print it out and we should
see 15 since we already updated
it brownie run
scripts read value to pi-- network rink
B and great we do indeed see 15 now that
we know how to write some scripts and
actually deploy things with Brownie and
work with brownie I'm going to show you
one of the most powerful features to
also work with brownie typically we
write our scripts when we want something
to be reproducible and we want to do
something over and over again deploying
simple storage or reading a value is
something that we're probably going to
want to do over and over again however
maybe we want to work with some of these
contracts a little bit ad hoc and get
into a shell where we can actually
interact with these contracts this is
where the brownie console is actually
going to come into play and make our
lives a lot easier so what we can do is
we're can brownie
console and what will happen is brownie
will actually kick us off into a console
it has all of our contracts and
everything already imported so if I run
simple storage it gives me back an array
it's saying great that's your simple
storage contract since we're working on
a brand new local test environment there
are no simple storage contracts deployed
so what I can do is I can say account
equals account zero
and we now have our account that we can
work with accounts is one of these
keywords that's automatically imported
into our brownie console everything that
is imported via brownie in our script is
automatically already imported into this
little shell here so with that being
said we can go ahead and even deploy our
simple storage contract so we can
literally take this line copy it paste
it in here and you'll see exactly the
same thing that happens as if we ran our
script we get a little transaction hash
here and we get a simple storage
now if I type simple storage the simple
storage variable now has a storage
contract here if I type simple
storage you'll see I now have a contract
in here the length a simple storage is
now one because I've deployed one simple
storage
contract if I were to deploy it again
the length is now two browning now knows
I'm holding on to two simple storage
contracts and I've deployed two simple
storage contracts I can then even do
things like simple
storage.
retrieve we can see we start with zero I
can go ahead and even
run simple storage.
store
15 from
account and we'll see we'll get a
transaction now if I rerun simple
storage. retrieve a nice little hack
here is in these shells if you just hit
the up key you'll actually be able to go
back in history of the shell so if I
just hit up twice here I can go back to
this command and I hit enter now we see
the 15 is here so the brownie console is
a great way to interact with these
scripts in a more ad hoc manner maybe we
want to test some weird functionality or
maybe we have some experiment that we
want to try it's a great way to really
interact with anything that we have in
Browning and the other thing is we can
do everything that we normally do in
Python in here so for example I could
write
print
hello and it'll print out hello I could
do cat equals 1 + 2 and I type cat and I
get three so this brownie shell is a
python shell with all of our smart
contract features already natively
integrated and it's incredibly powerful
here we can go ahead and quit it by
doing quit so I know we've learned a lot
so far I'm sure you're starting to see
why working with brownie is so much
easier and makes our lives as smart
contract developers a lot easier for
testing them deploying them and working
with
them all right let's move on to our next
project is we're going to take the
fundme contract that we made recently in
remix and actually import that one into
brownie with this we're going to go over
a lot more of the advanced features that
brownie has to offer offer us and we're
going to get into some more
sophisticated testing and deployment
mechanisms for this so I'm going to make
a new directory
browny
fundme we're going to CD into Brownie
fundme and remember if you hit tab it'll
autocomplete and we're going to open
this up in a
folder again if code period doesn't work
you can always go up to file open folder
and do it like that we're in our brownie
fundme project and we're going to initi
ize a new project by running
Brownie and it we're going to create a
new contract called fundme that's soul
this is going to be exactly what we had
before for our fundme contract so if you
have remix up great you can go ahead and
grab it or you can check the GitHub
repository associated with this course
and just copy paste the
code now typically this is where in our
last project we just ran browny compile
what happens if we run brownie compile
here brownie is going to give us this
error it's going to say hey this Source
wasn't found so what's going on here
well remix understands that at
chainlinks contracts is an mpm package
that it can import from however brownie
isn't aware of mpm packages and brownie
can't actually download directly from
mpm however brownie can download
directly from GitHub so we have to tell
brownie where it should be downloading
these external these third party
packages from so that we can use them in
our contracts here and while I'm in here
I might as well change Global compiler
version to
3.6.6 and we'll just change the compil
version to carot 0.6.0 so that our
linter is happy so we need to tell
brownie where to import these contracts
from from GitHub instead of from npm
luckily there is a package out there
specifically created for downloading
chain link contracts the way that we can
tell brownie where to get these from is
in our brownie config
so let's create our Browning
config and in here we're going to create
a
dependencies section and this is where
we tell brownie the
organization SL repo name at version
that we want to download
from so so to get these chain link
contracts we can look up chain link
rounding contracts and we can use this
repository to get it so instead of
downloading from PM we're just going to
download directly from this GitHub repo
so we need to tell brownie the
organization which going to be smart
contract
kit the repository name which going to
be chain link brownie
contracts and then the version you don't
always have to use the latest version
here and in fact we can go to the past
nine versions by clicking on the version
history we're actually going to be using
1.1.1 and yes it does look like the
latest version went back wordss but as
of a recent release as a 1.2.0 version
of this package all the releases of
Chain Lake brownie contracts is going to
match exactly the at chain link
contracts mpm tag so that's why it looks
like this is an earlier version so we'll
say 1.1.1 so great so now brownie knows
to download this repository from GitHub
once we do that everything everything in
this contract section will be available
for our solidity code to import and use
however that's not the final story here
we also need to tell brownie what this
at ch link thing means because we're
downloading from Smart contract kit
chain link brownie contracts brownie is
going okay cool well what's this at
chain link thing so we need to tell
brownie whenever we're using at chain
link we're actually referring to this
import so we need to tell the compiler
this so let's add a new section we'll
say
compiler when it compiles sulk we need
to
remap at chain link
we say whenever you see at chain link
here it
means we're referring to this package so
compiler solk mappings at chain link is
equal to this package up here now let's
go ahead and try to
compile perfect we see here that it
compiles successfully and if we look in
our build folder in the contract section
we now have this new folder called
dependencies and if we even expand this
a little bit we can see it says
dependencies smart contract kit chain
link Browning contracts at
1.1.1 and this is what it downloaded
from that GitHub repository it
downloaded aggregator V3 interface and
smart math chain link because we're
using both of those files in our
solidity code all right great so let's
write our first script to deploy this to
a development ganache chain to Brownie's
built-in chain
let's do this so in scripts let's go
ahead we'll create a new file let's go
ahead and build a simple deploy script
to work with rink B and then we'll
actually learn how to deploy this to our
own local ganache development chain so
let's build our deploy script so in
scripts we'll do new
file deploy piy and we'll start by doing
def deploy
fundme then we'll do pass for now and
then we'll do entry point of Def Main
and we'll call deploy fundme in this
file of course we're going to do from
brownie import
fundme so we can actually use this and
let's go ahead and build this deploy
fundme function so first we're going to
need to get an
account and same as last time we used a
function called get account which would
know to switch back and forth between if
we were on development or if we were
with an actual test net that we could
pull from our config we can actually
once again copy that function and use
that use that in our script here so once
again we can use that get account
function that we had before what I like
to do with this get account is add it
into its own file called helpful scripts
so what I'll do is create a new file
called
helpful scripts.
piy and in here I'll add that get
account function right so literally just
pasted it from from our last project and
just a quick recap on what this is doing
is we're saying if the network is in
development we're going to use the
accounts zero syntax otherwise we're
going to pull from our config and of
course we're going to have to from
brownie import
Network config accounts then of course
in our Browning config we're going to
have to add wallets and from key so
let's go to our config do wallets
from Key and we'll add our private key
environment variable setup which of
course means that we're going to have to
setv Tov and we're going to have to
create new
file and we'll paste the exact same
values from our last EMV so it's going
to be our private key and our project ID
kind of just a lot of the basics of the
setup here but now that we've added this
get account to its own script how do we
actually use that in our deploy script
depending on the version of python that
you're in you might actually have to
create a new file first named uncore
init.py you might not but just in case
let's make it here because it doesn't
hurt and with this now python knows that
it can import from other scripts and
other packages in this project so now we
can do from
scripts. helpful Scripts
import get account so we're
importing that get account function from
our helpful script here and we're going
to make this get account function a
little bit more robust a little bit
later but for now it'll work perfectly
for what we're looking to do now we can
just run our typical deploy function
funme do the fundme contract equals
fundme
deoy and of course we'll do
from account
because again since this deploy is going
to make a state change to the blockchain
we always need to do a from account
section here then we can even do a
little print we'll do a print F here so
we'll say
contract ployd
to
fundme address this is how we'll get the
address of our fundme and great we can
even go ahead and try this out right now
remember you'll need
R
eum brownie runs scripts deploy up high
D-
Network rink
B
and perfect contract deployed here it is
we can even go to rink be
ether scan
again and we can see the contract right
here now this is great and all but if we
look at our contract it's kind of this
blank jarble of bites here right nobody
can actually see this contract and and
easily interact with it and we want to
make our contracts easy to interact with
what we can do on ether scan is verify
and publish our smart contracts to
verify our smart contract all we have to
do is hit that verify button we'll
choose our solidity compiler type which
we know is going to be
0.6.0 and we know we're working with the
MIT license here
now to continue we would then have to
add in all of the rest of these pieces
we' have to do optimization which is
going to be yes we'd enter our solidity
contract code below which importing
fundme like this wouldn't actually work
because ether scan doesn't know what at
chain link contracts is so we would have
to copy paste the code from these
Imports to the top of our contract here
removing these Imports and copy pasting
the code associated with the files is
known as flattening and this is an
important concept for verifying our
smart contracts on platforms like ether
scan however brownie has a really nice
way to get around this actually what you
can
do is go to their main site etherscan.io
you can sign in and sign up and get an
API key I've already signed up so I'm
going to go ahead and sign in here log
in and what we can do is we can go to my
profile and scroll down to API keys and
this is where we can create an API key
for us to interact with and
programmatically verify our smart
contracts on ether scan I've already got
one here but all we need to do is hit
add we'll give it a name I'll call it
verify Browning continue and we've
created this new API token that will
allow us to verify our smart contracts
what we'll do to use this in brownie is
we'll copy this API key and we'll move
back to our scripts here we'll set this
API key as an environment variable so
we'll do export the name of this is
ether scan token we'll set it equal to
that key that we just got now to verify
this all we have to do then is once we
deploy this contract we'll tell brownie
whether or not we want to verify the
contract so after our dictionary here
we'll do comma publish Source equals
true we're saying yes we would like to
publish our source
code now if we rerun this script let's
see what happens again remember we'll do
brownie run scripts deploy
up-- Network space
Rinke it says fundme has been deployed
to here now we're going to say waiting
for API rink be. etherscan.io to process
contract and we're submitting our code
for verification here and it'll say
verification pending verification
complete pass verify it'll say where the
contract has been deployed and what's
been done with it now if we go back to
Ether scan again we're going to have to
go back to rink be ether scan we
deployed this to rink B and we paste
this in we now have this little check
mark associated with our contract and if
we click contract we can see all of the
code in here for our
contract we have contract fundme payable
you need to get more eth everything that
we defined in here and if we scroll up
we can see that they did indeed flatten
this contract right they pasted that
aggregator V3 interface import and they
also pasted that Library safe maath
chain link now let verified we can even
read the contract see the different
public variables in here such as the
owner get version get price and all the
exact same buttons that we saw in remix
this read contract section is for all
these view functions right the ones that
aren't going to be making a state change
right contract is going to be for when
we want to call something like fund or
withdraw and we could even go ahead and
interact with this so for example we
could connect to web 3
metamask okay and it would automatically
get connected to our metamask here then
we could call fund and withdraw just
like we did in remix if you want to give
it a shot go for it all right we're back
in our code editor after successfully
verifying one of our smart contracts on
ether scan now just a quick note
sometimes the verification process can
be a little bit touchy and for version
of solidity 0.8.4 there's currently a
bug that makes verifying a little bit
tricky but it's being worked on so don't
be discouraged if it gets a little bit
funky so this is great that we've
written a deploy script we're deploying
directly to rink be however as you know
we're always going to want to be able to
deploy to our own local blockchains or
or Brownie's built-in development chain
so we can test a lot quicker and that
yes so that we can write some tests but
we have a little bit of an issue here
the first issue being that our funme
contract currently has an address
hardcoded to work with the rink be chain
so in fact the way it's written right
now it's going to be hard to work with
any other chain other than ring be the
second bit is that these price feed
contracts don't exist on a local ganache
chain or a ganach chain that brownie
spins up there's two ways we can get
around this we can do what's called
forking and work on a forked simulated
chain
or we can deploy a mock or deploy a fake
price feed contract on our ganach local
development chain deploying mocks is a
common design pattern used across all
software engineering Industries and what
it applies doing is deploying a fake
version of something and interacting
with it as if it's real so again right
now if I run
brownie
run scripts deployed IPI and I don't set
this network flag we're going to
actually have a default spinning up a
ganach chain and it's even going to try
to verify which it's going to run into
an issue because we can't verify on a
ganach chain so we have a couple issues
that we need to address here in order
for us to get this to work on a ganach
chain similar to how in this get account
function in our helpful
scripts we do a little bit checking we
say hey if we're on a development
Network use this development accounts
version otherwise pull from our config
we can do that exact same mentality
but with working with these mocks so the
first thing that we need to do is we
need to parameter tize our fundme
solidity smart contract so that we don't
have this hardcoded in here anymore so
what we can do is right when we deploy
this contract we'll tell it what price
feed address it should use right when we
call our deploy function here instead of
having it hardcoded and we can add this
parameter to our Constructor we'll say
address price
feed as an input parameter and whatever
input parameter we use here is going to
be our Global price feed address so
instead of us creating these aggregator
V3 interface contracts right in the
functions here we're just going to
create a global one so we
say aggregator V3 interface public price
feed and right in our Constructor right
when we create this we'll set price
feed
equals aggregator V3
interface price
feed and now what we can do is we can
just delete this part because as you can
see this is doing the exact same thing
it's up here this is doing aggregator V3
interface price feed equals aggregator
V3 interface and then the address here
and we're going to do the exact same
thing but in our Constructor meaning
right when we deploy this contract so we
can delete this
and we can delete it here as well in our
get price function we can even verify
this with brownie
compile great looks like it's compiling
perfectly now our deploy function is
going to need to look a little bit
different we're going to need to
pass the price feed
address to our fundme contract so do
this all we'd have to do is
paste that address before we we have our
from account variable here so this is
how you can actually pass variables to
Constructors anything inside this
Constructor function you can pass
through brownie in our deploy script
here so great so we could 100% always
just pass this rink B address here but
that's not really going to solve our
problem obviously right the problem is
that the problem right now is that we
always have this rink B address we need
to say if we are
on a persistent Network like rink
B use the associated
address otherwise deploy Mock and I know
we've been talking about mock we'll get
into them in a second but let's first
set this one up here so we can check
what network that we're on again by
importing from brownie this network bit
and we can say if network. show active
does not equal
development then we'll say price
feed address equal
equal this address here and we'll just
pass this price feed address now this
still doesn't solve our issue because
we're just always passing this the rink
be hardcoded piece here so what we want
to do is parameter tize where we get
these addresses from so instead what we
can do is in our Browning config we can
add different addresses for different
networks so right underneath our EnV
We'll add a new section called networks
and we'll do one called rink B and we'll
say the F you
USD price feed address is going to be
this price feed address now what we can
do in our deploy
script is we can say if we're not on a
development Network let's grab the
address from our networks section this
way we can Define different addresses
for this price feed across different
networks so we can add we could add a
coven
section we could add a main net section
section any other networks that we want
to work with all we need to do is add
add these flags for those contracts so
back in our deploy now we can say the
price feed address is going to get
pulled from the config instead so we'll
say config and this means we're going to
have to import
config brownie say config of
networks based off of the network. show
active
and then we'll use the FUSD price feed
flag
here perfect so this little if statement
is going to say hey if we're not on a
development Network pull the address
right from the config and this will make
it so that we can deploy to really
anywhere that we want to deploy to but
what if we are on a development chain
what do we do then we can say else if
we're not on a development chain we're
going to have to deploy a mock so right
now on all these live networks that
we're working with there is a version of
this price feed contract this price feed
address on our development chain
obviously there won't be one because
it's going to start off as blank so what
we can do is we can deploy our own
version of the price feed contract this
is known as mocking and we can interact
with it accordingly in order for us to
deploy a price feed contract ourselves
we're obviously going to need to have
the solidity code associated with it so
what we can do is in our contract
section we'll create a new folder called
test when you create a test test folder
in your contracts folder this is
typically where mock contracts are going
to go and we'll create a new file called
mock
V3
aggregator doou and this is where we'll
add the code for us to deploy our own
price feed now I'm going to show you
another repository pretty soon called
the chain link mix that we're going to
work with for now if you're looking for
one of these mocks I highly recommend
just pulling it from this chain link mix
repository so we can grab it by going to
contracts test and grabbing V3 agregator
Soul we can just copy this whole code
and paste it into our mock V3 aggregator
doso this has all the same exact
functions as a real price feed contract
such as decimals and latest answer which
are going to be two of the ones we use
the most we can also see its Constructor
here these are the variables that it
takes whenever this contract is deployed
it takes a decimals and a IAL answer
decimals is of course going to be how
many decimals that this contract should
have and initial answer is going to be
its starting value like 2000 for example
once we have this contract in our test
section we can of course run brownie
compile and brownie will go ahead and
compile this mock V3 aggregator as well
because remember brownie compiles any
contract in this contracts folder let's
go back to deploy script now that we
have this mock V3 aggregator in here now
what we can do is we can do a little l
here saying okay well if we are on a
development chain let's do something
let's deploy these mocks so let's do a
little print statement here a little
printf saying the Active network is
Network that show
active do another print statement print
F saying deploying mock dot dot dot
little closing there and then this
doesn't need to be print F can just be a
regular print and then now the same way
we import funme we can import mock V3
aggregator we can just deploy this
contract the same way we deploy all of
our other contracts so we'll do mock V3
aggregator do deploy and as we just
learned we have to add the parameters
The Constructor takes which is going to
be decimals and initial answer so maybe
we'll set decimals to 18 and then maybe
we want to set the initial answer to
2,000 so 2 1 2 3 1 2 3 4 5 6 7 8 9 10 1
2 3 4 5 6 7 8 comma and of course since
we're deploying we got to do a
from we'll use our account here we'll do
another
print
saying mock deployed and of course we're
going to need to get this mock V3
aggregator address so we'll do mock
aggregator equals this and we'll set
price feed address to equal our mock
aggregator do address and now we're
development or live Network agnostic if
we deploy this on a live Network we'll
use the address from our config
otherwise we'll use a fake aggregator
contract that we've deployed let's go
ahead and even try this on a development
Network so we can do
grounding run scripts deploy py we don't
need a network flag here we'll hit enter
it'll spin up the ganach and we even
will deploy a mock aggregator contract
first and then we'll do our fundme part
of course we are running to an issue
because we're trying to verify a
contract on a chain that doesn't exist
ether scan doesn't know about our local
ganach chain so to fix this instead of
doing publish Source equals true we can
have this publish Source be again based
on what chain that we're on so we'll go
back to our Browning conf
and for rink B we'll say verify will be
true but for
development we'll say verify will be
false and back in our deploy script we
now say publish source is going to be
pulled from our config so again we'll do
config
networks network. active and then we'll
do do get
verify this dot get verify will make our
lives a little bit easier if we forget
to add verify in here you could still do
like this verify but you're run into
some index errors if you forget to
actually put the verify so sometimes I
get lazy and it's just a little bit
nicer like this now if we run this again
deploy ipy we'll spin up our local
ganache we'll deploy a mock price feed
contract and then we'll deploy our
fundme contract and it completes
successfully so this is awesome we have
a way
P our fundme contract that uses a price
feed contract to our own local
development environment with a mock AKA
a fake price feed contract this is
awesome now this is great but our deploy
script is starting to look a little big
and a little clunky so let's actually
clean this up to make it look a lot
nicer the first thing that we want to do
is we want to fix this this big 2,000
number just looking at right away I'm
not exactly sure how many zeros it has
so to make this look a little bit nicer
and more readable we can once again
again call on our friend web 3.y from
web3 import web 3 and down here we'll do
web
3.2
way 2000
comma ether this two-way function will
just add 18 decimals to this 2,000 so
now this is much more readable that the
initial value for this is going to be
200000 the next bit is that we're always
deploying this mock V3 aggregator here
and if we already have a mock deployed
to whatever Network that we're working
on we don't need two mocks here so what
we can do then is right before we deploy
this mock is we can do a little if
statement we can say
if the length of our mock
V3
aggregator is less than or equal to zero
only then will we deploy this mock V3
aggregator remember we can check the
length of our V3 aggregator because this
V3 aggregator is just going to be a list
of all the different V3 aggregators that
we've deployed now instead of using mock
aggregator do address we can just
use mock V3 aggregator minus one.
address so we're just saying okay great
just use the most recently deployed mock
V3 aggregator and then of course we
don't we no longer need to set this as a
variable and that looks a little bit
cleaner and we'll make this a little bit
more efficient so this deploying MOX bit
though is going to be something that so
this deploying MOX bit though is going
to be something that we're actually
going to do relatively frequently let's
even move this print statement up here
so instead what I like to do is put this
whole mock deploying bit in its own
function in our helpful scripts so let's
open back up our helpful scripts we'll
do a new function called
def deploy
Mox and we'll just paste that code in
here of course this means that in our
helpful scripts we're going to have to
import Mach V3 aggregator we'll also
have to do from web
3 Port web 3 and instead of account
we'll just use this get account function
now back in our deploy script we can
just delete this whole part replace it
with deploy
Mox and then import deploy MOX from our
helpful
scripts and then we can also delete this
import now let's remove some of these
comments if you'd like this is starting
to look a lot more sophisticated and
this is great because now we have a way
to deploy based off if we're on a live
chain or a development chain and then
one more thing I like to do so that
everything is
parameterized I like to set these as
static variables in the top of our
helpful scripts so I'll set decimals
equals 18 and then I'll set
starting price equals 2000 and then I'll
have mock V3 aor to deploy to Des
web 3.2a to starting price here so so
let's say now that I wanted to deploy
this to my own ganache instance well
what we could do is we could open up our
ganache here do quick start and we'll
just quickly create our own gach
blockchain in our script let's go ahead
and just run this deploy script again
let's see what happens instead of
brownie spinning up its own ganache here
it says attached to local RPC client
listening at at and then this address
here brownie is smart enough to detect
if you're running your own ganach
instance here and will automatically
attach itself to it knowing that that is
going to be a development environment if
we go to our ganache we'll see we have
two transactions which are going to be
contract Creations we're going to create
a price feed contract and then also our
fundme contract so this is great this is
great for testing quickly and locally
but there is an issue with this for
development networks again brownie
doesn't keep track of those so in our
build folders if we go to deployments we
only are saving stuff from the rink be
chain here so we would need to tell
brownie hey there's another Network that
we want you to work with and we want you
to remember the deployments to that
chain so what we can do is we can add a
new network to our brownie network list
remember
brownie networks list we have all these
different pieces in here these are the
ones that brownie is going to not
remember and these are going to be the
ones that brownie remembers so let's say
we want to deploy to a ganach chain and
we want brownie to remember those
deployments well we can add a network
here and this is going to be how we add
any blockchain that we want any evm
blockchain like Avalanche like polygon
Etc to add a new network to the brownie
networks is we'll run brownie networks
add we'll choose development or ethereum
we're going to choose ethereum because
we want this to be a persistent Network
do ethereum we'll give it a name I'm
going to call this
gach
local we need to give it a host AKA and
HTTP address which we know is right
here then I'm just G to make this
lowercase and then a chain ID
which for this we know is
1337 enter now if I do brownie network
list I see a new blockchain called
ganach local and this is going to reach
out to our ganos UI or our ganach
command line depending on what we're
running now just to note we are going to
be deploying to this ganach UI or ganach
CLI a lot for the rest of this lesson so
please keep your ganache instance
running now what I can do is I can run
brownie run scripts deploy pi-- Network
ganach
local let's see what happens of course
we run into our our first issue ganach
local isn't development so it's going to
go ahead and try to pull from our config
file we don't want this we want to
actually deploy a mock for our local
ganach if a mock hasn't been deployed so
what we can do is we can extend our
definition of what a development
environment is in our helpful SC scripts
we can add a flag in here we'll say
local blockchain
environments equals and this will be a
list we'll say development of course
will be one but we can also say
gach local will be another and now we
can import this local blockchain
environments into our deploy so from at
the top from scripts. helpful scripts do
a comma here paste that and save M gets
reformatted which is really nice and
instead we'll say if network. show
active not in local blockchain
environments then go ahead and pull from
the config what this is saying is it's
saying if whatever Network that we're on
if it isn't development or ganach local
then go ahead and use a config if it is
one of these two we're going to go ahead
and deploy a mock here now that we have
that let's try this again rowny run
scripts deploy py--
Network
G local and we run into a different
issue we're saying hey you don't
actually have enough gas well why is
this let's look at our get account
function aha this one is also looking
directly for this development chain this
one will say if network does show active
is
in local blockchain environments then
return accounts zero so we're saying if
the network we're working on is
development or ar ganach local then just
return accounts zero so let's try this
okay we're getting closer now we're
running to this key error ganach local
well we do know how to fix that as well
in our config We'll add this new network
we'll say ganach local and we'll set
verify to false so let's try this one
more time perfect now mocks have been
deployed and our funme has been deployed
and if we look look in our build folder
in deployments we now have a new chain
ID for 1337 for saving these deployments
and it looks like in our ganach chain we
have these actually saved in here which
is great now an important thing to note
if you were to close this or delete this
ganache chain all of your contracts will
be lost so you won't be able to interact
with them again to account for this you
can always delete
1337 and delete the entries in 1337 from
your map. Json or if you're find
deleting the whole build folder you
could delete the whole build folder so
now that we've deployed this let's
actually write a script to interact with
this so let's create a new file we'll
call it fund and withdraw pi and this
will be the script we use to fund and
withdraw so let's create a function
called fund we can say fundme equals the
most recently
deployed fundme we're going to have to
do from browning import fundme we're
going to have to get an account since we
are going to we're going to be making
some State changes and we just have this
equal to get account and we can do from
scripts. helpful
scripts import get account let's get the
entrance fee so we can figure out how
much we want to fund ah actually sorry
uh since this is going to resemble that
FUSD price feed it actually only has
eight decimals two 1 2 3 for 2,000 and 1
2 3 four 5 six s eight the reason we
want to do it like this too because in
our get price function we know that it
only has eight decimal places so we're
multiplying it by an additional 10 here
we want it to resemble that as well so
we'll do eight decimals starting price
of 2,000 with eight decimals here and
for our Mach V3 aggregator we're just
going to use those exact values and
we're not going to do the web 3
converting we're just going to make it
exactly those hardcoded values now we're
going to want to get the entrance fee so
I've gone ahead and actually added a
function called get entrance fee to our
contract to make our lives a little bit
easier here I'm going to recommend that
you take a look at this and then type it
in yourself or you just copy paste it
from the GitHub repository so that we
can use this get entrance fee because
it's just a whole bunch of math here so
back in our Fund in withdraw what we can
do then is we can do entrance
fee equals fund
me.get entrance fee excuse me get
entrance
fee and we can even print out this
entrance fee just to see if we're doing
it right but first we're going to want
to run brownie run
scripts deploy Network gach local
because we changed our fundme
doou all right great and now we can run
brownie run
scripts fund and
withdraw Network Mar
local and whoops I need a main function
so we'll do def
main F in
here let's rerun
this and great we can see this is the
entrance fee do a little print statement
here print F saying
current entry fee
is entrance
fee do a little print
saying
funding and then we'll call
fundme
fund of course we're going to have to do
a
from account
and we're also going to send a value of
entrance
fee any low-level transaction data that
we want to send with our our
transactions and function calls will add
in this little bracket piece here let's
hit up let's do browny run scripts fun
and withdraw again and great it looks
like it's going through perfectly
awesome let's also do a withdraw
function for the owner to
withdraw say fundme equal ALS
fundme
one do account equals get
account and then we'll just call fundme
withdraw from
account and then right after fund is
called we'll have withdraw be called and
our main function
here let's go ahead and try
this script
findun withdraw
Network gach
local this our funding script our
funding transaction going through and
then our withdraw transaction perfect so
it looks like our approximate
functionality here works great and this
is a script that we could run on a main
network if we like now again it's still
much better for us to run so now we're
going to move into actually
writing those tests and for these tests
we're going to want to quit our gachui
let's go ahead and write some of these
tests create a new file called test
fundme Pi we'll quickly speed through
this test because we're not going to
learn too much new here keep in mind
when we run this test we're going to
want it to be able to work independent
of the network that we're working on so
let's just keep that in mind let's do a
test just to see if we can fund and
withdraw so we'll do def test can fund
and withdraw and we'll do basically
exactly what we've done before do count
equals get account of
course we'll do from scripts that
helpful
scripts import get account then we'll
want to deploy fundme and we can even
just use our deploy fundme script in our
deploy so we can do from scripts
dooy import Ploy fundme in an our deploy
fundme at the bottom we'll just say
return fundme so that our test can now
have this fundme contract for it to work
with so now we'll say
fundme equals EMP Ploy fundme we'll grab
the entrance
fee which will be equal to fund
me.get entrance
fee and then let's go ahead and fund it
so we do transaction equals
fundme fund
we'll call from
count we do value entrance
fee do tx. weight one we'll do an assert
here we'll do
assert fundme do
address to amount
funded it's going to be account.
address to the entrance fee so we want
to check
that our address and the amount that we
funded is being adequately recorded and
then we'll do transaction two will be
fundme
withdraw from
count tx2 weight
one and then we'll assert fundme address
to amount
funded account. address
equals
z and let's go ahead and run this test
so we do brownie
test and perfect looks like it's doing
well now you may be wondering why
sometimes we use the dashd network flag
and sometimes we don't in our Network
section brownie automatically picks a
default network to use and the default
is always set to
development however we could set this to
be anything that we wanted we could set
the default to be ganach local we could
set it to be rink B whatever we want it
here whatever you set for the default in
your brownie config is what the network
will be defaulted to so right now when
we run brownie test this is equivalent
to running Browning
test-- Network development we can even
go ahead and run that too now we could
also run this test on rinky and we will
in a second but often times we don't
want to test all of our functionality on
on rink be and on live networks because
it's going to take a long time for them
to run so sometimes we only want to run
tests on our local chains well how do we
do that we can use py test skip
functionality to do so to work with py
test we're going to first need to
install it so go ahead and run pip
install P test to demonstrate this let's
create a a test that makes sure only the
owner can withdraw and nobody else can
so we'll call this def test
only owner
can withraw to skip this test if we're
not on a local network we'll first check
the network we'll say if network. show
active is not in and yep probably would
have guessed it we're going to pull this
local blockchain environments in from
our helpful scripts so we'll do comma
local blockchain
environments and we're going to say if
the network. show active is not in this
list of local blockchain environments
we're going to do pest. skip say only
for local
testing of course we're going to have to
import
Network and we're also going to have to
import P test now if I try to run this
test here with
brownie test- K D- Network Rinke it
Should
Skip perfect and we do see this s here
meaning meaning that it skipped this
function if we run this with D- Network
development it should go ahead and run
this and it'll pass because nothing
happens in this function and it does
perfect let's keep going so now we'll
say account equals get
account we say fundme equals deploy
fundme and now let's get a different
account to try to call the withdraw
function so we'll say bad actor
equal this will just give us a blank
random account uh but we do have to
import accounts from B here now we want
to test to see that them calling this
withdraw function actually reverts them
and causes an exception because if I try
to do fundme do
withdraw
[Music]
from Bad actor right now what do you
think will happen well that well we know
in our fundme doso our withdraw function
has the only owner modifier so
technically only the owner should be
able to call this function so what
happens actually we don't even need this
account get account bit let's just go a
and delete that so what happens if
somebody else tries to call this
withdraw function well let's go ahead
and test this we'll do
gring
test-
K test only owner can withdraw
H and you can see we're getting this
error here wrting browning. exceptions.
virtual machine error revert from this
fundme do withdraw well we want this to
happen we we're expecting this to happen
so how do we test that we want this to
happen well we just need to tell our
test that we want this to happen so
first we're going to have to import from
brownie this
exceptions package this way we can tell
our test exactly what exception we're
expecting to see then we'll say with pi
test do raises
exceptions. virtual machine
error
fundme
withdraw we'll just actually we'll just
copy this line down here now what this
is telling our test is that if this
reverts with this virtual machine error
that's good we're saying we want you to
revert when you try to call this line so
if we delete this line and hit up and
try to run this again
we can see that it now passes and this
is exactly what we're expecting so this
is awesome all right we've learned a lot
of fantastic tools for working with
brownie here now the last version of
testing that I want to show you how to
use is mainnet forking mainnet forking
is incredibly powerful when we're
working with smart contracts on mainnet
that we want to test locally so let's
talk about forking for a minute so on
the left here I have a blockchain right
an example of a blockchain this is going
to be like a test net rink coulde or
something like mainnet right this is
going to be a blockchain that we
actually deploy to now there are a whole
bunch of blocks in here right and
there's a a huge chain that we can
actually work with all this information
is public information right this block
is going to have like
transaction
transaction
transaction it's going to have you know
each one of these blocks is going to
have a whole bunch of transactions and
all this information is here in addition
to all these transactions it's going to
have price feed
contracts a contracts you know Etc it's
going to have all these different
contracts in it so hypothetically if
it's all already there we should be able
to basically copy this all this whole
blockchain and do some simulations
ourselves and that's exactly what
forking does a forked blockchain
literally takes a copy of an existing
blockchain on the left here and brings
it into our local computer for us to
work with we actually have control of
this blockchain since it's going to run
on our local computer similar to ganach
now all the interactions that we do on
this local blockchain are not going to
affect the real blockchain because it's
our local chain right it's a simulated
blockchain but because it's simulated we
can go ahead and interact with price
feeds we can interact with a we can
interact with all these different
contracts that are already going to be
on chain meain that for is a buil-in
part of brownie and also pulls from
infura the same way it works with rink B
and Coen and everything else we can
start to interact with the mainnet fork
contracts the exact same way therefore
so we can take this whole rink be
section copy it paste it and we'll just
change this FUSD price feed
address to its main net address so we'll
go to docs. chain. link ethereum price
feeds get FUSD here
copy that and we'll paste it into here
and we'll change this to mainnet fork
and since this is going to be a fork of
course for verify we're going to do
false now if we try to run one of our
scripts like brownie runs scripts deoy
D- Network main at Fork you'll see we'll
actually run into an issue here it's
saying insufficient funds for transfer
in our deploy
script when we do our get account and
our helpful Scripts
right now we're using accounts. a config
while it's from key yes it's going to be
our account which right now has zero
money in it on Main net so Brownie's
right away going to say hey you don't
have any money on mainnet what's the
deal so we need to tell brownie that
when we're working with main net Fork it
should create us a fake account with 100
eth in it however we don't want it to
deploy a mock because price feed
contracts already exist so we don't want
it to deploy a mock but we do want it to
get us an account here so typically what
I like to do is I'll add another
variable here and I'll call it forked
local
environments and I'll
add maintenance fork in here and I'll
use this now as part of my if statements
so I'll say if network. show active in
local blockchain environments
or network. show
active in Fork to local environments
then we're going to go ahead and return
count zero however in our deploy piy
mainnet Fork is not going to be in this
local blockchain environment so we will
just get our price feed from our config
so now if I run this mainnet Fork again
now if we run this you'll see we'll
still get an error we'll get list index
out of range so Brownie's built-in
forking mechanism doesn't actually come
with its own accounts here however it
has these issues so what normally I like
to do is I like to create my own custom
mained Fork right in brownie the way we
can create our own development custom
network is by using the brownie
networks's ad key so we can do
brownie networks add we'll make this a
development network instead of a
persistent Network and we'll call this
main net Fork
Dev to set this up we'll do a ganach CLI
so we'll say the command to to run this
Fork is going to be ganach
C the host is going to be the same as
always HTTP that colon 127.0.0.1
Fork is going to be equal to and this is
where we just put
https main
net. inf.
iv3 slash web 3 INF
fura project object ID now don't hit
enter quite yet I'm going to explain a
couple things so this single quote means
run this as is if we ran this without
the single quote our environment
variable we' get actualized here and
we'd always have to use whatever our
current environment variable is so we
want to have this little little
semicolon here then we would do accounts
equal 10 this tells brownie for us to
set up 10 fake accounts for us we'll
give it a pneumonic of brownie so we'll
say great make those accounts just have
a pneum monical Browning and we'll do
Port equals
8545 now once again don't hit enter
quite yet I do want to explain one other
thing so this is great for working with
infero and forking from infero however I
have to note that performance wise
forking from infura has pretty much
always given me an issue so I prefer
actually to Fork from this application
called Alchemy and in fact if you'd like
you could set up all of your networks to
work with Alchemy uh by modifying them
I'm going to go ahead and sign in here
and we're going to give it an Alchemy
URL instead of an inferior URL so I'm
going to go ahead and create an app I'm
going to call this fundme demo
description will also be a fundme demo
be a development environment on the
ethereum mainnet let's create this we
can now view the details of this we'll
go to view key and we'll copy this HTTP
address and we'll move back over here
and for forking
we can just delete everything next to
this
fork and we'll just paste that in here
instead and let's go ahead hit enter
you'll know you've done this right if
you can see something like this mainnet
Fork dev has been added oftentimes in my
example I will actually just delete
mainnet fork and have mainnet Fork dev
be my default for mainnet fork but for
us we're going to go ahead and do
mainnet Fork Dev so in our config we're
going to change mainnet fork to main it
Fork Dev so since we're giving this a
different name that means in our helpful
scripts we going to have to do a comma
here say mainnet fork Dev all right
great now our get account should return
account zero for mainnet fork Dev and it
should actually work so let's run our
script again Ronnie run scripts deploy
Das Network main net Fork Dev and
perfect we're running our mainten Fork
Dev and it is running successfully now
we should also be able to test exactly
the same way let's look at our test real
quick test fundme and see okay cool
we're going to be skipping this one
since main at Fork Dev isn't in the
local blockchain networks but this
should work perfectly and then often
times in my tests here I'll actually do
like a little plus 100 or something for
entrance fee just in case I need like a
little bit more money for whatever
reason so now if we run Browning test--
Network mainnet Fork
Dev we'll see that this does indeed pass
and this is awesome so this is fantastic
incredibly powerful project here now
we're going to teach you how to actually
share your code and enter the world of
Open Source and decentralized code the
way the world works when sharing code
and sharing ideas and collaborating
together is they use what's called open-
Source git repositories GitHub is an
example of one of these git repositories
that we can use to share our code and
it's one of the dominant ways that smart
contract Engineers share ideas and share
code we are now going to learn how to
add our code to GitHub and then we can
even share the code and show the world
what we've built and what we've done
this isn't going to be a full endtoend
git course however there are some links
in the course repository that will show
you how to work with Git work with
GitHub and work with Version Control so
the first thing that we're going to do
is we're going to come to GitHub and
we're going to sign up for service at
our email
create a
password enter your username no now
we'll go to our email to verify
it continue we're going to be working
with some collaborative coding we're
going to choose the free edition and
perfect we are now in GitHub now that
we're in GitHub we're going to create
our own first open-source repository so
we're either going to hit this plus
button here or create repository let's
choose a repository name for this we'll
give it the same name as our main folder
so call this brownie fundme give it a
description the smart contract
application we'll hit create repository
this is where we're going to upload our
code to share with the world back in our
vs code now we're going to send this
folder to that repository first thing we
need to do is installing git there are a
couple different ways to install git
depending on the version that you're on
we'll put this link in the description
to our course to actually install git
once you have an install you should be
able to run
get-- version let see a get version here
now we're going to initialize our
repository here by doing get and nit
we're going to choose a branch name
we're going to call it mate we go ahead
and add our username and email to our
get config
user. name
Vols
video email
now we're going to do a couple things to
push all of our code to GitHub here
however remember we do not want to push
ourv pieces up here so we can do a
couple of things we can a we go ahead
and delete this of course but we can
also add in ourg ignore file aemv this
will help us so that we don't
accidentally push ourv file to GitHub we
can choose what files we want to push by
doing get add and then a period And if
we do get status it'll Now show us all
the different files that we have staged
to push to GitHub we look in here we see
we have git attributes G ignore ring
config fundme some contracts some
scripts but we do not have that file if
you were to remove EMV from.get ignore
and you ran get add. again then we did
get status we now see the EnV in here we
do not want this in here so we can do
get remove D-
cached we'll add EMV back to ourg ignore
file and then we'll run get status again
and then we'll run get add period and
then get
status and great we do not see that Dov
in here so that's very good now we'll
Commit This by get commit minus
M first
commit and now we can add this folder to
our GitHub back in our GitHub there's a
little line here which even tells us how
to do it we're going to copy this line
right here get remote add origin https
free code Camp BR fundme copy that paste
it in here hit enter and now we can just
do this second line get push D origin do
get
push origin main we're get an output
like this and if we go back we'll now
see all of our files and folders in here
now I've already added my email and
password in here but instead of this
you'll probably get GitHub asking you
for authorization you can just go ahead
and put your GitHub username in and your
password in if your username and
password doesn't work you can come into
GitHub go down to settings
scroll down to developer settings
personal access tokens generate new
token call this F Brownie and we'll want
to give it at least repo authorization
here we hit generate token and instead
of using your password you can go ahead
and use this GitHub token amazing and
you now have your first GitHub
repository we could even come in here
add some topics solidity chain link p
python brownie Etc so that we know what
our file is about and this is incredibly
exciting now I'm GNA even encourage you
to pop on Twitter and share your
excitement I just
made my first first at
GitHub
pository thanks to freecode
camp at solidity
Lang
browny chain link if you want to tag me
you can also tag Patrick C and pop your
repo in there go ahead and tweet the
community absolutely loves hearing about
all the Fantastic things people are
doing in this ecosystem so be sure to
reach out have fun and engage I know
we've gone over a lot here but let's
talk a little bit about some some
testing pieces here now a big question
you might have is well okay so I learned
a ton of stuff we learned about mainnet
forking I can do stuff on ganache I can
use Brownie's ganache I can use
Brownie's main net Fork there's I can do
a test that there's all these places to
do stuff where do I need to run my tests
the default for every single one of your
contracts is as follows you always 100%
need to have tests that pass on a local
brownie spun up ganache instance that
should be priority number one to get all
your tests to pass it on this this means
that you will need to deploy mocks after
that the other place you absolutely need
to have tests or do some type of
development is on a test n these are
going to be what's known as your
integration tests and we'll talk more
about those later so those are the two
places you always need to have test
development and a test net I think
testing on main net fork and your own
local ganache are optional testing on
mainnet Fork can be done and probably
should be done whenever all of your
contracts and all of your interactions
are going to be onchain on one chain
without any external offchain components
testing on your own local ganache is
really more meant for tinkering and kind
of exploring and seeing things yourself
so that's going to be the setup here so
great now let's move into our most
challenging example once you pass and
once you complete this example you
basically will have all the tools to be
an incredibly powerful smart contract
developer then after that we're going to
show you the chain link mix package and
how to do what's called a brown bake to
automatically open up this package with
all these scripts and all these
contracts pre-built in this is going to
make our lives substantially easier and
faster for deploying our smart contracts
however let's go through the process of
understanding all the pieces that are
going to be inside of this brownie mix
are you ready you should be let's get
excited and jump
in okay so let's get into our most
advanced smart contract project that
we've made so far this is going to be
the best example of a full scale
application and by full scale I really
mean end to end full Suite all our
brownie all of our smart contracts are
are really solid here what we're going
to want to do is create a Lottery
application where anybody can enter the
lottery and a random winner is selected
so let's get to it and let's get started
so first of course we going to make new
directory we'll call it smart contract
Lottery CD into smart contract Lottery
and then open that
folder and great we are now in our
Lottery application so let's go ahead
and start a new
project browny and it we've got our
project here now let's create a quick
readme.md to explain what we're going to
be trying to do here so number one we're
going to say users can enter the lottery
with f based on a USD fee so for example
let's set the price to be like $50 and
the users actually pay with ethereum so
we're going to have to get that
conversion
rate two an
admin will choose when the lottery is
over and then
three lottery will select a random
winner now something important to note
here is since we have an admin here this
means that our application isn't
necessarily going to be truly
decentralized because we have a single
person chooses when the lottery is over
we could scale this out to have maybe a
dow being the admin or something like
that or we could have the lottery
automatically open and close based off
some time parameters but for the moment
this is the setup that we're going to
have keep in mind even though this is
much less decentralized it's still going
to be a great use of smart contract
technology so first thing that we're
going to get started with of course is
our Lottery contract so create a new
file called
lottery. soul and let's begin with our
initial setup here so let's choose our
version prag
solidity carat
0.66 and this will be the version that
we want to work with
here do
contract
Lottery bracket here now let's think for
a second on what some of the functions
that are going to be what our main
functions are going to be here we'll
probably have a function
enter that'll be
public we'll probably have a function
get entrance
fee to get the entrance fee of the
lottery we'll probably have a
function start Lottery that only the
admin can call this will be public as
well which means we'll also probably
have an end Lottery
function and those are really going to
be the main functions the user can enter
based off the entrance fee you can start
the lottery and then of course we can
end the lottery so let's get started
with this enter function just because
this is most likely going to be the
entry point as we know since we're going
to want them to pay using this entry
function in ethereum we're going to need
to make this function
payable and in here we're going to need
to keep track of all the different
players everybody who signs up for this
Lottery to keep track of all the players
we're going to make an
address payable array we'll make it
public call players
and anytime somebody enters we'll just
do
player. push message.
sender however right now we're not
checking to see how much value that
they're actually sending we want to set
the price of this to be at least $50 so
we'll say $50 minimum so here we're
going to have to do a require
statement requiring them to do at least
$50 in order to do that we're probably
going to need to have some function to
get the entrance fee to check whether or
not how much they're sending ending is
actually $50 so let's go ahead and make
that get entrance fee function now since
we're just going to be returning a
number for get entrance fee we can
probably go ahead and make this a public
View and have this
return a un
256 to get this entrance we're first
going to have to have stored somewhere
what the entrance fee is we're going to
have to store this $50 minimum somewhere
this is something we'd probably want to
set right when our contract is deployed
so where can we put stuff like that well
in our Constructor we'll do con
structor public we'll create a new
variable outside of here we'll call it
un
256 public USD entry
fee and our Constructor we set USD entry
fee equals 50 now because I like to have
units of measure always in way we'll
also do times 10 raised to the
18th now we have some USD entry fee
let's go ahead and get this entrance fee
as we know since we're going to try to
get a conversion right here we're going
to want to use a chain link price feed
so you can head on over to docs. chain.
link scroll down to get the latest price
and we can even just go ahead and copy
paste this again but for the sake of
robustness let's just walk through again
how to actually set this up we're going
to need to pull from the price feed to
convert $50 to $50 an eth so let's go
ahead and create an Agra gor V3
interface
internal
FUSD price feed and in our Constructor
we'll go ahead and set this we'll say
Fus price feed
equals
agregator V3 interface and we're going
to want to grab an address Mark contract
addresses but of course as you know as
we've learned from last time we're going
to want to parametrize this so we're
going to want to pass the address of our
price feed as a Constructor parameter so
we'll do
address price feed address and we'll
have our aggregator V3
interface past that price feed address
then of course since we're using an
aggregator V3 interface we're going to
have to import this from chain link so
we can just go ahead copy this from the
documentation and paste it right at the
top
or if you want to rewrite it out
yourself feel free to do so and of
course since we're doing this import
here new
file bring config
yl we're going to want to add this as a
dependency so we'll do
dependencies smart contract kit SL chain
link bring contracts and we'll do add
1.1.1 again
then
compiler sulk REM
mappings at chain link
equals this right
here we'll pull up our
terminal we'll try this out do Browning
compile see if we're doing everything
right we forgot an spdx license
identifier which is just a warning but
let's add it in anyways
spdx license
identifier MIT I should probably spell
me remappings right REM
mappings and let's try to compile again
all right lovely so we at least know
that we are compiling correctly awesome
so now that we have a price feed let's
go ahead and set up this entrance fee so
we're of course going to need to get a
price from this price feed so we can
even check the documentation how to do
that we can call this latest round data
function so we could copy paste it I'm
just going to go ahead and rewrite it
but again we don't need round ID started
at timestamp or answered in round we
only need price so we can go ahead and
ignore these variables on our call so
what we'll do is we'll do like comma in
price and then comma comma comma
equals FUSD Price feed. latest round
data and this means we're just going to
get the price here now we're going to
want to do a little bit of quick math
typically if we're setting the price at
$50 and we have price feed of $2,000 per
eth we would just want to do 50 divid
2,000 but of course since SL doesn't
work with decimals we can't actually
actually just do this so we'll have to
do 50 times some big number divid by
2,000 so we're going to go ahead and do
it like that but first let's go ahead
and convert this price from in 256 to
uint
256 so say U
256 adjusted price
equals
256 and 256
price and
then since we
know we're going to be using an ethereum
USD price feed that has eight decimals
let's also just convert it to having 18
decimals as well so we can also do times
10 raised to the
10th so now we can have
18
decimals now that we have this adjusted
price we'll do U 256 cost to enter is
going to
equal
USD entry fee times again we're going to
want to times it by some big number here
so we'll just times it by 10 raised to
the
18th this way USD entry fee has 18
decimals but it has an additional 18
decimals here that'll be canceled out
with our price feeds the math will work
divided by
price then we'll
return cost to
enter now of course since we're doing
some interesting math here it's
recommended to use safe math and use
safe math functions we're going to skip
over the safe math functions here again
because in the newer versions of
solidity you don't really have to use
them but I think it's important to note
here that sending this code this exact
code to production would be a bad idea
for at least the reason of the safe math
functions but in any case we have a
function here we think our math is
pretty good but I know for a fact that
my math is usually not very very good so
let's go ahead and do some testing as we
code just to make sure our get entran
function is working properly so based
off of our last lesson let's talk
about how do we want to test
this well we could do a main net Fork
here because we're only working with
some onchain contracts and some math we
will at some point have to do our
development with Mox
and of course our test net I kind of
want to just do a quick and dirty way so
let's try our main net Fork just for now
just to see if if this is really making
any sense if the current price of
ethereum is
$2,500 or or this much here and we want
the price of this to be $50 we can do 50
divided by this and we get
019 so this should be
approximately what we get for our eth
value so so if we were to write a test
test lottery. Pi we were to test this
function we would expect to get
0.019 or in way it'll be 1 nine 2 3 4 5
6 7even n 10 1 2 3 four 5 six we'd
expect to get approximately this so
let's go ahead and create a function
that tests us so we'll do test get
entrance fee
and in here we'll deploy Lottery and in
here the first thing we need to do is
deploy this Lottery function of course
so we'll do
from browny import
lottery in order to deploy this we're
going to need to get an
account we are going to import our
helpful scripts from the last project to
this one too so we can get our get
accounts but for the time being we can
actually just use accounts Zero from
brownie so we'll say accounts zero
should start with death and we'll do
Lottery equals lottery.
deploy from
count and ah of course we have a
parameter here of our price feed
address so we're going to have to add
some type of parameter here for now
let's just hardcode it from our config
and we'll go into our config and we'll
start our networks flag we're going to
be working like I said said on the
mainten it fork for this quick and dirty
here we call F USD price
feed grab the FUSD price feed from Main
net since we're going to be doing a main
net Fork
here pop that in
here now we can just
say from
config Networks
network. show
active yes
D
Feed of course we're going to need to
import Network
here and now we can do our kind of quick
and dirty test we can do Lottery dot get
entrance fee
spelling that right
get
yes CT lottery. getet entrance fee
should be greater
than let's just say let's just go down
on
18 or if we wanted to make sure we're
actually doing this right we do from
three or
web3 do web 3.2 way
0.019 comma
ether should be greater
than even do 0.018 just to make sure it
should be less
than
0.022 now these numbers are of course
going to be a little bit different for
you and if you want you can go ahead and
skip this part so that you don't have to
do the math but it is kind of nice to do
a quick sanity check saying okay like
based off what things are right now what
would this price end up to be now in our
last section we made a mainnet fork Dev
Network I'm going to just go ahead and
customize our mainnet Fork the way that
we showed you guys how to do mainnet
Fork Dev this way you can use accounts
and we can be a little bit more robust
here to do this we're first going to
have to delete browny's internal
built-in main it Fork so we do
grounding networks
delete main that fork
main net Fork has been
deleted and now let's go ahead and add
our own mainnet Fork using
Alchemy as our ethereum
connection so you'll want to create a
new app I've already created one here
called smart contract Lottery we'll view
the key and this is the HTTP endpoint
that we'll use so to do this we'll do
Browning networks add this will be a
development chain we'll call this
maintened
Fork it'll be a ganach
CLI the host is going to be our Local
Host so
127.0.0.1
and the fork is going to be equal
to our Alchemy H2 top
here we'll do a counts equal 10 that way
we can use the
accounts do the New Monic
brownie Port is going to be
8545 and great main it Fork has been
added now that we have this here we can
go ahead and run our test
brownie test d d Network main net
Fork oops looks like we got a a little
compile error on our math here oops it
looks like we're dividing by Price which
we need to be divided by adjusted price
and we forgot the parentheses on latest
round data let's try this
again and I put an extra comment here
let's try this one more
time lovely and it looks like we're
forking
correctly and awesome it looks like our
test indeed passes here of course we
know that we're going to want to change
this because this isn't a great way to
actually test our contracts here but it
can be a nice sanity check and we know
we're going to have to refactor this as
well for mocks and for accounts but
we'll get to that in a little bit
awesome sanity check complete let's get
back to our contract here so we are
getting the cost to enter correctly
perfect getting this entrance fee what
that means we can do in our enter
function we can do
require message. value it's got to be
greater than or equal
to our get entrance fee function
and if it's not give them an error of
not enough
teeth we have a way for them to enter
and we have a way to get the entrance
fee but we want to make sure that we're
not ending the lottery before the
lottery even starts right or we're not
entering a lottery when a lottery hasn't
even begun so we're going to want to
weigh to iterate through the different
phases of this Lottery and we can do
that with what's called an enum or an
enum according to the solidity
documentation enums are another way to
create userdefined types in solidity we
saw an earlier version of doing this
with a struct enums are a little bit
different in that they're explicitly
convertible to and from all integ types
so what does that actually mean well we
can have an enum like this action
choices go left go right go straight and
sit still there just more readable ways
to say go left is going to be rep
presented at state zero go right is
going to be State one go straight state
two sit still state three so for our
Lottery contract we're going to want to
create this new type that represents the
lottery state so to do this we'll do
enum Lottery State
open
closed and calculating winner this means
that we have a new type called Lottery
state with three positions open closed
and calculating winner these different
states are actually represented by
numbers so open is actually a zero
closed is actually a one and calculating
winner is actually a two now that we
have this new type we can create a
variable of type Lottery state so we'll
say Lottery
state
public Lottery State and right when we
initialize our contract here we're going
to want to set our Lottery state to
being
closed so in our Constructor we do
Lottery State
equals Lottery state. closed now since
these are represented by numbers as well
we could also just do Lottery State
equals one because one stands for closed
however it's much more readable to do
Lottery state.
closed now that we have a lottery state
in our enter function we can
require the lottery state
is going to be equal to lottery state.
openen so we can only enter if
somebody's started this Lottery and
that's exactly what we're going to do in
our start Lottery function we're going
to do a require in here that the lottery
state is going to be equal
to Lottery state do
closed we can even
add failure function here
saying and start a new Lottery yet and
when we do start this Lottery we say
Lottery State
equals Lottery state.
openen now when somebody starts the
lottery they'll be able to
enter of course this start Lottery bid
here needs to be called only by our
admin so this is where our only owner
modifier is once again going to come
into place we could write our own only
owner modifier or we can once again use
open Zeppelin's access control and open
Zeppelin's ownable function instead
which is what I'm going to use here so
we're going to go ahead and grab this
copy this paste it
in import atop Zeppelin contract access
ownable and of course since we're doing
this we're going to have to add this
depend dependency into our config we're
going to be using
open Zeppelin
slop Zeppelin contracts at
3.4.0 we're going to
remap at open Zeppelin
equals
this
oops then we'll say our Lottery is
ownable perfect now we'll try to compile
this awesome looks like brownie grabbed
everything correctly and we're good to
go great now we can finally move into
our end Lottery function this is where
we're actually going to choose a random
winner here we only want the admin to be
the one to actually end the lottery so
let's add the only owner modifier here
and let's talk a little bit about
Randomness because this is what we're
looking to do now we're looking to get a
random winner here now as you know the
blockchain is a deterministic system
right and this is super advantageous
because it allows us to do all these
smart contracts and have this system
that can actually reach consensus very
easily random numbers are much harder if
let's say you had a blockchain with a
whole bunch of different nodes and each
node responds and gives their own random
value well each node is never going to
be able to sync up and say Hey you know
we all agree on a random number what you
could do is you could base the random
number on some other attributes in the
system but then it's not really random
it's actually going to be pseudo random
so getting truly random numbers in a
deterministic system is actually
impossible and if you know a lot about
computer science you actually know that
even when you call like math.random in
your JavaScript what your computer is
really doing is it's looking at some
place in memory grabbing some value and
saying hey this is probably random
enough here go ahead and use this now in
smart contracts especially when working
with with any type of financial
application such as a lottery having an
exploitable Randomness function means
that your lottery is at risk of being
hacked or destroyed and this isn't even
a fairy tale um at the time of recording
about 2 weeks ago I did a rundown on an
exploit where a protocol used insecure
Randomness and got hacked for
$700,000 so I am going to show you this
insecure way first and the reason that
I'm going to show you is that it is a
quick and dirty way to get a pseudo
random number but please do not use this
in any any production use cases I'm
going to show you a method that's often
used to teach people how to get random
numbers and then we're going to explain
why it's so vulnerable and not a good
method of Randomness and what some
insecure protocols will do is they'll
use a globally available variable and
hash it so in your smart contracts
there's actually a number of globally
available variables one of those as we
saw above it's going to be message. Val
right it's going to be the value that's
sent with a transaction another globally
available variable is going to be
message. sender you can actually see a
whole list of these different globally
available variables in the solidity
documentation here so since there are
all these globally available variables a
lot of times someone will see something
like block. difficulty which Returns the
current block difficulty now one of
these globally a now one of these
globally available variables is going to
be block difficulty or block. difficulty
it's the current block difficulty
remember how I said the time between
different block generation it's called
The Block time well you can always keep
that block time as is by changing the
block difficulty over time the harder
the problem or the harder the proof of
work algorithm the longer it's going to
take or the more nodes you're going to
need to solve that problem there's this
constantly recalculating metric called
ethereum difficulty or block difficulty
depending on the chain that you're
working on that constantly changes so
you might think this would be a great
use of Randomness right because it's a
somewhat hardto predict number so what a
lot of people do is they think that hey
those sound pretty random let's use them
as a unit of Randomness and what you'll
see is you'll see like something like
uint
kak kak 256 which is again this hashing
algorithm do something like ABI encode
packed
NS message.
sender lock.
difficulty block.
timestamp mod players.
length so I know there's a whole lot
going into this line and and let's talk
about it so first as we can see is that
we're casting or we're converting
everything in here to being a un 256 the
reason that we're doing this of course
course is because we're going to want to
pick a random winner based off of an
index right we're going to want to pick
somebody some random winner in our
players array or our players list so we
say okay whatever number that we're
going to use that's going to be the
index of the winner that we're going to
randomly pick then they use K 256 which
is again our hashing algorithm so they
Hash a whole bunch of variables together
and they do this ai. encod packed ABI is
another keyword for some lowlevel work
add they'll add maybe a nson they'll add
the message. sender block. difficulty
and block. time stamp basically what
they're trying to do here is take a
bunch of seemingly random numbers mash
them all together in a hashing function
and then say yeah this this is pretty
random but the issue here is that the
hashing function itself isn't random the
hashing function is always going to be
exactly the same K check 256 it's always
going to hash everything exactly the
same way so we're not actually making it
more random by hashing it all these
numbers inside are the pieces that
actually determine how random it is so
if block to difficulty is random then
this will be a random method if the
block. difficulty isn't random then this
won't be a random method and block.
difficulty is not random difficulty can
actually be manipulated by the
miners in Tim
stamp time stamp is predictable nuns is
predictable AKA transaction number
because in this regard they're using the
nuns as some transaction number and
message.
sender is
predictable when using a random number
in this way the hashing algorithm is
always going to be the same un 256 is
always going to be the same we have a
predictable number predictable
address a predictable
timestamp and then a manipulatable value
so all this is really doing is giving
the miners the ability to win the
lottery or win whatever Lottery that
you're working on so this isn't going to
be an effective way to get a random
number this is an unacceptable way to
get a random number in our applications
yes we do have this only owner modifier
here which means that we are the ones
who are going to choose when to call
this so it is still centralized in that
regard but let's just teach you the best
practices for working with random
numbers right from the get-go so you
don't run into any issues I'll explain
what this part is doing in a little bit
in order to get a true random number we
are going to have to look outside the
blockchain the blockchain itself like I
said is a deterministic system so we
need a number outside the blockchain but
what we can't do is we can't use just an
API that gives a random number right if
that API becomes corrupted if they're
malicious if they go down if something
happens Etc what we need is a provable
way to get a random number and chain
link vrf is actually that solution chain
link vrf is stands for chain link
verifiably Randomness function and it's
a way to get a provably random number
into your smart contract it has an
onchain contract that checks the
response of a chain link node to make
sure the number is truly random using
some cryptography magic it's able to
check a number of the parameters that
the chain link vrf started and ended
with to make sure that it's truly random
it's already used for protocols like
avag GOI ether cards pool together and a
whole bunch of other protocols as well
because it is a secure reliable truly
provable way to get a random number
which is incredibly powerful in a
decentralized system so that's how we're
actually going to get our random number
here so let's work on getting that what
we can do is we can go ahead and head
right over to the chain link
documentation to actually learn how to
work with one of these let's go over to
the chain link documentation just to
make sure that we get it right so if we
go to the get a random number here we
have all the documentation you could
ever want so if you ever get lost or
confused you can always come right back
here to work with it what we're going to
do is we're going to deploy the their
simple version in remix version of
working with the Chain Lake VF and we're
going to walk through a minimalistic
contract to see how it actually works in
a contract so once again we're hit this
remix button remix pops up and we
immediately get this random number
consumer. soul in our files that we can
check out so awesome so here is our
files right here we can see that this is
actually using a different chain than
what we've been using we've been mostly
working with rink be
but for this demo it's actually on koven
so we can do some work with koven here
and remember if you do want to stay with
rink B you can always go to this
contract addresses section of the
vrf and grab these addresses to use so
what's going on in this contract how do
we actually use this well as you can see
the first thing that happens is we're
importing some code from the chain link
package and our contract is inheriting
the abilities of this vrf consumer based
contract so we're going to see what
functions we're actually going to use
that are inherited from this contract
and the first thing that we notice is we
can see that our Constructor in here
does some weird stuff it looks like it
almost has two Constructors so what's
actually going on here well let's look
at this vrf consumer based. contract in
the chain link
GitHub so we can come to the chain link
GitHub here we'll go to evm contracts or
depending on when you're watching in
this it's migrating to contracts at some
point we go to evm contracts we'll go to
SRC so we're using v0.6 we'll go there
and we'll look at this vrf consumer
base. Soul as we can see this vrf
consumer base that we're importing has
its own Constructor and it takes an
address for the vrf coordinator this is
the onchain contract that actually
checks to make sure our numbers are
random and the address of the chain link
token which we'll talk about ER c20s in
a little bit what we're doing is we're
also inheriting The Constructor into our
contract so this is our Constructor for
our random number Consumer but we can
also use the Constructor of the vrf
consumer base and this is actually how
we go ahead and do that we grab the
Constructor of the vrf consumer base and
plop it in
here now it's taking two addresses it's
taking the vrf coordinator and the link
token like I said the vrf coordinator is
a contract that's been deployed on chain
that's going to verify that the return
of the chain link node is truly random
and we're going to use the link token as
a payment to the chain link node for its
services and then we also have a keyh
and a fee defined inside of this
Constructor as well keyh uniquely
identifies the chain link node that
we're going to use and then the fee is
how much link we're actually going to
pay to the chain link node for
delivering us this random number now
let's talk about a couple things here in
ethereum whenever you make a transaction
you have to pay some eth Gap
right or transaction
gas this is to pay the smart contract
platform a little bit of eth for
performing our transaction with a smart
contract with a smart contract that
operates with an oracle we have to pay
some link gas or Oracle gas this is to
pay the oracles a fee for their services
for providing data or doing some type of
external computation for smart contract
the question that might then follow up
is oh okay well how come I didn't have
to pay when we did this price feeds
thing well for Price feeds somebody had
actually already paid for the data to be
returned and if we go to data. chain.
link and we scroll down we can actually
see a list of sponsors here that are
paying to get this data delivered so
they're already paying the Oracle gas to
bring this data on chain for us since no
other protocol is getting a random
number for us we're actually going to
have to pay the Oracle gas here now in
this contract we have a function called
get random number which is going to
return a byes
32 and what it's going to do it's going
to call this request Randomness function
which is inherited from this vrf
consumer base if we look in here we look
for
request request Randomness we can see
there's a function right here called
request Randomness this function is
going to send our Oracle fee or the link
token and it's going to call this
specific to the link token function
called transfer and call this function
is going to call a chain link node now
I'm not going to talk now I'm not going
to go into exactly how it's doing that
right now but we will talk about it in a
little bit so we call this request
Randomness function and we send the keyh
in the fee remember the keyh uniquely
identifies the chain link node and the
fee is going to be how much Oracle gas
we're going to pay if you ever get lost
on how much to pay or what the contract
addresses are you can always head over
to this VR contract section and see
where the most recently deployed VFS are
how much the fee is ETC now here's where
it gets a little bit
interesting getting a random number
actually follows What's called the
request and receive style of working
with data let's go ahead and just try
this out and I'll explain what this
means once we see it now we're going to
save the answer to this random result
variable here and let's just go ahead
and try this and see what happens so
we're going to switch to our injected we
three since we're now swapping to a new
test Network this means that we have to
get test net eth and test net link
again you can always look for the link
token contracts page to find the most
upto-date faucets so scroll down we'll
find coven look like this is the test at
link faucet and the test e faucet so
here's our coven faucet we'll just want
to switch from rinky to
koven grab our address paste it in send
me1 test
link here's our transaction we can see
we're
transferring some
erc20 we'll take this contract address
we'll add it to our metamask by copying
the address scrolling down to add token
pacing it in here I already have the
address in here so I'm just going to hit
cancel for now and we'll also want some
testut Coen ethereum which looks like
this faet has it so we'll paste the
address in here not a robot and we'll do
send me 0.1 test e and perfect now that
we have some test on ethereum and some
test on link we can proceed we're going
to make sure we're on the coven test
Network and we're going to deploy our
random number Consumer gist here let's
go ahead and hit deploy metam Mass pops
up we're going to go ahead and confirm I
didn't explain this fulfill Randomness
function intentionally you'll see why in
a second and great
a random number Consumer comes up let's
check what our random result is right
now it's obviously zero because we
haven't got a random number so I'm going
to do something intentionally wrong
because there's a good chance that
you'll run into this at some point if I
hit get random number right now we see
this air gas estimation failed we have
plenty of eth why would this fail the
reason that it's failing is because the
contract doesn't have any Oracle gas so
we got that gas estimation failed
because we need to fund this contract
address with some link to actually get a
random number so we're going to hit this
copy button and this is going to copy
the address and we're going to come into
our metamask here and we're going to
send this address we're going to paste
it there swap to link and we'll send it
one link this is probably
Overkill because as you saw the fee is
only 0.1 but we're just going to be
overkill for
now and great now that this contract has
some test net link now we can call this
get random number button because we can
actually pay the chain link node to
actually return our random number so
we're going to go ahead and do confirm
and this is fantastic so we're paying a
little bit of transaction gas to make
this transaction to make this request
and then we're paying a little bit of
Oracle gas to make this transaction now
so the
trans now so the transaction confirmed
but if I hit random result now it's
still going to be zero so why is that
what's going on well getting a random
number like this actually follows what's
known as the request and receive cycle
of getting data you can read more about
it here in this basic request model in
the documentation so in one transaction
we actually request some data or in this
case a random number and then in a
second transaction The Chain Lake node
itself will make a function call and
return the data back to the smart
contract in this case the function that
we're calling is fulfill Randomness it
calls this fulfill Randomness with byes
32 request ID which is going to be the
request number of when we called this
and it's going to return with this
random number called Randomness so after
we wait a little bit if we hit random
result now we can see indeed our random
number is in here and again the reason
that it's in here is because we actually
had two transaction occur one paid by us
when we called get random number and one
paid by the chain link node when it
called fulfill Randomness now I lied to
you a little bit technically that vrf
coordinator contract calls this function
and then the chain link node calls the
vrf coordinator function but for
Simplicity sake you can kind of just
think of it as the chain link node
itself is calling this fulfill
Randomness function so now that we know
how to do this in remix let's go ahead
and add this to our brownie project so
actually before we even do that we need
to require so before we even get a
random number let's change the state of
our lottery so now we'll do Lottery
State
equals Lottery
state. calculating
and while this is happening no other
functions can be called right this will
lock out nobody can start a lottery and
nobody can enter a lottery while we're
calculating the winner awesome so now
that we know a little bit more about
random numbers and everything that we're
doing here let's go ahead and try
implementing this now so in our chain
link smart contract dogs of course we're
going to scroll down we're going to go
to our get a random number bit here we
can copy and paste all this code as well
into our smart contracts so the first
thing that we're going to need to do do
of course is import the brf consumer
base code let's move back over scroll to
the top and we'll just paste this in
chainlink contracts slsrc V 0.6 vrf
consumer base and We'll Inherit this
into our Lottery contract so we'll say
Lottery is vrf consumer
base and it's ownable let's take a look
at this vrf consumer base in the chain
link GitHub here if we scroll down
to the Constructor of our vrf consumer
base we can see it takes these two
parameters the address of the vrf
coordinator and the address of the chain
link token we can use a Constructor we
can use a Constructor of a contract
inherited in our contract inside our
Constructor so what we'll want to do is
we want to come down to our Constructor
and right after this public keyword we
can add any additional Constructors from
inherited smart contracts
so we'll say Constructor and this is our
normal Constructor and then we'll put
the RF consumer
base and we'll add the vrf consumer base
addresses in here we know that it's
going to be a vrf coordinator address
and a link token address similar to the
price feed these two addresses are going
to change based on the blockchain that
we're on so it'll probably make sense
for us to parameter tize them the same
way we parameterz the price feed address
so in our top
level Constructor parameters we'll add
an address for the
vrf
coordinator and we'll pass this to the
Constructor of our vrf consumer base
then we'll also grab an address for the
link token so we'll do
address link and we'll pass this the vrf
consumer based Constructor as well great
what else do we need to make this work
well back in the documentation we can
see we need a fee and a key has the fee
is associated with the link token needed
to pay for this
request so we'll make a public variable
uint 256 public fee since this might
change blockchain to blockchain we'll
have this as an input parameter as well
so we do un 256 undor fee and in our
Constructor
do
Fe equals underscore Fe set our Global
variable to fee I need a Comm here no
what else do we need well we need a key
has the key has is a way to uniquely
identify the chain link VF
node so create another one do bytes 32
public
keyh We'll add this as a parameter in
here
here byes 32
keyh then we'll say keyh equals undor
keyh perfect our contract is coming
along right here now that we have the
main pieces that we need how do we then
request this random number well if we
scroll down in the
documentation we can see we have this
request Randomness function that we need
to call if we scroll back to our vrf
consumer based contract this request
Randomness function is a built-in
function from the vrf consumer base so
our contract can natively call this
request Randomness function right in our
contract and you can see it takes a key
has and a fee as its
parameters so right in our end Lottery
function we can add this function and we
can see this also returns a bytes 32
called request ID this return syntax is
pretty powerful you can actually
identify the name of the variable you
want to return right in your right in
your function declaration so by saying
byes 32 requested we're saying we're
going to return a byes 32 variable named
request ID so right in our function here
we can do request
Randomness because again that's this
function that we're importing passing it
the keyh and the fee this will return a
bytes 32 called request ID so this is
actually doing this and having our
function having our function declaration
tell us that there's going to be a
variable name request ID is going to be
exactly the same as if we did bytes
32 request ID equals request Randomness
now this function call follows again
what we've talked about as the request
and receive mentality the request and
receive architecture this means that in
this first transaction we're going to
request the data from the chain link
Oracle in a second callback transaction
the chain link node is going to return
the data to this contract into another
function called fulfill Randomness so
again if we look back in our vrf
consumer base we can see it has this
function raw fulfill Randomness we can
read some of the comments in here saying
raw fulfill Randomness is called by a
vrf coordinator when it receives a valid
vrf proof raw fulfill Randomness will
then call fulfill Randomness so there's
a little bit of contract tag going on
but it's going to eventually call this
fulfill Randomness function which is
going to be what we Define in here and
that's how our contract is going to know
what to do once it gets the random
number back so in our first transaction
we're going to end the lottery request a
random number and then in a second
transaction later on once the chain link
node has created a provably random
number it's going to call a second
transaction itself based off of what we
Define we just have have to call it
fulfill
Randomness and as you can see takes a by
32 request ID and a random number so in
here we'll do fulfill Randomness takes a
by
32 quest ID and then a u
256
Randomness we don't want anyone else to
be able to call this function we only
want our chain link node to call this
function so we can return a truly random
number so we're going to make this an
internal function
it's internal because actually the chain
link node is calling the vrf coordinator
and then the VF coordinator is calling
our fulfill Randomness so we'll make
this internal so that only the vrf
coordinator can be the one to call and
return this function then we're going to
give it a keyword of override this
override keyword means that we're
overriding the original Declaration of
the fulfill Randomness function our vrf
consumer base has a function fulfill
Randomness defined but it doesn't have
any parameters or anything about this
function actually laid out this function
is meant to be overridden by us and
that's exactly what we're doing right
here so in this fulfill Randomness
function let's go ahead and Define
what's going to happen once we get this
random number back so before we can
process this random number let's just
check to make sure we're even in the
right state so we'll do
require our Lottery state is going to be
equal to Lottery state do
calculating
winner and if we're not in that state
we'll just say
you aren't there
yet my auto format is is on for this one
so it's a it's jumping in then let's
just do another check to make sure we
actually get a response so we'll do
require underscore
Randomness is greater than
zero and if it's not we'll say
random not
found now we need to pick a random
winner well we need to pick a random
winner specifically out of our list of
players our list of payable public
players so our players array is just a
list of players so it's like one player
one player two player three player four
and they're each at a different index
what we can do then to pick a random
winner is to do a called a modulo
function in fact let's even open remix
to do an example of this remix let's pop
open a new contract call it mod. Soul do
pragma solidity carat
0.6.0 do
contract
mod and in here we'll do a
Constructor bline Constructor and we'll
get a global variable went 256 six
number and we'll set it equal to five
we'll go down to
0.6.0 save
compile and you let's even just get rid
of the
Constructor let's now create a function
called dood take a un
256 mod value it's a public
function public view returns
256 and we'll just
return five
modulo mod
value now let's go to JavaScript VM
we'll deploy
this we'll go in here so our number is
right now five and let's learn about how
the modulo works if we have this dood
function what we're
doing is module
divides by the number and returns
Returns the
remainder for example if we did five mod
5 what do you think we're going to get
so we're going to do five divided by
five and then return the remainder well
five divided five is one and there's no
remainder there's no decimal there so
five Mod Five should be what zero
exactly well what's five mod four then
well four can go into five evenly once
but there's one number left over so five
mod four is going to be
one five mod 3 is going to be two five
mod one is going to be zero right since
one goes with everything this is how the
mod function works it's this little
percent here we can use that mod
function in our fulfill Randomness with
the length of our players so we can say
U
256 index of
winner it's going to be equal to the
random number that we
got modded
by the players. length so let's say for
example we had seven players sign up and
our random number is 22 well we want to
get one of these random seven players so
we would do
22 mod 7 7 divides evenly into 22 three
times with one left over 7 * 3 equals
21 difference between 21 and 22 is 1 7 *
4 is 28 so we know this is how we know
we've reached our upper limit so this is
how we can get a random number based off
of the index now that we have this index
what we can do is we can say the winner
equals
players of the index of
winner and just to keep track let's make
a new variable called recent winner at
the
top we'll do
address public recent
winner we'll grab this recent winner
instead of winner we'll say recent
winner equals players and this index of
winner here now that we've got a winner
wallet we want to pay them all the money
gathered from our enters here so what we
can do is we'll do this recent
winner. transfer
the entire balance of this address so
we'll say address of
this
balance and perfect we'll transfer them
everything that we
have then of course we're going to want
to reset the lottery so that we can
start from scratch we can start blank
again so we'll do
players equals new address
payable array size
zero so we're just resetting players to
just be brand new array then we're going
to change our Lottery
state two being Lottery state. closed
because the lottery is now complete and
I often also like to keep track of the
most recent random number so at the
top I'll do a u 256
public Randomness
variable and in our fill Randomness I'll
say Randomness now equals underscore
Randomness and perfect we now have a
contract here of course we haven't
actually tried it out but we're assuming
that it works great so you know what
this means it's time to go into testing
mode testing and development mode but
let's even just try to do a
brownie compile first looks like we have
an issue here send and transfer are only
available for objects of type address
payable not
addresss looks like we made our recent
winner just an address but it needs to
be an address
payable so let's try Brown and compile
again and beautiful we at least know
it's compiling so that's a great sign
let's now move into our testing and
development phase as you are starting to
figure out we can ignore these file
import callback not supported bugs and
Bs code for now I'm sure the solidity
linter will get better as time
progresses but great so now let's go
ahead and move into actually testing and
working with everything here so let's go
ahead into our scripts and we'll make a
little deploy script
first let's do a new
file call it deploy Lottery that pi and
let's go ahead and deploy our lottery so
same as always we'll do def
main we'll come with a new function
called
Ploy
Lottery and then we'll do def
deploy
Lottery then we'll just have a pass R
now and if we run this brownie run
scripts deploy lottery.
piy our default network is not defined
which means the default is going to be
development we can even be verose here
development write that in our brownie
config
run this ganach will get spun
up and nothing will happen because our
deploy Lottery function doesn't do
anything right now awesome first thing
we need always to deploy a contract is
we need an account so we'll do account
equals and we've been using this get
account function for some time that
we've been adding in a helpful script
section so that it can pull from a real
test net or from a local development
environment if we like so to do this of
course let's create our new
helpful
scripts.
Pi create our uncore
init.py so that python recognizes it as
a package and in here we'll create a new
function f get
count now we'll just have it pass we'll
copy
this into our deploy Lottery we'll do
from scripts. helpful Scripts import get
account now
this now this is what our get account
looked like in our last
project along with that we had these
Fork local
environments we also head from brownie
import accounts and network and
config to make this look really nice
right let's flesh this out just a little
bit more so it's even more robust right
now as we know
we have a way to use browny's ganach
accounts and we have a way to
use our environment
variables however there was a third
method that we learned that isn't
identified here accounts. load and this
is with our ID if you still have your
account and you still have all your
brownie set up if we do brownie counts
list you'll see we have a couple
accounts here
we want our get account to be even more
liberal so that if we wanted to use one
of these as well we could so let's
modify our get account script here a
little bit let's first get rid of this
else and rid of this indent what this
will do is this will be our default if
nothing that we Define prior to this is
defined we'll just default to grab right
from our config which since we are doing
that let's create our EnV we'll paste
our different variables in here our
private key web 3 INF fura need to scan
token and in our brownie config of
course do
wallets from
Key private key and now let's flesh this
out a little bit let's add an
index and an
ID index equals
none and
idals this way if we pass an index to
our get account function we'll just use
use an index from this accounts variable
if we pass an ID we'll have trying to do
this accounts. load here so now let's
change this up a little bit we'll say if
an index was passed we just return
accounts on that
index otherwise if we're doing a local
blockchain we'll just return accounts to
zero but if there's an
ID or return
accounts. load
ID whoops we need to actually move this
up a little
bit so that it's before our local
blockchain checking so now in our deploy
Lottery we could do something like get
account ID equals free code
Camp oops and this is actually freecode
account fre code Camp account let's try
one more time it's going to ask for our
password here now we have a much more
liberal get account
function so now that we have a count we
can actually deploy our lottery so we'll
say Lottery equals lottery.
deploy this is where we're going to
import from brownie import our contract
Lottery and we're going to have to add
in all these different variables so if
we go back over to our Lottery contract
we need give it a price feed address a
vrf
coordinator chain link token a fee and a
keyh now the way we did that in fundme
is that we did it in a way where we
checked to see if we were on a local
chain or not if we weren't on a local
chain then we would just pull our
addresses directly from our config if we
weren't on a local chain though we'd
deploy some mocks and use the address of
those mocks we're going to want to do
the same thing here but let's make our
lives a little bit easier we can take
this whole process and put it into its
own function so let's make this a little
bit easier mentally the first thing that
we're going to need is this price feed
address if we're on a real test net of
course we would just go into our brownie
config and add the address which we will
do we'll add our rink
B Network here in a little bit but for
now don't worry about
that but if we're not on a rink be chain
what we're going to need to do is deploy
our mock we're going to wrap all of this
mocking and and checking into a single
function called get
contract and we're going to add this
function in our helpful
scripts so let's create this function
called get Contract do def get
Contract
pass let's talk a little bit about what
we want this function to do let's add
one two
three three double quotes here and three
double quotes here to start what's
called a doc string this will Define
everything about this contract so we're
just going to say this
function
will grab the contract
addresses from the brownie
config if
defined
otherwise it will deploy a mock
version of that
contract and return that mock contract
for the arguments of this chain we're
going to take a contract
name this is going to be a string and
it'll
return a contract or in particular it's
going to return a brownie. network.
contract.
project contract the most recently
deployed version of this
contract so for example if we have a
mock V3 aggregator
contract it'll do the most recently
deployed version of that this minus one
syntax now this get Contract function if
this is a little confusing to you again
we're going to go over this chain link
mix in a little bit and inside of this
it has a more
robust description of what's going on in
this get Contract bit so you can check
that out if you want to learn more but
let's go ahead and actually Define this
so we obviously want a contract name as
an input parameter so let's go ahead and
add contract name in here meaning that
this get Contract function will get
something like
FUSD price feed right that's going to be
the same as what's defined in our
Browning config and from this name we're
going to get the type of contract that
it is contract type to do that we're
going to have to create some mapping
that'll map the contract names to their
type so right above we're going to do
contract to mock
and we're going to create a mapping in
here which will map everything out so an
FUSD price feed is going to be of type
Mach V3
aggregator so we have to import Mach V3
aggregator from browny so now we're
saying anytime you see FUSD price feed
you know that that's going to be a Mach
V3 aggregator if we need to deploy a mo
so we'll say contract type is going to
equal contract to
mock of the contract
name now we need to check okay do we
actually even need to deploy a mock so
sure let's check if we're on a local
blockchain so we'll say if network. show
active is
in our local blockchain
environments and we'll skip the fork
local environments because again we
don't need to deploy a mock price feed
address on a fourth local environment
which say if network. show active is in
the local blockchain
environments then we'll check to see if
one of these contracts has already been
deployed say if the
length contract
type it's less than or equal to zero
then we're going to go ahead and deploy
MOX so this is equivalent to
doing something like mock
B3
aggregator length we're checking how
many mock V3 aggregators have actually
been deployed if none have been deployed
we're going to go ahead and deploy them
so we're going to have to create this
deploy MOX function so we'll do def
deploy Mox and this is going to be the
same as what we
did in our brownie fundme right it's
going to be the exact same so we'll say
count equals get a count
I'm not going to put the prints in here
but you absolutely can say mock price
feed equals mock B3
[Music]
aggregator
deploy we'll need to give this some
decimals and an initial value so right
above we'll do
decimals equals 8
initial value equals
2,000 2000 2 four five six seven
eight and then our deploy Marx we'll say
decimals equals
decimals initial value equals initial
value deploy decimals
and initial value of course it's going
to be from count and for now that's it
say print deployed
all right great so now we have a way to
actually deploy the mock price feed here
so let's go back up to our get Contract
function so we have a way to deploy the
mock if one already isn't deployed now
what we're going to want to do is we're
want to get that contract right we're
going to want to get that mock so we'll
say contract equals contract type minus
one right so this is going to be equal
to doing mock V3 a
Gregor minus one this is saying hey
let's grab the most recent deployment of
the mock V3 aggregator which is exactly
what we want perfect so this will work
perfectly for our development context
however we're not always going to just
want to deploy to a development Network
we're also going to want to deploy to
test Nets so then we'll say else and
this is where we'll just grab that
contract from the rning config for
example at us price feed so we'll say
contract address equals
config
networks network. show
active and that contract
name for example again if it's ethusd
priz feed it'll be ethusd priz feed here
and the way we're setting it up it's got
to be the same as what's in our contract
to mock dictionary here so up here the
way that we did it was we actually got
the contract because we had its contract
type based off of brownie for here we're
going to have to interact with the
contract getting those two pieces that
we always need which are going to be the
address we actually have the ABI from
our Mach V3 aggregator type right here
and we just got the address so we can
create this new contract type by saying
contract equals
contract. from ABI and this contract
package can be imported right from
Brownie and and has this function from
ABI that allows us to get a contract
from its ABI and its address so we'll
just give it a name say contract typeor
name you do the contract
address and
then contract type.
AI so these mock V3 aggregators and all
these contracts have
aavi attribute that Returns the AI they
also have aore name which returns their
name so this is perfect this is how
we'll get the contract otherwise and
then at the end of all this we'll just
do
return contract awesome so this is an
incredibly powerful function for us to
get a contract based off of if it's
already deployed as a mock or it's a
real true contract I know there's kind
of a lot here but definitely check the
GitHub repository if you're a little bit
confused on what's going on with this
function and let's and let's also just
deploy this to make our lter happy why
not yays code's happy now but now that
we have this function let's go back to
our deploy Lottery now we can do a comma
get account now we have a get account
function so let's go through this again
this lottery. deploy get account is
going to get an FUSD price feed if we
don't have a mock deployed it's going to
deploy a mock price feed for us and
we're going to return that mock price
feed however if we're on a test net if
we're on a real Network we're going to
grab its actual address and return mock
contract of it our mock contract here
has all the same functions of a regular
contract so we can just use it as the
same this way we don't have to adjust
this function for whether or not we're
deploying to a test net or to an actual
address the only additional piece we
should put in here just for clarity so
we should add address here because this
is going to return the actual contract
and we really only want the address this
is going to make our coding a lot more
robust for moving between development
environments and test environments and
working with scripts in a really
effective manner so now that we have
this incredibly powerful function let's
go back to the lottery and figure out
what are the different pieces we need in
here okay great we also need a vrf
coordinator so to do this we're going to
go back to our docs. chain. link we'll
go to contract addresses and we could do
main net here but let's also just set
this up to work with rink B so we do
crlf for rink B vrf coordinator is going
to be this address right here so we'll
copy it we'll go back and we're going to
have to do in our config is we're going
to have to add a new network here for
rank B do vrf
coordinator will be that address right
there and then while we're doing this
let's also get the rink B address for
our price feed so price feeds rink be
scroll down for
FUSD FUSD here we go grab that enter
this will be FUSD price
feed paste that in here perfect so now
we can do get Contract vrf coordinator.
address of course we are going to have
to go back to our helpful scripts
because there's currently no mapping
between what a vrf coordinator is and
what its mock needs to be so we'll add a
comma
here and we'll do VF
coordinator and we need to get a mock VF
coordinator well first of all we don't
even have our mock V3 aggregator so
let's go grab that as well so we can
grab both of these again I'm going to
highly recommend going to the chain link
mix going into the contracts here going
to the test folder for these different
mocks because these are already set up
to work with the chain link mix however
you can definitely go into the chain
link help as well go to contracts SRC
0.6
tests and then look for the different
mocks in here so mock Oracle VF
coordinator mock Etc so we're just going
to I'm just going to grab it though from
this chain link mix so let's go to vrf
coordinator Mock and I'm just going to
grab this whole thing here so do
contracts folder
test file VF
for for
mock
Soul paste it in
here and then while we're in here we'll
want to do a new file mock D3
aor
s we'll grab this as
well from our train
mix again it's got all the functions of
a price feed update
answer latest round Etc VF coordinator
walk has different functions for
actually working with the VF coordinator
one of the specific ones in particular
is this call back with Randomness that
we're going to use in our tests so our
vrf coordinator is going to get mapped
to our vrf for theor
mock which will also import this from
bring great and just to double check
everything's working we'll want to run
over just a quick bring compile
make sure we are importing our mocks
correctly and everything's compiling so
it looks like we're good there all right
so now we
have get Contract Bure of coordinator.
address perfect what else do we need in
here we need a link token the chain link
token is of course just another smart
contract so we're going to do the exact
same thing here get
Contract link
token. address
of course this
means in our
config for rink B let's add a link token
address we'll go to the chain link
documentation go to link token
contracts we'll look for rink
B we'll grab this
address we'll drop it in here perfect
now we have it in our brownie config
we'll also need to add it to
our helpful
scripts so we'll
need a mock link token which again we
can just go ahead and
grab from our chain link mix here we go
to test and as you can probably see what
I often normally do is literally just
copy this entire test folder project to
project so I'm going to copy this whole
thing create a new file we're just going
to call this
one link token.
Soul contract link token perfect and
then in our helpful scripts we're going
to have this be link
token and of course we're going to
import this from
BR great get Contract link token.
address perfect what else do we need we
need a fee and a keyh so the fee and the
keyh are both just numbers right these
are aren't actually contracts so we
don't need to put this through that get
Contract bit what we can do is just in
our
config in our development Network we can
just add a default for the key has and
for the
fee I'm just going to set my development
keyh and fee equal to the rinky ones so
to grab
those we go to the chain link dogs once
again we'll scroll down to using
Randomness contract
addresses we look up rink
B grab the key hash
here which we'll paste in for
both our
development and rink
B and then the fee it says 0.1 link so
we'll just do that in way here which
will be one 1 2 3 4 5 six seven 8 nine
10 1 2 3 four five six
seven we'll do this line for ring v as
well now in our deploy Lottery we can
just grab this directly from our
Browning config because we're always
just going to have this default keyh and
this default fee here for our
development Network so we'll do
config
networks network. show active
which ones first the
fee
fee of course this means we're gonna
have to grab network from
Brownie and also
config then we'll do
config
networks network. show active
and then of course our last bit
here
from
account and then additionally as we
learned last time if we want to publish
this do publish
Source equals
config
networks network. show active
say
doget
verify and then we'll add this false bit
here what this is saying is get that
verify key but if there's no verify key
there just default to false this way if
we don't set a verify key in development
that's fine it just won't get to verify
the rink B let's go ahead and said
verify true so we can actually verify
this on the rink B chain and then we'll
even do a print statement
here floyed
Lottery all right lovely let's try this
out we'll do brownie run
scripts deploy lottery. we won't set a
network flag so it'll go to the default
development Network let's try this
out things are compiling ganach is
spinning up it looks like we did run
into a little issue here with our our
get Contract function ah of course we
forgot to add deploying these mocks in
our deploy mock script whoops let's go
ahead and add that as well right now our
deploy mocks only deploys the mock V3
aggregator so let's add the rest of our
mocks in
here we're going to need to deploy a vrf
coordinator Mock and a chain link token
model so let's open up those contracts
see what they need the link token for a
Constructor doesn't have a Constructor
so we can just have it be blank so we'll
do link
token.
deploy and all we need is a
from account
here and then let's see what that vrf
coordinator mock takes VF coordinator
mock it takes the link token as an
address
perfect so then when we deploy the link
token here we'll say link token equals
link token. deploy and then we'll do
VF for dor
mock deploy
deoy and then we'll use the link token.
address it's an input parameter and then
of course
from count all right so now we're
deploying all three of those mocks right
away let's try this again Ry run scripts
deploy lottery.
py gach SP up perfect so we can see here
that our mock V3 aggregator was deployed
then our mock link token was deployed
then our mock vrf coordinator was
deployed and then our Lottery was
deployed with those mocks to finded and
we deployed the lottery awesome now we
could
100% go ahead and then run this script
on an actual test right because our
config is set up well let's write some
more functionality for actually
interacting with this Lottery before we
actually do that and then we can
actually just run a script which will do
all this functionality end to end
because again deploying to a test net
takes a long time and we really only
want to do that when we're done and
we're fairly confident that everything's
working well let's even just delete this
here so now what's the next thing that
we'd want to do here what's the next
thing we want to do in a script here
well we' probably want to go ahead and
start the lot so let's write a script
that can actually do that do
def start Lottery
and in here we get our account let's get
account we say the lottery is going to
be the most recent deployment of the
lottery and we're going to call this
start Lottery function here this is
indeed Changing State so we do have to
make a transaction do Lottery let's
start
Lottery say
from count
then we'll do a little print and just
say Lottery is
started and then in our main function
down here we can even call this start
Lottery
function so if we run this again on our
development
chain we'll see if everything works
smoothly here okay we did run into an
issue and this is something that you'll
see from time to time typically the
workaround is you want to wait for that
last transaction to actually go through
so we'll say starting transaction equals
lottery. start Lottery will do starting
transaction. wait one browny sometimes
gets a little confused if you don't wait
for the last transaction to go through
so let's try it again and perfect we do
get this working uh as intended so that
is a really helpful helpful tip if you
run into those weird issues you'll
notice that even when we didn't have
this it's still completed successfully
uh it just got a little confused at the
end all right cool so what do we want to
do next well we probably want to enter
the lottery let's do Dev
enter lottery so how do we enter the
lottery say account equals get
account Lottery is going to be
Lottery minus one we need to pick some
value to send when we call the enter
function right because we need to send
that entrance fee with it so we'll say
value equals lottery. getet entrance fee
and just to be safe I usually will tack
on a little bit of whey as well because
sometimes it might be off by like one or
two or something like that so we'll do
lottery. get entrance fee plus you know
maybe something like this which is like
barely anything then we'll do
transaction equals lottery. enter do
from
account send a value which will be
valume
we'll do tx. weight and then we'll do
print you entered the
lottery and we'll do this enter Lottery
bit down here too enter
Lottery we'll run this see if our enter
script is working
appropriately you entered the lottery
looks great and let's do our last
function here we'll do def end Lottery
count equals get
account Lottery equals Lottery minus one
we'll make a transaction which will be
lottery. end
Lottery now before we actually end this
Lottery we're going to need some link
token in this
contract remember our end Lottery
function calls this request Randomness
function and we can only request some
Randomness if our contract has some
chain link token associated with it so
we're going to need to First fund the
contract and then end the lottery since
funding our contracts with the link
token is going to be a pretty common
function that we use let's go ahead and
turn this also into a helpful script so
let's go to our helpful scripts we'll
make a new function called fund with
link and let's have this take a couple
of parameters so first we want to have a
contract address of course we'll want to
know who we're going to fund with link
we'll set an a default account to being
none so if you want you can send an
account but you don't have to if you
don't want to we'll also do the same
thing with a link token we'll say if you
want to use a specific link token you
can otherwise we'll just grab it
ourselves and then we'll also do a
default amount which will set to one 1 2
3 four 5 six seven eight nine 10 1 2 3
four five six seven
which is going to be 0.1 link so first
let's get an account we'll say account
equals we're going to do a little clever
python stuff here we'll say account
equals the account if somebody sent it
if account so we're saying the account
that we use is going to be this account
thing if this account thing even exists
otherwise we'll call our get account
otherwise we'll just do our regular get
account function then we'll do the same
thing with the link token say the link
token is going to be equal to the link
token that somebody supplies as a
parameter if they applied something as a
parameter otherwise we'll just do that
get Contract stuff that we did before of
the link
token now that we have this link token
contract from our get Contract function
which again is basically the equivalent
of doing which again is doing this
contract from ABI on our link
token pulling from our config or from
our mock now we can just call the
functions on this link token so we'll
get say our transaction equals link
token.
transfer we're going to transfer token
to contract
address with certain amount and of
course we'll do
from
count do tx. we
and then we'll do
print funded
contract then we'll even return that
transaction I do however want to show
you another way to work with this using
the interfaces instead of doing this
link token. transfer directly on the
contract we can use this interfaces
section to actually interact with some
contracts so right now we have our mock
link token in here which is great
because it has all the definitions and
all the functionalities defined in here
sometimes you're going to have contracts
that you don't have everything you don't
have all the functionality and maybe you
only have the interface maybe you only
have some of the function definitions so
we can still interact with contracts
with just an interface because again
that interface will compile down to our
AI so as another way of teaching us how
to actually work with some of these
contracts what we can do is we can use
we can use the link token interface
basically the same way as we use the
link token contract here so again I'm in
my chain link mix because there's
already a link token interface in here
and this will compile down to a way that
our brownie package knows how to
interact with these contracts so if you
wanted to we could just grab this go to
our brownie section we'll do a new file
in
interfaces we'll call it link token
interface. soul we'll paste it in here
save my auto format Auto formatted here
and what we can do our helpful scripts
instead transaction equals
interface we can also just import
interfaces right from brownie
interface dot link token
interface and we just need to give it a
contract address so we can say
link token.
address excuse me we can say link token
contract was interface. link token
interface link token. address so this is
another way we can actually create
contracts to actually interact with them
so we saw up here this contract. from
ABI which is great this is another way
we can do that exact same thing so then
we can just do link token contract.
transfer contract address
amount
from count
so this TX equals so this is another way
to actually interact with contracts that
already exists you're probably starting
to see that brownie has a lot of
built-in tools that make it really easy
for us to interact with contracts if we
have the ABI we can just pop it into
contract. from ABI and again with the
address and the ABI and then just give
it some name if we have the interface we
don't even need to compile down to the
AI ourselves because brownie is smart
enough to know that it can compile down
to the AI itself and we could just work
directly with that interface which is
incredibly powerful for now I'm going to
comment these two lines though and we'll
just use the link token. transfer for
now now that we have a funding script or
a funding function we can import this
from our helpful scripts from scripts.
helpful scripts import get account get
Contract fund with
link and we can just call in our end
Lottery function we'll do fund with link
and parameters we just we only really
need a contract address because the way
we set this up will just automatically
grab a default otherwise so we can say
lottery.
address that's it that's all we need and
then I know we're doing tx. weight right
in the fund with link but just for to be
rebose here we'll get the transaction
from the fund with link and we'll do tx.
we here as
well then once we're funded with link
then we can go ahead and call all end
Lottery function because again this is
going to call that request Randomness
function from the chin bef we'll do end
ending
transaction equals lottery. end
Lottery and all we have to do is
from
count to
ending transaction. weight
one so from our end this is really all
that we need to do right but remember
when we call this end Lottery function
we're going to make a request to a chain
link node and that chain link node is
going to respond by calling this fulfill
Randomness function so we actually have
to wait for that chain link node to
finish now typically it's within a few
blocks so normally what we can do is we
can just do a Time dos
sleep for something like 60 seconds and
typically in that time the chain lck
node will have responded so we'll just
do import
time top time. sleep and then we can see
who that recent winner is if that chain
link node responded with a recent winner
so we can say print
F Lottery a recent
winner is the new
winner all right now of course for those
of you who are thinking ahead a little
bit you might be thinking hey well
there's no chain link nodes watching our
local ganache and you're exactly correct
so what happens when we add our end
Lottery
function to our main function here do
you think that we're going to actually
get a recent winner back why are we not
what do you actually think well let's
give it a shot do brownie run scripts
employ lottery
depy so we're doing a lot of
transactions here we've started the
lottery we're entering ing the lottery
you entered the lottery we're sending
some link token now we just called the
end Lottery function while we're waiting
here this is when the chain link node
would go ahead and start responding with
our Randomness however as you're
probably astutely telling however as you
probably astutely guessed there's no
chain link node that's going to call
this fulfill Randomness function right
now so for our ganache chain this will
hypothetically end with nothing right
there's no chain link node actually
responding zero is the new winner of
course this means that the chain link
node actually didn't respond because
there is no chain link node on our local
ganache for our testing purposes we're
going to figure out how to actually get
around that and deal with that awesome
it looks like we have everything set up
to be successful in our Lottery here but
we want to do our due diligence we want
to make sure that our tests are really
solid on a development chain before we
actually test this on an actual test net
so let's jump into some of these tests
we've already started with this test
lottery. piy bit here but we're going to
iterate on this and make this even
better now before we get into these
tests there's a couple things we want to
talk about here and that's going to be
integration tests and unit tests unit
test is a way of testing the smallest
pieces of code in an isolated system and
we're going to use it to Loosely Define
testing independent functions in our
Lottery cont we also want to do what's
called integration testing which is
going to be testing across multiple
complex pieces typically I like to run
my unit tests exclusively on a
development environment and my
integration tests on a test net this is
really helpful because we can test the
majority of our application like we said
on a development Network and then still
be able to see what actually happens on
a real testet and see what happens on
ether scan and everything like that
typically what people do is INS side
their test folder they'll create two
different folders one for
unit and another folder for in
creation since for this demo we're only
going to have one file for both I'm just
going to go ahead and not create this
folders
but but it's a pretty common
practice instead what I'm going to do is
I'm going to rename this I'm going to
hit enter to renamed it and do
underscore type
unit for unit test and we're going to
create a new file called test lottery
integration. so this this one we'll do
our integration tests and in this one
we'll do our unit tests now when writing
unit tests we really want to test
hypothetically every single line of code
in our smart contract this is incredibly
important of course because smart
contracts are open to everybody to see
and interact with so we really want to
test every single line of code we have
in here so let's go ahead and let's go
ahead and finish writing a get entrance
fee test that will work on a local
development Network as you can see we're
already going to have to re Factor this
from what we originally had let's go
ahead and just delete everything under
here for now we already learned so much
more from there all right so how are we
going to test this get entrance view
function now so first we're going to
want to deploy our Lottery again since
we
have a deploy Lottery script already we
can just use this deployed Lottery
script as well if we wanted to we could
just copy paste this whole part into our
test but we're just going to go ahead
and work from this deploy Lottery script
so we're going to import this and then
we can actually even get rid of this
from web three line for now we can get
rid of these two comments too and we'll
say from scripts. deploy
Lottery
import
deploy Lottery and this deploy Lottery
function would say Lottery equals deploy
Lottery and we will return our Lottery
now on a unit test we'll say Lottery
equals deploy
Lottery and this will give us our
Lottery contract once we have our
Lottery contract we can just call this
get entrance fee so we can say entrance
fee equals lottery. getet entrance
fee and oops let's just make sure we're
doing the
rrange
ACT certainer mentality here and we're
going to want to make sure this entrance
fee is what we expected to be so what do
we expect it to be well again our
helpful scripts is going to deploy these
mocks right it's going to deploy this
Mock and the initial value is this 2,000
number so if the
price of e here is
2,000 $2,000 FUSD feed and the
USD entry fee is 50 we' say 2,00 over 1
is equal to 50
X which is going to be equal to
0.025 so we can go ahead and even do
this math
here we can say
expected expected entrance
fee is going to be equal to it's going
to be equal to 50 divided 2,000 we'll
just do
0.025 but we'll do this in way do from
web 3 support web
3 say this is web
3.2 way 0.25 ether and now we'll assert
our expected entrance fee
equals the entrance fee now to test this
we'll do browny test-
K and perfect this is working exactly as
we anticipated so that's awesome now as
we mentioned since this is a unit test
we really only want to run this when
we're working on a local environment a
local blockchain environment or a local
development Network so we'll go ahead
and do this with pest again say if
network. show active is not in local
blockchain
environments pest. skip of course we're
going to have to import
pest we're gonna have to import this
local blockchain environments from our
scripts. helpful scripts my vs code
automatically added that bit here now
now if we try to run this brownie run
EXC brownie test
DK get entrance Fe Das Dash Network rink
B rink EB it should go ahead and skip
this perfect that's what it does what's
the next piece that makes sense here
enter is going to be one of the first
things that these developers do so let's
do test def test enter but let's even be
more specific than that we don't want
people to be able to enter our lotteries
unless the lottery is actually started
so let's make sure that this line
actually works so we'll call def test
can't enter unless started and again
we're only going to run this on a local
development chain so we'll just copy
paste this section down here we'll say
Lottery
equals Ploy Lottery because we're going
to want to work with the lottery and now
we're going to want to that when people
try to enter a lottery that hasn't
started yet it's going to revert so we
can use what we've used before we'll say
with py test.
raises
exceptions. virtual machine
error lottery.
enter
from get
account
value L.G get entrance
fee of course we're going to have to
import both get a
count from our helpful
scripts and exceptions from
brownie perfect and this as well is
following the
arrange this is actually act
slash
assert so let's go ahead and test
this brownie test- K test can't enter
unless
starters let's do start
Ed and great that's passing as well
let's go ahead and keep going down this
list what else now that we've tested
whether or not they can't enter Let's
test whether or not they can enter so
we'll do def test can start and
enter
lottery so we're going to copy this
again paste it down here since we're
going to work on a local blockchain do
Lottery equals
deploy Lottery
account equals get account we'll start
the lottery lottery. start
starty do
from
count do lottery.
enter from
count say value is
lottery. getet entrance fee
and then we'll
assert that we've correctly added a
player to this lottery so we'll assert
lottery.
players of zero it's going to be this
account right because we have our
players array and we're going to assert
that we're pushing them onto our array
correctly lottery. players zero equals
account so here's our Act
here is our assert so let's try this now
browny test- K test can start and enter
Lottery and once again awesome things
are looking great now let's test to see
if we can actually end a lottery so
we've tested we can start a lottery so
we'll do Dev test can end Lottery we're
going to copy this again paste it down
here do Lottery equals deploy
Lottery count equals get
account start the lottery lottery. start
Lottery now we could 100% just import
the rest of these functions in here like
end Lottery enter Lottery and start
Lottery it's similar to how we're just
doing Lottery was deploy Lottery we
could absolutely do that for being very
verbose here I'm just going to go ahead
and and write all the functions and
transactions myself and this way we'll
actually be able to test a little bit
more granularly
anyways do Lottery dot start
Lottery
from
count do lottery.
enter
from count we'll give it a
value lottery. get entrance
fee I'm going to have to do account
of course equals get
account now to actually end the lottery
we do need to send this some link
because we're calling request Randomness
we use our fund with link script that we
have and our helpful
scripts we'll import this from our
helpful
scripts we'll call fund with link on our
Lottery
contract once we fund with link we'll
then call lot lottery. end
Lottery from
count and then how do we actually
know that this is being called correctly
well if we look back in our Lottery
contract here when we call end Lottery
we don't we're not really doing a whole
lot all we're doing is changing our
state so let's go ahead and check to see
if our calculating winner state is
different so we'll say assert lot of
dot Lottery
state is equal to what so calculating
winner if we scroll to our enum is in
position two open is zero close is one
calculating winner is two so we can say
cert lottery. Lottery State equals to
two we can go ahead and test this as
well do brownie test- K test can end
Lottery
see if this
works and it does now let's test the
most interesting piece of this entire
Lottery contract we're going to test
whether or not our fulfill function
actually works correctly does this
correctly choose a winner does it
correctly pay the winner and does it
correctly reset so let's go ahead and
build our most complicated and most
important test of this whole contract
choosing the winner do
def test can pick winner
correctly let's copy paste this
bit about getting
started do Lottery
equals employ
Lottery count equals get
account we'll do lottery. start
Lottery
from C
and then we'll enter with a couple
different players do lottery.
enter let's say
from
count
value lottery. getet entrance
fee
enter and we'll copy this two more times
but instead
we use some different IDs do index
equals
1 we'll do index equals 2 these are
going to be different accounts here
because we're going to use a different
index because we want to just test for
multiple different people here this unit
test is getting drastically close to
being an integration test but as I said
we're being a little bit loose with the
definitions here now we're going to want
to fund it with link so we can just go
ahead and copy this line here fund with
link Lottery and now we're going to want
to choose a winner here and this is
where we actually have to modify one
more thing in our Lottery contract so in
order to test actually calling this
fulfill Randomness function and testing
everything in here we're going to need
to call this fulfill Randomness
function now if we look at our vrf
coordinator mock we have this function
called call back with
Randomness and this is the function that
actually calls this fulfill Randomness
do selector which eventually will call
that fulfill Randomness function but
this is the entry point that the that
the node actually calls we have to
pretend to be a chain link node and call
this function we're going to return a
random number of course we're going to
choose the contract we want to return to
but we also have to pass the original
request ID associated with the original
call now in our Lottery contract our end
Lottery function isn't going to return
anything and even if it did it would be
really difficult for us to get that
return type in our python so what we
want to do to keep track of when this
contract actually entered the
calculating winner state is we want to
do what's called emitting an event
events are pieces of data executed in
the blockchain and stored in the
blockchain but are not accessible by any
smart contracts you can kind of think of
them as the print lines of a blockchain
or the print statements of a
blockchain we can go to this log section
which also includes all the different
events now there's a lot of information
here so we're actually going to do an
event ourself just so that we can see
what this really looks like you can see
here that when we call this end Lottery
function in the logs if we scroll to the
bottom there's an event here called
Randomness request this was spit out by
the vrf coordinator this was spit out by
the vrf consumer base that we inherited
and it even has some data that's already
been decoded one of those pieces of data
is the request ID now to add an event we
first need to create our event type so
at the top we'll go ahead and do event
requested random
s say bytes
32 request ID so now we've identified a
new type of event called requested
Randomness it's really similar to the
enum in this regard to emit one of these
events all we have to do in our end
Lottery bid is we'll do emit requested
Randomness and then request ID because
requested Randomness takes a byes 32
as an input parameter and we're going to
pass it that request ID as an input
parameter now that we have this event
being emitted back in our test when we
call end Lottery it will actually emit
one of these events to our
transaction so what we can say then is
transaction equals lottery. end
Lottery same way we've always done
it but now we can look inside this
transaction object inside of this
transaction object is actually an
attribute called
events which stores all of our events we
can then look for certain event name
which we know is requested Randomness so
we'll say out of all the events look for
the requested Randomness
event and in there in that requested
Randomness
event find the request
ID request ID
now we can say request
IDC me request
ID is going to get grabbed from this
event that we emit so these events are
going to be really helpful for writing
tests these events are also really
helpful for a number of other reasons
one of the big ones is is upgrading our
smart contracts or understanding when a
mapping is updated but for now we're
going to be using them for testing now
that we have this request ID what we can
do is pretend to be the chain link node
and use this call back with Randomness
function to dummy getting a random
number back from the chain link node so
what we're going to do is we're going to
call our get Contract
function and get that vrf coordinator of
course we're going to have to import it
from our helpful scripts and we're going
to call that call back with Randomness
function so we're going to do dot call
back
with
Randomness and we need to pass
it this request ID a random number and
then the contract to return to so we'll
do request ID we'll do some random
number like we'll say
static RNG equals
777 so we'll say the random number that
we're going to return is going to be
777 and then we'll do lottery. address
we're going to return it to the
lottery once again we're going to say
from count because this is making a
state change and now that we've got a
call back what we can do is do our
asserts now so this is us dummying
getting a response from a chain Lake
node and this is how we mock responses
in our tests to make our lives way way
easier so now we can do we can figure
out who the winner of this Lottery
actually is these are our three enter
entries
that means it's
777 mod 3 since our random number is
going to be 777 if we call out a
calculator
777 / 3 it divides evenly so we know
that this means the answer to this is
going to be zero AKA our account is
going to be the winner so let's assert
the lottery do recent winner is going to
be equal to our account
right because we set a recent
winner in here we transfer them some
money we'll assert lottery.
balance is now zero because we're
transferring this account all of the
money and let's even make sure that the
account gets more money right so we'll
do starting balance of our account
starting balance of account
equals count. balance count. balance and
we'll do
balance
of Lottery equals lottery. balance and
then we'll assert account. balance is
now going to be these two added together
started balance of account
plus the balance of the
lottery because we should get all of the
lottery winnings here
okay so this is a long test but this is
probably the most important test let's
make sure this is doing what we want it
to do do brownie test- K test can pick
winner correctly let's see if this works
oops forgot to put
a a parentheses here parentheses here
let's try this again and perfect we are
actually updating paying out and running
our Lottery correctly and fair
with true Randomness this is incredibly
exciting and we've admitted events in
our Lottery contract to use in the
offchain event logging of ethereum I
know we're getting ansy to actually run
this on a real chain so let's go ahead
and do our last bit here create our
integration test which we will run on an
actual chain and then if we wanted to we
go ahead and try our deploy Lottery
function on a real chain as well all
right so let's do our integration test
here this is where we're going to
actually test on a real live chain we're
going to use ring be because that's the
network that we've been using this whole
time which is great now I'm being a
little bit liberal in the way that we're
doing our tests here and we're just
going to do one test for this
integration test but keep in mind you're
going to want to test every piece of
your code so let's just create a test
called def test can pick
winner now this is going to be the
opposite of our unit tests our unit
tests are only going to be on our local
blockchains right we're going to skip if
it's not on our local blockchains we're
going to do the opposite of this one so
we can even just copy this or we can
type it out we say if our
Network that's show
active is in those
local blockchain
environments then we're going to do p
test
skip of course since we're grabbing
these pieces we're going to do from
browny
import
Network we're going to import P test and
we're going to do from scripts dot
helpful
scripts
import
local blockchain and
by we're going to deploy our lottery so
Lottery equals deploy
Lottery which we're just going to grab
from
scripts deploy
Lottery support
deploy
Lottery do count equals get
account of course we're going to grab
that from our helpful scripts as
well so we'll do
Lottery that's start Lottery
this will be
from
account do lottery.
enter say this will be
from
count we'll do some value which is going
to be
lottery. getet entrance
fee and if we run into an issue here
sometimes again we can do lottery. a get
entrance fee plus like 100 or a th000 or
something like that this is going to be
barely any way but for now let's keep it
like this then let's just copy this
line run it again we'll have two people
enter the lottery of course it's going
to be us both times and great now we're
going to want to actually end the
lottery so first we're going to want to
fund it so let's import that funding
script so we get fund with link or that
function so we'll call our fund with
link function on our Lottery contract
here
and then we'll go ahead and end the
lottery so we'll say
Lottery do end
Lottery we have to do this from our main
account this from the admin account now
this is where it's going to be a little
bit different from our integration
tests or from our unit test in our unit
tests we pretended that we were the vrf
coordinator and we called the call back
with Randomness we pretended that we
were a chain link node here we're not a
chain link node because we're on an
actual Network so we're actually just
going to wait for that chain link node
to respond so for Simplicity we'll just
do time. sleep we'll wait like a minute
for it to respond of course since we're
using
time we're going to want to import time
the top and then since account was the
only one to actually be in this we do
insert
Lottery recent
winner equals equals
count and we'll also assert lottery.
balance is equal zero all right great so
we have an integration test that we can
run which is going to run through pretty
much the vast majority of our
functionality here so we can go ahead
and test this with
brownie test will be a little bit
verbose here we'll say- K test can pick
winner and then of course we'll do das
Das Network rink feed now before we run
this per usual we got to make sure do we
have any test net rink the ethereum we
do great do we have any test net chain
link we do perfect we have a
EnV we do it's got all all of our pieces
let's check our brownie
config envv awesome and again if you
don't want to use the EnV you can use
that other method that we showed you
guys how to encrypt with a password that
you can abolutely
use before we run this set this to start
Lottery because that's the actual
function here and we'll also need to be
lottery. balance parentheses here sorry
that now we can run brownie test
DK test can pick winner D- Network R
we'll also add this- s flag which will
print out whatever brownie is going to
be printing out we make everything a
little bit more your Bose here and if
you want to you absolutely should
because this is something that we'll
have to do at some point anyways however
if for this tutorial you want to skip it
go ahead because we're actually going to
run through this whole process of
deploying and waiting again anyway so
now we've added all of our tests what we
can do is run our entire test Suite so
we'll do brownie test and this is going
to run through all of our development
tests here see it'll go really quickly
you see how much faster it is for us to
run our test on a local chain as opposed
to doing everything on a test now so
it's going to make your life way easier
and we have everything passed here so we
know that our contract code is doing
approximately what we want to do
so it's time for the moment of truth
let's deploy this to an actual test net
so we have our deploy Lottery script
which oftentimes I'll have it be just
this deploy Lottery bit and then I'll
have some other scripts for these other
pieces or maybe I'll do it in the proudy
console but just to demonstrate
everything end to end we'll have deploy
Lottery start Lottery enter Lottery and
end Lottery All in This one script so
that we can see everything end to end
and see what it looks like on ether scan
so let's go ahead and run this script on
a rink be Network and then we'll go jump
onto ether scan and see everything so
let's do it browny run scripts deploy
Lottery Network
Rinke so first we went ahead and we
deployed our Lottery we got our
addresses with our get Contract method
we got our fee we got our keyh we got
our published source and everything then
we went ahead and verified it because of
this published source so if we grab this
address Lottery deployed here we jump
over to Rinky ether
scan paste this address in here we'll
see this contract with a little check
mark is verified and again we'll go to
the read contract we can see all the
public variables and all the public
functions we can go to right contract
and we'll see all the transacting
functions that we can interact with
after we get verified and things get
deployed we went ahead and called our
start Lottery function to actually start
the lottery got a little print line
saying the lottery started then we
entered you entered the lottery we then
funded the contract with link so that we
could get our random winner back and
then right now our end Lottery is
confirmed we're just waiting this 60
seconds right because we did this time.
sleep and if we sit on this contract if
we go to transactions and we refresh we
can actually see some of these different
method calls over you can see we did a
contract creation we started the lottery
we entered the lottery and then we
recently ended the lottery and you'll
see in our script here it says 0x blah
blah blah is the new winner which is
perfect right that means that the chain
lck node actually responded we can
actually verify that by looking in the
contract we'll go to read contract we
can go to the recent win and see
somebody did indeed recently win we can
also go to events and we can see some of
the events that we created you can see
this first event right here is this
requested Randomness event this is the
event that we called we have this end
Lottery here you can also see an
ownership transferred function that go
call this was called when we actually
deployed this in the first place now a
little bit more on these events AKA
these logs right so topic zero this hash
represents this entire event right here
in this bit is going to be our topic one
our first topic which represents that
request ID so this is going to be the
request ID awesome we have successfully
created a working smart contract Lottery
with true provable Randomness this is
absolutely insane incredible job here
now one additional piece that I want to
talk about before we jump off here is
again in our testing a file that you're
often going to see what's called conf
test
Pi python automatically knows to look
for this comp test file and we'll grab
different functions from it we can also
add external plugins fixtures hooks
testing root path it adds a lot of
really fantastic features and is a
common thing that you'll see we skipped
over in here for Simplicity but in
future projects you'll probably see this
comp test file which has a lot of really
nice testing configuration pieces in
it now that was a lot of stuff to code
and quite frankly I don't think any of
us want to have to do that every single
time have to code everything from
scratch now you can absolutely get Clon
all of these repositories right from
their GitHub but there's actually an
even easier way for us to start with a
blank project here and this is with
brownie mixes so if we Google brownie
mixes GitHub we'll get this mixes
organization which just has a ton of
boilerplate code for us to go ahead get
started and start developing the one
we're going to be working with is this
chain lick mix piece which is forked
from this official one here this gives
us some wonderful contracts some tests a
brownie config and really everything
that we need to do to get started so if
you have brownie installed we can just
bake this mix so we'll do brownie bake
chain link mix and in our new empty
directory here we'll get this new chain
link folder with everything inside of it
so then we can CD to chain link and we
can see it has all all these pieces in
here here already in the contracts we
have a whole bunch of different samples
of working with the vrf working with a
price feed working with this thing
called Keepers to automate our smart
contracts and making API calls and
delivering any API call that we want to
the blockchain it also has a brownie
config which already has a number of
wonderful pieces in each one of these
networks so that we don't have to go
copy paste and add it in here it's even
got support for test Nets like Avalanche
poon finance and more it has a number of
really powerful tests including testing
some price feeds it has a whole bunch of
deployment scripts some mocking scripts
some helpful scripts and really
everything that we need to get started
and get going for starters we could run
brownie
test and it's going to compile
everything and then on a development
chain run all these unit tests and if we
wanted to test this on a real test net
we could do brownie test D- Network ring
or any network that we wanted if you're
looking for a good starter place that
has a lot of really powerful smart
contracts for you to get started I
highly recommend using this mix as a
boilerplate starting point for any of
your contracts or any of your projects
here now we are cooking so we've learned
a ton of the fundamentals of working
with Brownie and working with smart
contracts now that we have kind of all
the building blocks though we can
actually code a lot of these much faster
and much more efficiently than before
one of the things that we've seen over
and over and over again is working with
tokens and the erc20 token standard
we're going to learn how to build our
own token but before we do that let's
understand why we'd even want to do this
now first let's define even what are ER
c20s so er c20s are tokens that are
deployed on a chain using What's called
the erc20 token standard you can read
more about it in the erc20 token
standard here Link in the description as
well but basically it's a smart contract
that actually represents a token so it's
token but it's a smart contract it's
both it's really cool tether chain link
uni token and die are all examples of
ERC 20s technically chain link is an ERC
677 as there are upgrades to the ec20
that some tokens take that are still
backwards compatible with ear c20s and
so basically you can think of them as e
c20s with a little additional
functionality now why would I even care
to want to make an ec20 well you can do
a lot of really cool stuff with it you
can make governance token you can secure
an underlying Network you can create
some type of synthetic asset or really
anything else in any case how do we
build one of these ER c20s how do we
build one of these tokens well all we
have to do is build a smart contract
that follows the token standard all we
have to do is build a smart contract
that has these functions it has a name
function a symbol function decimals
function Etc all these functions we need
to be able to transfer it we need to be
able to get the balance of it Etc and
again if you want to check out some of
the improvements that are still erc20
compatible like the ERC 677 or the ERC
777 you definitely go check those out
and build one of those instead so let's
create a new folder and get started
we're going to create our new brownie
file of course with Brownie and knit
it's going to start up our repository
and start up everything that we are
going to work with here we can kind of
actually just jump in and start right
with our contracts so let's create a new
file and we'll call it our
token. soul
and this is where we're going to add all
of our token code now since this is an
EIP right this all this is is a smart
contract so what we could do is we could
grab all these functions copy and paste
them in here one at a time grab the name
grab the symbol grab the decimals and
then you know code all these up be like
ah this does some stuff blah blah blah
or we could do it the much easier way
right since we're Engineers we don't
always want to reinvent the wheel so
once again our friends at open
Zeppelin have some amazing contract
packages for actually building our own
erc20 token so we can go right to the
open Zepp and documentation I'm working
on the 4X version but again it doesn't
matter the version that you use so long
as in our config file we add the version
that we're going to use which again
we've already gone over so let's go over
to their erc20 documentation and this is
the entirety of the code that is need
needed to make an erc20 so we can just
go ahead and even copy this paste it in
here and boom we have some erc20 code in
here let's actually just change the name
of everything in here though so we're
going to call this our
token. soul we have this this spdx
license identifier MIT great we're going
to be using solidity version 0.8 which I
know I've done a lot of this code
actually in point in 0.6 but I highly
recommend working with 0.8 because it
has a lot of really fantastic
improvements to solidity you notice this
is our first dive into using a different
version of solidity here you'll notice
that most of the syntax is exactly the
same there are like I said a couple of
nice improvements with 0.8 the main one
being you no longer have to use those
safe math functions that we talked about
before um but then we're going to go
ahead and import open Zeppelin contracts
token erc20 Soul now of course since
we're importing open Zeppelin we're
importing this package we got to add
this to our brownie config
Dio and before we even get started you
technically have all the tools that you
need to code and deploy your own erc20
token now I'm actually going to
challenge you to go ahead and try to
start a Browning project create your own
token using open zeppin packages and
then deploy it on a test net I'm going
to show you how to do all of it here
anyways but challenging yourself and
trying to do things your own and
exploring is really one of the fastest
ways to learn and grow in in this
space did you give it a shot no really
pause it now and give it a try all right
welcome back now we'll go through it and
we'll do it together of course we need
to add these
dependencies open
Zeppelin open Zeppelin contracts let's
do their version
four so let's even go to GitHub open
Zeppelin and we'll do 4.2.0 which was
released yesterday at this time which is
great
4.2.0 and of course again
compiler we'll have silk
oops
remappings we'll add at open
Zeppelin
equals
this and then we're going to go ahead
and save now we can use this at open
Zeppelin and it will refer to the open
Zeppelin contracts here so great now we
can go ahead and import these let's
change the contract name to our token
we're going to inherit this erc20 doou
from open Zeppelin we can even go ahead
to open Zeppelin contracts GitHub and we
can even see what this erc20 looks like
so we can go to uh their contracts down
to
token
erc20 erc20 doso and this is their
initiation of an erc20 which has all
these functions like name symbol
decimals total Supply Etc in our
Constructor we're going to add an
initial Supply which is going to be in
way of course so the initial supply of
that token and we're going to use the
Constructor of the erc20 DOA which again
we can go ahead and check in the code
here and we can see the Constructor uses
a name and a symbol so we have a name
we'll call it our
token and the symbol we'll do OT and
boom that is literally all we need for
our token here I told you this was going
to be a much faster project now for
scripts all we have to do create a new
file We'll add a one deploy token. soul
and we'll also add a
helpful
Scripts excuse me this deploy token. piy
excuse
me we'll just quickly add a get account
function we say def get account and you
can go ahead and just copy paste from
the last one and if you want you can
actually just copy paste from our last
helpful scripts because it's pretty much
going to be exactly the same so that we
have all these wonderful uh ifs
statements so that we can deploy from
really anything that we want now in our
deployment token script we'll do
from brownie
import our
token and then from
scripts
do helpful scripts import get count and
just to make sure let's add
anit Pi in here just to make sure that
our scripts can actually import so since
we know since we know that we need an
initial Supply here let's go ahead and
do initial Supply equals and then we can
do whatever we want here if we want to
make it a little bit more readable we'll
also do from web 3 import web 3 and we
can do web
3.2 way and we'll
say 1,000 is the initial Supply and this
is in ether so our initial Supply is
going to be 1,000 ether then we just add
our main
function do account equals get account
we do our token
equals our token.
deploy we just add as a
parameter initial
Supply do
from account then we'll do
print our token dot name and that's the
whole function now of course if you
don't have your environment variable set
we're going to add ourv file this is
where we can add our private key
our web 3
infura project ID and then if we want
our ether scan token I'm going to skip
doing this for now because my
environment variables are already set
and then last but not least we'll
add so private key equals Ox blah blah
blah three inferior Pro equals blah blah
blah ether scan token equals blah blah
blah and perfect now if we want to
actually deploy this to a test net
always we have to do go into our config
we'll add
wallets from
Key We'll add our environment variable
private
key now brownie knows where to grab this
from because we've defined it in our
helpful scripts what I could do
now to brownie run scripts deploy token.
piy and we can go ahead and see that our
token is printed out we can see that we
have this token deployed on our local
ganach we can see our token here and
this is great now I can go ahead and run
once
again Network rink
be now if I grab this address go to the
rink be ether scan pop it in after a
quick refresh I can now see that my
contract has indeed been added and ether
scan even picks up that it's a token now
what we could do you grab this grab this
contract
address go to
assets add it in our metamask here next
add tokens and you'll see we are the
proud owners of 1,000 our tokens now
something else that you might want to do
is add this to a liquidity pool or add
this to a place where you can actually
go ahead and sell it and put it on the
market you can do something like that
it's easily as just popping onto Unis
swap going to pool hitting more create a
pool and then adding our token in here
we'd have to manage the token list and
be sure to add the token here but we can
go ahead and add a token create our own
pool and automatically put it on Unis
Swap and that's how easy it is to
actually sell it on one of these pools
but all right so this was probably our
easiest project of the course but it
really shows how far you've come along
everything
here that we know a little bit more
about Defi and why it's such an amazing
amazing technology that only works in
the blockchain world let's look at this
site D5 pulse or if you want to look at
another one there's another fantastic
one out there called defi llama which
also shows a lot of these different
protocols in here so defi pulse is an
application that shows some of the top
def5 projects based on how much total
asset is locked into each protocol a
which currently is the number one ranked
defi application with
9.32 billion in assets under management
in terms of USD then we have some
fantastic ones like curve compound maker
instadp Etc now we're going to be
looking at two of these protocols in
particular the first one of course being
a the second one is going to be a type
of what's called a decentralized
exchange to get started with a we're
going to go to testnet
a.com dasboard and it'll bring us to a
screen that looks something like this
please connect your wallet and
everything will be pretty empty paraso
is what's known as a DEX or a
decentralized exchange it allows us to
trade tokens incredibly easy on the
blockchain now there's not a whole lot
of test net deck that actually work so
we're just going to look at them and and
simulate as if we were working on them
for example if I wanted to trade one eth
for some usdt or maybe some wrapped
Bitcoin or some D or some a or link or
really any token that we wanted all we
would need to do is connect our wallet
here and a swap button would show up and
we would go ahead and hit swap some
other really powerful these dexes and
really popular ones are going to be
curve bance Unis Swap and it's a really
really easy way to go ahead and swap
your tokens for one another depending on
what you're looking to do a is
incredibly powerful and it's going to be
one that we're going to be working a lot
with because it has pretty much all the
fundamentals of working with the D5
protocol that we're looking for and it
has a test net that we can go ahead and
test and simulate actually working with
some of these protocols so we're going
to first work with the UI or the user
interface and then we're going to do
everything here programmatically first
things first if you don't already have
it make sure you have some test net
ethereum at least and again you can get
some test net ethereum from looking at
the link token contracts and going to
koven this one indeed uh the test net of
a right now is only on coven so we're
going to go ahead here we add our copy
our address paste it in I'm not a
robot 70.1 test eth remember use this
link token contracts page because this
is going to have the most upto-date
faucets here once we see some eth in our
Coen test net here we can go back to a
so whereas Paras swap allows you to
Simply swap between assets and do a lot
of buying and selling of tokens a is a
lending and borrowing application so we
can actually put down a token as
collateral and we can borrow and we can
generate some yield from interacting
with this protocol borrowing and lending
is a critical piece to doing any type of
really interesting Financial
applications or financial instruments
such as Short Selling being exposed to
more assets Etc you can also gain some
percentage back if you look at apy it'll
tell you how much percentage over a year
you'll actually get in returns from
staking or depositing an asset so here's
what we're going to go ahead and do
we're going to connect to the
application using metamask and you'll
see on the deposit tab here we'll see
our balance be 0.1 eth because that's
how much I currently have in my wallet
right now what we can now do is click on
eth here click this Max button to
deposit some ethereum we'll hit
continue and a little dashboard will pop
up asking us okay would you like to
deposit clicking this deposit button
will actually have us deposit right onto
the a contract on the Coen test net make
sure once you hit deposit here that
you're actually on a test set here it
looks like I actually have some
insufficient funds so I'm actually going
to go borrow a little bit more from the
faucet here grab a little more from the
faet here we're to come back we're
actually going to go back
refresh and now it says I
have
0.1 we're going to deposit
0.1 continue deposit and metamask is
going to pop up saying hey are you sure
you want to do this right we can check
our data we can grab this address even
if we want pop it on to co. ether
scan paste it in here
we can even double check to make sure
that this is indeed the right contract
that we want funnily enough you'll see
that this is the we Gateway when we
deposit our coven eth it actually gets
transferred into an erc20 version of our
ethereum and then it'll go ahead and
deposited into the a contract so we're
going to hit confirm now we're going to
get this pending here we have a link to
the Explorer which shows us this
transaction that's going through and
then we'll see that we've indeed
successfully deposited our ethereum now
down here you'll see a little button add
a eth to your browser wallet and we're
going to go ahead and click this and
this will automatically add this token
to our wallet so we're going to hit add
token and we see now in assets we have
this a e down
here we could also have manually hit
added token got the contract address but
AI was nice enough to just go ahead and
add us a little button that does it for
us aeth is what's called an interest
bearing token and goes up in real time
you'll see if I sit here long enough
you'll see this number actually
continually going up this is the profit
given to us from other people borrowing
the eth that we've deposited into a if
we go to our dashboard now we can see we
have 0.1 e deposited and if we roll over
it you'll constantly see the amount go
up and up and up we can go ahead and
withdraw our eth which will convert our
aeth back into eth with the additional
interest that we got from depositing so
depositing into aate will give us
interest back as a payment for other
people borrowing the eth that we've
deposited we can also use this eth as
what's called collateral so if I go to
this borrow tab I can actually use the
eth to borrow some other asset maybe I
want to borrow D which is a stable coin
meant to always equal $1 usdc and usdt
also are meant to always reflect a
dollar we can borrow what's called
wrapped Bitcoin which represents the
Bitcoin price we could borrow some a
token some bat token some link token we
can borrow all these different tokens
now borrowing an asset is incredibly
incredibly powerful by borrowing you're
allowed to obtain liquidity without
selling your assets and borrowing is one
of the first pieces in order to actually
short sell borrowing in defa protocols
is absolutely massive because it allows
you to frictionlessly short sell obtain
liquidity without closing your position
gain yield on some deposit collateral
you can do a massive number of new
things only in the defi World such as
flash loans now an important note on
borrowing assets on mainnet since we're
just borrowing it on test net and this
isn't real money this is 100% okay to
experiment with and work with however if
you borrow an asset and you do not pay
attention to how much you have for an
underlying collateral you could get
liquidated and lose some of your funds
so be very careful and pay a lot of
attention if you're going to do this on
an actual Network now let's say we want
to borrow the a token for example we
click here and we can choose the amount
that we want to borrow now here's the
thing since we've placed down some
collateral right 0.1 if the amount that
we borrow ends up being too high we'll
actually get what's called liquidated
every time we borrow an asset we get
some type of Health Factor the health
Factor represents how close to being
liquidated you are once your health
Factor reaches one the collateral that
you've actually deposited will get
liquidated and somebody else will get
paid to take some of your collateral
this is so that the the a application is
always solvent being solvent means it's
never in debt so when I want to borrow I
want to choose some amount that might be
a little bit safe here and so that I'm
not going to get liquidated so zoom in a
little
bit I'm going to choose some number
where I see a health factor maybe like
5.6 we're going to continue now we'll
have to choose our interest rate when we
borrow an asset we actually have to pay
some interest this payment is actually
going to go to the people who are
depositing die or depositing the asset
the interest rate that we're going to
pay is actually going to be paid to
those who are depositing the asset that
we're borrowing so like how we're
getting interest on our deposited
collateral others are getting interest
on their deposited collateral based off
of how often people are borrowing it we
can choose a stable apy which will
always be 4% or a variable apy which
will change based off of how volatile
and how in demand this asset is for now
I'm going to choose variable but you can
pick whatever you want especially for
this demo we're going to hit continue
I'm going to zoom out just a little bit
and this same interface is going to show
up we're going to go ahead and hit
borrow metamask is going to pop up and
ask us if we really want to borrow we're
going to go ahead and hit confirm and
now we've successfully borrowed die into
our application we can even hit this
little add die to your browser wallet to
add the token to our wallet now if we
hit the button we go to assets we can
now see die is indeed in our token
assets here now if we go back to our
dashboard you'll see we have a health
Factor score here this is a really
important score if you click on this
little I thing it says the health Factor
represents the safety of your loan
derived from the proportion of
collateral versus amount borrowed keep
it above one to avoid liquid
and we'll see all of our deposits here
so we still have 0.1 in E deposited we
also have 28 die deposited you can see a
whole lot of different stats here for
working with our application we can
withdraw our die we can withdraw our e
we can borrow more die or we can go
ahead and repay we can either repay from
our Wallet balance or from our current
collateral yes we could repay with our
collateral let's go ahead and do from
our Wallet balance we'll hit Max
continue and we even get this little
thing that says you don't have enough
funds to repay the full amount well why
is this the case we just borrowed this
amount it's because already since
depositing we've accured a little bit of
we've acred a little bit of extra debt
remember we hit that variable apy and
every second it's going to tick up just
a little bit so let's go ahead and pay
back what we can with our wallet we're
going to confirm we're going to approve
our do to be spent and then we're going
to go ahead and hit the repay button and
gray now if we go back to our dashboard
you can see we've repaid almost
everything here but we have a little bit
left so let's just go ahead hit repay
with our current collateral we'll hit
Max continue and this will use our eth
to pay back the collateral instead of
the
die then we'll hit repay this way we'll
have no more debt great now if we go
back to our dashboard we can see we have
no more debt which is fantastic a is one
of these applications that relies on the
Chain leag price feeds in order to
understand and the ratio between how
much you have deposited as collateral
and then how much you can borrow and
take out if we look in our wallet now we
can see we still have some a eth we also
have some eth and now we have zero die
because everything's paid back but we're
still gaining interest on the eth we
have deposited let's go ahead just
reconnect let's go ahead back to test
net.
a.com and let's just withdraw all of our
eth
now keep in mind when working with some
of this this is a test net right and
working the way we're working right now
is just on a test net so sometimes the
test net doesn't work quite as well as a
main net because it's just for testing
and doesn't have the exact same support
we were just working on the test net but
if you want to go to a for
real you can go to app.
a.com connect your wallet on the
ethereum main net connect your wallet
move to the ethereum main net and and
interact with it exactly the way we just
saw now if we're on the mainnet here we
can see some additional pieces when you
deposit something like die yes you get
2.3% back as interest paid to you for
depositing the die you also get a little
bit of what's called a governance token
you also get a little bit of a token I
know it's really small here but this is
an additional incentive that a has given
the users for working with their
protocol since a is a decentralized
protocol in order for anything to be
improved or anything to be updated on
the protocol it actually has to go
through a decentralized vote so these
governance tokens actually dictate and
decide how the protocol improves moving
forward now that we understand how to
work with all of that through the UI
let's actually learn how to interact
with a and interact with defi all from
our scripts learning how to do it this
way will get us one step closer to being
a quantitative defi engineer or defi
researcher this is someone who
programmatically does algorithmic trades
algorithmic modeling and just does
everything in a programmatic sense
making them much more efficient and
Powerful interacting with di5 now all
the code that we're going to be working
with here it's in this ay brownie Pi
application and you can always refer
back to it in the link in the
description or in the link in the GitHub
repository and see all the code written
yourself so with that create a new
folder and open up your vs code to that
folder and let's get into it and a has
some fantastic documentation that we're
going to use as well link here is also
in the description let's go ahead and
start
with our our basic brownie setup just
with Brownie and it and we got a new
brownie project we got all our folders
in here and we are good to go now we're
working with brownie we're actually not
going to really be deploying any
contracts because all the contracts that
we're going to work with are already
deployed on chain all of them are just
going to be working right with a here
create a quick readme.md so we can know
what we're doing here number one we're
going to try to deposit some eth into a
then we're going to
borrow some asset with the eth
collateral and then if you wanted to I
challenge you to actually
sell that borrowed
asset this is what's known as Short
Selling but we're not going to do that
here and then we're just going to repay
everything
back great and this will be the full
functionality of working with a in this
deployed contract everything that we're
going to learn here will teach you how
to work with other contracts as well
such as Paras swap or unit swap or any
other type of swapping contract that
will allow us to buy and sell so let's
just go ahead and create a script we
call it a
b.p let's go ahead and create a function
called def Main and we'll just do pass
for now the first thing that we need to
figure out how to do is deposit some F
into a when we actually deposited our F
via the UI you could actually see when
we call this deposit function if I hit
this deposit button here oddly enough if
we go to this contract address on the
Coen ether scan we'll
see that this address is actually what's
called a we
Gateway what a is doing like I was
saying before and let's go ahead and
actually cancel this for now reject what
a is actually doing here is swapping our
ethereum for we again weth is an ERC 20
version of ethereum and this allows it
to easily work with all the other ER
c20s on the AI protocol like d usdcoin
you know ample forth link Etc so we
actually have to do the that as well so
the first thing we're going to need to
do actually isn't deposit some of our
eth first thing we're going to need to
do is going to swap our eth for we so
let's even just put this in its own
little script we'll call it get W.P so
we're going to have a function def
main I'm just going to do pass for now
but we're actually going to want to use
this get we function in our a bar to Pi
so we're going to actually have a main
and we're going to have a
def get
W and our main function is just going to
call get W so how do we actually convert
our e theum to we or wrapped ether we'll
even do a little dock string here min we
by depositing eth now to save gas we
could actually interact with this we
Gateway for a but I'm going to teach you
guys how to just get we in general so we
can look up the we
contract ether scan we koven contract
ether
scan and we'll see here we have this
wrapped ether page and we can go to the
contract and we can see that this is
indeed
verified the way a works is
there's withdraw and deposit we deposit
eth into this contract and it transfers
us some
we so this is the first contract that we
actually want to interact with so we
need our script to be able to call this
deposit
contract so per usual the two things
that we need to do this are going to be
an
ABI and an address for this we contract
I really like just doing everything
directly from the interfaces I've
already copy pasted the interface
into this here so we're going to go to
we interface. soul and we're just going
to copy all this right
here so in our interfaces we create a
new file we're going to call it
iw. Soul we're going to paste it in you
can see this has all the exact same
functions has our deposit contract
symbol name transfer pretty much
everything you would expect from erc20
plus this extra deposit piece
we'll call this ieth it's a common
naming standard to just have I in the
name of what your contract is when
you're talking about an interface so we
have an interface now and we also have
an address but again this is our address
on the koven network since we know ahead
of time that we're probably going to be
using this on different networks like
mainnet and koven and Etc we're actually
going to create a new file we're going
to add a brownie
config hopefully this is starting to
look a little familiar to you now we're
going to go ahead and add our networks
in here in here we're going to go ahead
and add koven and in here we're going to
write w
token and we're going to add this
address of the we token past it in here
while we're in here we're going to add
the rest of our pieces we're going to
add
wallets from
Key private key and that's all we really
need for now speaking of which we
probably are still going to want to test
this locally now since we've done some
work with testing we know that for
testing we can do our integration test
inte gration
tests of Coen because there's an
integration test there what about our
local
tests well this is something good that
we're thinking about right now we know
that a actually has all these same
contracts on the main net as well well
and we also know that we're not going to
be working with any oracles because of
that we don't actually have to deploy
any mocks ourselves we can if we want to
but we don't have to what we can do is
for our unit
tests we can actually just use main net
Fork Network and just Fork everything
that's on the main net into our own
local network so instead of actually
using mocks we'll basically just mock
the entire main net and one more time
just so that we absolutely have it here
if you're not working with oracles and
you don't need to mock responses we can
just go ahead and use a main net Fork to
run our unit test if you are using
oracles then it makes a lot more sense
to do the development Network where you
can mock oracles and mock Oracle
responses with this in mind we know that
we're going to be doing a lot of our
tests on Main net Fork we can go ahead
and add a main net Fork Network here and
then we can just add the main net we
token for mainnet for we'll look up we
token ether scan
with token ether
skin and we'll grab this contract
address remember absolutely positively
if you want to double check that the
contract address that you're working
with is correct I highly recommend you
do so because if you get it wrong you
could accidentally add some money to a
contract address that you don't
want so we're going to have the main net
Fork address be the we token address and
in our terminal we can do
brownie networks list
and see that indeed we have a mainnet
fork here that's going to use the ganach
CLI to fork mainnet for us there's
there's a link in the description to
refer back to the section where we
actually set this up so now that we have
the interface we know that we can
actually compile it down to the Abbi so
back in our get we here first thing we
need to do to make any transaction
obviously is get an
account well this is where we can go
back and make our helpful Scripts
so we can go
ahead def get
account index equals none ID equals none
same as before and if you have your get
account function from our last demo you
can just go ahead and copy paste it in
here all right great now we have our get
account function so we can do account
now equals get account oh but we have to
import it in here so we'll do from
scripts. upful Scripts
import get
account and depending on your python
version we'll add an init that Pi just
so that python recognizes that scripts
is indeed a module all right cool so we
have our account where we can make some
transactions with now let's go ahead and
get our we contract to do this we can
import interfaces from rowning
browning import
interface same as we did
before and we can do we equals interface
I
we and the address here is going to be
from our config
config
networks network. show
active
then we
token we also have to import config from
BR and network as
well now you might be asking why aren't
we using the get Contract function here
well you can absolutely 100% go ahead
and use that get Contract function but
since we're going to be testing on
mained Fork here I know that we're
always going to refer back to the config
so I'm confident that I'm not going to
be deploying any mocks it's better
practice to go ahead and use that get
Contract function but for this one we'll
just make it a little simpler and use
the config and now in our Browning
config if we're on the coov network
we're going to use this one if we're on
mainnet or main net Fork we're going to
use this one for going to mainnet or for
to real production you could also have a
mainnet network and it'll just be an
exact copy of the main net
for and remember we're going to want
ourv our EnV file our environment
variables to get pulled from thatv file
so we can just set it like this now
everything in ourv file will get pulled
in automatically great so we have an
address and we have an Avi which comes
from the interface now we can just call
we can just call this deposit function
where we deposit ethereum and we get we
so now we'll just do transaction equals
we dot
deposit and we'll do
from
account
value is going to be let's just say 0.1
so 0.1 * 10 raised to the 18 so we'll
deposit 0.1 and we should get 0.1 we in
return do a print F
string received 0.1
we this doesn't even need to be print
out and then we'll just return TX now
per usual if your environment variables
aren't set such as private key we're
going to want to do that so in our em
we're going do export private key equals
zerox at the beginning right here we're
going to export web 3
in
fura Project ID we'll want to add our
web3 INF fura project ID which we've got
before if we want to use our ether scan
token we absolutely can and since we're
putting a whole bunch of stuff in EnV we
want to make sure in our G ignore we
have EnV so that we don't actually push
this up to gith up again if you're
nervous about having all these amvs in
here you can absolutely do the accounts.
add or whatever other methodology you
like to set your enir variables anyway
let's go ahead and run this script now
so we can do brownie run scripts get W
Pi Network coin generating the abis for
my
interface we have a little transaction
hash that we can use pop into Co and
ether scan and we can see the
transaction going through in our
wallets we'll get minus .1 eth and we'll
get plus .1 we
we can see it's actually been
successful to add this and see this in
our metamask we're going to grab the
contract address here we're going to go
back to metamask add token paste it in
here add tokens and you can see we now
have 0.1 we if you want to switch back
your weth to ethereum you would just hit
this withdraw function or we could
programmatically add a withdraw function
in here this withdraw function
will withdraw and take our ethereum out
the contract and burn the we that
replace it with we so you need to swap
your we back to get your eth out awesome
we have some we and now we have an erc20
token we have an erc20 token that we can
use to interact with the a application
now that we've got this get we function
let's go ahead and start borrowing so
let's go ahead and start with our
account it's going to equal to get
account which now we're going to want to
import right at the top like so then
we're going to get our we address or we
can even just do our erc20 address
because the we token is in erc20 and
maybe we want to deposit some other
erc20 we'll do
config
networks network. show
active we token and of course we're
going to have to now add from
brownie import Network and now we'd want
to call this get weth Contract just in
case we don't already have we we would
just add another from
scripts. get we
import get we but we don't actually need
to call it right now because we already
have some wrapped ethereum in our Coen
address now if we want to test this
though on our local main net Fork we
probably will want to call this get W so
I'm just going to add a little if if
Network got show active is going to be
our main net
Fork we should go ahead and call this
get we function and for brownie we're
also going to want to import this config
we'll also have to add main net Fork to
our local blockchain
environments like
so so that when we call get a account in
our scripts it actually knows that it's
a local environment that we're working
with and it will just return accounts
zero instead of us having to actually
load a private key in every single time
and we want to actually wait for our
transaction to complete here so we'll go
ahead and add this weit and then do tx.
weight and wait for this transaction to
actually finish otherwise brownie will
get a little bit mad so now that we have
that we can run brownie run
scripts OB borrow to Pi Network main net
Fork so you can see that actually in
this case testing everything on Main net
Fork is going to give us a really really
accurate view of what doing this on
mainnet actually is going to give us we
don't have to do any mocking we can
literally just Fork all of main net and
go from there we are still going to test
on Coen though in a little bit just so
we can see all the transactions that go
through how long it takes for stuff to
happen just get so now that we've gotten
some we here we actually need to go into
our our second bit we're going to
deposit some f or an AR case some we
into a so how do we actually do that
well everything that we need is going to
be in this a documentation here where we
deposit and borrow from in a is in their
contract this lending pool you can see
here The Lending pool contract is the
main contract for the protocol it
exposes the user oriented actions that
can be invoked in solidity in web3
libraries these have all of the
functions that we need it has deposit
where we deposit our asset as a
collateral withdraw where we take it
back we have borrow we have repay and we
can have we have swap borrow rates uh
and a couple other interesting ones
which we'll go into later but for now we
just really need to focus on repaying
borrowing withdrawing and depositing so
as you probably guessed deposit is the
function that we're going to work on
right now and since this is the contract
that we're going to work with as always
the two things you need when working
with a contract are going to be the ABI
and the address so we're going to get
this lending pool contract we're going
to say lending
pool equals and we're actually going to
even make a function called get lending
pool so down below we're going to do def
get lending
pool lending pool not poll and we're
going to get the lending pool address
and the lending pool contract so we can
interact with it down here now something
about this lending pool is that the
lending pool address can actually change
a little bit depend depending on a lot
of different pieces so there's actually
this address provider which gives us the
address of a specific or particular
Market if we go back to this a UI
there's actually different markets so
there's different types of ways we can
interact with a we're just going to work
with the basic a V2 because it's easily
the most used on mainnet as well the
address provider registry will give us
so this address provider will give us
the address of the lending pool for our
Market if we want to go across different
markets we'll have to to go to the
address provider registry to find it but
the addresses in here don't change and
the addresses in here don't change it's
just the lending pool address itself
might change so we just have to go to
this address provider here and there's
just one function that we need to work
with it's this get lending pool which
will give us the address of the actual
lending pool so don't let this confuse
you too much basically all we're trying
to do is we're saying hey where is a
located right now and a has a contract
that will always tell us where the main
a contracts are and that's this
addresses provider right here so this is
another contract that we have to work
with and again when we have a contract
what do we need we need an
Nai and we need an address so we can
absolutely once again we could go ahead
and and you know copy paste like AB
equals whatever the ABI is but we're
just going to use an interface because
because life is great with an interface
so a couple of great things about
interfaces to if we know we're only
going to work with one or two functions
we can actually just make the interfaces
ourself so in interface we could do new
file we could do I lending
pool address provider. soul and we can
just add it in here oursel so we'll
first do
spdx
license
identifier we'll do like MIT or
something do pragma solidity
0.6.0 or whatever we want to do and then
we'll do do
interface
I lending pool addresses
provider EXC me this should be lending
pool
addresses
provider and we know that there's only
one
function called get lending
pool and we're not exactly sure what get
lending pool is defined as but what we
can
do so we can go to
ether scan ether scan a lending pool
addresses you can see here this is
actually the lending pool but what we
can look at is the a protocol we can go
right to the GitHub we go to
contracts you can see they have an
interfaces
section and they have this lending pool
addresses provider get lending pool and
kind of as we expected it's an external
View and a returns and address so we can
literally just copy paste this and here
and we could run with this and this
would work perfectly fine but this leads
us to the next point we might as well
just grab the whole thing this way we
know for a fact we're not getting
anything wrong but yes if we wanted to
our interface could be this right
because this is going to compile oh
could be this because this interface is
going to compile down to an ABI and the
ABI is going to say hey there's a
function here and that's all the ABI is
really doing it's just telling us how we
can interact with contract but let's
just go go ahead and add everything so
that if we want to interact with more
things we can so now we have the ABI we
also now need an address which we can
definitely find from the a documentation
we can go to their deployed contract
section we can find lending pool
addresses provider is going to be right
here we're going to copy
that and where are we going to put this
well as you know we're going to put this
in our brownie config we're going to do
lending
pool address is
provider going to paste that right there
and since we know we're also going to do
Coen we can also grab from Coen here so
lending pool addresses
provider we're going to copy this
here
do and we're going to add this addresses
provider for Coen as
well boom now we have it for both koven
and for Main Fort awesome so so we can
keep going now now that we have an AI
and we have an address for both Coen and
for our mainit mainit Fork what we can
do now is we first get the lending
pool addresses
provider it's going to be from our
interface which again we're going to
grab from
brownie interface. I lending
pool address is
provider which the address of that is
going to be
config
networks network. show
active
lending
pool addresses provider and then we're
just going to say lending pool address
it's going to be equal to lending pool
going to copy and paste it instead of
typing the whole thing add address
divider provider. get lending
pool right because again this address
provider has this get lending pool which
returns this address which is the
address of the lending pool then now
that we have this address we can
actually return the lending pool
contract by once again getting the
ABI and the
address of the ual lending pool so we
have the address check we just now need
the API which once again we can work
with our wonderful interfaces here do
new file I lending pool so and there's
only going to be a couple of functions
we're going to work with here but a
actually gives us the interface right
here and uh a actually even gives us the
interface The Lending pool address
provider for us so we can go ahead and
copy this pop it over into here now we
do need to actually change change one
thing in here as well this interface
Imports locally with this slash so we
actually just need to change these
Imports to actually import directly from
GitHub instead of importing locally
luckily this is something we already
know how to do so let's go to our
Browning
config and up at the top we're going to
add this dependencies bit in
dependencies so we're just going to work
with A's protocol right from GitHub so
so we're going to work with
aprol
V2 and let's see what their latest
version is looks like they got a couple
different versions here
1.0.1 so let's go ahead and work with
this one at
1.0.1 and then with
compiler
sulk
remappings per usual we're going to say
at
a is going to be equal to this
dependency this way brownie will
download this right from GitHub and now
we can just use this at a instead so
back in our ilending pool. soul we can
just change this to pull right from
GitHub and if we look in
GitHub go to their contract section go
to their interfaces
section I lending pool we know that
we can pull this
from a SLC contracts SL
interfaces because we see this ey
lending pool addresses provider right in
here and then this data types bit you
can actually look in
contracts this I know because I've been
through already it's in
protocol
libraries
types here it is Data type. so we can
just take this exact path again and do
at a SL
contracts SL
protocol SL
libraries types datat type. okay great
so now that we've actually imported this
interface for us to use we can go ahead
and compile just to make sure that
everything is working correctly brownie
compile and perfect if these interfaces
had an issue they actually wouldn't
compile through brownie here so we know
that they're compiling correctly but
great so now that we have an interface
we know that these interfaces compil
down to the ABI and we already have the
address here so to actually interact
with the lending pool now we can just do
lending
pool equals
interface DOI lending
pool We'll add this lending pool address
lending pool and then we can return
lending pool so now we have a function
that goes through the lending pool
addresses Provider from the a
documentation and returns this lending
pool contract that we can now interact
with and we can even test this out by
just printing this lending pool address
in our script so we'll do brownie run
scripts aarrow Network main net
fork and perfect we we can see the
address here is printed out and there no
errors so we know we're doing it right
so now that we have the actual address
what we're going to do now is we're
going to take this wrapped ethereum that
we've got this erc20 version of ethereum
and we're going to deposit it into this
contract just like what we did in the
user interface in order to actually
first deposit it we need to approve this
erc20 token erc20 tokens have an approve
function that makes sure that whenever
we send a token to somebody or whenever
a token calls a function that uses our
tokens we actually have given them
permission to do so so that's the first
thing that we're going to actually have
to do is we're going to have to approve
sending our erc20 tokens and this
resembles so since I know that we're
going to have to approve a lot I'm
actually just go and go ahead and make
an approve erc20 token function similar
as to what we did with the get lending
pool so we're going to need to approve
this erc20 so we're going to need to
approve this C20 so let's go ahead and
make a function we'll call it def
approve erc20 so how do we actually call
this approve function on a token
contract well as always we're going to
need the
ABI and the address of the token
contract same as always I told you I was
going to be saying this a lot now we
could create our interface ourself
looking at all the functionalities of
the erc20 tokens so we could go to EIP
20 look at the token standard find all
the different functions and put them
into our interface or we can go ahead
and just cheat and just grab it from my
GitHub repository here so I already have
an ic20 doou right here and we're just
going to copy everything in here and add
it in a new file called
ic20 do soul and paste it in here so you
can see there are number of different
functions in here we can check the
allowance we can check the balance of
different addresses how many decimals a
token has the name the symbol we can do
some transfers and transfer from and
then the function that we're going to be
using is this approv function so right
here we can already see the parameters
this approved function takes we're going
to need to have a spender of who to
approve can spend our tokens and then
how much they can actually spend so if
we come back over to approve erc20 we
know that for input parameters we're
probably going to need an amount a
Spender address the erc20 token
address so which token we're actually
allowing to
spend and then an account right or this
is going to be that
[Music]
from account bit so we'll just have this
be passed as part of the function
parameters so let's go ahead and code
this let's first just do a Quick Print
line so that people know what this
transaction is doing we say
approving erc20
token and then we'll get the erc20 token
by saying ERC equals interface same as
always I
erc20 and we'll give it whatever erc20
address that we pass to this function
and now we can actually interact with
this contract and we can call that a pro
function so we'll say transaction TX or
again TX usually stands for transaction
equals
erc20 approve and we're going to approve
move this spender
for an amount then we'll say
from count we'll do a tx. we we'll wait
one block confirmation for it to finish
and then once it's done we'll do
print approved and we'll return the
transaction awesome so now we have an
approv erc20 function that we can use to
approve any erc20 token so back up at
our main function we can run approve
vc20 for some amount which right now we
don't have
defined the spender is going to be this
lending pool but the address of the
lending pool because remember lending
pool is the entire contract we just want
the address the erc20 address of course
is going to be the erc20 address and the
account of course is going to be our
account the only thing we don't have
defined right now is some amount which
we can make it really whatever we want
to be to keep things standard let's just
go ahead and do 0.1 so I'm going to make
this a global variable say amount
equals one 1 2 3 4 5 six 7 8 nine 10 1 2
3 4 5 six 7even and we can go ahead and
do amount we're going to all these zeros
incredibly disgusting so we're just
going to refactor to do from web import
web and then instead of always we'll
just
do 0.1 ether 0.1 which is the amount
that we actually want we'll say ether
now we can run brownie run scripts a
borup network main net
fork and we can go ahead and see that
our approval function is working as
intended Network that will always
whenever we run any type of can get a
little Annoying let's go ahead and
change our default Network to main net
Fork so we don't have to do any network
our Browning let's go back to our a
borrowing section now so we have
everything approved now we just need to
go ahead and deposit it into a
since we know we're probably going to
use this a lot too let's go ahead and
create a deposit function since we have
everything approved we can now go ahead
and use the lending pool deposit method
and we can check the documentation here
or look on GitHub or ether scan to see
what the parameters that it takes are so
I'm even just going to go ahead copy all
this bring it over
here so what we can do now we can do
lending
pool do deposit
and then all these parameters let's go
ahead and walk through them one by one
so first thing is going to be the
address of the asset which we know is
going to be our erc20 address Boom the
amount of the token which we can go
ahead with our amount
variable address on behalf of is just
going to be our account. address we're
depositing this collateral for ourselves
and then referral code so refer referral
code is so the referral code is actually
deprecated and referral codes don't
actually work anymore so we're just
always going to pass it zero here and
just to make sure we know that this is
what we're doing we're going to go ahead
and print
depositing two three and then after
we're done we're going to do
print T and whoops looks like we forgot
to add that final dictionary here of
from
account ah one more thing thing here
let's go ahead and do TX for transaction
equals lending pool. deposit and we're
going to go ahead and once again we're
going to wait for one block confirmation
wait one transactions still being
processed so now if we run brownie run
scripts of a borrow.
pi we can see that this actually went
through fine all right now that we have
some collateral deposited we can go
ahead and actually take out a borrow we
can go ahead and borrow some other asset
question is going to be how much how
much can we actually borrow how much
should we borrow what would result in a
positive Health Factor well maybe we
should actually pull off chain some of
our stats how much do we actually have
deposited how much collateral we have
how much debt we have and so on and so
forth that way in the future when we
don't start clean we can take some
inventory of where we stand with our
collateral and our debts at the a
documentation we can go ahead and see
this this function
called get user account data this is
going to return the user account data
across all reserves so it's going to get
the total collateral that we've
deposited in terms of ethereum it's
going to get our total debt in terms of
ethereum how much we can borrow the
borrowing power that we have the
liquidation threshold or how close to
that liquidation threshold will be the
loan to value ratio and again this
health Factor this health factor is
obviously incredibly important because
if it drops below one or reaches one one
users can call this liquidation call now
this function returns all these
variables but for now we really only
care about how much collateral we have
how much debt we have and how much we're
available to borrow so let's go ahead
and write a function that will actually
sort that out for us we'll call it get
borrowable
data
borrowable data so let's go ahead and
create this def get borrowable
data and we're going to pass in The
Lending pool as a first parameter and
then the account as a second parameter
because we're looking to call this
function on the lending pool from an
account so let's go ahead and just call
that function so we'll do lending pool
doget user account data and we'll pass
in account. address because if we look
at the API again all that it needs is a
user's address to get started here and
it returns one two 3 four five five six
variables so we can go
ahead and get all of them with this
Tuple syntax here so we'll say
total collateral
e total debt
eth available borrow
eth
current
liquidation threshold loan to value and
then the health
Factor so it's with this syntax here
that we can actually get all of these
variables with this one call and again
this get user account data is a view
function so we don't need to spend any
guess all of these variables are going
to get returned in terms of way so let's
just go ahead and convert these from way
to something that makes a little bit
more sense to us so we want to get this
available borrow e so we can figure out
how much we can borrow let's get that in
terms that we can actually understand
stand so we'll do
fway available borrow eth in terms of
ether we'll do total collateral eth
equals web 3. from
way we'll do total collateral eth
ether ether and then we'll do total Deb
eth equals same thing web 3. from
way total debt eth terms of ethers and
let's even do a little print F statement
for each one of these so we'll do print
F this F allows us to put variables
inside the print function and we'll say
you
have total collateral
eth
worth of eth
deposited we'll even copy paste that a
couple times and we'll change this one
to total debt e and we'll change this
one one
to available ar e so we'll say you have
worth of e deposited you have total
death e worth of f
borrowed and you can
borrow avilable bar e worth of
eth and then we're going to go ahead and
return again we're going to use this
Tuple syntax so we can return two
variables and we're going to say a
float of this available borrow
e and a
float of the total debt e the reason
that we have to add this float variable
here is that without it some of the math
that we're going to try to do later
won't pan out as well so now we have
this function get borrowable data we're
going to pass the lending pool and we're
going to pass our account here since
we're
returning the borrowable eth and the
total debt we can say
borrowable eth and then total
debt equals that function right there so
let's go ahead and try this
out with BR run scripts a pi
again because in our config we have a
default network of mainten
fork things seem to be approving things
seem to be depositing and awesome we
have we have our output here we
deposited 0.1 worth of f we have zero f
borrowed and we can borrow 0.8 worth of
f yes this is correct even though we
have 0.1 F
deposited we can only borrow
0.08 this is because the liquidation
thresholds of different assets are
different in this risk parameters
documentation here we can see the
different liquidation thresholds on the
different assets we can see that
ethereum has an 80% loan to value so
with ethereum we can only borrow up to
80% of the deposit assets that we have
and if we have more than 82.5% borrowed
we'll actually get liquidated it also
tells about the liquidation bonus
Reserve factor and some other helpful
pieces in here as well but now that we
have this borrowable eth amount we can
go ahead and actually borrow some Dy so
let's do a Quick Print saying let's
borrow now in order for us to borrow
some Dy we also need to get the
conversion rate we need to get die in
terms of f so we're going to have to use
some price PR feed here luckily we
already know how to work with chain link
and how to get price feeds a uses the
chain link price feeds as well so we're
using the exact same conversion rate
tools that AI is going to use so let's
go ahead and create a function to get us
this conversion rate we'll say the die
to f price is equal to get asset price
and then in here we'll pass the die f
price feed this will be the address of
the die ethereum conversion rate let's
go ahead and create this function call
def get asset price and the parameter it
needs is going to be price feed address
so the first thing that we're going to
need is we're going to need to get this
die f price feed where can we get this
well as we know re usual we head over to
the chain link documentation we'll go to
ethereum Price feeds we'll find we grab
this and we'll paste it into our config
for main net so we can go ahead and add
the die f price feed in here and paste
it into our config again if we want to
test this with Coen we can obviously
just scroll
down for koven find the dth right here
grab that address pop it in for
koven and then we can get this the same
way that we got the address of the we
token so I'm just going to go ahead and
copy
this paste it here but instead of having
we token in here do do
f price feed and now we have a way to
change the price feed address depending
on what network want so in our get asset
price function we're going to do the
same exact thing that we always do we're
going to grab an ABI and an address to
work with the contract so again we can
get the ABI by just working directly
with the interface so we'll say die
f price
feed equals interface
dot aggregator B3 interface because this
is the name of the price feed
interface which again if we look at our
interfaces it looks like we don't
actually have so what we can do is we
can go to the chain link GitHub or uh as
you guys are already starting to figure
out all my example code has all these
interfaces as well but we can go right
to the source too what we can do we go
here we go to
contracts we get to add Source we do 0.6
through interfaces and right here is the
aggregator V3 interface so if we want we
can just copy this whole thing move back
over to our interfaces new file and this
file is actually named aggregator V3
interface you could call it I aggregator
V3 or aggregator V3 interface you could
keep it with I agregator v3. soulle to
keep with the convention that we have or
you can just call it
aggregator V3 interface. so
to keep in line with what the chain link
code is actually called it I'm going to
call mine aggregator V3 interface you
notice a couple different projects have
a couple different conventions but now
that we have it saved we can do
interface. aggregator V3 interface and
we'll pass it this price feed address
now this dief price feed is going to be
a contract that we can call a function
on again we can always refer back to get
the latest price documentation to see
how to actually work with it there's
even some python code here for working
with it in web 3 we're going to go ahead
and call this latest round data function
which we can also find in our aggregator
V3 interface this latest round data
which returns a round ID answer started
at ended at and answered and round all
we're really concerned with is this
answer bit here so the way we can do
this is we can say latest price equals
die dieth price feed that latest round
data and instead of grabbing all five of
these one two three four five what we
can do is we can actually just
grab the price which is at the one index
so round ID is at zero price is at one
start at two Etc so we can just
say the first index and then we can
return a
float of this latest price you can even
print another print F statement the die
f price is
latest price so let's go ahead and run
this and great we have the dieth price
feed here which of course we know that
looking at this right now this isn't in
the right units we know that th f price
feed has 18 decimal places so what we
can do then is we know that this number
would be 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5
6 7
8 this number is really 0. Z for blah
blah blah blah blah so maybe we don't
want to return it like so maybe we want
to say the dieth price feed is and we
add a little bit of web 3. pi to make
this make a little bit more sense so
we'll say web 3. from way we'll add this
latest price bit in here comma
ether maybe we'll even do a
converted latest price which is going to
be equal to web 3 that from way latest
price ether and we'll print that out
instead so let's go ahead and run this
again all right that looks a little bit
more accurate perfect okay great now we
have the die e price we're getting
really close to being able to borrow
this actual asset and let's even return
this converted lated price here just so
that we're always working in units that
we understand okay now we're getting
somewhere now we can calculate the
amount of die that we want to borrow we
can find this by doing a little bit of
math we're going to do the reciprocal of
the die e price
times our borrowable eth and just to be
safe we're going to times it by
0.95 so this line we're converting our
borrowable eth to borrowable D and then
we're timesing it by 95% we're timing it
by 95% because we don't want to get
liquidated so we're going to be a little
bit more C cous remember how we slid
that sliding scale around to make it
safer and less safe well the lower
percentage that we actually borrow maybe
we even borrow 50% of our collateral the
safer that we're going to be so keep
that in mind when you're deciding how
much to actually borrow if you want to
run this in a production environment so
now that we have this amount die to
borrow let's even print it out let's say
print F we are going to
borrow amount dat to borrow die and then
we're finally going to do it now we will
borrow looking at the a documentation we
can look at their borrow function and we
can see the API here let's go ahead
let's go ahead and call this function so
we'll do borrow transaction it's going
to be equal to lending pool. borrow
let's look at those parameters so the
asset that we want to borrow die address
so first we should get a die address
which we can once again we'll want to
put in our config so we'll go over to
our config and we'll add a die address
or a die token here which we can find on
ether scan die token it looks like this
is the token right here so we'll copy
this address for main net remember if
you want to run this on coven you're
also going to need to have a die token
for koven now on test Nets a actually
changes up where the tokens for its test
Nets are actually going to be so if we
go to their documentation we go to
deployed
contracts and we go to Coen here you'll
always see this little flag thing pop up
say always ensure you're using the
latest lending pool address since koven
is updated from time to time it's going
to be the same thing if we scroll down
for tokens they have an upto-date list
of Coen addresses in adjacent file here
so it looks kind of gross but if we look
up die we can see symbol die and the
address of die on the Coen test net so
sometimes this does change so if you run
into an issue maybe it's because the die
token that you were working with on
their Co test net has actually changed
then we're going to do config
networks network. show
active die token great now let's move on
to the next parameter the amount which
we just figured out here amount died to
borrow which we do need to change back
to way so we're going to do Web 3. Two
Way amount datab borrow ether because
right now amount datab borrow is in our
human readable version which we need it
in
way then our interest rate mode which is
going to be stable or variable stable is
where the interest rate will always be
exactly the same variable will change
depending on a lot of different things
going on with a for safety we're just
going to go ahead and add one here then
we're going to do a referral code and on
behalf of so referral codes no longer
exist so we'll leave zero it's going to
be on behalf of
ourself so we'll do account. address and
then of course we have to do a
from account then we'll wait for this
transaction to complete and if we' done
this right we should have borrowed some
die programmatically from the a protocol
so let's even
print borrowed some
D and we can once again call our get
borrowable data
function since this get borrowable data
function will print out our new count
information for how much we borrowed so
let's go ahead and run this on mainit
Fork
again awesome so if we've done this
correctly we now see that we've borrowed
some die so we can see here we now have
0.1 worth of f deposited
0.059 999 worth of f
borrowed uh and we can borrow a little
bit more worth of F this 0.759 N9 is
actually
the Dy that we've borrowed so we've
deposited some eth and we've borrowed
some dye and obvious telling us how much
that Dy converted to e is there so we
actually borrowed 160 D which is great
all right we've now learned how to
borrow everything which is fantastic
let's go ahead and actually repay that
back so we're going to call their repay
function and let's just put this into
its own function called repay all and
we'll give it the amount that we want to
repay The Lending pool address and our
account so let's call let's define repay
all or we're just going to repay
everything that we have and again we're
going to add an
amount lending
pool an account for parameters so if
we're going to pay back this network
first thing that we need to do is
actually call the approve function and
to prove that we're going to pay back so
the first thing we're going to have to
do per usual is we're going to actually
have to approve that erc20 so let's say
how much we're going to approve web 3.
2way
amount ether to The Lending
pool and we'll grab it from the
config
networks network. show
active this is going to be the die token
again
and of course with our account I believe
our approve erc20 already calls weight
so we don't have to call it here so once
we approve we're going to be using this
die that we borrowed to pay most of what
we have borrowed back now we're going to
call the repay function so we'll say
repay TX equals lending pool.
repay first we need the asset that we're
going to use to repay which we're going
to use config
networks network. show
active die token the amount which it's
going to be passed in here amount the
rate mode which we've hardcoded to one
and the address on behalf of which going
to be account. address then of course we
always have to do front
count then we're going to do repay
tx. weight we're going to wait one block
confirmation and then we'll print
repaid and if we've done all this right
we'll do one more print line saying you
just
deposited
borrowed and repaid with
a brownie and chain
link all right most moment of truth
let's see if this
works oh we did it repaid you just
deposited borrowed and repaid with a
brownie and chain link awesome work now
if you want to what we can also do is we
can see if this will work with our
wallet address here so what I can do is
I can copy my address go to Coen ether
scan and paste it in here right now we
can see that I have a whole bunch of
link and some ether what I can do is
actually test everything that we just
ran through on the coven test scent and
see everything happened right on this
ether scan address so if we've been
following along correctly and we've
added contract addresses appropriately
we should be able to run the exact same
script on the Coen testnet I'm going to
do one additional thing here though
I'm going to have us not repay so we can
see us with a little bit of debt so
let's go ahead and run brownie run
scripts aapi and we'll change to network
Coen and now it's going to take a lot
longer as we've seen before because
we're actually making these transactions
on a real Network whoops it looks like I
got one of the dief price feeds wrong
for Coen so I can once again just go
over to the
documentation do
f it looks like this is the real address
for Cen so we'll copy that paste it in
here whoops we should also probably have
some we token so first let's go ahead
and run our get W script for Coen and
we're going to change this account to
get account brownie run scripts get w. p
network COV from our helpful scripts
that way we can actually that way we can
actually use our wallets correctly all
right great so now we have 0.1 we and
actually again what we can do is grab
this address
here add token paste it in add tokens
for the we token now we can see we have
0.1 we which is perfect so now that we
have some weth we can run the borrow
script a brownie run
scripts a borrow Network
Coen and wow we can see that everything
went through correctly and successfully
so since I actually commented out this
repay function we still should have die
in our address here in our wallet here
and again we can see that by going to
our brownie config grabbing this die
token address add token custom token
tokens next add tokens and we can see we
do indeed have 160 die in our wallet we
have no we since it'll be in a now and
we have borrowed die instead can also
see that we now have this AE if we added
it from when we were working with the UI
we have this interest bearing we instead
of regular WAP ethereum let's look at
one of these
transactions we can see that our borrow
transaction gave us some stable debt
bearing Dy and also some Dy so we owe a
some Dy from this debt we got some debt
we got some die and we gave out some a
interest bearing die to the rest of the
a protocol you'll notice now if we go to
test net. a.com D dashboard we'll see
exactly what our script just did we have
160 die borrowed and we have 0.1 e
deposited if we want to repay our funds
we can do it with our current collateral
or from our Wallet balance and you'll
notice something if I try to repay
everything from my wallet all the DI
that I've actually borrowed you'll
notice we don't have enough funds to
repay the full amount this is because
since we actually borrowed a little bit
we've inced some of that interest so we
actually owe more back than we
originally borrowed that's how the loans
work so when you're designing this repay
functions be sure to have that in mind
you can also have your repay be minus
one to repay the entire debt it's
recommended to send it an amount
slightly higher than the current amount
borrowed but in any case maybe we say we
want to do from our current wallet we'll
hit Max but maybe we want to actually
just repay with our current collateral
we can go ahead and repay the maximum
amount again we could do this all from
the UI we'll approve and this is exactly
what our repay function actually did and
now we're all repaid up we go back to
our dashboard and we hit refresh we'll
see we just have a tiny bit of ethereum
and no more borrowed assets
awesome you've essentially learned
everything that we need to go through
for here this is a massive step forward
in teaching you how to become
quanitative dii Wizards and build really
robust applications and really robust
Financial applications in the defi world
now something I want to point out even
though this isn't a python course and
we're teaching more about solidity and
smart contracts it's still in your best
interest to test these functions yes I
know they're python functions but it's
still going to be in your best interest
to test them to make sure your
application always works as you expect
it to now I'm not going to go through
this testing Suite that I put here but
it's a really simple testing Suite to
test some of the different functions
that we created it can be really helpful
especially for something like get asset
price where the math might be a little
bit off and you want to make sure it's
correctly again Link in the description
to seeing some of these tests this is
actually going to be even easier than
that Lottery contract that we did since
we're just testing python functions and
again you can test these all with
brownie test
all right you are all doing
fantastically now is another fantastic
time to take a break go for a walk get
some food because our next session our
next lesson we're going to be learning
about nfts how to build them use them
and deploy
them look nfts are hot right now nfts
also known as ERC 721s are a token
standard that was created on the
ethereum platform nfts stands for
non-fungible token and is a token
standard similar to the erc20 again
erc20 is like link a maker all those
goodies that are found on the ethereum
Chain an nft or a non-fungible token is
a token that is non-fungible this means
that they are starkly unique from each
other and one token isn't
interchangeable with any other token of
its class a good way to think about it
is$ one is interchangeable with any
other dollar $1 is going to have the
same value of another dollar those are
fungible tokens that's like ERC 20s one
link is always going to be equivalent to
one other link by contrast is going to
be nfts those of you nerds out there
would know like a pokemon would be a
good example of an nft your one Pokemon
is going to have different stats
different move sets and isn't
interchangeable with any other Pokemon
or maybe a more relatable one is like a
trading card a unique piece of art or
the like so that's what these nfts are
they are nonf fungible
non-interchangeable tokens that for the
moment are best represented or thought
about as digital pieces of art that are
Incorruptible and have a permanent
history of who's own them who's deployed
them Etc now like I said nfts are just a
token standard so you can actually make
them do much more than just be art you
can give them stats you can make them
battle you can do really unique things
with them you can do pretty much
whatever you want with them but right
now the easiest way to think about it
and the most popular way to think about
it is by calling them art OT
it's OD or some type of collectible or
just anything that's unique now they've
begin getting a ton of Buzz recently
because we've been seeing more and more
of these being sold at insane prices
like we saw ax Infiniti sell nine plots
of their land nine plots of their unique
land for $1.5 million we also saw the
original creator of the neon cat you
know this
cat sold for like 300 eth so like I said
they're just tokens that are deployed on
a smart contract platform and you can
view them on different nft platforms
like openc or rable and these are the
nft marketplaces that let people buy and
sell them you obviously can do that
without these marketplaces because it's
a decentralized but they help and give a
good user interface so that's the basic
gist of it let's talk some more about
the standards the ERC 721 standard or
the nft standard this is the basis of it
all there is another standard that's
semi fungible tokens the 1155 we're not
going to talk about that here but you
can check it out the main differences
between a 721 and an erc20 on erc20 is
they have a really simple mapping
between an address and how much that
address holds 721s have unique token IDs
each token ID has a unique owner and in
addition they have what's called a token
URI which we'll talk about in a minute
each token is unique each token ID
represents a unique asset so since these
assets are unique and we want to be able
to visualize them and show what they
actually look like we need to define
those attributes of the object if it's a
piece of art we need a way to define
what that art looks like if it's some
type of character in a game we need a
way to define that character's stats in
the nft this is where metadata and token
Uris come in so if you know anything
about ethereum you know that sometimes
gas prices can get pretty high
especially when it comes to storing a
lot of space it can get really really
expensive so one of your first questions
might be well are they storing these
images and and these art pieces on chain
and the answer is sometimes back when
they were coming up with nfts and
artists were deploying stuff the eevs
and the artists were like yeah art let's
do that art I'm just going to deploy
this one megabyte image onto the
ethereum chain and oh God it's so much
gas expensive how do I delete button how
do I it's not um it's not delting and
they realized that if they put all this
art on chain it was going to be
incredibly expensive so to get around
this what they did is they put in the
standard What's called the token URI
this is a universally unique indicator
of what that asset or what that token
looks like and what the attributes of
that token are and you can use something
like a centralized API or ipfs to
actually get that token URI typical
token URI has to return something in
this format like this where it has the
name the image location the description
and then any attributes below now if
you're like me your first question would
probably be wh PA from a single Source
seems pry
centralized this is a current limitation
of the nft ecosystem there is often this
talk of on onchain metadata versus
offchain metadata because it is so much
easier and cheaper to store all your
metadata offchain a lot of people will
use something like ipfs that is
decentralized but does take a little bit
of centrality to keep persisting but
they can also use their own centralized
API however obviously if that goes down
then you lose your image you lose
everything associated with your nft
because of this most nft marketplaces
actually can't and won't read off
onchain attributes or onchain metadata
because they're so used to looking for
the token URI obviously if you do
offchain metad data you can't do
anything really cool or really
interesting or have any games with your
nfts for example if you wanted to create
an onchain Pokemon game all your
attributes would need to be on chain in
order for your Pokemon to interact with
each other because if it was offchain
then that becomes a lot harder to
cryptographically prove so if you're new
with nfts and you're like wait this is
kind of a lot of information I'll make
it easy for you if you're looking to
render an image of an nft add your image
to ipfs add a metadata file pointing to
that image file on ipfs and then grab
that token URI and put it and set up as
your nft the chain link D and D article
does a great job of walking you through
this and showing you how to do this so
be sure to read that if you're looking
to learn how to do that so all the code
that we're going to be working with is
actually available for you in this nft
mix brownie mix it's an official brownie
mix and it allows us to deploy these
three adorably cute dogs and there are
two different types of contracts that
we're going to be working with we're
going to be first working with a simple
collectible and then we're going to work
with an advanced collectible the simple
collectible is going to be a very simple
ERC 721 standard we're not going to
really add any bells and whistles other
than give it like a name and then our
Advanced collectible is going to take
advantage of some of those more advanced
true scarcity features that we were
talking about so protocols like avag GOI
and ether cards use chain link vrf to
get verifiably random numbers to create
verifiably scarce nfts something that's
important to keep in mind is that in the
real world when companies create trading
cards there's no way to prove how scarce
or how valuable these training cards
actually are if we use a verifiable
random number then whoever is deploying
these nfts can't even control how rare
these nfts really are so we get this
verifiable scarcity and this verifiable
Rarity which adds some value to the
tokens if you want to just go ahead and
work right from the brownie mix you can
actually just run brownie bake nft
mix and then CD into
nft and all of our code is going to be
right in here we're going to go through
and deploy and develop everything from
scratch because we're going to actually
take some previous Concepts that we've
learned improve on them and we're going
to learn a lot of nitty-gritty
interesting pieces about making this
hybrid smart contract because these nfts
really are a perfect example of a hybrid
smart contract they have some offchain
component interaction with a random
number and rest storing their metadata
with ipfs and I'll explain ipfs a little
bit more in depth as we go on here so
let's go ahead and get to it I'm going
to go ahead and make a new directory
called nft demo I'm going to CD into
it
code period and perfect I have a blank
project here and you already know what
the first step we're going to do is is
do Brownie and knit to create our blank
brownie repository now let's go ahead
and create our first contract we'll call
this
simple collectible doou since this is
going to be since this is going to be a
simple collectible a simple nft that
we're going to get started with now
similar to the erc20 this ERC 721
standard has a number of functions that
we can actually work with we can go
ahead and even look at the 721 the ERC
721 non-fungible token standard on the
e.e. org website and we can see a sample
interface and some sample events and
some functions and kind of everything
that we've grown to know and love and
once again instead of us kind of
recoding copy pasting all this from
scratch we're going to be using we're
going to be using open Zepp ERC 721
documentation for this now we're going
to be working with version 3.x there is
a version 4.x that has come out using
version 3.x of their open Zeppelin
contracts is also I think a little bit
easier to explain but again those of you
want to challenge yourself definitely
try their 4.x version so let's go ahead
and jump right into it first we'll do
our s our
spdx license
identifier MIT then we'll choose our
solidity version we're going to use
pragma solidity
0.6.0 but again most of this should work
for 0.8 moving forward and then we're
going to go ahead and look at the open
Zeppelin erc721
documentation and we're going to go
ahead and grab this line right here
import open Zeppelin contracts token
earc 721 earc 72. soul you can even see
a sample erc721 that they give you and
this is actually going to be similar to
the ERC 721 that we're going to make so
we're going to go ahead and paste that
and of course since we're doing this at
open Zeppelin contracts we're going to
need to create our brownie
config and same as always
depend
dencies it's going to
be open Zeppelin
slopen Zeppelin contracts and again like
I said we're versing we're using version
three so
3.4.0 again and then we'll do
compiler
Suk
remappings and we'll say at open
Zeppelin
equals
this and great let's even try to just
compile this right now brownie compile
and perfect it has been compiled now
similarly to our erc20 that we did with
open Zeppelin we're going to do the same
startup here so we're going to say
contract simple collectible is erc721
and this is how we're going to inherit
all those
functions in the ERC 721 token standard
here and we can start adding our and we
can start coding r simple ERC 721 now
for our ERC 721 we're going to make it
be a couple of these cute adorable dogs
so it's going to be one of these three
dogs for our simple collectible we're
just going to go ahead and use the Pug
here so so you can use any image that
you want for this demo um however if you
want to just follow along with us we can
just download this dog we'll call it pug
create a new
folder here called IMG and then I'm just
going to add pug PNG to this IMG folder
so this is going to be the nft that
we're going to deploy we're going to
deploy this very simple pug for our
smart contract so we're going to be
deploying this pug this is the image
that we're going to use for our nft it's
going to be this adorable pug so let's
go ahead and create the rest of the
contract for this pug so the first thing
we're going to make is our
Constructor it's going to take no input
parameters it's going to be a public
Constructor and then we're going to go
ahead and use the erc721
Constructor which if we look at the
documentation we give it a name and then
a symbol we're going to use the erc721
Constructor
parameters which is going to be a name
which we're going to say is doggy and a
symbol which we're going to say is dog
and
perfect that's all we really need to do
for the first part this nft contract is
actually what's known as a factory
contract there's a main contract and in
it it has a list of all the nfts and the
owners that are of this type of nft so
in this example all of the type of nft
is just going to be this pug and it's
just going to be this dog and we
actually need a function to Mint new
nfts based off of this pug now we can
absolutely have an nft Factory contract
that only creates one single nft but
we're going to use this Factory
implementation to create multiple nfts
we're going to do it with a function
called create collectible this will
create a new nft and assign it to
whoever called this function so anybody
can come here and create a new poppy for
themselves or in other words adopt a
puppy so we're going to say
function create
collectible public and we're going to
say returns you
256 you'll see why we need to do this in
a minute now when we create this
collectible all we're doing is we're
assigning a new token ID to a new owner
and if we look look at the open Zeppelin
erc721
GitHub we can see they have this safe
mint function this is the function that
they use to Mint or create a new nft
this function it it takes a new address
to which is going to be the new owner of
the nft and a token ID every nft in this
Factory contract has a unique token ID
we're going to have our token IDs start
from zero and and just increment every
time we have a new to token minted this
safe mint function calls the safe mint
function which calls this minting
function so if you're looking at the
code here this mint function is really
the the function that calls and creates
this nft you'll see actually that they
just have two mappings that they update
they update this owners
mapping which is just a mapping of token
IDs to the owners of the token IDs and
then they update this
balances mapping which is a mapping of
owner address to the Token count so the
number of tokens that an owner actually
has and that's all that's happening when
we call this mint or in our case safe
mint function the difference between
safe Min and mint is safe Min checks to
see if a token ID has already been used
or not and this way we don't actually
override who owns tokens and who owns
token IDs so we're going to use the saf
Min function so first we need to think
okay well we're going to need to a way
to count these token IDs so that every
single person has a unique unique token
ID so let's create a global variable un
256 public token counter and we'll
initialize it token counter to zero of
course this is the same as initializing
token counter to zero but let's just
make it very explicit so when we create
a new collectible we're going to say you
went
256 new token ID is going to be equal to
this token counter and we're going to
iterate this every time we mint a new
token so for example we're going to
iterate that in this create collectible
here so new token ID equals token
counter we're going to
call this safe Min function since we're
inheriting it from open Zeppelins erc721
we need to give it this new nft an owner
which is going to be message. sender so
whoever calls this function and then we
need to give it a unique token ID which
is going to be this new token ID now
whenever we miss one we're going to want
to increment this token counter so then
we can say token counter equals token
counter + one and we can then return
this new token ID so we'll return the
token ID of the token that we just
created and boom if you're looking for
an incredibly minimalistic contract to
deploy nfts this is all that you need so
we can run brownie
compile to make sure we did everything
right and product has been compiled we
can see it in the build so great job job
obviously this might be a little
dissatisfying to you after the breakdown
that we just gave how do we view this
token what does this token look like I
thought we wanted this to be a doggy how
do we know that this looks like a dog
how do we get this image on the
blockchain this is where metadata is
going to come into play now if we look
at the original ERC 721 there is this
part called the metadata extension is
optional for erc721 smart contracts as
we've talked about anytime you make a
transaction on chain it costs some gas
even very tiny amounts of data can cost
more and more gas images are much bigger
than these little bits of data here and
they can cost a lot more gas so when
this standard was being created the
developers kept this in mind and knew
that storing entire images and entire
gifts and entire videos on chain was
going to be incredibly costly so they
added this piece about metadatas and
token Uris the token URI is a distinct
uniform resource identifier for a given
asset this is an example of a URI and
the metadata that we're going to be
demoing today a URI is just a unique
resource identifier so this can be
something like https or ipfs or any URL
string that uniquely points to some
metadata your metadata file is going to
look like this it's going to have a
title for the title of the nft can have
a type and it can have all these
different properties or stats or
attributes for example we're going to
have our pug nft which is going to be
defined like this it's going to have a
name as pug description is going to be
an adorable pug pup and it's going to
have What's called the image URI which
defines what the token actually looks
like and if we copy paste this into
another browser we get returned this
it's this token URI with this metadata
adjacent object that's going to enable
different nft platforms to actually
render our nft so this is an example of
what this pug is going to look like on
different nft marketplaces like openc
platforms like openc understand that
they need to show this image they need
to use this name they need to use this
description and have these traits so if
we look back at this nft on openc we can
see the name is pug we can see the
description here if we go to levels we
see its cuteness is 100 out of 100 now
this of course leads us to a really
interesting point if we're storing the
image offchain then how is this image
decentralized if we're storing this
image offchain how can we guarantee this
nft is going to stay forever now this
leads us into a little tidbit about
storing data on the blockchain as of
current recording storing a lot of data
on chain can get incredibly expensive
the more data that you store the more
transactions that you have to make to
store that data on chain and the more
gas that you're going to have to spend
at the time of recording e the eum is
about little less than 900 GB in size if
a ton of people were to put full videos
or or movies or massive images ethereum
would grow exponentially out of
proportion and this would become
unsustainable for the blockchain network
as a whole so ethereum isn't great for
actually storing a ton of data it can
store a lot of data but it's a lot
better for doing the logic and the smart
contracts so there are a lot of
different platforms that are actually
working on this problem of storage these
platforms allow people to store data in
a decentralized way that isn't going to
exponentially explode the size of
ethereum or different smart contract
platforms the decentralized storage
methodology we're going to work with is
going to be ipfs or interplanetary file
system and this is where we're actually
going to store our image and this is
actually where we're going to store our
image so that nft marketplaces know what
our nft looks like now here's what some
protocols do some protocols just set up
a server and set this token URI to
instead be from a decentralized service
like ipfs and use just maybe their own
centralized server this is obviously a
massive issue because if their server
goes down or if they want to change the
uh image or they want to change the
stats all they have to do is change it
in their server and this is why a
protocol like ipfs is going to be a lot
easier quicker and more decentralized
version of doing this the full solution
is going to be using something with ipfs
and filecoin but easy solutions to do
that are still being built out so for
now we're just going to use ipfs because
it's free it's quick and it's easy and
it can be expanded to combine with
filecoin to be even easier to work with
now something else that I want to touch
on too when it comes to this metadata
right now all these nft marketplaces
only know how to pull attributes from
this token URI now if we want to build
really cool nfts that can interact with
each other having some attributes or
maybe some like like attack stats or
attack moves like in Pokemon for example
or trading cards we can't just store
these in this token URI because the
blockchain doesn't know anything about
this token URI so we actually need to
store these attributes on chain I'm
really hoping in the future a lot of
these nft marketplaces are going to get
better at and pulling metadata from
onchain but now right now any attribute
that we give our nfts we actually have
to reproduce in the token metadata and
the token URI as well so we've just
learned a lot about metadata ipfs token
Uris and everything like that let's
update this simple nft to be able to
render on openc and render on these nft
platforms because right now if we were
to deploy this nobody would know what
this doggy looks like so let's give it a
token URI so in this crate collectible
let's do string
memory token
URI and after we call this safe mint
function there's another function that
we're importing called
set token U and we're going to set the
token URI for the token
ID and we're going to give it this token
URI this will allow our nft to actually
have an image associated with it that we
can actually see so let's go ahead and
so let's go ahead and create a script
that's going to deploy this nft Factory
contract and then create us a
collectible so we're going to do new
file we'll call it deploy and create piy
and let's jump into our script so we'll
do def main first we need to start with
an account
and once again we can go ahead and
create helpful
scripts. py we can go ahead and copy
paste this get account function in here
if you want
but of course since we added this config
wallet from Key we're going to go to our
brownie config we'll add
wallets from Key and we're going to grab
our private
key environment variable since we're
using a private key again we're going to
create a EnV and we need our to export
private key and we're also going to need
to export our web 3 INF fura project
ID so we can just copy paste from our
last project the private key web3
inferior project ID and our ether scan
token so that we can actually verify
this on chain and we'll add a new file
in
ITP so that older versions of python
know that this is indeed a package so
we'll go ahead and do from
scripts. helpful scripts import get
account now all we have to do is import
our simple
collectible and
run simple
collectible
equals simple
collectible. deoy and if we look our at
and if we look at our simple collectible
we have no Constructor parameters here
so we can just do
from
account and now this will have our
simple collectable deployed now we need
to actually call this now we actually
need to call this create collectible
function and we're going to pass it a
string which is going to be this token
URI I'm going to go ahead and use this
sample token URI that is included in our
nft mix so if you're looking to get this
token U look up nft mix Patrick Collins
hopefully the GitHub will show right up
and we can just go right to the scripts
in
here in the simple collectible folder
create
collectible that the big free and we're
going to grab this and in our script
we're going to do sample token URI
equals this now when you paste this
token URI in your browser if you can't
see it you might have to add something
like ipfs companion to your browser like
this some browsers don't natively have
it so so there is a link to ipfs
companion for this project in the GitHub
repo but now that we have a token UR I
we can call this create collectible
function so we'll do
transaction equals simple
collectible do
create
collectible and we'll pass in this
sample token urri and then of course
we'll do
from
account we'll do tx. we we'll wait for
one block and then if we've done this
correctly we'll actually be able to see
this nft on an nft Marketplace like
openc so let's do a Quick Print line
here we'll do print awesome you can
now you can view your
nft at and we'll do this an FST string
and this is where we're going to put the
openc URL for this rink B so we're going
to say openc URL which is going to be
equal to if we pop over to open C if we
pop over to this openc pug here on the
rink B testnet we can go ahead and grab
this first start of the string so it's
going to be https testnets
doc.io assets and then this is the
address of the contract so we can see
openc URL is going to be this slash
we'll put this little brackets here
slash and then another one of these and
this is because the URL for here tests.
open.
assets it's the contract address and
then the token ID on the end here so
this is what it's going to look like so
in our print line awesome you can view
your nft open c. format simple
collectible. address comma and we going
do simple collectible
dot token counter minus one for the most
recently deployed one and then we'll run
this now browny run
scripts deploy and create
Network
Rinke and awesome we get this print line
here saying awesome you can view your
nft at https test n.c. just keep in mind
obviously for mainnet we can't use this
test nuts. openc doio but assets the
address of the nft contract and then the
token ID as well so if we go ahead click
this and it looks like it's already
actually been rendered here in opy we
could even go ahead and hit refresh
metadata just in case it doesn't show up
right away but it looks like for us it
did show up right away which is awesome
some other kind of fun Parts about openc
is if we go to our profile here we'll
actually be able to see all the nfts
that we own on this test net I've
actually deploy this this doggy twice
here once to test and then once to
actually do it great we've created our
simple collectible of course no project
is complete without some tests so let's
create some tests since we're also going
to be doing an advanced collectible I'm
going to skip the integration test and
I'm just going to write a really simple
unit test so we'll create a new folder
we'll call it unit and in here we'll do
a new file test simple
collectable dopy so let's create our
first test we'll do def test can create
simple collectible we'll just make sure
that we can actually create a Syle
collectible now we'll make sure that
this is our unit test so we'll do from
script
helpful scripts import local blockchain
environments and then we'll do if
network. show
active not in local blockchain
environments pest.
skip so of course we need to do
from
brownie import
Network and then also import py test now
something that we can do here is
actually in in our test we could go
ahead and even test our scripts by
importing uh deploy and create here and
testing this we can do something like
return simple
collectible and in our test then we
could do from
scripts deploy and create import deploy
and
create and then back in our deploy and
create script we can modify this a
little bit instead of main here we'll
call this deploy and create and then
we'll have our main function just call
deploy and create and you'll see rowny
run
scripts deploy and create to Pi if we go
ahead and run this again we can just run
this on the development Network real
quick instead of on rink B you'll see
that this does also work obviously we
won't actually be able to see our nft on
open C because this is deployed to the
brownie temporary ginach chain as
opposed to a persistent rink be chain in
our test here we could then just do we
could just run
simple
collectible equals deploy and
create and then we'll do an insert here
we'll
assert simple
collectible. owner of
zero is going to be equal to get account
and then we'll also
import get
count so we can run brownie test
make sure this works and perfect now
this was all fun and dandy but there's a
couple of things that we didn't go over
and that we didn't do so let's create a
quick readme.md for a couple of notes so
number one we didn't upload an image to
ipfs ourselves so we just used a token
URI that was already existing right we
didn't actually upload something to ipfs
we didn't go over why is
ipfs decentralized we didn't really talk
talk too much about what ipfs is number
three anyone can mint an nft
here with any type of stats right it's
not going to be it's not verifiably
scarce or random Right This Isn't that
cool so we want to actually build an nft
project that has all these pieces where
we upload the image to ipfs ourselves
we're going to talk a little bit more
about why ipfs is decentralized and it's
the preferred solution for storing nft
metadata and we're going to make our nft
more verifiably random and verifiably
scarce like for things like ether cards
and aboi let's go ahead and do this
project again but we'll integrate the
chain link vrf to make this nft
verifiably scarce and verifiably random
and then we'll also teach you guys how
to upload to ipfs and work with ipfs
ourselves so let's go ahead and do this
so let's create a new file in our
contracts and we'll call it
Advanced collectible. soul and what
we're going to do here is we're going to
make again an nft
contract where the token
URI can be one of three different dogs
so if we look at this nft mix in the
images section there's a pug a shibba
Inu and a St Bernard or one of these
three dogs we're going to make it so
that when you Mint one of these nfts
you're going to get you're going to get
a random one of these three dogs now I'm
not going to go over stat generation and
like creating battle battling nfts or
really games out of these nfts if you
guys want to see a version of those
contracts check out this Dungeons and
Dragons nft there's a link in the GitHub
to see this and it actually creates
characters that can do battle and have
like stats and attributes like um like
attack uh Constitution and different
things you'd find in dung Dungeons and
Dragons this one's done actually with
truffle as opposed to being done with
brownie but all the contracts are going
to be the same other than this
migrations do Soul so if you're looking
to check this out you absolutely can it
is a ton of fun and they have some
really cool images as well so be sure to
check that out if you're looking for
more anyways here's what we're going to
be looking to do we're going to make an
nft contract with a token URI can be one
of three different types of dogs and
it's going to be randomly selected so
let's go ahead and do it so first again
we're going to do this SPX license
identifier right at the top so we can go
ahead and put that there and we're going
to even use use same solidity version
and we're going to use open Zeppelin
again so we can literally just copy and
paste that from our last project now
we're going to create our contract
Advance
collectible we're going to say is ERC
721 great and then since we're going to
want to work with chain link vrf to get
a provably random nft we're also going
to want to
import at chain linkon
contracts slsrc
v0.6 vrf con
consumer base.
soul and of course that means we're
going to go back to here and we're going
to add smart contract kit SL chain
link
brownie contracts at
1.1.1 then we're going to go ahead and
add the remapping in we'll say
at chain link equals
boom awesome so we've imported the chain
link bit our Advanced collectible is
erc721 and it's going to be vrf consumer
base so same as always let's go ahead
and start with the Constructor we know
from our Lottery smart contract that
we're actually going to want to
parametrize a lot of these pieces for
working with the vrf coordinator for
working on different chains and
different test Nets so we're going to do
address
VF coordinator we're going to do address
link token bytes
32 keyh and we can always head back over
to docs. chain. link go to get a random
number just in case we forget what some
of the parameters are VF coordinator
link token keyh and fee great you went
256 fee and we'll make
this public as well add a little curly
bracket there
and we can go ahead and start doing the
rest of this of course we need to do the
vrf consumer based Constructor and the
erc721
Constructor so
vrf consumer
base is going to be this vrf
coordinator and this link
token and the ERC
721 we could parameter tize these as
well but we know it's going to be a dog
so we'll do doggy and the symbol of dog
which is the same as our symol
collectible here we know we're also
going to need to do this token counter
bit so we'll do un 256 token
counter and right in here we're going to
do token counter equals zero of course
we're going to need a key hash so let's
make this un 56 public token counter
excuse me we're going to do a bytes 32
public
keyh and we're going to do a un
256 public fee and we'll set keyh
equals
keyh and fee equals fee great so this is
a combination of a lot of the stuff we
did in our Lottery smart contract and
some of the pieces that from our ERC 721
we need the keyh the fee VF coordinator
link token all for the vrf consumer base
oops I should put a extra quote here and
then we need dog doggy and a token
counter for EC 721 so now we're going to
create our function create
collectible so we're going to do
function create collectible and again
we're going to do a string memory token
URI but this time in our Python scripts
we're actually going to Define where
we're getting this token URI from and
we're going to create it ourselves but
we're going to make this public and it's
going to
return it bytes 32 remember way back in
our Lottery when we did this event
requested lottery winner when we called
the chain link vrf we're going to do a
similar thing here where we're going to
make an event for whenever we request
one of these new dogs and that is also
what we're going to return we're going
to return that request ID here so since
we're using the chain link vrf here we
can go ahead and call that request
Randomness function which again head
over the docs. chain. link this is
imported from the ERC
721 and then in that request and receive
model it's going to call back with our
fulfill Randomness function we're going
to need to do a couple of different
things here because we want the user who
called to create collectible to be the
same user who gets assigned the token ID
so first we'll do bytes
32 request ID equals
request
Randomness and we're going to pass
obviously the key hash and the fee this
is going to create our Randomness
request to get a random breed for our
dogs so let's go ahead and just Define a
little bit of the fulfill Randomness
function so we can figure out how we're
actually going to pick a random dog well
the first thing that we're going to need
is we're going to need some definition
of what the different breeds that the
dog can actually be and again similar to
Lottery we're going to create a new type
called breed using the enum so we're
going to do enum
breed and then we're going to give it
three types pug which is going to be
state
zero Shiba Inu which is going to be
State one and St Bernard which is going
to be state three so our breed is going
to be one of these three breeds here so
then in our function
fulfill
Randomness when we get that random
number back we can use that random
number to pick one of these three
breeds so of course we need to have a b
32 request ID and U
256 random
number and we're going to make this
internal override so that only the vrf
coordinator can call this and what we're
going to do now is we're going to select
a breed based off of this random number
so we're going to say breed breed which
we're saying
this breed variable is of type breed
it's going to be equal
to breed generated from that random
number mod three since we have one two
three different breeds awesome so this
is how we're going to get our random
breed however we do need to assign this
breed to its token ID so now that we
have a random breed back how do we
actually go ahead and assign this well
we're going to have to create a mapping
to do this it'll look something like
token ID
to breed we're going to have to get our
token ID
somehow and we're going to have to equal
it to the breed so then our first
question is okay well in order for us to
assign this breed to the Token ID how do
we actually get the token ID well we're
going to grab the token ID by doing U
256 new token ID equals
token
counter and then we'll just set the
token ID to breed using this new token
ID equal to the breed so we're going to
want to make this token ID to breed
mapping up here to which we can do
mapping un
256 map to breed and we'll call it token
ID to breed this way each token ID is
going to have a very specific breed
based off of this mapping results
perfect okay what else do we need in
this fulfillment we need to Mint the nft
and we need to set a token URI well when
we Meed it before we called this safe
mint function however message. sender
here is always going to be the vrf
coordinator since the vrf coordinator is
actually the one calling this fulfill
Randomness so we can't actually have
this just be message. sender we need to
figure out how we can get the original
caller of create collectible here how do
we get the original message. sender of
create collectible well the answer there
is actually going to be in another
mapping when we call create collectible
we can create a mapping of request ID to
sender and this is going to take the
request ID as a
key and then whoever sent it as the
value so we're going to create this new
mapping at the
top and then actually let's make this
other mapping public as well we'll do
mapping bytes
32
to
address I'm we'll call this public
request ID to
Sender now in our fulfill function the
same request ID that requested the
random breed is returned so what we can
do is we can say address owner or
sender is going to equal request ID to
Sender
of request
ID and then this address owner is who
we're going to Safe mint the nf2 and of
course while we're matching up the
functions we don't want to forget to
always do token counter equals token
counter plus one at the end awesome now
we still need to set the token URI here
so back in our Advanced collectible
we're going to have to do this set token
uai at some point so let's actually
think about this for a second we're only
going to know breed of our dog dog once
this random number is returned and we
know the breed of the dog is going to be
one of these three breeds it's going to
be a pug a shibba Inu or a s Bernard and
let's actually for now let's even just
go ahead and add those three images to
our project here create a new folder
we'll call it image and you can put
whatever images you want in here I'm
actually just going to download I'm
actually just going to download the
three images right from the nft mix boom
and now I have my pug my shba Inu and my
St Bernard in here so anyways it's going
to be a pug shib Inu or a St Bernard
here we're only going to know what the
breed is once the random numberers
returned and the breed is actually going
to govern if it's a pug shib Inu or a St
Bernard so we technically could actually
just get rid of the input parameters for
crate collectible since there's going to
be no token URI initially created what
we could do is we could create a new set
token URI function that sets the token
URI based on the breed of the dog for
the Simplicity of this project we're
actually just going to create our own
set token Ur function that we're going
to update based off the breed of the dog
a challenge for you after we finish this
project is to make this even more
decentralized and have the fulfill
Randomness function actually be the one
to decide what the token URI is but for
now in our fulfill random Mis function
we're going to skip setting the token
URI and we're actually going to call it
in a separate function we're going to
create our own function called set token
URI and we're going to pass it a un 256
token ID
string memory token URI and we're going
to make this a public function once this
fulfill Randomness function is responded
the breed of the dog is going to be set
right this token ID to breed is going to
say hey this token ID now is associated
with this breed which is going to be pug
shba Inu or St Bernard all we want to to
do then is now that we have the onchain
metad data we're just going to
reciprocate that with the offchain
metadata so we're going to need three
token uis for those three dogs we're
going to need one for pug ship Inu and
then obviously St Bernard however we
want to make it so that only the owner
of the token ID can actually be the one
to update the token URI so we can use a
require function for this we can say
require and we're going to use an
imported open Zeppelin function called
is approved or
owner message
sender token ID and we're going to do
comma here
erc721
caller is not owner nor
approved this is approved or owner
function if we go into the erc721 GitHub
for open Zeppelin we can find this this
function is approved or owner which
checks the owner of the ERC 721 of that
token ID and it makes it so that only
the owner or somebody approved to work
with this token ID can actually change
the token URI so then we're just going
to call that function called set token
URI of the token ID and the token URI
now we're actually manually going to be
the ones to call this set token URI once
the breed has been decided we could of
course like I said use a mapping at the
top that automatically routes it there
but so that we can experim experiment a
little bit more and learn a little bit
more about ipfs we're going to leave it
a little bit more General like this and
perfect this is pretty much the majority
of what we're going to need for our
erc721
contract obviously we still need to work
with ipfs and getting our token URI but
for the most part this is everything
that we need now I do I am going to
introduce a new best practice here
whenever we update a mapping typically a
good best practice is going to actually
be to emit an event so let's create an
event for each one of these mapping
updates we call
event requested
collectible and we'll do a bytes 32
indexed request ID and we'll also do
a address requester this requested
collectible event is going to be emitted
when we request ID to Sender because
we're updating the mapping here this is
also going to be really helpful when we
run our tests so we can get this request
ID similar to what we did with the
lottery so down here we're going to do
emit requested collectible let's
collectible here let's use an i instead
of an a here collectible and we'll pass
it this request ID and then message.
sender we also update a mapping down
here with token ID to breed so we're
going to do a new event we're going to
call event
breed
assigned and we'll do a uint
256
indexed token
ID and then we'll do a breed
breed and then when we assign the breed
here we're going to emit breed
assigned
with new token
ID and
breed so let's see if we did everything
right let's do brownie compile looks
like we have a quick error here did you
mean fee or fee let's do a quick
underscore
there now let's try to
compile much nicer all right great let's
move on all right so now let's take a
little look see at our scripts here so
we have this deploy and create script
which is going to work for our simple
collectible so let's go ahead and
actually give them both their own folder
so we're going to do a new folder
we'll call one
simple
collectible and we'll do another new
folder called
Advanced
collectible and we'll grab this original
deploy and crate and we'll place it into
this simple collectible folder here
awesome now if we wanted to run this we
would do
brownie run scripts symbol collectible
deploy and create and we can go ahead
and and test this out on our local
ganache here and cool looks like it's
working correctly great so now let's
create our Advanced collectible script
and a lot of what we're going to do is
going to be the same as this simple one
deploy and create so I'm actually going
to copy
this we're going to create a new file
called deploy and create. piy we're
going to paste everything in here but we
are going to change a couple things up
so let's do a little bit of refactoring
first so this open crl we're going to be
accessing in a couple different scripts
so we're actually going to take this
copy it get rid of it in our deploy and
create here and we're going to move it
to our helpful scripts and place it
under here open C URL equals this script
Right Here and Now what we do in our
simple deploy and create is we're going
to do from scripts. helpful scripts
import open C URL we're going to delete
that here
so now in this
script this openc URL is going to come
from our helpful scripts which is what
we want and we're going to do the same
thing for our deploying crate for
advanced okay great so I've now copied
and pasted all the code from deploy and
create into this deploy and create for
our Advanced collectible so let's go
ahead and modify this now so instead of
from brownie import simple collectible
we're going to import
Advanced collectible
and we're going to do the same thing
down here and I'm even just going to go
ahead and delete
everything before this we're going to
change this to
Advanced
collectible and awesome okay this is
going to be our starting point and we
actually we can even get rid of this
sample token U great so this is going to
be our new starting point we've done a
little bit of refactoring now open C URL
is going to be in the helpful scripts
we're pulling in advanced collectible
instead of simple collectible
and the rest applies we're still using
our get account to get the account and
now we have this Advanced collectible
equals Advanced collectible. deploy of
course our Advanced collectible has a
different Constructor it's got a vrf
coordinator a link token keyh and a fee
so we're going to have to add those as
the parameters in here we want to work
with rinky for this because the openc
marketplace right now for test Nets only
works with rink B so that's why we're
going to work with rink here so let's
get started and just grab those rink be
addresses first so our Advanced
collectible needs a vrf coordinator and
a link token so if we head over to the
chain link documentation we go to
contract addresses for the
vrf we can scroll down to rink B grab
the vrf coordinator here and same as
before we'll jump into our Browning
config do
networks rink
we'll do vrf
coordinator we're also going to need the
link token here so we'll do link
token we need the key
has key
has and we need the fee which is going
to be 0.1 link which we can do fee as 1
1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 which
going to be 0.1 you can of course just
copy and paste brownie configs over to
different projects because because these
values are always going to be the same
now on our Advanced collectible deploy
and create we can go ahead and add those
variables in here since we're going to
be interacting with actual contracts
that are on chain and we're going to
want to be able to flip back and forth
between the mock versions of them we're
going to bring back that get Contract
function that we used before this is the
function that's going to be smart enough
to know if we need to deploy a mock or
just grab from an actual contract I'm
going to show a little fast forward of
me rebuilding this function but feel
free to copy and paste it from our last
project now something that we do need to
talk about though is our deploy mock
function the syntax here is going to be
basically exactly the same however we do
need to deploy a couple of mocks so make
sure you have these in your deploy mock
function specifically we're going to
need a mock link token and a mock vrf
coordinator and again feel free to just
grab these from our last projects
and then of course be sure to add your
contract to mock dictionary where the
link token is mapped to the link token
and the vrf coordinator is mapped to the
vrf coordinator if you guys look in the
GitHub repo there's a couple try catches
there um that just make it a little bit
nicer for error handling but this is
basically the entire script so now what
we can do we can go back to our Advanced
collection we deploy and create import
this get Contract from our helpful
scripts and we'll just replace this with
get Contract vrf
coordinator get Contract link
token and then for keyh and fee since
these don't really matter these can be
whatever we want and these aren't really
contracts we can go back to our
config We'll add
the development Network and we'll just
add
keyh and
fee and again since it's just testing we
can just go ahead and make them exactly
the same as rink
be done a lot of work now let's go ahead
and run this on the development Network
again so we'll do brownie run scripts
Advanced deploy and create no network so
it's going to default to development let
see what happens here and awesome so we
can see we actually did a couple of
things here so first we deployed this
mock link token then we deployed our
mock vrf
coordinator we finished that and then we
deployed our Advanced collectible all on
a local network so let's go ahead and
continue here once we deploy this code
we're going to want to fund this
contract with some link the reason we're
want going to want to fund it with some
link of course is so that we can call
the random number I like to have my
funding with link also in a function so
we'll do fund with link and we'll give
it an address advanc collectible.
address and let's go ahead and create
this function in Fast Forward we're
going to fast forward this as well but
feel free to copy and paste your fund
with link functions from past projects
or if you want to slow this down and
follow along feel free to do that too
let's go back to our deploy and create
we now have this fund with link that
we're going to do right here and then
all we have to do now is call our create
collectible function here so we'll just
do Advan collectible
dot create
collectible of course
from
count and we'll do creating
TX we'll wait one block
confirmation and then we'll
print you token has has been
created so we are definitely going to
want to test this because we have a
number of custom scripts here right so
let's go ahead and just do a manual test
so we'll do brownie run
scripts Advance collectible deploy and
create and we'll do it on a development
Network whoops we got to add ether here
sorry about that in the web 3.2a one
ether so let's go ahead and run the
script again
and all right it looks like everything
worked everything was deployed new token
has been created great this is fantastic
now ideally before we do an integration
test we would of course write some tests
but I want to teach some things that are
easier to demonstrate on an actual test
net so we're going to go ahead and
deploy this to an actual test net before
we write our tests so we're just going
to run the script again and do das Dash
Network rank B
and awesome a new token has been created
so what we can
do so we can grab the contract address
once
again we'll paste it into the rink be
ether scan and we can see everything in
here we can see we've given it a little
bit of Link we can see our two function
calls one is going to be the contract
creation one is going to be create
collectible our contract has already
been Auto verified actually because I
verified this contract on rinky already
and ether scan says Ah this bite code is
the exact same of another contract that
we've already verified and if we go to
read contract and we go to token counter
we'll see one token has been created
we've actually created our first token
now what we can do in our Advanced
collectible scripts we can create a new
script and just call it create
collectible p and in here we'll just
create a collectible so all we have to
do is we'll do def main per usual we'll
have to do
from rowny import
Advanced
collectible we'll import
accounts from our helpful
scripts we'll
import fund with link in our main
function we'll do account equals get
account
of course we need to import this as well
from our helpful
scripts then we'll do
Advanced
collectible
equals Advanced collectible minus one
because we just want to get the most
recently deployed we'll fund this
contract with link so we'll do Advanced
collectible.
address and we'll also choose an amount
here we'll just do web
3.2 way 0.1
ether so that means we also have to do
from web 3 import web 3 then we'll do
transaction then we'll
do creation
transaction equals Advance
collectible. create
collectible
from
count we'll do create ation transaction.
we wait one block
confirmation and then we'll
print
collectible
created oops sorry I actually don't have
to import account here or accounts
excuse me sorry this actually needs to
be amount equals excuse me now let's go
ahead and run this and what we're going
to do is we're going to fund our
Advanced collectible with link which is
0.1 link and then we're going to create
a new
nft awesome collectible created so if
once
again we take this
address go back over to Ether scan do a
quick refresh here go to our contract
read
contract look at the token counter it
may still be one so you might have to
give it a second for the chain link vrf
to respond
respond once the chain link VF responds
we'll see two in here we can also check
the token ID to breed if we look at zero
with one we'll see the breed is two and
if we look back at our
contract the advanced collectible. Soul
we know that if the breed is two that
means it's a St
Bernard see the token ID of one it has a
breed of one so it got randomly assigned
a shibba Inu awesome so we have tokens
and they get randomly assigned reads
fantastic as you can see we're doing
kind of a lot of manual testing work
here right so what we're probably going
to want to do instead is you guessed it
automate these tests go ahead want
deploy we go ahead and import that
deploy script that we just wrote so we
would do from
scripts Advance
collectible deploy and create import
deploy and create
and then all we have to do is call
deploy and
create in this function we'd probably
want to then return the advanced
collectible contract so we can make sure
that we actually get what we want here
so we'll say Advanced collectible equals
deploy and
crate and that'll be our
acting step beginning we'll do
arrange and then we'll do an assert
of we'll just check to see that the
token counter has been increased do
assert Advanced
collectible the token counter is equal
to one all right great so this will
return our Advanced collectible however
we know that since we're actually going
to be working with a mock V Rift
coordinator if we look at our Advanced
collectible we know that the bulk of the
work actually comes in this fulfill
Randomness function and we're going to
have to tell our mock to actually return
and call this function so in order to do
that we should probably also return this
creating transaction here so that we can
get the request ID remember how in our
Lottery we actually just directly called
everything and we needed this request ID
to call this call back with Randomness
function in our test here we're actually
using our scripts a little bit so we
could either just go ahead and write out
all the steps similar to what we did in
the lottery or we could adjust our
scripts a little bit for Simplicity here
we're just going to go ahead and have
this deploying create function also
return the creating transaction this way
we can go ahead and get the request ID
so back in our test here that means we
have to do deploy and create equals
Advanced collectible
and
creation transaction now that we have
this creation transaction we can use it
to get our events and again if we look
back in our Advanced collectible we can
see here that we're emitting this
requested collectible with request ID so
we can go ahead and do request
ID
equals creation
transaction.
events we'll add the
name of our vent here which is requested
collectible and then we'll
get that request ID once we have this
request ID we can then go ahead and grab
the vrf coordinator so from our scripts
we'll grab this get contract and we've
coded our get contract in a way that if
the mock has already been deployed again
if we go back to our helpful scripts if
the contract has already been deployed
then we're just going to go ahead and
grab it so since here our mock will have
already been deployed so we don't have
to redeploy it so we can just do get
Contract VF
coordinator.
callback with randomness
and we'll use the request
ID we'll pick some number like 777 we
give it
to the address of our Advanced
collectible and remember we're going to
be calling the call back with Randomness
this is what a real chain link node is
actually going to call back and it just
needs the request ID the randomness
number and a consumer contract so
request ID random number and then the
consumer contract and then of course we
have to do a from
account from get
account and we'll import get account as
well now we can move into our seert
phase so first if this is correct then
our token counter should be at least one
so we can
assert Advanced collectible. token
counter is greater than zero
or we could be a little bit more
specific here equals equals 1 we also
should technically be able to get the
breed and figure out the breed of this
first token of this first collectible
let's go ahead and parameter tize the
777 we'll call it random number equals
777 we'll place that
here then what we can do is we can say
seert Advanced
collectible. token ID to
breed of zero right in our fulfill
Randomness we're going to assign the
token ID to being the breed and the
breed is going to be this random number
mod 3 so on our test we can say the
token ID to breed of dog zero is going
to be equal
to random number
mod three and this is pretty much our
full test so let's go ahead and run this
we can do that test with- K whoops it
looks like our simple test has actually
got an error now we're getting this
module not found no module named
scripts. deoy doc create this now since
we actually changed it is going to be
scripts.
simple
collectible. deploy and
create so now if we rerun our test we'll
see brownie isn't GNA airor out anymore
so even though we skipped this test
brownie still compiles it to make sure
that everything makes sense but what we
see here is fantastic our Advanced
collectible unit test has worked
perfectly let's go ahead and make an
integration test for our Advanced
collectible here so now we'll have our
test folder here and we'll have unit and
we'll have
integration our integration test is
actually going to look really similar to
our Advanced collectible here so I'm
just going to go ahead and copy
everything new file test
Advanced
collectible in
integration and we'll just paste
everything in here now the only thing
that we're going to have to change is
that we're not going to be the ones to
call back with Randomness here we can
remove this part we also don't need the
request ID anymore since the chain link
node is going to be responding this
means that the breed that we're going to
get is actually going to be random so we
can get rid of that assert as well all
we need to do is wait for the
transaction to get called back so we're
going to import time and instead of us
calling back with
Randomness we're just going to
do time.
sleep then we'll wait 60 seconds test
can create collectible we should also
give this a different
name
integration now we should be able to
test this on a rink be chain and our
token counter should indeed increase
with the chain link node actually
responding so now we can run brownie
test- k
just that test D-
Network rink
B oh whoops right now we're skipping
this because we're saying only for local
testing now since this is going to be
our integration test we're going to do
the opposite if network. active is in
these local blockchain environments then
we're going to skip it and say only for
integration testing all right great so
now we have a quick and dirty
integration test that we can run we're
not going to run it for now because
we're going to be working a lot with
this rink be chain and we're going to be
deploying a lot of different things and
we don't want to wait so long so this is
fantastic we have a way to deploy this
we have a way to get these new
collectible tokens and create them but
if we were to take this address right
now and try to view this token on
something like openc we would get
nothing back we wouldn't get any result
right now our token doesn't have a way
to be viewed or be visible by everybody
else these nft platforms don't know what
they look like and again this is where
that set token URI is is going to come
into play so we have to figure out a way
to host an image and host all the
metadata for our token URI and the way
that we're going to do this is by using
ipfs and this is a lot better than
actually hosting this on our own server
because anybody can then go ahead and
Host this image or this metadata
themselves now there's further
improvements to this with something like
file coin where you actually pay to have
your image hosted forever however ipfs
can hook into file coin in the future
and is going to be a good enough
solution for what we're looking to do
here just keep in mind that what we do
not want to do is run this on a
centralized server when we spin up our
ipfs node we will be the only node that
actually runs and actually hosts our
image however the image is open for
anyone to pin to their nodes as well so
it's much easier for us to host our
images in a decentralized manner what's
bad obviously is if we just had the
image stored on our own centralized
server because if our server goes down
then that URL no longer exists if at
least one node on the ipfs network is
hosting this image it will be available
for anybody to see so that's why it's
going to be a much better solution than
some centralized server as I mentioned
decentralized storage is a topic that's
getting better and better and we're
looking forward to seeing more and more
ways to interact with them in any case
we need to create an ipfs node that's
going to host some data that looks like
this or like what we saw with our simple
collectible and E to host metadata that
will look like this we both have to host
a metadata file and an image URI file
which will host the actual image both of
these need to be stored on ipfs so let's
go ahead and create a new script
called
create metadata which will read offchain
and create our metadata file so we'll
start our scripts PR usual with def Main
and we'll get the most recently deployed
Advanced
collectible using this minus one syntax
of course we're going to do
from brownie
import
Advanced collectible once we have this
Advanced collectible we can then Loop
through all of the tokens and actually
figure out the metadata for each one of
them so we'll do number
of
advanced
collect equals Advanced collectible.
token
counter because we want this create
metadata to create the metadata for
every single token that we've created do
a Quick Print line here just saying
print you have
created number of
Collectibles collectibles
we even run this really quick brownie
run
scripts Advanced create
metadata Network rink B since we've
already run this on the rink be chain
we'll see you've created one collectible
if I were to run our create collectible
script again and then our create
metadata script we' of course get more
but right now we only have one
collectible now let's Loop through all
these Collectibles and create their
metadata so we're going to create that
that file it looks like this and it's
going to have it's going to have the
name which is going to be based off of
the random breed that I got it's going
to have the description which is based
off of again the random breed that I got
it's going to have an image which will
also be based on the random breed that I
got and I just put some attributes in
here but these attributes so we're going
to say for each token
ID in the
range of number of advanced
Collectibles for each one these Advanced
Collectibles first we need to get the
breed so we're going to say the breed
the breed is going to be equal to
Advanced collectible. token ID to
breed of the token
ID now Advanced collectible. token ID to
breed this is going to return an integer
right because again our Advanced
collectible this enum breed is going to
be 0o one or two so we actually want to
create a quick mapping that represents
that zero was pug one is shibba Inu and
two is St Bernard so I actually like to
create this in a helpful
script called def get
breed and then it takes as an input it
takes a
breed
number and it uses a switch statement so
up top we'll
say breed mapping
equals zero is going to be pugg
one is going to be Shiba
Inu and two is going to be Saint
Bernard so in this get breed function
now we can just do return breed
mapping of that breed number that we
get so instead of doing Advanced
collectible the token I do to breed we
can now just
do get breed
and this will this will return the
number and this will return the actual
string so we can just do from
scripts helpful scripts import get breed
now that we have the breed we can start
creating this metadata file now what
we're going to want to do is we're going
to want to have some type of format for
our contract to always pull from so what
I I like to do here is I'll create a new
folder called metadata
and in this folder I'll have a new
file called sample metadata. piy and
then I just have meta dat template
equals and I just have this this
template that we're always going to use
now in here we're going to need a
name and then we're going to leave the
name blank because we're going to want
to fix it later we're going to have a
description
which we're also going to leave blank
for now we're going to have that image
URI which we'll also leave blank and
then we're going to have some attributes
which should be blank for this dog
because we don't actually have any
onchain attributes but I'm just going to
go ahead and add some to show you what
you could do uh if you wanted to give
your dog some stats you know maybe maybe
cuteness maybe maybe raw power maybe
speed agility you know whatever you want
to do so we'll do
trait type
be
cuteness and then value is going to be
100 this would basically say hey there's
a trait type called cuteness and the
value of that is 100 so cuteness of the
dog is 100 so now once we have this
sample metadata file we can import this
into our script here so we'll say from
metadata. sample metadata
import metadata
template and another quick note you
might have to put put aore
init.py file in that metadata folder if
you're working on older versions of
python and we can start creating our new
metadata file for this breed for this
dog we want to save each collectible
under their Network and with their token
ID so let's go ahead and create a new
folder call it rink B and this is where
we'll save all of the rink B metadata
for all these Collectibles for all these
token IDs now before we actually save it
though we should just check to make sure
that the file doesn't already exist
right because if the file already exists
that means we've already created the
metadata for that token and we don't
need to so we can just go ahead and get
the
metadata file
name which is going to be equal
to
metadata network. show
active of course this means we need to
import network from browning slash
the token
ID token ID with a
hyphen with the
breed. Json just to make sure we're
doing this right we can even just print
this
out do a quick manual test brownie run
scripts Advanced create
metadata Network
rinky so this will be the name of the
file so metadata rink B token ID and
then the breed. Json okay cool now we
can actually check this to see if this
already exists and we're going to use a
python Library called path so we're
going to say from path lib import path
and we're going to say if that path it's
metadata file
name. exists if that path exists we'll
do a Quick Print saying metadata file
name
already
exists delete it to overwrite this way
we won't accidentally overwrite metadata
that we've already created and do extra
work so if it exists we'll print that
out great
otherwise we can go ahead and
print
printf creating metadata
file metadata file name
can even run this real
quick great you have one collectible
creating metadata file perfect so let's
go ahead and start creating this
metadata file so we're going to have to
give it a name description image URI and
we're not going to give it any
attributes though so just name
description and image URI so name is
easy enough since this is a dictionary
or a mapping in Python we can actually
just go ahead and start mapping so up
above before the this if we'll do
collectible metadata it's going to be
equal
to this template so this is going to be
where all we sort all of our metadata
we'll say collectible metadata of name
is just going to be the Brie so if it's
a pug the name will be pug if it's a
shibba Inu name will be shibba Inu if
it's St Bernard name will be St Bernard
and we'll give it collection
metadata description
is going to be equal
to we're going to do an F string here
and
adorable
read
but now if we print out this collectible
metadata we should
see at least the start of the metadata
which we do great name St Bernard
description an adorable St Bernard pup
of course you'll have a different random
breed but it should look something like
this now we're going to need collectible
metadata image URI this is where we're
going to have to have our image already
uploaded to ipfs so we can assign it to
our metadata here so how are we going to
do this well we're probably going to
need some upload to ipfs function it's
going to return our image URI and then
we can just set that image URI to the
collectible
metadata of image
so let's go ahead and start doing that
let's create our upload to ipfs function
now in order to upload to ipfs we of
course need to have the images ourself
already have them downloaded here and
again you can download them right from
the GitHub yourselves if you like to
make this a little bit generic we'll
have this upload to ipfs take a file
path that way we can pass this image R
upload to ipfs we're going to give it
some type of file path here we're going
to have to grab that image path
so we'll grab that image file
name by just doing
breed do
lower because right now our breeds are
all uppercase so we're going to want to
make a lowercase then we're going to
replace the underscores with hyphens
PNG say Plus
PNG and then you know what let's just go
ahead and add the full path here so
we'll
say slash
image
slash plus 3. lower perfect so and then
we'll even change this
to image path and then we can pass this
to our upload to ipfs so this file path
now is going to be the location of the
object that we're going to upload to
ipfs we're going to use this path
library to actually grab that path to
upload it to ipfs so we're going to say
with
path file path.
open RB as file path now this is a
little bit of sophisticated python here
what we're doing is we're taking this
path here we're opening the file RB
means we're going to open it in binary
since these are images that's how we're
going to actually open it and we're
going to upload the binary actually to
ipfs and then as F FP so we're saying
this opened file is going to be named FP
or or file path we're going to do
image binary equals fp.png
will come right to the docs here and
again there's going to be a link in that
GitHub and in here there are
instructions to to download it for
whatever system that you're working on
right if you're working on Windows if
you're on Linux if you're on Mac these
are the different ways to actually
download this ipfs command line you'll
know you've done it right if you can
type ipfs D- verion and you see
something like ipfs version 0.9.0 it's
important to know that we could also do
the ipfs download desktop and we could
download the desktop version version of
this and we'd see a user interface which
looks something like this we could
upload our files manually and then
manually go ahead and grab those files
and place it into our scripts but we're
Engineers we want to do this
programmatically in any case once we
have this API downloaded we can actually
follow the documentation here the HTTP
API reference for actually uploading our
code we're going to be mainly working
with this endpoint API v0 add as this is
the endpoint that's actually going to
add our file or directory to ipfs now
what we're going to want to do is we're
going to actually upload our images to
our own ipfs node we can run our own
ipfs node by doing
ipfs Damon and we'll see an output that
looks something like this we can even
see a web UI using this web UI URL here
this will look similar to what the ipfs
desktop looks like but again we're going
to work just mainly from this Damian
from our own ipfs node congratulations
you're running your own ipfs node right
now as you can see it's currently
running on our own Local Host right here
HTTP 127 0.0.1 at Port 50001 so to
actually upload this we're going we
first need to get that ipfs
URL which is going to be equal to this
URL right here
paste now we want to make an API call or
a post request to this endpoint using
this this API v0 ad and these are all
the different parameters that this ad
can actually take in so that we can
actually post it to ipfs for those of
you familiar with curl and you want to
test this out using a curl I've added a
curl into this create metadata file as a
comment so that you can actually go
ahead and test this if you want to use
this now what we're going to want to do
to keep working with our scripts is you
should have like a little plus button
somewhere on your vs code we're going to
hit that plus button and now we're
actually going to have two different
shells one which is running our ipfs
node and one which is running our bash
or zch or whatever other shell that your
OS natively works with now that we have
this ipfs URL we're going to grab the
endpoint which is going to be again this
right
here- ai- v0 add and we can make a post
request to it so for us to do that we're
going to say response equals requests
post we're going to do the ipfs URL plus
the endpoint and we're going to say the
files that we're going to
upload it's going to be equal to
file image binary request is a python
package that we're going to import so
we're just say import requests now if we
go back to the ipfs documentation we can
scroll down to see what the response
looks like it's going to return a bytes
a hash a name and a size now if we look
at this sample token U we can see the
API call here ipfs stores all its data
using a hash and if we're looking at
this and if we're looking at the simple
collectible this hash here is the hash
that represents this pug. Json file
everything in ipfs gets hashed and every
single piece of data has a unique hash
which is why it's so fantastic if we
were to change anything with this image
this hash would be drastically different
all we need to do is get the hash that
ipfs gives the image that we upload and
we go ahead and plug it into a template
URL like this one here so what we're
going to do then is we're going to say
ipfs hash is going to be equal to this
response.
Json since we're just going to jsonify
the response to make it look like this
response here and we're going to
grab that hash right since it's going to
return this dictionary and we just want
the hash here then we're going to give
it a file
name by saying it's going to be that
file
paths split we're going to do some fancy
python stuff here we're going to say
minus
one to zero which basically all this
line is doing is saying you know if we
have
slash image pug.
PNG we're going to remove
we're going to split it up by these
slashes into an array and we're going to
grab the last part of the array so we're
basically just changing this to this
with this line right here then with this
we can get the image URI which is going
to be equal to an FST string again
https
ipfs.io
ipfs slash ipfs hash question mark file
name
equals file name and it's this format
right here which will give us
this so if I go ahead and even just copy
paste this under as a comment to show
you
guys we see this part's exactly the same
and then this is that hash here
represented here and then we have
question mark file name equals and then
the file name so excuse me this is
actually going to be like zero hyphen
pug zero hyphen pug and that's exactly
what we need we need this image URI so
we'll do a quick
print
image image URI and then we'll go ahead
and return the image
URI now since we're actually going to be
testing this with ipfs we can add a new
integration test so we'll call this test
ipfs up upload. piy now you might want
to write a test for this and we're not
going to do one but I challenge you to
later on maybe come back and and write
your own test for this upload to ipfs
for now we're actually just going to
manually test it so we're going to go
back up to our script here and we're
going to run image U equals upload to
ipfs image path and then we're going to
get printed in image URL since we're
working with the St Bernard here we
should get a St Bernard image URI
so if I run brownie run
scripts
Advance create
metadata Network rink
B let's see what happens I needed to add
brackets here sorry about that now let's
try it again awesome we were able to
create this metadata file now if we go
ahead and copy
this paste it perfect we see exactly
what we're looking for we see our St
Bernard awesome job and this has been
uploaded to our own ipfs node now I want
to show you guys actually another
service and another way we can actually
upload these to ipfs some people don't
want to run their own ipfs node because
they're not actually going to be keeping
it running the whole time anytime their
node goes down this means that nobody
will be able to see your image unless
somebody else pins your image or or uses
your image so what I also like to do is
I like to upload it to some other
thirdparty Service as well as uploading
it to my own ipfs node so I like to
create another script actually called
deploy to pinata so let's go to scripts
new
file upload to pinata dopy so pinata
pinata is an ipfs file management
service and they actually will pin
whatever files that we're working with
as well so we'll have it pinned in our
node and they will have it pinned as
well so we can go ahead and
register awesome this is what pinata
looks like it's a way to upload and work
with ipfs and they'll give us some extra
support and they have a free tier which
is fantastic as well they have some
wonderful documentation as well under
this documentation section so let's go
ahead and upload this to ipfs so that
when our node goes down our images don't
go down so we'll do pinata base URL is
going to be equal
to
https D- api. pinata Cloud you can find
all this in the documentation as well if
we scroll down at the documentation
we're going to be using this pin file to
ipfs endpoint here and you can see that
entire endpoint right
here with the base and then the endpoint
so we're going to copy that endpoint
we're going to say endpoint equals
pinning SL pin file to ipfs we're going
to choose some file
path and for us we're just going to do
SL image SL pug. PNG of course if you
want to upload some other image you
could you know change this file path or
you could even do some type of for Loop
to pin everything uh in the image
section here again we're going to do
file name we're going to use that same
syntax before that's we're doing file
path dosit
slash some fancy python
stuff just to get this last part and we
also need and we need to use some
headers in this post request so it's a
type post request we need to use some
headers here so we're going to say
headers
equals copy this pinata API key which is
going to be some API key and then we
also have this pinata secret API key a
secret API key which is going to be
something else we can find these two API
keys if we scroll the way down we hit
API Keys create a new API
key I'm going to call this you can make
this an admin key I'm just going to do
limit max
users limit max uses I'm going to set
this to 200 uh because I'm I'm going to
make this a public key so I don't want
people using this a million times please
make sure you select at least one
permission pin file ipfs for those of
you guys watching you can absolutely
just grab all these if you want you can
make this an admin you know do whatever
you want to do here since I'm only going
to be using this pin file to ipfs that's
all I'm going to do hit create key and
here are our tokens here so our API key
is going to be right here and we're
going to copy that we're going to open
back up
thatv and add this as one of our
environment variables here so we're
going to export pinata API key
equal to that key there this API secret
we're going to copy and we're going to
do export inata API
secret equals that key there and we
actually don't need this uh JWT but if
you guys wanted to you could copy it as
well so now that we have them in ourv
file these are now going to be
environment variables that we can use
and brownie is going to automatically
put them into our uh environment so what
we can do then is we can do OS
.
getv
kinata API key and then of course we're
going to have to
import import
W and
then for our secet key it's we're going
to do the same thing os. get
EnV pinata API Secret
and this is how we get those two headers
for uploading to Piata then we're going
to do a lot of the same code we did
before we're going to say with path a
file path. openen RB for the binary as
FP of course since we're using path
we're going to do from path lib
import
path we're going to do the same piece
image binary equals
response is going to be equal to
requests which we have to import
requests import
request.
poost and you a base URL plus that
endpoint that we have and for files
oops it's going to be equal
to
file and we're going to upload a couple
of things here though we're going to
give it a file name we're going to do
the image binary that is getting really
annoying when it keeps getting in the
way file name image binary and then
outside of these brackets here we're
going to do comma headers
equals equals
headers and then we're just going to
print response. Json so to have this run
in brownie we're just going to do a def
main function here a nice little trick
we can do is we can select all this text
text and just hit Tab and it'll move it
over one and perfect we can now run this
inside of
brownie so we can do brownie run scripts
upload to pinata and perfect we get a
little output that's going to look
something like this it's going to give
our ipfs hash the pin size the Tim stamp
so now if we go back to
pinata we go to pin
manager do a little refresh here we now
see our pug has actually been uploaded
to pinata awesome work we're going to
keep going using the ipfs Damon to
actually upload things but if you want
you could totally swap out this upload
to ipfs to use that script that we just
created to upload it via pinata instead
of our own ipfs node anyways this upload
to ipfs is going to return this image
URI so we can go ahead then and set the
image URI it's going to be set on this
collectible metadata image and then all
we have to do is dump this collectible
met data into its own file and then
upload that as well to ipfs we'll dump
this to its own file by doing with open
metadata file name and we open it with a
W which means that we're going to write
as
file json. dump collectible metadata to
the file so we're going have to import
Json to do
this and what this is going to do is
just going to dump this dictionary as
Json to this collectible met metad data
file then we can upload to ipfs also
this metadata file name and this upload
to ipfs should print out the image URI
or in this case the metadata URI so
let's go ahead and try this out so
remember we do need our ipfs Damon
running and let's go back to our scripts
and we'll do
rowny run scripts Advanced create
metadata Network rank B and boom okay so
here is our image URI which if we click
this we'll be able to see looks just
like this and then here is our uploaded
St Bernard metadata file which is
fantastic so now we have both a metad
DAT file and we have an image URI this
is fantastic we've uploaded both of
these to our ipfs and if we scroll over
go to our metadata file in rink B we'll
see we have this new file in here
because we've gone ahead and saved it in
here it has everything that we need it
has same Bernard it has the description
it has this image URI that we just
created and it has some attributes that
again we're basically ignoring now to
make our lives a little bit easier and
since I've already actually uploaded
these to ipfs myself a couple times and
since the hashes of these are going to
be the exact same for all of us when we
upload this we're going to go ahead and
just quickly Factor this to make it a
little bit easier so we don't always
have to have ipfs running so in our EMV
I'm going to add a new environment
variable called upload ipfs and I'm
going to set it equal to false so now
down here I'm just going to say if
.gv
upload
ipfs equals equals
true anyway since we're going to do OS
here we're going to do import OS and
before this I'm going to
doops image U equals none and we're
going to
say image U equals image U if image URI
which again I know this could be a
little confusing but we're saying we're
setting image URI to whatever image URI
is if image URI isn't none else we're
going to create a mapping called breed
to image URI
of the breed so again since I've already
uploaded them I already know what all
these image you eyes for these three
dogs are going to be so up at the top
we're just going to create a new mapping
called breed to image your
ey equals I'm actually just going to go
ahead and copy paste this whole thing
now you can skip this you don't have to
refactor here um and you can just always
have your Damon running and always
upload to ipfs it's a little bit quicker
to not always have to do that again this
brief image URI is in the GitHub repo
feel free fre to just copy paste it to
use it you can even click the links to
check it check to see that those image
uis are really there and this is what
we'll use so back down here reach IM
image U URI perfect and then we're also
going to add if again os. getet
EnV upload
ipfs equals equals
true then we're also going to upload to
ipfs down here but this is to go and
actually just show you how exactly we
could upload all this stuff to ipfs
since I've already done it we're going
to make it a little bit easier on
ourselves another thing that you might
do is you might actually save all these
URLs to their own file to their own Json
object maybe inside of the the metadata
folder maybe under rink be or something
and then you could go ahead and just
pull directly from those files same
thing with the metadata once we upload
to ipfs we're not actually going to save
these URLs anywhere you could absolutely
100% after you run this upload to ipfs
script we can go ahead and save it to a
file and pull directly from there moving
forward but awesome Okay so we've done a
lot of work here we have uploaded to
ipfs our metadata and our image uis so
we have everything that we need to
actually just set the token URI finally
for our Advanced collectible we finally
can call this set token URI function so
let's go ahead and do this last bit here
this last set token U function function
so let's go to scripts Advan scripts
create a new file we call it set token U
U.P and this is where we're going to set
the token U so we'll do def Main and in
here we're do a quick print print F
working
on network. show
active of course since we're using
network do from
brownie import Network
close that there and let's grab the most
recent
Advanced
collectible is going to be equal to
Advanced
collectible minus one since we're using
Advanced collectible contract let's
import that from brownie let's once
again Loop through all the tokens that
have been deployed so we'll do number of
Collectibles
equals Advanced collectible. token
counter
do a Quick
Print you have print F excuse
me number of
Collectibles token IDs and let's Loop
through this list of Collectibles again
so we'll say for each token
ID in
range number of
Collectibles first we'll get the breed
saying breed equals
Advanced
collectible. token ID to breed of the
token ID we actually have to call this
get breed function again which luckily
we generalize so we can do from scripts.
helpful
scripts
import get
breed and now let's first before we
actually set the token URI let's check
to see if it already has a token URI set
so we're going to say if
not Advanced collectible. token
URI of token
ID dot
starts with
https so what this line is doing I know
it's a little bit long is we're grabbing
Advanced collectible. token U
of the token ID so we're grabbing this
token ID's token URI and we're saying if
it doesn't start with htps that means we
know that it hasn't been set so we can
go ahead and
print setting token
URI let's actually make this a print F
of token ID and then we can set the
token U so I'm actually going to
generalize this out
into its own
function so let's go ahead and we'll do
def set token
URI and as inputs this is going to take
the token
ID the nft contract which is going to be
our Advanced collectible contract and
the token U so the first thing that
we're going to do we're say account
equals get
account so we're going to grab this get
account of course from our helpful
scripts because this set token URI is
actually going to call that set token U
function we're going to say nft
contract. set token
URI of the token
ID and the token
URI remember this is a function that we
added to our Advanced collectible right
here set token URI it takes a token ID
and a token URI and this is going to be
from of course
account we just created so we're going
to say
transaction equals that we'll do
transaction. weit we wait one second for
it or one block for it and then we'll
print we'll do a print F
awesome you can
view your nft
at we use that open C URL
format nft contract. address comma token
ID then I'm just going to add another
print here saying please wait up to 20
minutes and hit
refresh metadata hit the refresh
metadata button so now we have our set
token URI function we can add the token
ID in here the advanced collectible
contract and then we just have to add
the token URI here so since we've
already uploaded and since I've already
actually uploaded all three what you
could do and what I like to do is just
have a dictionary here so we don't
always have to be pulling from something
so I have a
dog metadata dictionary it's going to be
equal to and we're going to add those
different dogs in here so St Bernard
this this St Bernard URL we're going to
paste it here I've actually gone ahead
like I said and uploaded this metadata
for all three dogs so I'm just going to
go ahead and copy paste all three in
here again we're shortcutting a little
bit here but what you could do is you
could save all these metadatas to their
own file and you could just pull from
that file instead of doing kind of this
dog metadata dictionary so in any case
though we're going to do dog metadata
dictionary of breed right because dog
metadata dictionary of St Bernard is
going to be this which again has our
image U has everything about our dog and
is perfect what we also might want to do
is write some tests around our set token
U function of course but I'm just going
to move on so in any case we've done a
lot here I'm actually going to even
close down my ipfs
node and we should be just about ready
for everything so of course we'll run
our brownie
test want to make sure that all our unit
tests are working
great which they look like they are
working fantastically but we are ready
to do a full endtoend manual test here
and you could 100% And I actually highly
encourage you to 100% we're just going
to run these scripts in order and look
to see if our stuff shows up on the
openc nft marketplace so are you guys
ready let's do this so make sure of
course your Environ variables are set
here make sure that your
metamask for rink
B has some eth and has some link and
then we can go ahead and start running
some of these scripts so we'll do
brownie run scripts Advance collectible
deploy and crate Network rink B
integration test Moment of
Truth and perfect a new token has been
created awesome we can even even go grab
this address let's delete all these tabs
that we have opened up and we'll go to
rink b. etherscan.io
we'll paste it in here and we can see
contract has been verified even though
we didn't verify because it matches some
other source code we can see token
counter is one and we can even go to
token ID to breed of zero see what breed
it is so it's breed 2 and it looks like
we're getting a St Bernard again which
is incred
adorable we can even go to events here
and we can see the different events
since this is verified we can even see
the name of the events so we have our
breed assigned event and we have our
requested collectible event first is an
index topic of token ID and then there's
the UN 8 breed and then we have the
bytes 32 request ID and the address
requester now let's run our create
metadata script here so we'll do brownie
run Scripts Advanced create
metadata Network rink beam we don't have
to run create collectible since our
deploying crate already does that so now
if we run our create
metadata I've actually already have
actually since this is the St Bernard
again I'm going to go ahead and get this
already exists delete to overwrite so
what I'm going to do is I'm actually
going to even create another one so that
I get a new nft so I am actually going
to run this create collectible script so
we're going to do brownie run scripts
Advance collectible create
collectible Network rank
B and what this is going to do all it's
going to do is it's going to fund with
some link which it's going to be a
little bit Overkill with the link but
that's fine then we're going to do
Advance collectible. create collectible
so we're just going to do two
transactions here perfect collectible
has now been created now I'm going to
wait a solid 30 seconds to have that
chain link vrf respond and I'm even
going to go to the contract give it a
quick refresh look at this token counter
once the chain leag vrf responds this
token counter will then be two now that
I see a token counter of two here that
means that it actually has responded so
we can now run the create metadata
script and we should have a new metadata
file now you have two
Collectibles zero St Bernard already
exists deleted to overwrite create a
metadata file metadata rink B pug so now
if we look in
metadata for rink B we have a St Bernard
and we now have a pug awesome so we're
going to set the token URI of both of
these if I grab this contract and I go
to test nets.
openc t.
openc I can paste this address in and
I'll get this doggy and then this random
hash here right and we see there are two
token U deployed again if they're not
here you might have to refresh but they
don't have the images right because we
haven't set the token URI so we'll go
back look at the advanced collectible
we've deployed and created we've created
another collectible we've created their
metadata now all we have to do is set
the token
U so brownie run scripts Advance
collectible set token URI Network rink B
and this script it's going to Loop
through all all of them and actually
going to set those token uis so we have
setting token URI of zero so this
transaction is doing exactly
that and it's going to go ahead and say
awesome here's your output and then it's
going to say setting token URI of token
ID one and that's that second
transaction and it also gives us an
output to that one as well so if we've
done this correctly and we hit refresh
metadata on this test nest. open C.O
and we do a little refresh here we can
now see our St Bernard which is
fantastic and then if we change this
from 0er to one since I've deployed two
and I refresh this one's metadata and
then refresh the page we can now see the
Pug as well again just keep in mind
sometimes the refreshing metadata does
take some time and you might have to
wait up to 20 minutes but for all
intents and purposes we have just
deployed our nfts given them token youru
eyes that aren't around centralized
servers we can now see them on an nft
Marketplace like openc you can let out a
big sigh of relief because you just did
something fantastic that not a lot of
other Engineers can do you should be
incredibly proud of yourself at this
point let's take a minute go back over
some of the new things that we've
learned
here when deploying your smart contracts
on chain we all know that those smart
contracts are immutable or unchangeable
but what if I told you that they were
mutable well technically I wouldn't be
correct however smart contracts actually
can change all the time when people
transfer tokens when people stake in a
contract or really do any type of
functionality those smart contracts have
to update their balances and update
their mappings and update their
variables to reflect this the reason
that they're immutable is that the logic
itself never changes and will be on
chain like that forever so technically
yes once they are deployed they are
immutable and this is actually one of
the major benefits of smart contracts in
the first place that nobody can tamper
with or screw with our smart contracts
once we deploy them however this can be
an issue if for example we want to
upgrade our smart contract or protocol
to do more things or we want to fix some
glaring bug or issue that we have now
even though we can't change the specific
code that's been deployed to an address
we can actually do a lot more than you
think we're going to explain the
different methodologies behind upgrading
your smart contracts and then we're
going to show you how to do it now at
first glance you might be thinking if
you can upgrade your smart contracts
then they're not really immutable then
and in a way you'd be right so when
explaining kind of the different
philosophies and patterns that we can
use here we do need to keep in mind the
philosophies and decentralization
implications that each one of these
patterns have as they do all have
different advantages and disadvantages
and yes some of the disadvantages here
are going to affect decentral so we need
to keep that in mind and this is why
it's so important that before you go
ahead and jump in and start deploying
upgradeable smart contracts you
understand the trade-offs we're going to
look at three different ways to upgrade
your smart contract the not really
upgrading method the social AKA
migrating method and then the method
that you're probably here for which is
proxies so let's talk about the not
really upgrading method or the
parameterization method or whatever you
want to call it this is the simplest way
to think about upgrading your smart
contracts and it really isn't upgrading
our smart contracts because we can't
really change the logic of the smart
contract whatever logic that we've
written is there we also can't add new
storage or state variables so this is
really not really upgrading but it is
something to think about upgrades is
just parameterizing everything whatever
logic that we've deployed is there and
that's what we're interacting with this
function means we just have a whole
bunch of Setter functions and we can
update certain parameters like maybe we
have a reward parameter that gives out a
token at 1% every year or something like
that maybe we have a set of function
that says hey update that to 2% or
update that to 4% it's just a set of
function that changes some variable now
the advantages here are obviously this
is really simple to implement the
disadvantage is that if you didn't
didn't think of some logic or some
functionality the first time you
deployed their smart contract that's too
bad you're stuck with it you can't
update the logic or really update
anything uh with the parameterization
AKA not really method and the other
thing you have to think about is who the
admins are who has access to these
Setter functions to these updating
functions if it's a single person guess
what you have a centralized smart
contract now of course you can add a
governance contract to be the admin
contract of your protocol and that would
be a decentralized way of doing this so
just keep that in mind you can do this
method just need a governance protocol
to do so another example of this might
be a contract registry and this is
something actually that early versions
of AA Used before you call a function
you actually check some contract
registry that is updated as a parameter
by somebody and you get routed to that
contract and you do your call there
again this really doesn't allow us to
have the full functionality of upgrades
here you can argue that this registry is
a mix of one of the later versions but
for all intents and purposes this
doesn't really give us that flexibility
that we want for our upgrades but some
people might even think that upgrading
your smart contract is ruining the
decentral and one of the things that
makes Smart contracts so potent is that
they are immutable and that this is one
of the benefits that they have so there
are some people who think that you
shouldn't add any customization or any
upgradeability you should deploy your
contract and then that's it Trill bits
has actually argued that if you deploy
your contract knowing that it can't be
changed later you take a little bit
extra time making sure you get
everything right and there are often
less security vulnerabilities because
you're just setting it forgetting it and
not looking looking at it again now if I
were to deploy a smart contract and I
wanted to upgrade it with this
philosophy in mind that hey we got to
keep it immutable we could use the
social Yeet method to actually upgrade
to new versions the social Yeet method
or the migration method is just when you
deploy your new contract not connected
to the old contract in any way and by
social convention you tell everybody hey
hey this new contract this new one that
we just imployed yeah this is the real
one now and it's just by Convention of
people migrating and over into using
this new one that the upgrade is done
hence my slang name of social Yeet
because you Yeet the first one out of
the way and you move to the second
one I think I'm funny this has the
advantage of truly always saying hey
this is our immutable smart contract and
this is our new one this is really the
truest definition of a mutable because
since you give it no way of being
upgraded in place then if somebody calls
that contract in 50,000 years in the
future it'll respond exactly the same
another huge disadvantage here is that
you have to have a totally new contract
address so if you're an erc20 token for
example you have to go convince all the
exchanges to list your new contract
address as the actual address keep in
mind that when we do this we do have to
move the state of the first one over to
the second one so for example if you're
an ERC token moving to a new version of
that ERC token you do have to have a way
to take all those mappings from the
first contract and move it to the second
one obviously there are ways to do this
since everything is on chain but if you
have have a million transfer calls I
don't want to have to write the script
that updates everyone's balance and
figures out what everyone's balance is
just so I can migrate to my new version
of the contract so there is a ton of
social convention work here to do
trailer bits has actually written a
fantastic blog on upgrading from a V1 to
a V2 or Etc with this Yeet methodology
and they give a lot of steps for moving
your storage and your state variables
over to the new contract so Link in the
description if you want to read that now
let's get to our big ticket item so in
order to have a really robust upgrading
mentality or philosophy we we need to
have some type of methodology or
framework that can update our state keep
our contract address and allow us to
update any type of logic in our smart
contracts in an easy way which leads us
to our big ticket item the proxies
proxies are the truest form of upgrades
since a user can keep interacting with
the protocols through these proxies and
not even notice that anything changed or
even got updated now these are also the
places where you can screw up the
easiest proxies use a lot of lowlevel
functionality and the main one being the
deleg call functionality delegate call
is a low-level function where the code
in the Target contract is executed in
the context of the calling contract and
message. sender and message. value also
don't change so you understand what
delegate call means now right great and
in English this means if I delegate call
a function in contract B from contract a
I will do contracts B's logic in
contract a so if contract B has a
function that says hey store this value
in a variable up top top I'm going to
store that variable in contract a this
is the PowerHouse and this combined with
the fall bang function allows us to
delegate all calls through a proxy
contract address to some other contract
this means that I can have one proxy
contract that will have the same address
forever and I can just point and Route
people to the correct implementation
contract that has the logic whenever I
want to upgrade I just deploy a new
implementation contract and point proxy
to that new implementation now whenever
a user calls a function on the proxy
contract I'm going to delegate call it
to the new contract I can just call an
admin only function on my proxy contract
let's call it upgrade or something and I
make all the contract calls go to this
new contract when we're talking about
proxies there are four pieces of
terminology that we want to keep in mind
first is the implementation contract the
implementation contract has all of our
logic and all the pieces of our protocol
whenever we upgrade we actually launch a
brand new implementation contract the
proxy contract proxy points to which
implementation is the correct one and
routes everyone's calls to the correct
implementation contract you can think
the proxy contract sits on top of the
implementations the user the user is
going to be making contract and function
calls through the proxy contract and
then some type of admin the admin is the
one who's going to decide when to
upgrade and which contract to point to
in this scenario the other cool thing
about the proxy and delegate call is
that all my storage variables are going
to be stored in the proxy contract and
not in the implementation contract this
way when I upgrade to a New Logic
contract all of my data will stay on the
proxy contract so whenever I want to
update my logic just point to a new
implementation contract if I want to add
a new storage variable or a new type of
storage I just add it in my logic
contract and the proxy contract will
pick it up now using proxies has a
couple of gachas and we're going to talk
about the gachas and then we're going to
talk about the different proxy contract
methodologies because yes there are many
proxy contract methodologies as well and
this is why TR bits doesn't really
recommend using upgradable proxies for
your smart contracts because they're
fraught with a lot of these potential
issues not to mention again you do still
have some type of admin who's going to
be upgrading your smart contracts now if
this is a governance protocol then great
you're decentralized but if this is a
single group or
entity then we have a problem the two
biggest gotas are storage clashes and
function selector clashes Now what is
does this mean when we use delegate call
remember we do the logic of contract B
inside contract a so if contract B says
we need to set value to two we go ahead
and set value to two but these smart
contracts are actually kind of dumb we
actually set the value of whatever is in
the same storage location on contract a
as contract B so if our contract looks
like this and we have two variables in
contract a we're still going to set the
first storage spot on contract a to the
new value this is really important to
know because this means we can only
append new storage variables in new
implementation contracts and we can't
reorder or change old ones this is
called storage clashing and in the
implementations we're going to talk
about they all address this issue the
next one is called function selector
clashes when we tell our proxies to
delegate call to one of these
implementations it uses what's called a
function selector to find a function the
function selector is a 4 byte hash of
the function name and the function
signature don't worry about the function
signature for now now it's possible that
a function in the implementation
contract has the same function selector
as an admin function in the proxy
contract which may cause you to do
accidentally a whole bunch of weird
stuff for example in this sample code in
front of you even though these functions
are totally different they actually have
the same function selector so yes we can
run into an issue where some harmless
function like get price has the same
function selector as upgrade proxy or
destroy proxy or something like that
this leads to our first out of the three
implementations of the proxy contracts
this is called the transparent proxy
pattern and this is actually going to be
the pattern that we're going to be
demoing to you today in this methodology
admins are only allowed to call admin
functions and they can't call any
functions in the implementation contract
and users can only call functions in the
implementation contract and not any
admin contracts this way you can't ever
accidentally have one of the two
swapping and having a function selector
clash and you running into a big issue
where you call function you probably
shouldn't have if you're an admin you're
calling admin functions if you're a user
you're calling implementation functions
so if you're an admin and you build some
crazy awesome D5 protocol you better
come up with a new wallet address
because you can't participate the second
type of proxy we're going to talk about
is the universal upgradeable proxy or
the
[Music]
UPS this version of upgradeable
contracts actually puts all the logic of
upgrading in the implementation itself
this way the solidity compiler will
actually Ki out and say hey we got two
functions in here that have the same
function selector this is also
advantageous because we have one less
read that we have to do we no longer
have to check in the proxy contract if
someone is an admin or not this saves on
gas of course and the proxy is also a
little bit smaller because of this the
issue is that if you deploy an
implementation contract without any
upgradeable functionality you're stuck
and it's back to the Yeet method with
you and the last pattern or methodology
that we're going to talk about is the
diamond pattern which doesn't number of
things but one of the biggest things
that it does it actually allows for
multiple implementation contracts this
addresses a couple different issues for
example if your contract is so big and
it doesn't fit into the one contract
maximum size you can just have multiple
contracts through this multi-
implementation method it also allows you
to make more granular upgrades like you
don't have to always deploy and upgrade
your entire smart contract you can just
upgrade little pieces of it if you've
chunked them out the disadvantages here
really only seem like you have a lot
more complicated code all the proxies
mentioned here have some type of
ethereum improvement proposal and most
of them are in the draft phase there
isn't really a standard here for the
proxy that the whole Community has
landed on and says yes this is great
let's do it so for all these be sure to
jump in the discussion and give your
thoughts all right so now that we know a
lot more about upgrades and how they
actually work and some different
methodologies behind them let's go ahead
and learn how to actually Implement some
of these strategies and Implement our
contract so that we can upgrade them now
there is a brownie upgrades mix directly
in the brownie mixes organization that
if you want to use you absolutely can
once again to do that it's just brownie
bake upgrades mix and this will have all
the code that we're going to teach you
how to use right now but let's go ahead
and build this up from scratch ourselves
so we're going to go ahead and run
brownie knit this of course we're going
to create our new Browning project here
we're going to be using the open
Zeppelin proxy contracts to actually
work with this and run with this the
methodology that we're going to be
working with is the transparent
upgradeable proxy now they've been using
the universal upgradeable proxies a
little bit more however the transparent
upgradeable proxy is really fantastic
and easy to understand so that's going
to be the one that we're going to be
working with here and these are the two
contracts that we're going to be
importing directly from open Zeppelin so
let's get to it we're going to create a
really simple contract that we can
easily tell if it's upgraded or not
we're going to be using the exact same
ones that open Zeppelin actually uses so
let's create a new file
and this is going to be called box. Soul
we're just going to have it store and
retrieve some type of value so let's
give the
spdx license
identifier of MIT so let's pick our
solidity version and for this we're
actually going to use
0.8.0 often times you're going to have
to quickly pick up new versions of
solidity anyways anyways we're going to
do contract box and we're going to give
it a u
256 private value we're going to do an
event
called value
changed Going give it a un 256 new value
give it a function
store un 256 new value this is going to
be a public function that anybody can
call and all we're going to do is we're
going to set value to be new
value and we're going to
emit this value changed
event then we're going to have a
function retrieve and this will be a
public
View and it's just going to
return the
256 value return value and this is going
to be our whole contract hopefully you
can understand everything that's going
on in this contract I should spell
license right shouldn't I now we're
going to copy all of this
code and create a new contract called
box v2. so
and we're going to paste it in and box
version two is going to be exactly the
same except we're going to add one more
function called
increment this is going to be a public
function and we're going to set value
equals Value Plus One and we're also
going to emit a value changed
event with that new value now this is
going to be really easy for us to check
to see if a contract has been upgraded
or not if we can call increment on the
same address that we originally deployed
box to then this means that the contract
has been upgraded we shouldn't be able
to call increment on this box contract
but we should be able to call it on box
V2 perfect so that's all we need to do
to get started now to actually work with
the proxies and the transparent proxy
that we're going to be working with we
do need to add them to our Browning
project so we're going to create a new
folder and we're going to call it
transparent
proxy and in here we're going to add
those two contracts we're going to add
one called proxy admin.
so and all we're going to do is we're
going to grab all the code from the open
Zepp and proxy contract and P it right
in
here since since this code is pulling
directly from an open zeppin Package we
are going to have to fiddle with the
Imports a little bit to make a match so
brownie can actually compile it and of
course since we're going to be working
with a another package we have to add
this dependencies to our brownie
config so
[Music]
dependencies
open Zeppelin slopen Zeppelin hyphen
contracts and for this one we are going
to actually use
4.1.0 then we have to do
compiler so
remappings at
open Zeppelin it's going to be equal to
this dependency now while we're in here
we might as well do
ourv so we can get our environment
variables and we'll add our wallet in
here
wallets from
Key private key we can now just have
this be at open Zeppelin SLC
contracts access ownable doou and we
don't need to change this at all because
we're actually going to keep this
transparent upgradeable proxy
doole this is the second contract that
we're actually going to grab from open
Zeppelin so let's create a new file it's
going be called transparent upgradeable
proxy doso this exact text
here and we're going to copy paste this
whole thing from open
Zeppelin
boom paste it in
here awesome and then same thing here we
just have to little reverse engineer
this at open Zeppelin contracts proxy
earc 1967 ERC 1967 proxy and perfect
that is exactly where we are so great
now if we've done this right we should
be able to run a
quick Browning
compile oops I got to change this to
box
B2 now let's run a brownie compile and
perfect looks like we have compiled got
some stuff in build great everything's
working correctly so okay so we have our
box here our box V2 we have our proxy
contracts as well that we can use to
upgrade this box to a new version we can
even look if we go back to proxy of open
Zeppelin if we look at our proxy admin
here we see it has this function upgrade
and call and this call is the upgrade to
and call on the proxy contract if we
look in the transparent proxy this
upgrade to in call calls upgraded to in
call which has been imported actually so
we can actually even go back back go to
erc1 1967 proxy upgrade look for that
again and this is the function that it's
actually going to call and it calls this
upgrade 2 function which calls this set
implementation function and all we're
doing is we're doing storage slot. getet
address slot of this implementation slot
that value is going to be this new
implementation all it's doing is it's
setting the implementation slot to being
our the new address that we want it to
use and we can see now if we look in the
proxy contract the way that it actually
works is it has this fallback function
where it's always going to delegate all
of our calls to whatever the
implementation contract is this delegate
function fun we look at it does a little
bit of low-l assembly here and it uses
this low-l delegate call to send any
function call or any call to this
contract to the implementation contract
so this is exactly the function doing
all that delegation all right so now
that we've dug deep into the code let's
actually script this out and turn this
into a script so let's create a new file
and we'll call it 01 deploy box. and
this is going to be how we're actually
going to deploy the Box
so since this is a Browning script we're
going to do def main of course our
account it's going to be equal to get
account which we going to do from
scripts.
helpful scripts
import get
account so let's go ahead credit a new
file Help full
scripts
oops full scripts. piy
and again we're just going to paste in
that get account function from our past
helpful
scripts have our our get account script
again so we can just do account equals
get account oh this should be sorry
should BEP excuse
me do a Quick
Print
ploying to do network.
show active that means we got to do from
brownie import Network then we'll do box
equals
box.
deploy
from
count the little brackets
here of course since we're going to be
deploying this contract we also have to
import that from Brownie and perfect
this alone should just deploy the Box
contract right so this means we could do
something like print box dot
retrieve and it should be zero right so
if we run brownie run
scripts A1 deploy it'll deploy that
whoops we also got to add our
EMV we don't have to put anything in
here yet because we're not actually
deploying to a real network but let's go
ahead and run this I spelled retrieve
wrong it's probably good to spell things
right let's try it again
and great so we get zero here perfect
that's exactly what we'd expect cool
however though if we
run box. increment this should air out
right boom exactly it has no attribute
increment so this is what's known as our
implementation contract this box is
implemented it's the implementation
contract now we have to hook it up to a
proxy so let's first give it a proxy
admin and proxy admins are optional
um and it's also recommended that if you
do have a proxy admin you're and you're
going to use some type of def5 protocol
sometimes it's great to have your proxy
admin be something like a multisig a
nois safe which is really fantastic
there's going to be a link in the GitHub
for learning how to actually spin one of
those up let's go ahead and do a proxy
admin because they're really helpful
anyways we could optionally we could
just set ourselves to be the proxy admin
but let's set it to be this this
contract so we'll do proxy admin
equals proxy admin. deploy and again
this will be
from count and since we're using this
proxy admin we got to import that as
well so if we look at the proxy admin we
see a couple functions here we see like
get proxy implementation which is just
going to return the address of the
implementation we have get proxy admin
which is going to be us change proxy
admin we have this upgrade which is just
going to call that upgrade function on
the proxy and and then we have upgrade
and call upgrade and call changes the
implementation to the new implementation
and then calls that initializer function
since we want these to be proxies you
can see here that we don't have a
Constructor this is intentional instead
we could have some type of
initializer function for example maybe
we want to have this store be our
Constructor instead of having a
Constructor what we do is we call what's
called our initializer function the
instant we deploy the contract for the
demo here we're just not going to have
an initializer anyways so now we have
this proxy admin we have the
implementation contract we have the
proxy admin let's Now hook them up to
the actual proxy first thing that we
need to do actually is we need to encode
the initializer function if we wanted
store to be our initializer function
like I said we could do something like
initial lizer equals box. store comma 1
and this would be our initializer box.
store combined with one what we'd then
have to do is we'd have to encode this
for our proxy if we look at our
transparent upgradable proxy if we look
at the Constructor we have address logic
address admin and data here the logic is
that implementation right this is going
to be the address of our box the admin
is going to be ourselves or in our case
it's going to be that proxy admin
contract and then data is going to be
that initializer function if we go into
the ERC 721 proxy
contract go back to proxy ERC 1967
upgrade and we look at this as one's
Constructor we can see that this data
bit here once this is built with this
Constructor it's immediately going to
call this upgrade to end call so it's
going to call this this initializer if
we go to upgrade to and call if we go
back to this upgrade contract we can see
the upgrade to and call it's going to
call this address. function delegate
call new implementation data and this is
how it actually calls that initializer
function we have to actually encode this
into bytes so we have to say box. store
is the is the function of call and then
one is going to be the first parameter
right if this is what we'd want to do so
we do box
encoded
initializer function function equals and
code function data and this is where it
gets a little bit tricky um but I
usually have this encode function data
once again in my helpful
scripts so we'll do quick def encode
function data and it's going to take an
initializer which we're going to start
off as none and then any number of
arguments after that so again this could
be like you know initi izer equals box.
store and then the arguments could be
you know 1 2 3 4 5 Etc or whatever right
for us we only have one variable that
can be put into store but this is how
you would do it and to do this Browning
actually has a built-in function that
can actually do this we can just return
initializer do and code input star args
and that's all we'd have to do however
there is a bit of an issue when the
length of the args is zero so I've
already hacked away at it for you guys
so we're just going to do if the length
of the
args is zero or we're not using an
initializer then we're going to return F
utils two
bytes x string equals
ox and we do have to import F UIL import
F utils and of course we' have to pip
install it with Pip
install F utils so I know I kind of
rushed through that but basically what
we're doing like I said is we're
encoding this into bytes so that our
smart contracts actually know what
function to call so we're just encoding
it that's all we're doing and if it's
blank or there's no initializer we're
going to return an empty hex string and
our smart contract will understand ah
okay arguments are blank here perfect
I've got a nice dock string in the
upgrades mix that explains this even
better I'm even just going to paste it
in here for now if you'd like to pause
and read this a little bit more to kind
of get the full depth of what this
function is really doing uh feel free to
do that this is a little bit lower level
solidity and evm stuff that we're
getting into here but it can be good to
know anyways okay great so now that we
have this we can go ahead and run box
encoded initializer function equals
encode function data which we would
import from our helpful scripts and this
is what we use when we call the
Constructor for our transparent
upgradeable
proxy I'm just going to have a be blank
for now but feel free to fiddle around
and try to actually use an initializer
after we run through this demo so this
box encoded initializer function is
going to be blank we're saying hey don't
use an initializer and that's totally
fine if we were to add some stuff to
here we would say hey use an initializer
so now we can actually deploy this
transparent upgradeable proxy if we open
this up with look at the Constructor we
can see what we need here so so we're
going to say proxy
equals
transparent
upgradeable
proxy.org this is going to be our
implementation contract address so we
just say box. address already because
we've already deployed this which is
great
then we're going to need our admin which
we could just say is us but we're going
to use the proxy
admin address and then last we need that
function selector we need that encoded
function call which for us is just blank
but we still need that so box encoded
initializer function and then we have to
add
from account of course and I've also
noticed that sometimes it's helpful to
add some type of gas limit
so I'll even add a gas
limit of
one one two 3 one two 3 that's six zeros
there but sometimes you might be fine
but uh with the proxies they they
sometimes have a hard time figuring out
the gas limit so I've just manually put
it in here you can if you want to it
might work fine without it and then
great let's do a Quick Print function
we'll
print
F proxy deployed
to proxy
you can now upgrade to
V2 now what we can do is on the proxy
address we can call functions so
typically right if we wanted to call a
function on this box contract we do box.
you know retrieve or however you spell
it box. store let's just do box. store
right you'd call it like this however we
want to actually call these on the
proxies right because box this box
contract address this box contract is
always going to be the the same address
and can't change the proxy code can
change we want to all these call these
functions to the proxy and not to the
box here right so the way we do that is
we can do proxy box equals contract.
from ABI we'll call it
box on the proxy do address
box.i and of course we'll import this
from
brownie what we're doing here is we're
assigning this proxy address the
ABI of the Box contract and this is
going to work because the proxy is going
to delegate all of its calls to the Box
contract typically if you put an ABI on
top of an address that doesn't have
those functions that the ABI defines it
would just airor right but the proxy is
actually going to delegate all those
calls to the box so we could actually go
ahead and try some like
print proxy box
do retrieve hopefully I spelled that
right and even though we're using the
proxy address here we are going to
delegate the call to box so let's go
ahead and run this so we'll do Browning
run
scripts deploy box it's going to deploy
the box it's going to deploy the admin
it's going to encode that initializer
function which we've set to nothing then
it's going to deploy our transparent
upgradeable proxy and then it's going to
call retrieve on the transparent
upgradeable proxy instead of our box so
let's do
this and perfect we did it right it's
returning zero here that's awesome what
we could also do is we could also do
proxy box.
store one and then we'll call retrieve
we'll see what happens
here whoops it's yelling at me because I
got to do
[Music]
from
count now let's go ahead and run it and
perfect see so after we stored on the
proxy box on this proxy we're able to
retrieve the value there so this is
fantastic all right now that we've
deployed it let's learn how to upgrade
it going to change this to deploy and
upgrade thatp and we're just going to do
everything in here so now that
everything's deployed let's go ahead and
now upgrade this so so now we can always
point to this proxy box address and it's
going to be the most recent upgrade it's
always going to have the code that we
want it to have so let's go ahead and
upgrade from box that doesn't have that
increment to box V2 that does indeed
have this increment function so let's
try this out so first thing we need to
do is we actually need to deploy that
box V2 so we'll do box V2 equals box
2.
deploy we'll say
from account and we'll leave it like
that of course we're going to have to
import box V2 from
Brownie and right now actually let's
even do proxy box
increment right if we call boxy Pro
proxy box. increment from account this
should error right it shouldn't be able
to call this increment function because
that doesn't exist oh and then we also
changed the name of the script sorry
this is actually going to be deploy an
upgrade and perfect we see it actually
errors out here it says Hey box object
doesn't have this increment function
you're crazy I don't know what you're
talking about we good that's what we
want to do so let's delete that line box
V2 even do a quick
little upgrade
here now all we need to do is call and
upgrade function now basically all we
have to do is call this upgrade to
function right but depending on if we've
added axy admin contract if we're using
initializer function there might be a
couple of of different ways to go about
this so I like to just wrap everything
up into its own upgrade function you'll
see what I mean in just a second so what
I like to do again we're going to pop
into our helpful scripts and we're going
to create a new one called upgrade now
for parameters in here of course we're
going to take some type of account so
that we have something to account to
deploy
from we're going to use the proxy which
is again going to be that proxy contract
which is going to be our our proxy
contract here we're going to need a
new
implementation address we're going to
need the proxy
admin
contract which could be none for us
we're going to have one but it could be
none and then we're going to have an
initializer
which also could be none and then we're
going to have the args for the
initializer which also could be none
again this star is a special thing in
Python which says any number of
arguments will just get stored into this
list called arcs and perfect this is
going to be our function that's just
going to take care of everything for us
so first thing let's check to see if
there is a proxy admin contract so we'll
say if there is a proxy admin contract
then we want to check to see if there's
an initializer
what we're going to do is we're first
going to want to encode that function
data of course so we'll say
encoded function call equals encode
function data with the
initializer and those star
args this is going to be the encoded
initializer function here then all we
have to do and actually let's do start
with a blank transaction equals none say
transaction equals proxy admin contract
since we're using one of these proxy
admin contracts since we've detected one
dot upgrade and call since we also have
an
initializer we're going to pass the
proxy do
address new implementation
address and the encoded function call
and then of course from account so this
upgrade and call if we look in that
proxy
admin there's this upgrade and call
function right on the proxy admin and it
just calls upgrade to and call of the
proxy contract so hopefully don't don't
let this boggy down a little bit that
there's kind of a lot of mix and
matching going on but this is what's
going on oop sorry this is encoded
function call not encoded function data
great now if they don't have an
initializer well what do we do well we
don't need to encode any function call
here we can just say
transaction equals that proxy admin
contract.
upgrade so it has an upgrade and call it
also just has a regular old upgrade so
we'll just call upgrade and we'll give
it the proxy do
address the new implementation address
and then
from account now if it doesn't have a
proxy admin contract this means that the
admin is just going to be a regular old
wallet well what do we do do then well
first check to see if it has an
initializer still and if it does we need
again to encode that function call we
can just copy and paste that there then
once that's encoded we can just call
directly off the proxy contract we're
going to call exactly what the proxy
admin contract is calling which going to
be proxy
upgrade to and call we're going to give
it the new implementation address the
encoded function
call and then from
account let's wrap this all up in a big
else so if proxy admin contract do this
stuff else do this
stuff if initializer do that otherwise
we can just do transaction equals proxy
do upgrade two and we just add that new
implementation
address from
count and then we'll finally return
transaction so I know that there is a
lot here but we're really just making
this upgrade function really General we
could always just know okay if we we're
going to use a proxy admin let's just do
it like this okay no we're not going to
use a proxy admin we're also not going
to use an initializer great it would
just look like this but this is
essentially all that we have to do so
now that we now that we have our upgrade
function we can go ahead and use it here
so we need to give it an account a proxy
a new implementation address so we'll
say account so we'll say
upgrade transaction equals upgrade
account we need a proxy and a new
implementation address we're going to
give it the
proxy and we're going to give it box b2.
address for that new address
we do have a proxy admin
contract so we'll say
proxy
admin contract
equals proxy admin and we don't have an
initializer so we can leave that part
blank of course we need to import this
upgrade function from our helpful
scripts and this is all that we need so
now we can do
print proxy has been upgraded and what
we could do now is we can do proxy box
equals
contract. from
AI we'll call it box
V2 we give it the proxy do address box
v2.
ABI and now we should be able to call
proxy box.
increment
from account and then we can
print proxy box. re
retrieve and this should now be one and
what we'll actually see is that this
will return two why does it return two
well in our original proxy box we stored
one so it started with one we then
upgraded to this new contract and then
let's actually just do a weit of course
we upgraded to a new contract right here
however the storage of that contract
stayed in the proxy so that one stayed
in the proxy so even though we upgraded
the contract there's still one stored at
the location of storage so then when we
call increment now and then we call
retrieve it's going to go from one to
two so let's go ahead and and run this
brownie run
scripts Loy upgrade
enter and boom that is exactly what we
see output here this is an incredibly
incredibly powerful and advanced feature
and if you've gotten to this point you
are on the border of being one of the
most powerful smart contract Engineers
on the planet huge congratulations for
getting this far but we're not quite
done we of course need to write some
tests because that is what's going to
make sure our project always stays in
sync and always stays up to dat so let's
write a couple of tests here so let's
create a new file we'll call testbox
proxy dopy and for this we're really
just going to test to see that our
contracts work we're going to see that
this box actually is going to work
correctly so let's create a new test def
proxy delegates
calls so we're going to make sure that
we actually can delegate calls to our
contract we're going to say account
equals get
account which means we got to do
from scripts. helpful
scripts import get account then we're
going to do box
equals box.
deoy of course this is going to be
from account since we're using box we're
going to do from brownie
import box we're going to do this proxy
admin so we're going to say proxy admin
equals proxy
admin
deploy of course
from
count let's import proxy admin from
brownie all right so now we'll do the
Box encoded
initializer
function or whatever we called it before
this is going to be that
encode function data which uh my vs code
actually automatically imported thanks
vs code and again we're leaving it blank
uh because we're not actually going to
have a store there and then we're just
going to go ahead and run that
deployment so we're going to say proxy
equals trans parent
upgradeable
proxy and we're going to grab this from
brownie.
deploy say again the box.
address proxy admin.
address box encoded initializer
function we say from account and then
we'll give this a gas
limit
of 3 1 two 3 now we're going to put the
ABI on top of this proxy so we're going
to say proxy box
equals contract. from ABI we going to
name it
box this is going to be with the proxy
address and the box.
ABI of course we're going to need to
report contract from Brownie and okay so
now we can
assert proxy
box.
retrieve if I spelled that right is
equal to zero then we're going to do
proxy
box.
store do one and this will be from
account and then we're going to assert
again this proxy box. retrieve should
now equal one so we're using this proxy
contract we've slapped the AI on top of
it and this should work so we're just
testing to see that our proxy is working
correctly
so we can go ahead and test this then
with rounding test and beautiful it
passed now let's go ahead and create a
new script for testing the upgrades
create a new file call it test box V2
upgrades. piy and let's do it call def
test proxy
upgrades so account is going to be equal
to get account hopefully at this point
you're getting pretty good at writing
these these tests from scripts. helpful
scripts report and of course we want to
add this in
nitpy just in case you forgot so now
we're going to import get
account perfect so we have our account
here now as you can see we're doing a
lot of this box equals box. deploy
deploy the proxy admin it would probably
make sense in one of your scripts to
just write a deploy three to write a
function called like deploy all or
something like that so again if you guys
want to learn more if you want to
improve upon this I would highly
recommend you go back and you make some
of those improvements to to Really
modularize this up but for the time
being let's just keep going so box.
deploy
from account and since we're doing this
we're going to do from brownie import
box say proxy admin equals proxy admin.
deploy
this will also be
from
account comma proxy admin we're going to
get those initializer functions so we'll
say box encoded initializer
function equals
encode function data which we're going
to grab from our helpful scripts as well
then we're going to do the proxy
again proxy equals transparent up
gradable proxy that
deploy got to import this from browny as
well oops not twice
though
deploy it's going to have the box set
address proxy admin.
address box encoded initializer
function from
account guas limit
one two 3 one two three all right so we
have the proxy deployed we've already
tested that this proxy Works in this
test box proxy so we're not going to go
ahead and test that again what we're
going to do instead now is now we're
going to deploy box
V2 and we're going to update the proxy
and make sure that everything still
works so we're going to do box V2 equals
box v2. deploy
it's going to be
from account of course now we're going
to say
proxy box equals contract. from
ABI box
V2 roxy.
address box b2.
ABI and we're going to
grab both
this and this from brownie
and what we're going to try to do is
slapping this ABI onto this proxy
address we're going to try to call a
function only box V2 can call however we
know that like what we tested before it
actually should revert so we can
actually check for reverts by
importing py test and we can say with py
test. raises and I know that um this is
a brownie exception I know what type of
exception this is it's an
exceptions. virtual machine
error you can figure out what type of
error this is by um just just running it
and getting the error so this is
actually from brownie this exceptions
thing so we're going to actually also
import exceptions from brownie we're
going to
say proxy box.
increment from
count and I saved and everything sorry
got formatted here but calling proxy
box. increment should throw this
exceptions. virtual machine error so
this test will pass if this throws an
error and that's how we test that so we
want this to throw an error the first
time we call it then we're going to
upgrade and then we'll call it again and
it'll actually work now we're going to
call
upgrade on count proxy box
V2 proxy admin
contract
equals proxy
admin we're going to need to grab
upgrade from our helpful scripts and now
we should actually be able to call
increment with our proxy box so first
we'll do an quick assert proxy
box. retrieve equals z then we'll do
proxy box. increment
from account and then we'll
assert proxy box.
retrieve is one so we're deploying our
box we're deploying our proxy and
everything around it then we're
deploying our V tool implementation
we're trying to call increment which
won't work we then upgrade our proxy to
this new address and then we can go
ahead and call increment and it should
actually increment our box here so let's
go ahead and run this test rny run test
excuse me Ry test-
K grab this paste it
in and we've done it our tests are
working correctly so we know that our
box is working correctly awesome great
job like I said this is an incredibly
incredibly powerful feature to be able
to do these upgrades with these there
comes a lot of risk at least in the form
of centralization risk if you're the
only wallet that controls the proxy that
means your application is centralized
full stop so if you're going to deploy
anything with proxies to mainnet
absolutely absolutely be sure to get it
audited
beforehand now before we close this
project up let's actually deploy this to
an actual test net so that we can see
everything that goes on when we call
this deploy an upgrade let's go ahead
and do it so let's pop into our EMV file
and let's paste the variables that we
have in here we need the private key web
3 inferior project ID The Ether scan
token awesome let's even let's even
publish the source of all these
contracts so that we can see them on
ether scan so for box we're going to do
a little comma here we'll say publish
Source equals true I'm just going to
copy this comma to publish Source equals
true and paste it on all of my
deployments Source true publish Source
equals true on the on the
admin on the initial transparent
upgradeable
proxy on the box V2 deployment and
that's it I've got my ether scan token
my web 3 INF fura my private key my
brownie config is indeed pulling from
the private key myv hasv let's check to
see my wallet we have some r be in here
perfect let's do this brownie run
scripts deploy an upgrade Network rink
B all right so it looks like a couple of
our contracts weren't able to actually
verify there are a couple bugs being
worked out with some of the
verifications so we're going to ignore
the ones that weren't able to be
verified here but let's go ahead grab
these addresses pop them onto the rinky
ether scan and see what just happened
this is our box implementation let's
grab this address let's paste it into
the rinky testet ether scan awesome this
is exactly what we have contract has
been verified this is exactly the code
that we have here and we can see all we
have is a contract creation and this is
exactly correct because when we call the
store function on this it's actually
going to get stored we never actually
called any functions directly on this
contract all we did was deploy it which
makes perfect sense let's go check out
this proxy admin now this second address
second contract that we deployed sadly
this one didn't get verified however we
can see we did indeed call this upgrade
function at some point which makes a lot
of sense if we look at our script proxy
admin in our upgrade code since we did
have a proxy admin contract we did call
that upgrade function perfect makes
sense now let's go to this transparent
upgradeable proxy this is going to be
the most interesting one out of all of
our applications interestingly enough we
look at this contract we can see store
and increment both have been called on
this contract not on the box because
again this is the proxy that we're going
to call all the functions on to make our
contracts gradable internal transactions
are calls that another smart contract
made to this transaction and if we look
at a couple of these we can see if we
click more we had increment called from
another contract which makes sense we
had upgrade called from the proxy admin
and then we also of course we had store
called from another contract and if we
verified this we would be able to see
ether scan recogniz this as a proxy
contract as well hopefully when you work
with this you'll be able to verify it as
well but if not not a big deal you can
always just manually do it later
yourself so this was an incredibly
powerful project that we just did here
and that we worked on and all right
maybe take a nap maybe go for a walk get
some food get a drink because we are on
to our last coding project now I do want
to say that this project is considered a
bonus because we're going to be going
very quickly over the front end pieces
we're going to take all the building
blocks that we've learned and build an
amazing full stack application gear up
get ready let's jump into this bonus
project and then after we finish this up
we're going to close everything out with
a final quick section about security
future and and thank you for joining
this course so let's do this last
one all right now we are moving on to
our final project this is going to be
the most advanced projects and combine
all the knowledge that we've learned so
far into one project then we're
additionally going to put a front end or
a user interface onto this project when
we build our own applications we're
going to need a way for nevs to actually
interact with it in a meaningful way so
now this isn't a front-end or react
tutorial course although we will be
explaining some of the choices that
we've made and how to actually do them
you should be able to follow along fine
even if you don't have any front-end
experience here if you're looking for a
full front-end tutorial freec code Camp
has some amazing videos that you can
absolutely try out all right welcome
back everybody and now we are going to
be embarking on the most exciting the
most end to endend we're going to take
everything that we've learned and wrap
it all together in this single last
application here and we're also going to
be learning about front-end development
and we're going to be building a front
end on top of our application on top of
our contracts here now this isn't a
frontend tutorial however fre Cod Camp
has some wonderful wonderful react
tutorials we're going to be teaching you
guys just enough so that you can go
ahead jump in and build your own simple
but also kind of nice looking front ends
on top of whatever contracts that you
have for those of you who want users to
actually interact with your applications
and interact with your contracts
building a usable front end is a really
important piece so let's take a quick
walkr of what this application is going
to look like so here is our our front
end here and what this application is
going to allow users to do is it's going
to allow users to stake or deposit their
tokens into what's called our token Farm
contract once they have some token
deposited that's when you can kind of go
get creative with what you want those
tokens to do you could use it as staking
in some governance you could use it to
you could go ahead and invest it in
something like a or another D5 protocol
to gain interest you could build a yield
aggregator there's a ton of ton of
different features that you can actually
do once you have users stake their
tokens and here's how they would do it
on their UI side so we have this little
button here which we go ahead and click
connect on metamask is going to pop up
and we're automatically going to sign in
that's going to connect our metamask to
this user interface now so if I look at
my metamask I'm on the Coen test Network
we can see that I am indeed connected
now what I can do is I can now stake
some of my tokens into this contract we
currently have three different types of
tokens that this platform allows you to
stake wrapped ether
FIU which is mimicking die on the test
Network and our dap token this dap token
is going to be the reward token that our
platform gives users as an incentive for
staking on our platform once we stake we
can actually then unstake and that's
really it so we'll go ahead and stake
maybe we'll stake 10 dap we'll hit stake
minim mask will pop up this is the
approve function this first approved
function that gets called we get a a
really nice little waiting bar here and
once it's been approved we get a
notification saying the transfer has
been approved we then go ahead we'll
confirm staking we'll get this little
loading bar while it's being staked and
we'll see that popup that says tokens
staked successfully now if we go to the
Token Farm contract we can see that we
have 10 of this dap token staked we can
also unstake it the other thing that we
can do is as admins of this wallet we
can actually issue a reward to our users
based on how much how much they've
staked so you see right now we have 95
dap token we have 10 dap token staked on
the back end I'm going to run an issue
token script it's going to send all
users that have some stake a little bit
of a Dap token reward now you can see
it's been updated and we have we've been
given a little bit of dap token that
resembles the amount of dap token that
we have staked the way that we figure
out the value of all of our different
tokens is using of course chain the
price feeds we can then of course
unstake
everything and we see tokens unstaked
successfully and that's it and this is
what we're going to build now we aren't
going to go over the unstaking portion
of the front end application here but
here's what it would look like if you
were to go ahead and finished building
out the front end yourself there is a
full repository with the entire front
end with this unstaking piece but for
Simplicity we're just going to skip over
this unstaking bit so let's go ahead and
get started I'm going to go ahead and
make a new directory called D5
stake
yield
Brownie and then I'm going to
open this up in a new text editor now
the first thing of course that we want
to work with is going to be our contract
so we're in here remember always start
with brownie knit or you can start with
the chain link mix I'm just going to go
ah a and start with brownie knit and
perfect here is our setup all right
first thing we're going to do is we're
going to make
our dap token. so this is going to be
the token that we're going to give out
to users who are staking on our platform
this is our reward token you might have
heard of yield farming or liquidity
mining this is our token that allows
users to actually engage and participate
in that and this is just a regular old
erc20 so you guys already know we've
done this before and for this one we're
even going to use the latest and
greatest in solidity remember I said
that you're going to have to get really
good at bouncing around between solidity
versions so for this one we're going to
do everything in 0. eight so let's go
ahead and do that so we're going to do
pragma
solidity
0.8.0 and we're going to do this the
exact same way we made our other erc20
token we're going to go ahead and use
open Zeppelin again we can even just
copy paste the import from their
documentation or we can just write out
import at open Zeppelin SLC contracts SL
token
erc20 erc20
soul and you guessed it because we're
using this at open Zeppelin syntax we're
going to make a new
file rting config.yml going to make some
dependencies we'll do
open Zeppelin
slopen
Zeppelin contracts this time we're going
to actually use version four of these at
4.2.0 and again you can find out
everything about this package by going
to open zeppin slopen zeppin contracts
on GitHub and then
compiler
sulk
remappings at open Zeppelin
equals this part right
here paste it in okay great then what we
can do we can go back to our dap token
and just do some basic erc20 bits here
so we'll do contract dap token is erc20
and we'll give it our Constructor
public
erc20 we'll call
it dep token and we'll give it a symbol
of dep and we'll give it an initial
Supply as well so we'll call the mint
function
and we'll set the message. sender as the
owner give it an initial supply of 1
million which will be one 1 two 3 one
two three plus those 18 zeros so 1 two
three four five six seven eight nine 10
1 two three four five six seven
eight and now that we have our first
contract we can try to compile it
brownie
compile and looks like it worked great
now we're going to go on to create our
more interesting contract
our token
Farm we can even take a quick second and
figure out what we want this to be able
to do well we want to be able to stake
tokens unstake tokens issue tokens this
is going to be issuing those token
rewards we're probably going to want to
add allowed tokens to add more tokens to
be allowed to be staked on our contract
and we're probably going to want some
type of get F value function where we
can actually get the value of the
underlying Stak tokens in the platform
with that in mind let's move on
so you know the drill pragma solidity
carat
0.8.0 and we're going to be here for a
while so I'm going to close those
out and this will be our
contract token Farm contract token farm
and let's not forget our s PDX
license
identifier of MIT well let's go ahead
and start with the staking of the tokens
right because that's going to be the
most important piece of our application
so we're going to do
function stake tokens they'll probably
want to stake an amount of
token and they'll probably want to stake
a certain address of the token so some
amount of some token now there's a
couple things we need to keep in mind
here what tokens can they
stake how much can they stake so these
are our first two questions for our
application we're just going to say you
can stake any amount greater than zero
so we can even add that we'll do
require amount is greater than zero and
if it's not we'll just say amount must
be more than
zero and since we're using version eight
we don't have to worry about anything to
do with safe math which is awesome so we
can just go ahead and do stuff like this
we now we only want certain specific
tokens to be staked on our platform so
we could say require token is allowed or
something to this effect so we might
have to actually create a token is
allowed function so let's go ahead and
create that function
token is
allowed it'll take some token address we
make it a public function and it'll
return Boolean it'll return true if that
token's allowed or false if it's not
allowed so how do we know if a token is
actually allowed we probably want some
list or some mapping of these tokens and
whether or not they're allowed after all
we've learned you'll probably learn that
there definitely are some trade-offs
between lists and mappings here for
simplicity's sake we're just going to
stick with the list for now
so we're going to create an address
array we'll make it public called
allowed
token and this will just be a list of
all the different allowed tokens for our
token is allowed function we'll just
Loop through this list and see if that
token is in there so we'll do a for
Loop
four un
256 allow tokens index equals zero
allowed tokens index is less
than allowed tokens.
length allowed tokens
index Plus+ so we're going to Loop
through this list and we're just going
to say
if allowed
tokens of allowed tokens index equals
[Music]
equals this token
then we're going to return
true otherwise if we get through this
whole for Loop and we don't find this
token in here we're just going to return
false now we have a way to check to see
if allow tokens are there let's actually
write a function to add alloud tokens so
we can do function add alloud
tokens address token public function and
we'll do allowed tokens and we'll just
push
it onto that array now adding allowed
tokens is probably something we only
want the admin wallet or the owner of
this contract to do so we'll add only
owner as a modifier to this function and
we'll make this token Farm ownable is
ownable and we'll import from open
Zeppelin here too import at open zeppin
contracts
access ownable doso
do a quick
compile great things are being compiled
fantastically now that we have a little
bit of functionality here now might be a
good time to actually go ahead and start
writing some tests if you want to since
I know that we're going to change the
Constructor a little bit and we're going
to change a little bit of how this is
actually formatted I'm just going to
keep going but now might be a great time
hm should I start writing some tests for
my application you know we're going to
do those tests later on anyways though
all right great but in any case now that
we have these two functions we can go
ahead and actually start checking to see
if the tokens that these stakers are
going to stake is actually allowed so
what we can do now is we're going to add
this require statement in we can require
token is
allowed of
token otherwise we'll just say token is
currently not
allowed and perfect now we have two
required statements that answer these
questions what tokens can they stake and
how much can they stake so now all we
have to do is we just have to call the
transfer from function on the erc20
remember erc20 remember ER c20s have
these two transfer type functions they
have transfer and they also have
transfer from transfer only works if
it's being called from the wallet who
owns the tokens if we don't own the
token we have to do transfer from and
they have to call approve first so we're
going to call the transfer from so we're
going to call the transfer from function
on the erc20 since our token Farm
contract isn't the one that owns the
erc20 we also have to we also have to
have the Avi to actually call this
transfer from function so we're going to
need the ic20 interface we could go
ahead and pop it in here we could also
make an ec20 contract we could also just
grab it from open Zeppelin so we'll do
import at open Zeppelin SL contracts SL
token erc20
ic20 Soul we're using the interface here
because we don't need the whole contract
anyways let's now wrap ic20 let's wrap
this token address as an erc20 token so
now we have the
ABI via this interface and the address
and we'll call.
transfer
from from the message.
sender and we'll send
it to this token Farm contract so from
whoever calls stake tokens to this token
Farm contract and we'll send the
amount and perfect now we just need to
keep track of how much of these tokens
they've actually sent us so we're going
to want to create some type of mapping
here and this mapping is going to map
token
address
to Staker address to the amount this way
we can keep track of how much of each
token each Staker has staked so it's a
mapping per token per Staker per amount
so we'll just call
this mapping of that token address which
is going to get mapped to another
mapping
of
those user addresses which then gets
mapped to a un 256 so we're mapping the
token address to the Staker address to
the amount we'll make this a public
mapping we'll call
it staking balance now that we have this
mapping in our stake token function what
we can do is we can say staking balance
of this
token from message. sender
is now going to equal whatever balance
that they had before
plus the amount all right this is great
now we have a way for users to stake
different tokens that we've actually
allowed them to stake on our platform
awesome work so what do we want them to
be able to do next we want them to
unstake tokens we want to be able to
issue some reward we want to be able to
get the eth value based on that reward
typically you might want to do this
unstake tokens bit first however I know
that we're actually going to need some
additional functionality in our stake
tokens function for us to actually issue
tokens properly so let's just go ahead
and do this issue tokens bit remember
this issue tokens is a reward we're
giving to the users who use our platform
so we want to issue some tokens based
off the value of the underlying tokens
that they've they've given us so for
example maybe they've deposited 100 eth
and we want to
do a ratio of one to one for every one
eth we give one dap token that's pretty
easy for us to figure out however let's
say they have 50 eth and 50 die staked
and we want to give a reward of one
dap one dap token per one
die well then we'd have to convert all
of our eth into die so that we know that
conversion ratio for the DAP token
so that's the problem that we're going
to work on now let's create this
function called issue
tokens
this is going to be a function only
callable Again by the owner or the admin
of this contract so how do we actually
go ahead and issue tokens here well the
first thought would be to Loop through a
list of all the stakers that we have but
right now we don't have a list of
stakers what do we have we have a
mapping of stakers and we have a list of
allowed tokens well we're probably going
to need to have a list of stakers so
we'll do an address array because again
we can't Loop through a mapping so we'll
do an address array make it public
called
stakers is just a list of all the
different stakers on our platform now
when somebody Stakes a token we're going
to have to update this list we want to
make sure they're only added if they're
not already on the list so in order for
us to do this we should get an idea of
how many unique tokens a user actually
has so I'm going to create a function
called update
unique tokens Stak with message. sender
and the token and what this function is
going to do it's going to get a good
idea of how many unique tokens a user
has and if a user has one unique token
we can add them to the list if they have
more than one we know know that they've
already been added to the list so we
don't need to add them there so let's
create this
function update unique token State we'll
have it input an
address
user and an
address token and we'll make
this an internal function so that only
this contract can call this function and
what we'll say is if
staking
balance let's even do a little
underscores
here of
token of user is less than or equal to
zero we're going to update some unique
tokens staked mapping so we'll say
unique tokens
Stak of the user it's going to equal the
unique token Staker of the user plus one
and since we have this new mapping
called unique token Stak we'll make that
as
well so we'll do a
mapping of an address to a un
256 public called unique tokens Stak so
this way we know how many different
tokens each one of these addresses
actually has staked now that we have a
better idea of the unique tokens each
one of these users has staked what we
can do is we can figure out whether or
not we want to push them onto this
stakers list if they're already on there
we don't want to push them on there if
they're not on there then we do want to
push them on there so we can just do is
say if unique token
state of message. sender is equal to one
if they have one unique token staked if
this is their first unique token we're
going to add them to that stakers list
so we'll say stakers
push message. sender and this is going
to be our completed stake tokens
function here so we had to add this
little extra functionality between the
unique tokens to figure out how to
actually issue some reward for them but
now that we have this list and it's
going to get updated here and it'll also
get updated when we unstake what we can
do now is just Loop through this list of
stakers so we can say
four you
256 stakers index equals zero stakers
index is less than stakers
length stakers index
Plus+ and now we're going to issue some
of these tokens here so we're going to
say the
address recipient equals
sakers sers index so one at a time we're
going to Loop through grab these
recipients and then we're going to send
them a token
reward based on their
total value
locked so we got to do a couple things
here we have to send them a token reward
we have to figure out how to actually
send them this token and then we also
have to get their total value locked so
let's do this to send them a token
reward this is going to be this dap
token that we created in the beginning
this is going to be our dap token so
right when we deploy this contract we
need to know what a reward token is
actually going to be so we can do right
at the top and then I'm actually G to
I'm actually just going to move this
array up here so that they're all kind
of nicely together what we need to do is
we need to create a Constructor right
when we deploy this contract we need to
know what is the address of the DAP
token what's the address of the reward
token that we're going to give out so we
can say Constructor it will be passed an
address of the DAP token
address this will be a public function
and we'll store this dap token as a
global variable
so we can say ic20 since we're already
importing it here
public dap
token what we can do now is set dap
token equals
ic20 dap token address so now we have
this dap token with its Associated
address and what we can do now is call
functions on it for example we can
call dap token
transfer we can call transfer here
because our token Farm contract is going
to be the contract that actually holds
all these DB tokens and we're going to
send this token
to the recipient of course but how much
are we going to send right how much this
of this
token are we going to send to them well
we need some function to get the total
value so we're going to say you and 256
user total value equals some function
right and we can go ahead and Define
that right now we'll call this function
get user total value right or get
recipient total value or whatever you
want to say so we'll pop recipient in
here and let's go ahead and create this
function so we'll call function get user
total
value
address user and this is where we do a
lot of looping right we're got to we got
to find out how much each of these token
actually has now what a lot of protocols
do instead of actually them sending and
them issuing the tokens is they actually
just have some internal method that
allows people to go and claim their
tokens right you've probably seen that
before people claiming airdrops that's
because it's a lot more gas efficient to
have users claim the aird dropped
instead of the application actually
issuing the tokens right it's going to
be very gas expensive to do looping
through all these addresses and checking
all these addresses right we're going to
do it though because we are a wonderful
amazing protocol and we want to give our
users the best experience but in any
case this is going to be a public view
function that will return a un 256 right
because we want to return this total
value to our issue tokens function up
here so how do we actually get started
here well let's create a unit 256 total
value and we'll set it off to start it
to be zero here and let's even start it
off with a quick require statement right
we want to
require that the unique token state of
this
user is going to be greater than zero
right and if it's not we'll say they
don't have any tokens stake right so the
value is going to be nothing now if this
is true if they have some token staked
we'll go ahead and find it so we're
going to Loop through those allowed
tokens up here the allowed tokens and
we're going to find how much this user
has for each one of these allowed tokens
so we're going to say four unint
256 allowed tokens index equals Zer
allowed tokens index is less than
allowed tokens. length allowed tokens
index
Plus+ and let's go ahead and we'll add
the total value and now we'll say the
total value is going to be equal to the
total Value Plus however much
value this person has in these tokens in
this single token so get user total
value is the total value across all the
different tokens we need a way to get
the total value across one token so
we're going to create a new function
called get user single token value and
we'll pass it our user and we'll also
pass it this single token that we're on
right now so we'll pass it allow
tokens allow token index
so we got to create a new function here
function get user single token value
this is going to take an address of a
user and an address of a token it's
going to be a public function I'm just
going to put this on a new line to make
it a little easier to see it's going to
be a view function and it's going to
return a u in 256 we want to get the
value of how much this person staked of
this single token so for example if
they've staked
1
e and the price of one e is $22,000 we
want to make sure that this returns
$2,000 or if they have 200 die stakes
and the price of 200 die is $200 we want
to make sure this returns 200 right so
we're getting that conversion rate we're
getting exactly how much value this
person has staked in our application now
we'll do a quick if we'll say
if unique token state
of the user is less than or equal to
zero then we'll just go ahead and return
zero right we don't want to do a require
here right as we did up here because we
want this to actually keep going right
if this is zero we don't want the
transaction to actually revert okay we
want this to keep going so how do we
actually get the value of a single token
what we're going to need to get the
staking balance right but we also need
the price of that token so we're going
to need to get the price of the token
and then multiply that by the staking
balance of the token of the user so once
again we need to create another function
we'll call this one get token value so
in another
function we're going to call get token
value get pass an address of a
token we'll make this a public view
function that will turn a un
256 and this of course is where we need
some pricing information and this is
where we're going to actually work with
the chain link price feeds once again
and hopefully this part is going to be a
little bit more familiar for you so what
we're going to need is a price
feed address that's the first thing that
we're going to need so we're going to
actually have to map each token to their
Associated price feed addresses so we're
going to need some mapping that does
that right so we're going to need some
mapping it's going to map an address
to an address it's going to be a public
one and this is going to be token price
feed mapping right it's going to map the
token to their Associated price feeds
and with that that means we're going to
have to have a function called set price
feed contract where we actually set the
price feed associated with a token so
this will take an address of a
token and an address of a price feed
this will be a public and this will be
only
owner we don't want anybody to be able
to set what these price feeds should be
we just want the owner to be able to do
this so we'll do token price feed
mapping of the token is going to
equal the price feed and that's it so
now we have a way to set the price feed
contracts we have a way to map the
tokens to the price feeds right and
again go to docs. chain. link we can go
to Price feeds ethereum price feeds we
can find these different price feeds
here and this is where we're going to
set those price feeds now back down in
our get token value we can grab that
price feed address now by saying
address price feed address is going to
equal that token price feed
mapping of that token parameter and now
that we have this we can use it on an
aggregator V3 interface again we can
always go back to the docs here we can
grab this bit right here of course we're
going to change
it to be
0.8 and for those of you who would
rather I just wrote it out we're going
to
import at chainlink contracts
slsrc slash
interfaces SL agregator V3
interface. soul and since we're doing
this import we're going to go to our
brownie
config smart contract kit slash
chainlink brownie
contracts we're going to see what's the
latest version of these now I'm going to
point something out this package
recently changed to mirror the mpm
package versions so it does look like it
went backwards in versions and there's
even a little little update here uh but
this is the
the newest version even though it's a
0.2.1 it's literally just to match the
mpm contract tags so this is what we're
going to use so we're going to do at
0.2.1 then in our remappings we'll also
do at chain link
equals this bid right
here now that we've imported that we can
now grab that aggregator V3
interface or that price feed
and say aggregator V3 interface of price
feed
address and grab that price feed
contract then once we have this price
feed contract we can call latest round
data and again you can always check back
to the documentation to see what that
function actually looks like and this is
going to return it's going to return a
whole bunch of stuff but we only care
about the price so the first thing it
returns is round ID we don't care about
that so we'll just put a comma we do
care about the in 256 price so we'll put
that in there uh but we don't care about
the rest of these so we'll just do comma
comma comma because we only care about
the price
here we also care about the decimals we
need to know how many decimals the price
feed contract has that way we can match
everything up to be using the same units
so we'll say U
256
decimals equals price do decimal and
what we can do now is we can return both
of these so this actually needs to
return a un 256 and another U
256 the decimals here and we could do
return we can return both of these so
we'll do a uent 256 price we'll wrap
that price into a u 256 then we also
need to
wrap the decimals in a u and six since
decimals actually returns a uint 8 so
we'll return the price and the decimals
all right now we're cooking now we can
go ahead and start scrolling back up and
adding all this stuff in so we can say
you in 256
price you went 256
decimal equals this get token value that
we just created right here and then we
can just have this return staking
balance of the
token of the user times the
price we're going to do some interesting
math here divided by those decimals 10
raised 2
decimals and I know there's a little bit
of math here right and so you might be
going wait wait what are we doing here
wrap that up like that just so that
we're absolutely certain we're doing
correct order of operations here so
we're taking the amount of token that
the user has staked right let's say for
example
10 die and we're taking the price of
that die maybe we have all of our
contracts all these tokens get converted
back to the USD price so we have die USD
or actually better yet let say we have
10 eth right our price feed contract is
going to be eth
USD let's say the price is is 100 $100
per USD so this first bit is we're going
to do that 10 e time $100 so we're going
to do 10 * 100 which is going to equal
to 1,000 1,00 value the only thing is we
also have to divide by the decimals so
our staking balance is going to be in 18
decimals so it's going to be 1 2 3 4 5 6
7 8 1 2 3 4 5 6 7 8 nine 10 but let's
say our FUSD only has eight so 1 2 3 4 5
six seven eight so we need to multiply
these first
and then divide by the decimals that way
we can arrive at a price that actually
makes sense is going to be a function
that we're definitely definitely
definitely going to need to test to make
sure that we're doing everything right
so that we're doing all the math
correctly but okay now that we have this
user single token value we go ahead and
come back up to our user total value and
we can literally finish this function by
just calling return total value and then
we can pull up to our issue tokens now
that we have the total value that this
user has actually locked we can just
transfer the amount of tokens that they
have in total value so we can say dap
token
transfer this recipient we can transfer
them the total value right we'll say
however much they have in total value
staked on our platform we'll issue them
as a reward and that is our issue tokens
function we are making great progress
progress all right so we have a way to
stake done we have a way to issue done
we have a way to
get value or just get value done we've
add
way to add allow tokens and all we have
to do now is add some way to unstake the
tokens so let's go ahead and create this
function I'm going to make it right
underneath the stake token one we do
function
stake tokens we'll do we'll pass it
token address we'll make this a public
function so anybody can call this the
first thing we're going to want to do is
fetch the staking balance how much of
this token does this user have so we'll
say you 256 balance
equals staking balance of the
token from message. sender and we're
going to
require the balance bance is greater
than
zero otherwise we'll say staking balance
cannot be
zero and then we're going to do a
transfer so we'll do
ic20 of the
token.
transfer message.
sender
balance once we actually transfer the
token we'll do staking balance
of this
token of message. sender we're going to
update this balance to now be zero right
because we're going to transfer the
entire balance here and then we're going
to update how many of those unique
tokens that they have now a quick note
here later on we're going to learn about
re-entrancy attacks so at some point
come back here and figure out hey is
this vulnerable to re-entrancy attacks
so we'll say
unique token state of message. sender
is going to equal unique token
State sender minus one now the last
thing that we could do is we probably
should actually update our stakers array
to remove this person if they no longer
have anything staked this is a little
bit sloppy but we're just going to skip
doing that for the time being however if
you want to go back and add the
functionality to remove the stakers from
the stakers list as they unstake please
go for it it's not a big deal if we
don't actually do this because our issue
tokens function is actually going to
check to see how much they actually have
staked and if they don't have anything
Stak then they're not going to get sent
any tokens but all right that's
basically all the functionality here
let's just try a quick sanity check with
a brownie
compile whoops I forgot to add v0.8 in
here let's try again that little bit
this needs to be token and this needs to
be user whoops and then it looks like I
I did the same thing down here this is
actually staking balance let's try it
again and perfect everything is at least
compiling correctly just because it's
compiling correctly though doesn't
necessarily mean that we're doing
everything correctly so this is
fantastic typically now we'd want to go
ahead and start doing our tests I'm
actually going to go ahead and build one
of our scripts first the reason I'm
going to build one of the scripts first
is because I'm going to use my deploy
script pretty regularly in my test I'm
going to use it as part of my testing
this way I can also test some of my
scripts as well in addition to the
contracts so let's go ahead and make our
deploy script so let's create a new file
in here we call it
deploy we'll also create an init.py for
those of you on older versions of python
and let's go ahead and do this so we're
going to have a main function in here
and in our main function we're actually
just going to call
deploy token Farm
and that
token and then we're going to have a
function def Ploy token farm
and
token right and I should be able to
run R run scripts deploy
piy and great everything's compiling
right and we're running our scripts here
so first thing that we're going to want
to do as always is get our account and I
am going to copy a couple of those
helpful scripts from our past projects
so I'm actually going to pull up our nft
demo that we did so I'm actually going
to go to our chain link mix that we did
and I'm going to grab our helpful
scripts remember we can always jump onto
the chain link mix here and we can just
grab some of the scripts from here so we
could go to scripts helpful scripts and
just copy paste this whole thing or just
grab it like I did right these are going
to be those exact same scripts that we
built previously so now we have our
helpful scripts in here right we're
going to have this contract to mock for
running our tests we have get account so
that we can get our accounts easily we
have encode function data which we're
not going to have to work with since
we're not doing upgradeable contracts
but we have it here anyways we have
upgrade which we're also not going to
use but we have it here anyways we have
get Contract which returns mocks if
they're not already deployed or it just
returns whatever contract that we're
looking for and then of course we have
our deploy Mox scrp here so now we can
do from scripts. helpful
scripts import get
account and perfect we can get our
account like that no problem now and now
we're going to want to start deploying
some contracts so we're going to deploy
that dap token first so we'll do from
brownie import dap token we'll do dap
token
equals dap
token. deploy this takes no parameters
so we can just do
from count then we're going to want to
deploy our token farm so we could say
token Farm equals token farm. deploy and
this tags one parameter which is the DAP
token address right because we need that
address so we can give it out as a
reward so we're going to say dap token.
address we'll do a comma and then we'll
say
from count
we'll need to import this from browny as
well and while we're here we might as
well add some publish Source bits on
here so we could say
publish Source equals config we'll grab
this from the
config
networks network. show
active
verify grab network from brownie
grab config from Brownie and in our our
config here let's do
networks lad
development we'll set the verify here to
be false and then we're going to work
with the coven chain so we'll say coven
verify will also be false actually koven
sorry coven will be true and then we'll
do a a persistent ganache or verify for
this will be
false I'm even I'm just going to put
this up here so that all these gach
chains are kind of with each other so
we'll verify in Coven but we won't on
development or ganach now once we've
deployed this token Farm contract we
need a couple things right we're going
to need to send this some dap tokens
right we're going to need to send pretty
much all the DAP tokens so that I can
actually give those tokens out as a
reward so we're going to want to do a
transaction is going to equal to DAP
token. transfer we'll send it to the
Token farm. address and then we have to
choose how much we're going to send and
we'll send the total Supply but we'll
keep a little bit for ourselves so we
can do some testing and so just in case
so we'll also do minus kept balance some
static kept balance which we can say add
at the top we'll say the kept balance is
let's keep like 100 so this will be
equal to web 3.2 way
100
e so we'll do from web three port web
three so in our transfer we'll do dap
token. total Supply minus the kept
balance and then of course we're going
to have to do a
[Music]
from count so now we're sending our
token Farm basically
99.9% of the total supply of the stap
token so that it has this token to
actually give out as a reward do a TX
wait wait for one block confirmation
there now what do we want to do well if
we look at our token Farm we know at our
stake tokens function we can only stake
tokens that are allowed and each one of
these tokens also is going to need to
have some price feed associated with it
right and our token price feed mapping
so we're going to have to add those so
what we're going to want to do is we're
going to want to create a function
called add allowed tokens and what this
is going to do it's going to add the
tokens that we want to allow and it's
going to give them a price feed contract
associated with them so let's create
this function call it
def add alloud tokens and this is going
to take a couple things we're going to
want to take that token Farm because
we're going to need to call the add
allowed tokens function on it we're
going to take a
dictionary of allowed tokens and this is
going to be the names this is going to
be a dictionary of the different token
addresses and their Associated price
fees so we're just going to price
everything in USD so that so that we can
figure out the value of everything in
USD and then last of course we're going
to need an account for now I'm just
going to do pass here let's look at the
different inputs that we're going to put
into this so obviously we're going to do
token Farm but then we're going to need
to make this dictionary of allowed
tokens so we're going to need the
address of the different tokens that we
want to have now how do we get the
addresses of the different tokens that
we're going to use and what are the
tokens that we're even going to use here
for Simplicity we're just going to start
with three tokens we're going to allow
our platform to allow three different
tokens to be Stak we use the DAP
token as one we use we token or wrapped
eth because that's pretty much a
standard in most smart contract
platforms and then we're also going to
use an FAU token which stands for faucet
token and we're going to pretend that
this faucet token is D or di the reason
we're going to use this faucet token is
because there's this erc20 faucet.com
which allows us to get this fake faucet
token we can get unlimited amounts of
this faucet token on different test Nets
we're going to pretend that this faucet
token is going to be die right so fa
token SL die so how do we actually get
these addresses well dap token we know
we token what we can do in our config is
we can actually add those addresses here
so for
koven the we token address is going to
be this right here which again you can
go check this out and you can find it on
ether scan you can write your own if you
want we're just going to use this
already deployed one on Coen FAU token
which is going to be this token here
which I know is going to be this address
right here and if you want you can come
here grab your address paste it into
this erc20 faucet.com put in amount of
10 in here connect metamask oh it even
tells us the token address right here
which we can just copy paste we can do
mint free tokens confirm great it says
success if we don't already have it we
can take this token address go to our
metamask
assets add token paste it in I've
already got it we can see right now I
have five fa once this confirms I'll
have an additional 10 and now you can
see 15 here this is going to be this FAU
token that we're going to use we have W
here and then we know what the DAP token
address is going to be from when we
deploy it here now we could do again we
could do the config you know
networks Etc and just always get it from
our config or we could use our get
Contract method that we grab from our
helpful scripts which will deploy a mock
we token it doesn't exist in one of
these and that's what we want because
we're going to want to test this locally
so we're going to want to deploy our own
fake we token so we'll say the we token
equals get contract we
token and then the FAU token it's going
to be get Contract fa token and remember
what we put in here our string that we
put in here needs to match our string in
our config now in order for this get
contract to work for we token and the
FAU token we're actually going to have
to modify our helpful scripts here so if
we copied and pasted it directly from
our chain link mix this is basically
what we're going to have here we're
importing all of our mocks which we can
go ahead and copy paste these as well
from the chain link mix our test our
mock contracts here we have some forking
implementations we have contracts to
mock which tells us based off of the key
what token or for what contract we're
going to use to mock we have get account
which we use all the time in order for
us to do this contract to mock correctly
we're going to have to mock we and FAU
and actually we don't even need all
these in here we don't even need this
whole contract to mock in fact we can
get rid of mock Oracle we can get rid of
VF coordinator and we can even get rid
of the link token for this we do need
this sdusd price feed later on so I'm
just going to leave it in here for now
we definitely do the though FAU token
which is going to be mocked to something
and we need we token which was going to
be mocked to something else so what are
these tokens going to be mocked to well
they're each an erc20 mock but we want
to give them kind of their own identity
so what we're going to do is we're
actually going to make a mock erc20 for
both FAU and for web so we're going to
come in here we're going to do a new
file we'll call it mock die doou and
this is going to mock that FAU token so
it could be mock die it could be mock
FAU whatever we want it to be and we're
just going to make this a basic erc20 so
we'll do pragma
solidity
0.8.0 import at open Zeppelin contracts
token
ec20c 20. Soul obviously this is going
to look very familiar they should spell
ragma not whatever I just spelled this
is going to look really similar to that
dap token so now we can call it
contract mock die is erc20 and we'll do
Constructor public
erc20 mock
die be the name of this and the symbol
will be die and perfect and that's all
we need we'll copy this whole thing and
then we'll do the same thing for mock
we.so we'll paste this whole thing in
here and we'll just change the name we
call this mock we
zc20 mock we this will be
great so now that we have those mocks in
here we can change FAU token to mock die
and we token to March we we can import
those from Brownie and in fact we can
get rid of the Mach Oracle here and the
VF coordinator instead we'll do mock
die and mock we now of course since we
have die USD price feed and eth price
feed we're going to make sure we have
these in our mock here and then we're
also going to have to deploy these in
our deploy MOX script below so if we
scroll down to deploy MOX we can see
this is what it currently has which is
pulling directly from the chain link mix
so we just go ahead delete the vrf
coordinator Mock and the mock Oracle and
instead we'll deploy those that mock we
and that mock die so we'll do
print
deploying mock die die token
equals die.
deploy
from count and then we'll do print f-
statement ployed to di token.
address and then we'll do
print bloing mock mock we and then we'll
do we token equals mock we. deploy
say from
count and we'll
print deployed to this will be another
print f with token.
address now
additionally we have our FUSD price feed
left over from the chain link mix we
also need this D USD price feed so we
can go ahead in here we'll add D USD
price feed
and we'll set this as a mock V3
aggregator we could do is we could
parametrize this up so that the mock V3
aggregator takes maybe some different
decimals a different initial value so
that these could be different but for
the sake of testing we're just going to
leave them being the same here so great
so we have the address of the we token
we have the addresses of the FAU token
and if those don't exist on the network
we're working on we're going to deploy a
mark So now that we have all these
addresses we can do a dictionary of
allow tokens is going to be equal to
this dictionary that we make so we're
just going to Route each one of these
contracts like the DAP token two its
equivalent price feed for the DAP token
we're just going to say that the DAP is
going to be equal to die we're going to
say the fa token is also equal to die
and our we token of course is going to
be equal to eth so we're going to want
to get a d USD price feed another d USD
price feed and an FUSD price feed so in
our
config can to add D USD price feed and
since we're going to be testing since
we're going to be doing our integration
test on Coen here we come to the chain
link
docks we'll go to ethereum Price
feeds we're on
coven we'll scroll down to D USD which
is this address right here
pop that in and then we'll also want the
FUSD price
feed which we'll also go grab that from
here the Coen Network we'll grab that
from right here paste it in so now to
complete this deck we can do this get
Contract again and we'll deploy mock
price feeds if they don't exist so now
we can just
do get Contract die USD price
feed Fu token is is also going to be D
USD price feed and then our we token is
going to
be FUSD price feed and awesome now we
have our dictionary of allowed tokens
that we can pass to our add allowed
tokens this will map the tokens and
their addresses with their Associated
price feeds so that we can get them all
to equal the same value in our contracts
so we can go ahead and create this
function called add allowed tokens we'll
pass it this token Farm we'll pass it
the iary of allowed tokens and then of
course we'll pass it the account now in
our add allowed tokens function we're
going to Loop through all these
different tokens and call the add
allowed tokens function on it so we're
going to do four each token in the
dictionary of allowed tokens we're going
to do token
farm. add allowed tokens and we'll do
the token. address and we'll do
from
count
say add TX equals that do add tx. weight
one then we're going to call this set
price feed contract so we're actually
going to set the price feed associated
with that token so we'll do set TX
equals token
[Music]
farm. set price feed contract we'll do
token.
address the dictionary of allowed tokens
of
that token that we're for looping and
then of course
from count and we'll do set text. we
one and then we'll just return the token
Farm but we probably don't have to
return it and great that deploy script
looks pretty good and in fact we're
going to end our deploy script here with
returning token farm and dap token this
way we can actually use this deploy
script in our tests so I'm going to do
quick little zoom out and we can see our
wonderful deploy script right here and
awesome it looks like we have just about
everything here let's give this an
initial test on a local ganach chain see
if our mocks all work see if everything
at least makes sense we can call our
functions awesome it looks like we can
call all of our functions and we can
deploy our mocks and the mocking is
working at least somewhat correctly here
this is great zoom out a a little bit
here we've got our deploy scripts we've
got our add allow token scripts we've
got all of our mock contracts added
under tests things are looking good now
what do we want to do here well of
course we want to run some tests we want
to make sure our contract is actually
going to do what we say it's going to do
you guys ready let's jump into it so in
our tests let's make a new folder called
Unit we add a new file we'll call it
test
token f.p let's do some tests now
ideally we would also write some tests
for our dap token however we're going to
skip over those because we're basically
just doing open Zeppelins
implementation but in a fullscale
production here you probably would want
to write some tests on your tokens as
well so let's get into this let's look
at our token farm and see what we need
to test remember ideally every piece of
code in our smart contract here should
be tested in some form or another so
with that in mind let's get started so
one of the first functions that we see
is set price feed contract so let's make
a test for that so we'll do def
test set price feed
contract and we're literally going to
test just this one function so how do we
test that well first let's make sure
we're on a local network right because
we only want to be doing this on our
local network since this is one of our
unit tests so in our arrange stage we're
going to do if network. show active is
not
in local blockchain
environments then we're going to run Pi
test. Skip and say only
for local testing of course we got a
number of pieces here that we need to
import we're going to have to do from
Brown
Imports
Network we're going to do from scripts.
helpful
scripts import local blockchain
environments and then we're going to
import pest all right so now we're going
to get an account to make these
transactions we'll say account equals
get account and we'll grab that from our
helpful scripts as well so now we have
an account we can use let's even grab a
non-owner account so we'll say non-owner
equals get account and we'll do index
equals 1 this will give us a different
account rather than this account and
we'll use this to check some only owner
functions and then what we're going to
do is we're going to get the token farm
and the DAP
token based off of our deploy script so
we're going to use this deploy token
farm and dap token we're going to import
that by saying from scripts.
deoy import deploy token farm and dap
token and we're just going to call this
function in our test right here so we're
going to say token Farm dap token equals
deploy token farm and dap token awesome
this is how we're going to do this a lot
this arrange step for a lot of these
tests here because this is how we're
going to set them up we could even
hypothetically turn this into a conf
test or into a wrapper if we wanted to
but we're just going to leave it in here
like this for now now we can move on to
our act phase so we're going to want to
do token Farm do set price feed
contract because remember this is what
we're testing right now and we're going
to use token and a price feed address so
we use the DAP token. address we'll use
get contract to actually get an
FUSD price feed
address which we can also grab from our
helpful scripts get contract and an
important note here if you try to set a
contra contract as an address parameter
like this Brony will know okay that
you're looking for an address instead of
the actual contract in any case then
we'll do
from
count save it and it res shifts over
here now this should work perfectly so
we're going to assert this we're going
to move into our assert stage right if
we check our price feed mapping this
should now be updated so we can doert
token farm. token price feed mapping and
remember token price feed mapping is an
address to an address so we'll say d
token. address this should be equal to
get Contract of
FUSD price feed this should be updated
with exactly what get Contract of FC
price feed returns in fact we can even
make this a little bit better copy this
we'll say okay price feed
address equals get contract and then
we'll pop this in here and we'll pop
this
here that way now we're just using this
single variable for both all right
that's our first test let's run it
brownie test this will run the whole
test
suite and we're passing awesome now
let's also do a test to make sure that
non-owners can't call this function we
want to make sure that somebody other
than the owner who deployed this right
because deploy token Farm andap token is
going to be run by get account we want
to make sure that somebody else can't
call this function so we'll do with
pest.
raises
exceptions. virtual machine
error excuse me for that getting in the
way and then we'll try to call this
exact same function here right we can
even just copy paste it but instead
we'll call it from
non-owner right and then we do also have
to import exceptions from browning so
this should also pass it's expecting
this contract call to actually revert so
let's try this perfect it passes right
we can double check to make sure that
this pest. raises is working because
what if we did Count here right this now
should fail because this this isn't
going to revert and that's exactly what
happens perfect so we can leave this as
non-owner and our first test is looking
great so we zoom out just a hair here we
can sleep easy that this function is
going to work as we intended isn't that
a wonderful feeling yes it is great
let's move on so let's look at our token
Farm what's the next function aha issue
tokens all right great let's write some
tests for issue tokens so what are we
going to do def test issue
tokens so how are we actually going to
do this well in order to test issuing
tokens we actually need to stake some
tokens first so for now I'm actually
just going to do pass here and before we
test issuing the staking tokens we need
to write a test for staking those tokens
right because in order to issue tokens
you need to have some tokens staked so
let's write a test stake tokens first
and then we'll write this test issue
tokens so we'll do def
test
stake
tokens now let's set this up so we're
going to copy this bit
here because we are going to be working
on a local network with this we'll do
account equals get account and then
we'll go ahead and deploy the token farm
and the dab token so this initial bit is
going to be exactly the same making sure
we're on a local network getting the
account deploying the token farm and the
DB token so now let's move into the ACT
phase let's go ahead and act let's go
ahead and actually send some tokens to
our token farm so first we obviously
need to call approve on the DAP token
contract so we'll do dap
token.
approve to the Token farm. address and
again you can see and again we could go
to the open Zeppelin docs to figure out
what the parameters of this are but it's
going to be an address and it's going to
be some amount and then obviously from
count now I put a couple question marks
here because we're going to constantly
be using an amount right we're going to
be using an amount staked for a lot of
our tests here so what we're going to do
is we're actually going to turn that
into a fixture we're going to call it
amount State and we're going to Define
this in our conf test folder so we're
going to make our conf test file so in
here we're going to do new file
com
test.py and whoops it's in the wrong
directory so we're going to go CD tests
unit going to do move conf
test.py down one directory and it should
be in here now if that didn't work you
should be able to drag and drop it uh
into test you just want to pull it out
of unit is what we're doing here right
just want to get it so that it's just in
this test directory in a case in our
conf test.py we're going to create our
first fixture
so we're going to do at pest. fixture
we'll do def amount Stak and then we're
just going to return web 3.
2way one ether now of course we need to
import P test here then we're going to
need to import we're going to do from
web 3 import web 3 and now it saves
perfectly so now we can use this amount
staked fixture as basically a static
variable right we could have done at the
top we could do something like amount
Stak equals you know that exact same
thing but we're going to get into the
habit of working with these fixtures so
we have our DEA test stake tokens and
we're going to pass it this amount Stak
fixture P test and brownie will
automatically grab all this stuff from
the com test folder and put it into here
so now we can just use amount staked as
a parameter in our test here so once we
approve we can then do token
farm. Stak
tokens we can now
call our stake tokens function right
here it takes an amount and then a token
address so of course we're going to do
amount State as the amount and then
we'll do dep
token address as the address and of
course from count
and perfect this is going to be our our
basic action of testing the staking
functionality so we can go ahead down
here and move into our assert phase and
we can just assert a number of things
right do a little bracket here we're
going to do a couple of things here
we're going to assert the token
Farm that's taking
balance of dap token.
address of account do
address equals amount state so let's
talk about this really quickly what is
this actually doing so if we go to our
token Farm we know that we have this
mapping called staking balance and this
is a mapping of a mapping right so we
need to actually pass two variables the
first address and then the second
address to get this amount this is how
you do that syntactically with brownie
you just pass it as additional
parameters here so we pass the DAP token
address which is going to be the token
address here and then the account
address which is going to be the address
here and
perfect so we can even run this we're
doing
brownie
test-
K test stake
tokens and great looks like that passed
perfectly but we have a couple of other
assertions to make right because if we
look at our stake tokens fun function it
does a lot of things so let's check all
of these and make sure that they all are
working correctly so we'll also assert
the token
farm.
unique token
state of count that address is going to
be equal to one right this is going to
be the first token so it should have a
unique token State we should also assert
that the token
Farm do stakers at the zero withth index
is going to be this account that we're
using we update our unique token Stak we
update our staking balance and then we
add stakers do push right so we're going
to be the first address in this array
now and then I'm going to do one other
thing here too I'm going to do return
token
Farm inap token the reason I'm doing
this is because now we can actually use
this test in some of our other tests now
we're getting a little bit integration
here we're kind of mixing and matching
some stuff we could even probably put
this whole thing in a function in our
regular scripts directory but for
Simplicity sake this is how we're going
to architect it but great let's test the
rest of those we'll just hit up rounding
test- K test stake tokens we'll hit
enter and perfect this is passing
correctly as well awesome let's keep
going now we're moving into this test
issue tokens phase here and we're going
to use our test stake tokens test here
so the way that we're going to use this
is we're going to grab this amount Stak
parameter place it in here and we're
going to set this up exactly the same
way and we're going to set this up
almost exactly the same way so we can
even just copy these few lines here
paste it we're going to do an arrange
we're going to check to make sure we're
on a local network we're going to get
our account but instead of doing deploy
token farm and dap token we're going to
do token Farm comma dap
token equals test stake tokens and we're
going to pass it that amount Stak so
this is why we're returning the token
farm and the DAP token in our test stake
tokens that way we can use that function
now in our test issue tokens and perfect
now we can test issuing these tokens so
to test issuing tokens to issue this
reward we want to first take some
inventory of the current starting
balances of our address here so we'll
say starting
balance
equals D token. balance of count.
address and great this is how we're
going to start off in our range phase
now let's move to acting move in our act
phase and we'll just do token farm. isue
tokens save
from
account and this is really the only
thing that we're testing here so now we
can move into the arrange
stage and we'll do assert I'm going to
do a
little parentheses here this is going to
be a long thing and we're going to
assert that the DAP token dot balance of
the account. address should equal the
starting balance plus some new amount
what's that new amount going to be well
if we look at our issue tokens function
if we're staking in our conf test if
we're staking one ether right or one die
right because we're staking the DAP
token we're just staking one our
mocks are going to be this FUSD price
feed right our mock V3 aggregator when
we deploy it the initial value is going
to be this 2,000 right here and we're
saying in our mock in our our sample
here we're saying we are staking one dap
token
which is equal in price to 1 E so we
should get 2,000 dep tokens in reward
since we're saying since the price of
eth is 2,000 USD so there's a little bit
of math here but the initial value is
going to be 2,000 right you can almost
think of it like this with 18 decimals
and our application pays us reward based
off of the total total USD value that we
have locked so we actually can know that
this is going to be that 2,000 price so
what I'm even going to do is I and if
this isn't already in the chain link mix
shame on me I should add this in here is
we're going to add a new variable called
initial price feed
value it's going to equal to 2,000 1 2 3
four 5 six 7 8 nine 10 1 2 3 four five
six seven
eight be that super big number and we're
going to take that and we're going to
set that here to our initial value is
going to be now this initial price fed
value what we can do in our test is we
can then import that from our helpful
scripts and we can just assume that our
starting balance is going to be now be
our starting balance plus that initial
price feed balance and if we've done our
math correctly and if we've done our
issue tokens and if we've done all of
our get value correctly this should work
we should have done our testing already
on the things like get user total value
right because get user total value is a
subset of issue tokens but we're jumping
the gun a little bit here and we're
going to test this later on anyways so
with that being said let's run this
test browny test- K test issue tokens
and lovely so our math is correct
awesome we are doing wonderfully with
our tests here we've even gotten some of
the harder ones out of the way early
which isn't too bad either now as far as
this video goes we're actually going to
stop wrting the test because we're
literally just going to keep going down
that solidity file and grabbing
functions and adding tests to them we've
got all the tests located in the GitHub
repository associated with this lesson
there is both a unit test file and an
integration test file in the GitHub
repository if you want to just go ahead
and check that feel free to do so we're
going to move on to the next section to
keep things moving forward but I highly
highly recommend you trying to write all
these tests yourself so good luck we're
going to have to make now we going to
move into our private ke before we run
this make sure that your integration
test work well make sure that if you run
your deploy
onor testing everything works correctly
of course you're going to want to get
out your file you're want to add that to
your Browning config add private key in
AB your web3 inferior project ID and
make sure you have plenty of test at
Coen so that you can actually run these
deploy scripts we can always find the
latest faucets from the link token
contracts page under our koven or rink B
networks here we're also going to need
our wallets section do from Key this is
where we'll put the dollar sign private
key because now that we've done all the
contract work now that we've done all
the contract work we're going to learn
something totally new that we haven't
covered yet we're going to learn to do
some frontend development now like I
said this isn't a front end end course
and the focus isn't going to be on front
end and I want to point out right away
that this is considered a bonus section
there are a ton of pieces in this
section that we're not going to have the
time to go over thoroughly because we're
not going to be going into what's going
on on the front end side the editing is
a little bit choppier and I highly
recommend having the documentation
having the GitHub associated with this
front end with you while you're going
through this free code Camp has an
awesome video on doing front-end work
and if you want to learn more about
react and typ script and some of the
technology that we're going to go over
definitely check out those videos after
this we're going to make this though so
that you should be able to follow along
with everything that we're doing if
you're not interested in front-end feel
free to go ahead and skip this part
however understanding how these
front-end applications work is really
helpful and it'll give you an a massive
massive incredible skill to actually
build front ends for your smart
contracts having a really solid user
interface is really important in the
web3 and the blockchain world if people
can't use your contracts then what good
is your application so with that being
said let's jump on and let's build our
front end and I know we said we didn't
like JavaScript we're going to be
working with typescript here which is an
improved version of JavaScript and
catches a ton of the different bugs and
allows us to be much more explicit with
how we're working with our front end
we're also going to be working with
react we're going to be working with
create react app this is a front-end
framework that allows us to quickly spin
up a front end to build for our
applications here we're also going to be
working with this tool called usap it's
a framework for Rapid dap development
and works great with react here so let's
get started building this front end the
first thing that we're going to want to
do to build a front end for our full
stack application create react app
boilerplate so you should have MPX
installed if you run MPX D- version it
should show up this should be installed
from when we installed npm if you don't
have MPX installed you can run PM
install DG npx additionally we're going
to want to install yarn here to install
yarn again you just run mpm install --
Global or DG yarn you'll know you have
yarn installed correctly if you can run
yarn D- version you see a version of
yarn and I have a link to install both
npx and yarn in our GitHub repo but
great once you have those we can
actually create a folder with all of our
boiler plate code in it we're going to
run and MPX create react app we're going
to call it frontend this is going to
create a new folder called front end and
we're going to do d-h
template typescript because we're going
to want to work like I said with
typescript instead of JavaScript for
those of you who've never worked with
typescript before and who have worked
with JavaScript don't worry the syntax
is nearly identical for those of you who
have never worked with either don't
worry we're going to walk through
everything that we do and then we'll hit
enter here what's going to happen is
you'll see we're going to create this
new react app in this new front-end
folder in our project
here awesome now that we've downloaded
our create react app we have this new
folder called frontend and it's got a
whole bunch of stuff in it now typically
what different applications will
actually do is they'll have one
repository for all their Python and for
all their contracts but they'll
additionally have a different folder or
a different repository for their front
end application and their front end work
this is really good practice we're just
going to bundle everything up into the
same repo here just to get started and
just to make it easier for us getting
started here however what you will see
across different projects is they'll
have a totally separate repo for their
front end so let's take some inventory
on what's actually going on inside this
folder so the first folder you'll see is
node modules these are basically the PIP
installs these are the different
packages pulled in from JavaScript and
typescript we can pretty much ignore
this folder for the majority of what
we're working with here next we have our
public folder we're also not really
going to go here but it's got some nice
little images it's got our basic
index.html which has the HTML that we're
going to be running with it has a couple
logo images and it has a manifest the
Manifest is something that we want to
change this tells our browsers a little
bit about what our app is and what our
app actually does so this is something
that we we would change but everything
in here here is pretty self-explanatory
the short name of our application the
long name of our application some icons
start URL this is something that if you
want to fiddle with it later absolutely
please go for it and then robots. text
we're not going to talk about this at
all this helps web Searchers and
indexers learn a little bit more about
your site we can ignore this one as well
so for the most part we're not really
going to do anything in the public
folder or the node modules folder our
source folder however we are going to be
spending a lot of time in it has our app
. CSS which includes a whole bunch of
formatting for HTML we have app. test.
TSX this is going to be testing our
front end yes you can even test your
front end we're going to totally skip
over testing the front end which yes I
know we've spent a lot of time testing
our contracts if you want to learn more
about testing your front ends there's
some fantastic links in the GitHub and
in the description to go over this app.
TSX which we are going to be spending
some time in and it's one of our the
main places for us to write some code
index.css
again formatting and styling file
anything that ends in CSS is some type
of formatting and styling all these TSX
are going to be typescripts index. TSX
we're going to pretty much ignore we are
going to change the logo and we can
ignore all these last bits here a
package.json this file tells our project
what dependencies it needs and no JS
packages it actually needs to get
started we have a readme which of course
fores a read me we have a typescript
config which gives us some options on
how to work with typescript we're going
to ignore this and then we have our
yarn. loock which is an autogenerated
file we're not going to touch it at all
because yarn is going to automatically
create this if you're not if you're
unfamiliar with yarn. loock and
unfamiliar with a lot of this stuff
don't worry too much about it this isn't
going to be a file you're really going
to need to pay attention to but okay now
that we've created the basic create
react app we can actually go ahead and
WR now we can see what a front end would
look like so we'll CD to the front end
we'll run yarn just to make sure we have
everything installed what yarn does is
it actually installs all of our
dependencies anything in this
package.json yarn's going to go out and
download these dependencies and store
them into node modules and then yarn.
loock is going to tell us exactly what
it downloaded once running yarn now it
just checks to see it says Ah it looks
like you already have everything
installed because when we run create
react app it already goes ahead and
downloads everything but now we can just
run yarn start if you want to know where
this is coming from if you go on your
package.json and you look under scripts
these are the four different scripts
that we got actually run running yarn
start runs this MPX react scripts start
which will actually start our front end
so we'll do yarn start you'll see react
script start you'll see it says starting
the development server and after a
little bit of time time we'll get
something that looks like this edit
Source slapp TSX and save and reload and
this is a super simple front end
obviously this isn't at all what we're
looking for but we've now started a
front end which is fantastic it'll say
compiled successfully it'll say you can
now view front end in the browser it'll
tell you exactly where it's located on
our local host on the network and it'll
give you any outputs from the front end
down below so we're just going to stop
the front end for now by hitting command
C or control C and closing it down of
course if we reload now on the front end
it's going to be blank but great so we
have a really basic setup for working
with a front end awesome if we look at
an application like app. a.com you'll
see they have like this really fun
connect button that pops up and they've
got some nice user interface tools for
actually working with the blockchain we
don't want to have to reinvent the wheel
and build all these custom tools for
doing this so we're going to use this
application called usep or this
framework called usep which has a whole
lot of these already built in to get
started installing all we have to do is
run this Command right here yarn add
used appcore so here in our front end
we'll do yarn add at usap SLC and this
will go ahead and install all the used
app pieces into our front end so we can
actually work with used app and not
reinvent the with working with wallets
and working with ethereum and other
smart contract applications awesome now
we have that installed we can actually
go ahead and start building our front
end now what we're going to do is we're
going to go to app. TSX folder and we're
going to start in here we're going to
start adjusting some bits in here so
what we can do is we can do yard and
start and we'll get our our little react
front end here now what we can do is we
can go ahead and do something like
change anything in here right see how
this line says edit source. apppp source
slapp and save to reload you do we
change this whole
line being something just like hello
we'll save it it'll recompile we can go
back and now it just says hello right so
this is how we can actually upload and
update our front end we have these these
wonderful return pieces here these
return sections here which will return
the HTML to actually render the front
end and this is also our starting point
for allowing our application to be web 3
compa able so if we go to this used dap
documentation right we go to our our
getting started section we have a little
example here that shows kind of what
what something should look like right
but it's not exactly clear where we put
all this code so they do have this
wonderful step bystep bit and this is
probably the most helpful bit here it
says the first thing you need to do is
set up D provider with optional config
and wrap your whole app in it so we're
going to use these dep provider tags
right this is the open tag and this is
the closing tag we just wrap it around
our app so we can see here this this
whole thing right now is our app so we
can take this whole thing delete it
right and if we save right now we go and
see our friend is going to have nothing
it's going to be blank this function app
here that's getting exported export
default app and this is getting rendered
in this index. TSX we have this cool
little app HTML tag thing right but in
any case we want to wrap this whole
thing with this tag here right so we can
even just copy this paste it in I can do
D provider and then my vs code even Auto
adds a second D provider here we can
delete this div class name equals app
I'll just put put a little divider in
here and just say hi and at the top
we'll just import this D provider thing
like what what is this weird tag we're
going to import it so we'll do
import dep
Provider from at dep SL
core now if we hit save we'll get this
weird error saying hey property config
is missing in our D provider and that's
because this dat provider needs a config
associated with it so we need to add
this config bit into this dat provider
so we're going to do config equals this
first bracket says we're going to type
in typescript and this second bracket is
saying we're an object here so in this
config we're going to tell our
application a couple of different things
so we're going to tell it what supported
chains there are what are the networks
that our application can actually work
with the default value for supported
change in used app is going to be
mainnet REI koven brinkby robsten and XI
since we're going to be testing only on
Coen and rink B we could just do chain
id. coven and chain id. chain ID is
another term that we can pull right from
our used appcore right and now if we
wanted some other chain ID we could just
go ahead and put it in here right like
if we wanted to work with our ganache we
could just do
1337 if we wanted some other random
chain we could just put the other number
in there right but Shane id. koven is
going to be 42 and Shane id. rink is
going to be what is it three yeah three
or or whatever it is and this is all we
need to get started working with an a
web 3 a blockchain compatible
application so let's go back let's save
and we'll refresh and now it just says
hi how's it going so we're going to
spend a lot of time in this Source
folder and since we're going to be here
in a lot let's let's do some cleanup
just to cut down on the amount of fat
that we have with that crate react app
so app.css we're going to toss this app.
test yes tests are great but we're going
to toss it we're going to leave
index.css we do need index. TSX we don't
need this logo bit anymore because we're
going to use our own logo we do need
this we also need this and since we're
not running tests anymore we don't need
this but I'm going to leave it in here
just in case you guys want to later on
go back and and add some tests great so
now we're looking a little bit lighter
and in our app let's just remove app.
CSS let's remove logo. svv logo.svg go
bye now okay so we're going to create
what's called a component we're going to
create a header component now in react
components are basically where you you
put modular parts of your front end and
we're going to create one of these
components is going to be our header
component to do this we're going to
create a new folder call it components
and in here we're going to create a new
file called header. TSX and this is
where we're going to put our header
stuff and we're looking to to make a
little button up here right we're
looking to make a little button in this
header so what we're going to do is
we're going to import some stuff so
we're going to import use ethers from at
usep slore again if we look at the
documentation real quick this use ethers
thing has got some cool stuff it's got
this activate browser wallet thing got
this account thing it's got some it's
got some cool stuff so what what do
those actually do we're going to start
by exporting a constant variable called
header this is going to be a function
and this is some really this is some
really fancy typescript syntax what this
is meaning is that we're saying header
is a function and here's what the
function is going to do we're going to
use this use Easter thing to get a
couple VAR variables so we're going to
say constant variable
account
activate browser
wallet
deactivate equals use ethers in order
for us to actually use these though we
need to figure out first if the user is
connected so we're going to create
another constant variable we'll call it
is
connected and this is going to
equal an account it's going to equal an
account it's going to equal account does
not not equal
undefined so we're saying if the account
is undefined we're not connected if it's
not undefined then great we're connected
so we're literally just looking to see
if there's an account here and whether
or not we're connected we'll decide if
we show a connect button or not so to do
that we're going to return a div this is
where we're going to return some HTML
stuff and we got to check to see if
we're connected so we'll do is connected
and we're going to use this question
mark which is known as a tertiary
operator which means if this is true
we're going to do something and if it's
false we're going to do something else
so we're saying okay if we are connected
right what do we do if we're connected
here well we're going to create a
button we'll have the color equal
primary create this button here and then
my vs code autom makes these closing
tags we' even leave this button blank if
we want or we're actually going to put
some fancy stuff in here and then we'll
put a little function in it we'll say on
click equals deactivate this is this
deactivate function pulled in from our
use ethers thing I should spell it right
though and we're going to call this
button disconnect oops there's a little
parentheses next to this so this is what
this is connect thing does so we're
saying if if we are connected right to
this now we're going to do a little
colon here and this is going to
represent what we're going to do if
we're not connected okay if we're not
connected what we're going to show is a
different button color can still be
primary and we're going to do onclick
we're going to do a
function of activate browser wallet then
we close up the button tag with another
back slash button and we'll call this
one though so if we are connected we're
going to show a disconnect button and
then if we're not connected we're going
to show a connect button and that's it
right just make sure all of your divs
all your tab are matched up we can go
ahead and save this and if we look at
our UI you'll see nothing's changed
right okay well why isn't anything
changed well this component that we just
made it's living inside of this
components folder and we've exported
this this header variable this header
function right however it's actually not
in our app here right so if we look at
our index. TSX this is what's actually
getting rendered so we're just rendering
this app variable which is pulled in
from you know doapp right this app. TSX
so index. TSX is really our true Ground
Zero this is where everything really
comes from this is kind of our entry
point right this is our main function
kind of think of that way that pulls
from this app file that we have here you
can see in here we don't have any
reference to this header right we have
our D provider we have our div tag
saying hi but we don't have the header
in here so what we need to do is we need
to import this component we just made
into our app. TSX so what we're going to
do is we're going to do import header
from slash
components slash
header and now we can take this header
bit we can place it inside our header
tags here we just do header we'll close
the tag by adding it right here we'll
save we'll head back and now we can see
a little connect button here which is
great obviously it doesn't look great
but we have the functionality here which
is what we want if we hit the connect
button our metamask will actually pop up
and say hey would you like to connect
which account would you like to connect
I'm going to go ahead select my first
one next connect it's connecting and now
I'm actually going to be connected let's
go to one of the supported networks like
koven and now we can see here we have
this onclick equals disconnect if I
click this now oops I need to actually
sorry I need to put this inside the tag
here we just moved on click to being
inside of this little button here now we
can see it actually says disconnect and
if I click it I get disconnected if IIT
connect I get automatically connected
right so if we look at our metamask we
can see we're connected right here right
that little that little green thing you
can also manually disconnect by going
right into our metamasks click this
connected thing here click the account
and hit disconnect the account and
you'll see our front end does indeed
update awesome this is how we can take
our metamasks and actually inject it
into our front ends so we can actually
use the front ends great job this is
absolutely massive where we are so far
now you might be saying to yourself hey
Patrick this is cool uh but it doesn't
look very good that's kind of a gross
button in the top right corner can we
can we style this up can we make this
look a lot nicer the answer is
absolutely yes so there's a lot of
different styling packages out there you
can 100% write your own custom ones
we're going to be using one called
material UI it's a popular react
framework for creating components and
just and doing a lot of styling and
doing a lot of really nice work here so
we're going to be adding this to our
project as well so to add it we're just
going to use this this line I'm just
going to go ahead and do it myself come
in here we're going to cancel this with
contrl C do yarn add at Material hyphen
UI slore and this will give us access to
some really nice libraries for styling
all these buttons and styling a lot of
the things that we're going to be
working with back in our header we can
add this styling here so we're going to
do import
button make make
styles from at Material pyph ui/ core
and we're going to use their button and
their make Styles if we look in the
documentation here can find their butt
kind of like what their default buttons
look like and this looks pretty good
looks a lot better than what we
currently have we're also going to be
taking advantage of their make Styles
bit here so make Styles is a way to
actually do styles for based off of
different themes that you can actually
use with materials UI we're not not
going to be working with CSS files
because we're going to be working with
this make Styles instead if you prefer
CSS you can absolutely easily translate
these to CSS files so we are going to
add some Ed Styles first of all using
make Styles so in here we're going to do
const use
Styles equals make Styles this is where
we put a theme in here we're just going
to set it to be a default theme um
there's some documentation if you want
to go ahead and add your old themes
though say this make Styles function is
going to have a container and in this
container we're going to add some
padding theme.
spacing for we're going to add
display
Flex we're going to add justify content
Flex end then we're going to add Gap
even do spacing one so this is really
just some typical CSS stuff now we're
going to take this use Style
constant that we just made and down here
we're going to do const classes equals
UST Styles so now we have this classes
object that we can start working with
we're going to take this classes object
in our little is connected thing we're
going to do
div class name equals little JavaScript
in here classes.
container we're going to wrap this whole
thing in this div right and this is
going to style this whole button div
here so now if we go ahead and do yarn
start again because we we shut it off we
come back here we're going to see it's
going to look a little bit different now
it's been moved over here we have this
like fun little disconnect connect
button where there's some padding and it
looks a little bit nicer and we're going
to change all of our buttons to being
kind of this built-in button from the
materials UI so we're going to swap out
all those buttons with this with our new
button here if we go back we can see
it's it looks even nicer now now that
we've swapped it out with that uh that
new type button right it's got a a nice
little clicky feel to it and then we can
also do another line called variant
equals contained for each of our buttons
so right next to color primary we'll do
variant contained and then now we go
back and we have a really nice button
now so awesome now we have like a really
nice button let's create a component
that will contain the meat of our
application now though from materials UI
we're going to use what's called
containers right and these are nice
little containers are going to allow us
to style and make these different
sections well we can use we can import
this container bit from this materials
UI by doing
import
container from at
Material hyph UI SLC core in our app.
TSX and what we'll do to our header
we'll make a little container here
container give it a closing tag
container and then maybe in here we put
this little div high right so we'll
remove that div we'll paste it in here
and now you can see that it's been
formatted a little bit right it's been
pushed over from the side still says
High we're going to want to do one more
thing we're going to give it a Max width
of being MD oops Max width equals
MD and this Max width now if we look in
the docs again on materials UI these are
the different sizes we have large large
medium small extra large extra small and
then false right these are the different
options we can have for Max width we're
just going to do medium so if we save
this now go to wrap we can see it's been
pushed over a little bit more it's time
to add our main pieces right we're going
to need that top piece for staking and
the bottom piece for unstaking so we're
actually going to create a new component
called Main and this is going to be our
main component so we're going to create
a new file in components called main.
TSX so let's start by just showing some
information about our wallet right
showing what we have in our wallet
associated with what we have in their
smart contracts so we'll say
export constant variable called Main and
this will be a function here's that
Syntax for functions in typescript and
JavaScript in order for us to show what
amounts that we have in our current
wallet we're going to need to know what
chain that we're even on because the
network that we're on is going to
determine where the addresses are right
because it's going to be different if
you're on Coen or main it Etc now this
is where it gets a little bit
interesting because obviously with
brownie we know where these addresses
are right and brownie keeps track of
this for us right it does it in our
builds folder in our deployments folder
we look there now if you actually
deployed some into Coen you'll see this
42 you see some stuff in here you'll see
this map. Json which has the most recent
deployments of our tokens our tokens and
our token Farm if you actually deployed
it to koven if you haven't deployed to
Coen I highly recommend you doing that
now as well this way we can test our
front ends against a real test now so in
order to get these addresses we're going
to have to ask brownie hey brownie what
are these addresses where are these
coming from so we're going to need to
grab some information from this Browning
config we're basically going to need to
get all the information all the
information that's in this Browning
config right because this has has these
addresses already and this is what we
want however it's really hard for nodejs
to work outside of this Source folder so
what we're going to want to do is we're
going to want to send that brownie
config to our front end the way we're
going to do that is we're going to
actually modify by adding a new function
called def update front end now the only
reason that this works is because we
have both our contracts and our front
end in the same repository in the real
world once you deploy your contracts
those addresses are pretty much set so
you can just copy paste them over to
your front end repository but for us we
don't have set contracts yet so we need
a way to update our front end so what
we're going to do is we're going to send
that brownie config over to the front
end right that way our main can know
where those addresses are we're also
going to need to send we're going need
to send the brownie
config to our source folder we're also
going to need to send the build folder
why because this will have access to the
DAP token address or any other mock
addresses that we're using we're going
to open up our Browning config and we're
going to paste and we're going to dump
the config into that Source folder now
typescript doesn't work with yaml so
well it works with Jason really well so
we're actually going to convert it from
yaml to Json and dump it to the front
end so we're going to open up our
brownie config we're going to say
with
open brownie config yaml we're going to
open it
in read
format we're going to say as browny
config we're going to say config
dictionary equals
yl. load browny
config loader equals yaml
do full loader so we're going to have to
import this yaml from the top we're
going to do import yaml and what this
yaml is going to do is it's going to
allow us to load our yaml into a
dictionary that's really it so you
probably don't have it right now you're
going to want to run pip install
paml to actually get it now we'll be
able to have that now that we've got
this in a dictionary we're going to want
to send this to the front end right
we're going to want to write this
dictionary as adjacent object to our
front end so we're going to say with
open and we're going to open that front
end Source folder and that's just where
we're going to dump this file we're
going to call it
brownie
config Json we're going to open this new
file in right mode
we'll say it's as
brownie config Json what we're going to
do is just do what's called a Json dump
we're just going to take this dictionary
and dump it as Json into this file so
we're gonna say json.
dump config
dick brownie
config Jason of course we're going to
have to import Json and then at the end
we'll even print front and updated so
now that we have this update front end
script what we can do when we run our
deploy token and D token we can just add
this update front end bit now we don't
want to always update the front end
right we only want to do one when we're
working with the front end so in our
deploy token farm and dap token we're
going to set update front end equals
false so by default this is false this
way when we run our tests front end
won't get updated right and down here
we'll just say if upate front end then
we'll update the front end otherwise we
won't and in our main function here
we'll just say update front end equals
trip now if we deploy this to Coen or
rink B we'll automatically update and
send this brownie config and then let's
actually change this to front end update
instead of update front end so that we
don't have the same method name as our
Boolean here so we'll do front and
update instead so now when we deploy
we'll actually go ahead and update our
our front end here but we're not always
going to redeploy so let's also create
an
update front end. py script and this
we'll just call that function that we
just made so we'll do def main update
front end and then we'll do from
scripts. deoy import
update front end semicolon there great
let's open up a new shell Shell by
hitting a little plus button here now we
have two shell and we can just do
brownie run scripts update front end
doesn't matter the
network and what this is just going to
do it's just going to run that copy
script right it's going to run our our
update front end script which we made
right here so if we did this right we
should now have a brownie config.js in
our front end SL Source directory if we
go in here we go into our source
directory we can indeed see right in
here do we need anything else well so
that's going to give us those addresses
right it's going to give us it's going
to give us some of the addresses but
it's not going to give us everything
what about dap token right dap token
isn't going to be something in our
Browning config W token and FAU token
sure they'll be in our config but dap
token is going to be something that only
is going to be deployed by us so we need
to send that to the front end too we
need to send basically our whole build
folder so we're going to need to update
this update front end script to also
send send the build folder I know that
we're actually going to be copying a
number of different folders so I'm just
going to go ahead and make a new
function called copy folders to front
end and in here so we're going to make
this copy folders to front end function
here we're going to do a couple of
clever python things this is going to
take a source and a destination so we
want a source folder and then a
destination folder so we're going to
copy this build folder and move it to
you know some folder in the front front
it first we're going to check that that
destination exists and if it exists
we're going to kill it we're going to
we're just going to remove it so we're
going to say if os. path. exists
destination we're going to do this
shuttle. RM tree D and this is going to
kill everything so we need to import
both of those we're going to import OS
we're going to import shuttle or shutil
I actually have no idea how to pronounce
that but we're going to remove that
whole bit and we're just going to copy
everything over from our build folder so
we're going to do shuttle. copy tree SRC
test so we're gonna say hey if that
build folder exists in the front end
just delete it and we're just going to
copy everything over from the build
folder and we're going to do this copy
folders to front end a few times the
first thing of course like I said is
going to be with this build folder so
we're going to do this copy folders to
front end the source is going to beu so
we're going to take this whole build
thing and we're going to move it to
slash front end slsrc and we're going to
create a new folder in here called
chain info right and this is just going
to have all of the build information and
all right cool so now we can run that
browny run scripts update front end go
ahead and run that and great front end
is now updated so if we look in our
front end we look in Source we now have
this chain info folder which is
literally just the build folder fer
which is awesome now we can actually
start working with these pieces in our
front end so let's figure out how to get
the dep token
address well to get this dap token
address we're going to need that map
that we just got from chain info in our
deployments but we're also going to need
to know what chain that we're currently
on like what we saw before we have this
chain ID from usape which will tell us
what chain ID of the current Network
that we're on so we can go go ahead
import that in here as well so what
we're going to do is we're going to
import use ethers again
from at use daap SL core what we're
going to do here is use
ethers allows us to get the chain ID
that we're working on so we can say cons
chain
ID
equals use ethers now that we have the
chain ID we're going to have to map it
to the name of the network right because
our brownie config has this network
section but it's mapped by the name of
the network not by the ID so what we're
actually going to do is we're going to
create a helper config in our
SRC so we're just going to create a new
file helper
config Json and it's literally just
going to be a Json object that Maps
numbers to their Associated chain names
so 42 for example is going to be koven
four is going to be rink B 1337 going to
be Dev
or it could also be ganach right one
it's going to be main net Etc now that
we have this helper config we can do
import helper config
from Helper config.js and before we even
get the DB token address we can do const
network
name it's going to equal that helper
config at the chain ID now typescript is
actually going to get a little bit mad
at us here so we need to add a little
bit more to this line actually so we
need to say okay only grab from this
helper config if chain ID exists right
because there might be a chance that
train chain ID is nothing or it's
something really weird so we're going to
say chain ID and we're going to use this
tertiary tertiary operator again we're
going to say if this chain ID exists
then go ahead and use the helper config
however if it doesn't exist just use Dev
I should spell chain ID right so it
doesn't get really confused to me and
whenever we return one of these
components or try to use one of these
components we're always going to have to
return some type of HTML or or div tag
like this we head over to our app we add
our little main bit here of course we're
going to want to import this say import
main
from components SL main we save it we'll
add
our main tag main open do the syntax
we're basically saying in it now
depending on your setup you might
actually run into this eror here saying
element implicitly has an any type
because expression blah blah blah you
might be saying okay well what's going
on here now to make our lives easier
we're going to tone down typescripts
strictness here so what we're going to
do is in our typescript config.js we're
actually going to add to press
implicit any index errors so we're
basically suppressing when we get this
type of error because it's not ever
actually going to affect anything I
should probably I should probably spell
this correctly we'll save it now if we
save this file here we're going to
actually get this saying everything's
compiled everything looks good and if we
refresh our front end we're going to get
back to exactly where we are before now
what we can also do is we can also
console.log these out we can also see in
the console exactly what these are going
to look like so if we do console.log
chain ID and console.log Network name we
save and we go back we can go hit
inspect go to the console and we'll see
42 and koven gets printed out in the
console over here so that's 42 is the
chain ID and koven is the is the network
name so we know that we're doing this
right okay great so we have our network
name and we have a chain ID we've got a
way for us to update our front end with
a new script let's finally get those
different addresses that we need say the
constant
variable dap token address is going to
equal something from that build folder
or that chain info folder that we
created inside here inside deployments
we have this map.
Json and since I've already deployed
this to koven we have dap token and
token Farm on the Coen Network so we can
then use that and say if if we are
connected to a Chan ID and that's again
that's what this question Mark is doing
saying if this chain ID exists then look
into that mapping else we're just going
to use a zero address right so how do we
actually get this mapping in here though
so I'm going to say
import Network mapping from this is
going to be in that chain
info folder inside the deployments
deployments and it's just going to be
map. Json so we're going to take this
network mapping object and we're going
to say if the chain ID exists then
inside this network mapping Json object
we're going
to cast that chain
ID as a string and then we're going to
grab the name of the DAP token which is
going to be dap token and we're going to
grab whatever address is at the top
right so this is going to be a big list
the more times we deploy the more times
Brown is is going to keep track of it
and there's going to be all these
different addresses and we just want
this one right at the top right we want
the most recent one here so we're just
going to say at position zero otherwise
if we're not on a chain ID we're just
going to use a zero address and ether's
JS actually has a really nice package to
give us what's called constants so we're
going to do
constants dot address
zero and we can import that from
ethers so we'll do
import
Conant
from
ethers if you don't already have ethers
installed here we're going to do CD
front end we're going to do yarn add
ethers and now we have the ethers
package in here now we're not going to
do the same thing for the we token or
the fa token because those tokens are
defined in the brownie config as a OS to
being defined in our map. Json here so
to get those ones we're going to say
const we token address it's going to
equal let's check first if the chain ID
exists and if it does we're going to
grab it from the brownie config so to
grab that we're going to do
import brownie
config from again now that we've
imported it brownie config.js
now we can work with this brownie config
inside of our front end so we'll say
brownie
config of
networks of that network name of the
left token and if chain ID oops chain ID
does not exist then once again we're
going to do constants do address zero so
we're just going to leave it blank and
then we're going to do the exact same
thing for the fu slth die token so we'll
do const fu
token
address equals chain ID question mark So
if the chain ID does exist it'll be the
brownie
config
networks network
name FAU
token and if chain ID doesn't exist
will'll be
constants address zero okay awesome and
if we save it oops looks like I put an
extra comma in there by accident just
going to get rid of that and
resave and then refresh here so I'm
getting an issue uh because I'm on the
rink be chain right now and it's saying
hey there's no there's nothing for rink
there's no dap token for rink beat you
got to be on Coen so if I go back to
koven
here and I refresh now it works out fine
right this might still break for you if
you're on Coen and you haven't deployed
anything to Coen we can fix this in our
config for the D Provider by changing
the supported chains for this now
typically a lot of the times you're
going to want to test using a ganache
chain or some type of local chain so
that your front end testing can be a lot
faster for this we're just going to do
everything on Coen but a nice little
challenge for you would be to refactor
this so that it also works with
something like ganache and we're going
to not use ganache so I'm just going to
go back to app. TSX we're going to
remove ganache even we're going to even
remove rink B for now we're just going
to work with Coen just to make it simple
if I go to our react page now refresh I
can connect awesome if I go to rink B
it's not going to freak out because it
says Hey rink B is not even supported so
I don't care what you're doing however
koven is supported so we're connected
and we're looking good and the thing is
we really don't want to couple our front
end with our contracts right we really
want to code the contracts independently
in the front end independently anyways
so let's get back into our main . TSX so
we're going to be in here for a while
but we've already done some great things
we've gotten what network we're on what
chain ID we're on and we've gotten the
different addresses for these different
tokens so as you can probably see the
place that we're actually going to put
stuff on the front end is in this little
return statement here right right now
we're just returning I'm Main and I we
just see I'm main right here to do this
we're actually going to make another
component we're going to make a
component called your wallet this
component is going to be part of this
Main
component here it's a component inside
of a component that is literally only
going to address our wallet needs so on
our little components tab here we're
going to go ahead and create a new
folder and we're going to call it your
wallet this is just going to have
everything to do with our wallet in here
so let's get in here we'll create a new
file because we're going to actually
make a couple files and our first one is
just going to be your wallet.
TSX this is going to be our component
that is just going to deal with getting
our wallet getting the token balances of
the different tokens that we have since
we know we're going to put this
component in Main and Main is in our our
home base our app. TSX you know that
we're going to do an export const your
wallet in here and we'll make this a
function now in order to actually show
these tokens we do need to get some
information from our other component we
need to get some information on what the
supported tokens even are so we're going
to have our main actually pass a
variable to our wallet here we're going
to call it the
supported tokens and this is going to be
of
type your wallet
[Music]
props and this is going to be a your
wallet props here just to tell
typescript what this is what this
supported tokens is going to look like
we're going to say interface your wallet
props it's going to look like like this
supported tokens and it's going to be an
array of token array of some
token we're going to grab that token
type from Main as well so actually we're
going to do import
token
from
Main and in our main we're going to pass
this token and we're going to pass some
supported tokens to our wallet so right
underneath those three token addresses
back in main we're going to do const
supported tokens is going to be an
array of token this token
type so above here we're going to do
export type
token
equals and we're going to say a token
type is going to involve an image which
is going to be a string an address which
is also going to be a string and a name
which will also be a string so we're
creating a new type called token here in
our main function we're creating this
supported tokens object which is an
array of tokens and this is excuse me
and this is going to equal that array
syntax so our first
token is going to be have an
image that we haven't defined yet the
address is going to be this dap token
address and the name
the name of course is going to be dap or
dap token now we're going to need a
couple images so at this point you
should see where we're going with this
we're create this array of supported
tokens first is our dap token and we
need an image for this dap token so if
you're following along you can just grab
this image right off of the GitHub and
we're going to grab that D token and
we're going to pop it into
SRC we're going to change this to dap.
PNG now we can import this by doing
import dap
from dap. PNG now we can take this dap
image and under image I'll put now let's
do the other tokens so we'll do a comma
we'll do
image will be F oops F address will be
we
token we token address name will be we
and again we can either oh let's close
this off and again we can either grab
right from my GitHub or pop it into my
SRC here we'll change this to f.png
we'll scroll up and we'll import this as
well import F from sl.png and boom that
looks good one more comma do image it's
going to be
fa or this is going to be our die token
address is going to be f
fa token
address
name it's going to be
fa or die this will be our die token
we'll pop it into our SRC change the
name to
d.png then we'll
import die from
d.png grab die and it looks like we're
going to name it die actually instead
and if your vs code starts yelling at
you about this can't find module it's
really confused what we're going to do
at the top here we're just going to add
a little comment backstar
eslint disable
spaced
comment star backs
slash D D Dash
reference types equals react
scripts and we'll save and that issue
will go away all right well now that we
have our supported tokens token array we
can actually pass this to that your
wallet bit right so now we're going to
go to this return bit we're going to
remove that div on Main and we're going
to actually start getting to some meat
here so we're going to pass this to our
your wallet component that we're going
to import in just a second and we're
going to send it our supported tokens
say supported tokens equals supported
tokens back slash like this and of
course we're going to have to import
your wallet here so scroll to the top do
import your
wallet
from your wallet we're actually going to
make a new file in our your wallet
folder called
index.ts and we're just going to
export your wallet
from slashy your
wallet save
that we're getting an
issue saying you wallet is not defined
it's because this should be your
wallet Okay cool so we're getting
another issue but I'm going to fix that
in a second great so now we have some
supported tokens we have a wallet
here we're exporting our wallet with our
index.ts in our your wallet folder
now let's finish our your wallet
implementation and this needs a little
equal sign here whoops and we're going
to get this little error basically
because we don't have a return here so
we could just do return just to make it
happy
div
I leave it changes to I'm your wallet
and we'll save and now everything's
happy we'll go to our front end we'll do
a quick refresh and now we see I'm your
wallet so let's keep diving into your
wallet here right because this is going
to be where we're doing all of this
stuff about what's in your wallet now
we're going to use a couple of these
components from the materials UI here to
get
started to start we're just going to use
this box the Box component it serves
just as a wrapper component for most of
the CSS utility needs it's just a box
right it's a box that we can put on our
front end so we're going to come over
into our your wallet and we'll start
working with this box we're going to put
everything inside of this little this
little box here we're going to have to
import this box import
box
from at Material
UI we'll give this a little header H1
we'll
say the
wallet H
one get a little header your wallet I'm
your wallet great now we'll get rid of
this little on your wallet and we'll
create another
box and in here we're going to add all
of our functionality for uh what is in
our wallet now we're going to use some
tabs here from the materials UI to swap
between the tokens right we're going to
have one tab for FAU token another tab
for dap token and for wrapped ether
we're going to use this this this tabs
thing here so to work with tabs we're
going to need to import some
tab stuff so we're going to
import tab
context tab
list and tab
panel from Material UI SL laab so
material UI material UI laab these are
some components that they're not quite
ready to move to the core so we do have
to add these as well so we'll go to our
front end in our other shell we do yarn
add add material ui/ laab these are kind
of their testy ones but uh they have
some really nice features that we're
going to use but let's get into this box
and let's make our first tab
context value equal to now in our box
here the first tab that we're going to
have to use is going to be whatever
token that we have selected to select
tokens we're going to use what's called
a state hook so we're going to create a
state hook here inside of this we're
going to
do const
selected token
index set selected token
index equals use
state
number zero so use State we're going to
grab from react it looks like I've
already imported here import react comma
brackets use state from react and what
this is going to do it's going to create
one variable selected token Index this
is going to be whatever token that we're
on and then set selected token index is
going to update this selected token
Index this US state state components
thing is a way of saving State between
renders of components so in our little
box here we're going to start with a tab
context we start basically with our own
Tab and the value is going to be equal
to whatever token we currently have
selected. two
string and we're going to have to make a
list of these tokens in our tab
context we're going to have to add some
way to change between the tabs right
when we change between the tabs we want
a different token to be selected and
we're going to make a a tab list that's
going to change whenever we we click the
different tab so we're going to add
we're going to add some functionality to
this but for now we're just going to
give it an ARA
label call this our
stake form tabs and based off the
supported
tokens in a mapping of token to index
we're going to call a function in here
where we return a
tab which will have a label equal to
token. name value would be equal to
index string or EXC two
string key it's going to be equal
to
index tab is something that is just from
the material UI core so we're going to
import
tab
from
Material core I should probably spell
supported tokens correctly supported
tokens now if we look at our UI we can
now see we got a couple different
buttons here which great we have dap we
and die right these the different
supported tokens that we're mapping here
now of course if we click the different
buttons uh nothing actually happens so
we do need to to handle a change we do
need to code some functionality to
handle a change whenever we do something
different so in our TBL list we're going
to add on change EXC me
on change
equals handle change we're going to code
a little functionality at the top to
actually handle the change so we'll say
const
handle
change be equal to an
event a react. change event we'll do a
new value it's going to be a string and
this is a function so we're going to do
this little function syntax again and
all we're going to do is we're going to
use our little State hook here so we're
going to do set selected token index and
we're going to parse the int of the new
value value that we
get so what's happening here we've added
this new functionality where whenever we
change one of those tabs we're going to
change this the selected token right
this selected token number is going to
be different and what we do is we map
the indexes to a token right so each one
of these tokens is going to represent a
certain number so now when we save we go
check out our front end you can now see
that we do indeed swap between tabs here
which is really nice all right let's
keep going so that's cool we have a way
to swap between the different tokens
visually here but we need a a big stake
button right the reason that we need to
swap between the tokens is because we
need a way to stake between them so when
we're on one of these tabs we're going
to add a stake form here we're going to
add a big button that allows us to stake
so we're going to do some typescript
we're going to do supported tokens. map
going to map that token and index again
another function that and in here we're
going to return a different tab
panel the value in here is going to be
the
index. two
string key is going to be index make a
little div in here we're going to need
to put two pieces in here we're going to
need to be putting our Wallet balance in
here and then also a big stake button
right first we looking at right now it's
just going to say our Wallet balance and
a big stake button but how do we
actually do this how do we actually get
our Wallet balance and one of these big
stake buttons well we're probably going
to need some type of component to get
our actual Wallet balance that we're
going to stick in here so yep you
already know we're going to go in here
into our your wallet component we're
going to create a new file and this is
where we're going to
Define that Wallet balance component and
we're going to import our Wallet balance
into our wallet here so that we can
actually see the balance of our wallet
right in the front end and right and
this is where we're going to actually be
reading offchain finally after a lot of
typescript and react setup since we're
going to be importing this into our your
wallet component here of course we're
going to start with export
const Wallet balance and we're going to
make this a function so we'll do this
really
weird function syntax and we're probably
going to want to pass this the token
right the token that we want to get the
balance of
so we're even going to set that up like
this a token in here and we'll
Define what this looks like uh with a
interface called Wallet balance props so
we'll say export
interface Wallet balance
props and this will be a token
right this will be that same token type
that we defined before so we're going to
have to import that so we'll say
import token
from Main all right great that's our
initial setup here we'll grab from the
token that we passed to this we'll pass
we'll get the
image address and the name from that
token address and name we'll grab the
account right because we're going to
need the account with along with the
token so we'll say
account equals use
ethers and of
course have to
import count
from excuse me import not count
use ethers from at
usap core we're going to need the
account we're going to need the address
and usbcore has a nice little hook
called use token balance that we're
going to use you check it out in the
documentation provides a way to fetch
the balance of erc20 tokens specified by
a token address makes our lives a lot
easier so we'll just import that as well
use token balance and all we have to do
really is do
const token
balance
equals use token
balance of the address of the to
token and our count here we can even do
a quick
console.log token
balance see if we're doing it correctly
and we take this Wallet balance and
import it into our wallet here we should
be able to see something so we'll import
it into our wallet now scrolling to the
top we'll do import Wallet balance from
slash
Wallet balance and down inside our our
very large return function here we'll
add this new tab with this new uh
component we say Wallet
balance we still remember we need to
send it the token so we'll send it
tokens at the index of the
selected token index I should spell
supported tokens
right I should spell Wallet balance
right capital B we do need to do a
return so that it's actually a jsx
component do a div we'll just have this
say I'm the Wallet balance if we go to
our front end we do a quick refresh we
do indeed see this little print line
here uh this is javascript's big number
so if we really want to see this token
balance we'll do dot to string we have
to put this question mark here to tell
typescript hey turn it to a string if if
it's not undefined and now if we save we
go to our front end we do a refresh
since we are
connected to Coen here we can see we had
anount printed out here and if we switch
tabs you'll
see the different amounts being printed
here which is fantastic cool so let's
remove this little console.log we want
to show this token balance obviously in
our UI right we don't want to have
people to have to go to the console.log
right to actually see it we want it to
represent we want to show up where it
says I'm the Wallet balance so what
we're going to do first we should
probably format it right because this is
in units of way so we're going to do
const formatted token balance this be a
number which will equal
to token
balance if token balance does exist
again we're using this tertiary operator
we're going to parse
float format
units token balance
18 otherwise we're just going to use
zero format units is a nice little
import that we're going to grab from the
ethers project so we'll do
import format
units from at ethers project SL units
and of course yarn ad at ether's project
and of course we're going to do a yarn
ad on this this here we do yarn add at
ethers project units and now this
formatted token balance is going to be
this token balance that we just got but
formatted formatted much nicer and in
our little div here what we could just
do is we could just add this formatted
token balance we'll save and we'll look
at the front end now and aha we now see
we have 100 dep zero W and 15 die right
these numbers might be a little bit
different depending on how much you
actually got but this is perfect this is
exactly what we're looking for so let's
close out the console and let's let's
flesh this out a little bit let's make
this look a little bit nicer here so
instead of just returning a little div
like this let's actually make a new
component
called balance
message and we'll use this
instead create a new component called
balance message and it'll format up the
way we actually show these formatted
tokens and here we'll pass
we pass it a couple variables we'll pass
this component an amount we'll pass it a
label we'll say the label is going to be
your
unstaked
name
balance right we're grabbing name from
the token and we'll pass it e token
image SRC which is going to be that
image so we're going to pass it a
label excuse me not IMG it's image we're
going to pass it a label token image and
an amount right and this component is
just going to make us have this balance
look a little bit nicer so in our our
your wallet section we going to do a new
file called Balan message. TSX oops not
tsxxxspelled
parameters a
label an amount and a token image SRC
and this will be an interface of balance
message props this will be a function of
course so we'll do this weird function
syntax of course we need to tell
typescript what this looks like so we'll
say
interface balce message
props what are those inputs say the
label
it's going to be a
string the
amount is going to be a
number and the token image
SRC is going to be a string and in here
we're going to use and in here we're
going to once again do that use Styles
bit for materials UI because we might
want to style this up a little bit so
we're going to import make
styles
[Music]
from at material
slui core we'll do a const use Styles
it's going to equal make Styles theme
which we're going to skip doing a theme
but let's make some styles for the
different pieces let's give it balance
message be surrounded mainly by
container which will have a couple
Styles in here we'll say the display
it's going to be an inline grid the grid
template columns are going to be Auto
auto auto again you can check out all
these parameters in the
documentation there's going to be a gap
which will be theme. spacing one again
we're skipping theme but this will just
be a way to add some spacing and then
align items in the center we'll also
give the token image its own styling
give it a width of
32px 32 pixels and then the amount just
do give it a font weight of 700 so make
that a little thick so now that we have
our use Styles we have our styling here
we can go into our export below we'll do
const classes equals use
Styles and we're going to return we're
going to return a div class name is
going to be equal to that main container
classes.
container do another div just for that
label that we're looking for we'll do
another div for class
name
[Music]
equals classes.
Mount so have that that nice font weight
and in here we'll just have the
amount and then we'll grab that image of
the
token class name name is going to equal
to classes. token
image we'll grab the source of that
image is just going to be that token
image SRC that we get past and we'll
give it an ALT called token
logo close that Tab out great so what
we're going to want to do is in our
Wallet balance here this balance message
that we just created we'll do import
balance
message from dot dot dot dot
po
slash your
wallet capital W and actually I know
we're going to use this balance message
a little bit later so I'm actually going
to grab it and drag it into components
move it into components and move it out
of your wallet because I know that we're
actually going to use it a little bit
later so that means in our Wallet
balance we're just going to pull it
right from components slash balance
message and whoops we actually need to
make this look like this close it out
here move this
part this boom right like that and now
let's try out the front end okay we're
looking a little bit nicer right we have
a really thick number here explain
how much of the token we have we have
the images popping up this looks
starting to look great let's add this
stake button right so that when they see
this they can actually stake and
interact with our contract here so to do
this we do need to create another
component called our stake form so in
your wallet we're going to create a new
file called stake form.
TSX and this is where we're going to add
a little button and an amount for the
users to actually stake on our contract
so you already know we're going to start
with export const State form
equals and we're going to
have our wallet pass the token just like
we passed the token to Wallet balance so
we'll say token and we'll have this be
stake form
props which is an interface we're going
to Define in a second this is a function
so we'll do this fun
function syntax here and then stake form
props as you know is just going to be a
token so we'll do inter
export
interface stake
form
props this is just going to be a token
of type token which
again we're going to import
token
from
Main great and that is our starting
point for this so we're going to create
a stake form with a big button that says
stake and the user can actually choose
how much they want to stake on our smart
contract so we're going to do some
similar stuff as we did before we're
going to grab some variables we're going
to say the address is going to be that
token
address that we get from the past token
we're also going to get a name of the
token from that
token we're going to get our account
from use ethers again so we can import
that we say from oops
import use
ethers
from at use dcore we're going to want to
grab the token balance so we'll do const
token balance once again we can grab
that with the use token balance with the
token
address and the
account so we're going to use use token
balance this will also grab from used
appcore we're going to want to format
this token balance so we'll do const
format it
token balance this is going to be a
number again this is going to be the
exact same as we did before say token
balance do pars
float format
units token
balance
18 or zero format units once again we're
going to import that
import format units from at ethers
project units perfect importing here
we've gotten some some starter boiler PL
let's just go ahead and grab those
buttons right because those are really
the things that we're going to care
about here let's just return some stuff
here so something can show up on our
front end right so let's do
return let's start returning something
here and whenever we return something
it's all got to be in one tag right so
I'm going to I know I'm going to be
doing a whole bunch of different tags so
I'm just going to go ahead and make an
open and close tag here and this is
where I'm going to put all my stuff now
we know we're going to want to have a
big Stak butt right so let's go ahead
and just do let's get a let's get a
button tag in here and of course since
we're going to have a button we're we're
going to pull this in from that material
ASI material UI right so we'll do import
button
from Material UI core just so we can get
get started with something here and then
back in our your wallet. TSX let's add
this button in here inside of our tab
panel right below our Wallet balance
We'll add this stake form thing we'll
open and close of course we've got to
import it so we'll say import
import stake form from slash stake form
and we need to pass this that token
object so back in our your wallet we're
going to say okay token
equals supported tokens of that selected
token
index
selected
token index and let's not have this
just do a little backslash here to close
that out we should close this bracket
here we'll give this button some stuff
right we'll do color equals primary say
size equals large then we'll give it
some text
called steak double exclamation point or
however many you want to put in there
and now if we look at up front we got
this big steak button nice okay we're
looking a little bit better currently
doesn't do anything but we have a steak
button great now we can start adding
some implementation right we can have it
do some stuff now when we hit this stake
button what do we want it to do we want
it to do two things we want it to
approve whatever token that we have and
then we want it to stake that amount we
also need to have some type of form here
we need to know how much we want to
stake right so we're going to need some
little input box that we can add a
certain amount in well we can do that
too with a little input box from
materials UI so there's another package
we're going to grab which is called
input from materials UI cor and then
we're going to use this little input box
before the button so we're going to
input little slash here now if we save
refresh the front end awesome now we can
do some typing in here we can click this
stake button now to do this though we're
going to need to keep track of how much
amount is in here right we're going to
need to keep track of how much amounts
in here so we're going to inspect on the
front end and we're going to go to
console and see if we can follow along
with how much is in here or what what
amount is in here and to do this we're
going to make another one of those State
Hooks and we're going to track that
amount in there so we're going to say
const amount set amount one of these
Stak hooks equals use state which is
going to be a number or a string or an
array number or
string
zero we're going to import this use
State here from react we going to do
import
import
react use
state from react and now we have this
state hook that we can use to keep track
of the amount that's going to be put in
there with our input tag here we're
going to say on change whenever this
changes we're going to have to have some
handle function right we're going to
call it handle input change and this is
going to handle the input change so
we're going to create that function
we're going to do
const handle input change equals and
we're going to use some events stuff in
here we're going to say this is going to
take an
event
react. change event of HTML input
element this is going to be a function
that's going to set amount
it's going to say
const new amount equals event. target.
value whenever we change that value in
that field if if it's equal to nothing
then we're just going to say okay we're
going to do nothing otherwise we're
going to cast it as a
number vent. target. value we're going
to cast whatever is in there as a
number and then we're going to do set
amount to this new amount what we could
do is we can even do a
console.log new amount and now and we
can start using it right so if I go back
here I do one two three right you can
see it's console. logging every time I
change something in here so now we have
a way to actually get that amount with
this input now we're going to need to
way to send that amount as part of our
our stake right so we're going to first
have to call that approv function with
this amount and then we're goingon to
have to call from our token Farm then
we're gonna have to call the stake
method so how do we get it to call this
approv function here well to do these
we're actually going to make some new
state hooks that we're going to use in
our staking form here we're going to
make State hooks for approving and for
staking and even for unstaking so back
in our folder here we're going to create
a new folder called Hooks and this is
where we're going to add
some different hooks first hook that
we're going to make is going to be
called use use stake
tokens. typ script and this is something
that we're going to import into our our
stake form here so that we can actually
stake some tokens and the way we want to
do it too is that once we hit stake once
we hit our stake button it kicks off the
approve and then it actually right
afterwards it kicks off a send it kicks
off a stake token we want to run these
two functions sequentially and we're
going to make this use stake token hook
clever enough to do it in that order so
let's do it hooks are basically just
like components except for they're more
functionality wise so since we know
we're just like components we're going
to do export const use stake tokens and
this is going to be a
function just like our other components
and as input we're going to take a token
address it's going to be a string and
inside of this we're going to have some
intelligent scripts to know if it's
already been approved if it's not
already been approved and what we need
to do right we know we're going to need
some approv thing and we know we're
going to need some stake tokens thing so
let's let's at least try to approach
this approv thing first before we get
too creative right how do we approve
this transaction to get an approve we're
going to need a couple things we're
going to need the address as you guys
know we're probably going to need the
Avi we're probably going to need the
chain ID so we know which chain it's on
so let's go ahead and let's grab those
so we'll do con
chain
ID equals use
ethers since we're using use ethers here
we're going to import this so we'll do
import use
ethers from at usep SLC
core we're also going to want the ABI of
the token farm so we'll do const ABI
equals well where do we get this Abi
froma that's right we've imported it in
our little chain info piece and it
should be right in here we could should
be able to do import token farm from
down a directory it'll be in chain info
SLC
contracts toen farm. Json and now we can
say ABI is going to be equal to this
this token farm right because in token
Farm we have an ABI key so we can just
substract that away and just pull out
the ABI perfect we're going to need the
token address of course we're also going
to need our token Farm address and we
can find that the exact same way we
found it before const token Farm address
it's going to be equal to depending on
if the chain ID exists once again we're
going to want to use that Network
mapping so we can even go back to main.
TSX see how we did it here for the DAP
token address we can copy this as like a
frame of
reference we'll say if this chain ID
exists we'll pull right from that
Network mapping right we'll pull right
from the network mapping so we got to
import that too which we can grab from
import Network
mapping
from chain infos chain info slash
deployments slash M.J
so once again we're going to say if that
chain ID exists in the netw mapping
we're going to use that string chain ID
so we'll do
string chain
ID of the token
farm at position zero right because we
obviously want the most recent one
otherwise again we'll do constants
do address
Z since we're going to do that of course
we're going to have to do
import
constants
[Music]
from e3s and this hooks folder should be
in source so let's just make sure that
we have hooks in Source here now we're
going to want to interact with this
token Farm address contract right we're
going to want to run that approv
function first we want to create like an
interface so we can do const token Farm
interface we'll say this equals new
utils do interface with the ABI this
utils we can again grab from the ether's
project or excuse me from uh from ethers
so we'll do comma
utils now we can create a token Farm
interface here and now that we have an
interface we'll create a contract so
we'll do const token Farm contract
equals
new
contract and this will be a combination
of this token Farm interface and the
token Farm address actually it's address
first and contract is something we can
grab from import contract from at ethers
project SL contracts all right you're
probably starting to follow along and
figure out okay cool I have a token Farm
contract now that we have a contract we
can actually call some functions which
we totally can but right we need to call
the approve first so let's get the token
contract before we even work with the
stake token right so to work with the
token we're going to want to do the same
thing so we'll do const erc20
interface equals new utils do interface
interface this will be from
ec20 ABI which we should probably make
first so we'll do const ec20
ABI equals we'll do it the same way we
did up here except for in setad of token
Farm we'll do something else we'll do
look at our contracts here we'll do Mach
erc20 instead and then we'll just call
this
erc20 or yeah we'll just call this
erc20 but we'll grab it from our Mach
erc20 Json so now that we have this
erc20 we do con erc20 ABI equals erc20
Ai and we can just pop this ABI to
create our interface we'll Now do const
erc20
contract equals new contract of token
address comma the erc20
interface boom okay now we have both of
these contracts we have the erc20
contract we have the token Farm contract
now we should be able to go ahead and
call some functions right now to
actually send one of these we're going
to use this thing called use contract
function it's a hook in edep that
returns an object with two variables a
state and a send this state bit is used
to represent the status of the
transaction and that's how we're
actually going to automatically kick off
the stake after we approve to send a
transaction we have to actually have to
we actually have to use this send
function here so we're going to use this
use contract function to get to get a
state and a send so that's what we're
going to first need to do so we're going
to do const send
then we're going to call this approve
ERC 20
send and state because this is what it's
returning it's returning send in a state
we're going to say state is going to be
approve erc20
State equals use contract function we
pass the token contract the erc20
contract comma the name of the function
which is going to be approve then we do
a comma and then we we'll do a little
object here we'll call this transaction
name and this will just be approve
erc20
transfer then of course I have to import
this from used app this use contract
function now oddly enough whoops I got
rid of the closing tag here but great so
now in a weird way we actually have
these two new pieces here we have this
send function this approve erc20 send
and this approve erc20 State this is
going to be the status of our
transaction and this is going to be the
actual function that we use and if we
want to call this approv function what
we can do is now we can return Calling
this approv function so we'll do const
approve we'll have this be a function
we'll say it'll take a string amount as
an input parameter and we'll just have
it return this approve erc20 send and
we'll give it the token
Farm contract
address as a first input parameter
excuse me token Farm address and we'll
use this input amount as the second
parameter and then we'll just have this
this use stake tokens return this
approve function and then also this
state here so it's going to return
approve and it's going to return State
we could also just have return this if
we wanted but we're going to wrap it
just all up in this approved thing here
we also probably want to return this
state right so we're going to turn this
into hook as well so we're going to do
const
state set
State equals
oops use State and we'll have this be
the approved or the approved ERC 20
State as the input and of course since
we're using use State we're going to
grab this from react as well we also
want to return the state so we'll return
this approve erc20 State here so now we
have a way to actually do all this so in
our stake form what we're going to
have we're going to create a con that's
going to grab those two variables so
we'll do const approve and approve erc20
state is going to be equal to
use stake
tokens with that
token address pull down from the token
as the input
parameter and this is our new hook so
we're going to
import use stake
tokens
from do slash do do hooks now that we
have these two functions we have the
approv function and then we have the
state of that function now we can add a
handle submit functionality for our
button here so now we can say okay on
click when we click this button we're
going to do a
handle stake
submit right because this is that our
big well it's not going to show up now
because I broke everything but this is
our big button right this is our this is
our stake button so we're going to
create this function called handle stake
submit let's go ahead and do
const handle stake submit this will be a
function and what it's going to do is
we'll get this amount here so we'll do
const amount uh which we're going to
actually have to convert it from string
to we so we'll call it amount as way we
do equals utils dop parse ether we'll
grab parse ether we'll grab
utils again from ethers utils from
ethers and we'll do the amount to string
so we're going to grab this amount this
state hook amount here we'll turn it
into a string and then what we can do is
we can return this approve
function with this amount as way okay oh
and then we're getting a fail to compile
so in our hooks section we're just going
to do an index. typescript and we're
going to export this Ed stake so we'll
do
export use stake token
from sluse Stak
tokens close that we'll restart the
server then I should import this from
the right place and I should import this
from the right place as
well and let's get rid of the brackets
here whoops sorry
and let's do this as A2 string oops
because you can't do a big number now
let's save it'll recompile pop into our
front end here we'll do a
refresh our stuff is up that's cool our
stuff is getting logged out now if we
hit stake we should call the approved
function here metam Mass pops up we do
get allow Local Host to spend your dep
this is amazing we're going to reject
this for now though because we're don't
want to bother testing it so amazing job
getting this far we're hitting a button
metamask is popping up and we're doing
it we're we're actually sending a
transaction this is incredibly exciting
great work so far let's keep going the
approv function is working perfectly
it's working as intended or we're just
we're kind of assuming it's working as
intended but that's great this is
perfect so now we got to go one step
further we need to have this call stake
after it's been approved this is where
we're going to do a little something
called use effect we can Import in here
just do use effect
comma what use effect does it allows us
to do something if some variable has
changed so the way that we're going to
do that is we're going to say okay use
effect and it takes uh one of these
functions as an input and then we'll do
a little comma here and similar to those
State hooks we'll do an array of
different things we want to track and if
anything in this array changes we'll
kick off this use effect and we'll do
something in here so one of these things
that we definitely want to uh track is
this approve erc20 state if approve
erc20 state if this transaction comes
back successful then we want to do some
stuff so we'll say We'll track this this
state and we'll go ahead and say
if approve erc20 state.
status equals
success
then we're GNA go ahead and do like a
stake function and to do a stake
function we're going to follow this
exact same methodology that we did for
the
approve so first we're going to use this
use contract function thing so we'll do
const send is going to be
stake send and then
state will be stake
State this is going to be equal to again
we're going to use use contract
function this is going to be on our
token
Farm contract this is going to be our
stake tokens
function and this will be transaction
name it's just going to be stake
tokens that's it so let's make this look
a little bit more readable here lovely
so we have our little used contract bit
here and now this Stak send we can just
call this right in this approve ec20
state. status we just do Stak send and
if we look back in our token Farm we do
stake tokens we have an amount and a
token address so that's what we're going
to have to put in here we have to put
some amount and then token address will
just be token address where do we
actually get this amount from well when
we orig Ally called this approv function
this is when we should actually do it
and you might be asking hey how come we
wrapped this approve your C20 into a
function here but we're not going to do
that here I'll tell you why in just a
second so what we're going to have is
we're going to have a state hook for how
much we want to actually stake so we'll
do const amount to
stake and set amount to stake is going
to be equal to use state and we're going
to start with zero we're just going to
get this defaulted right to zero and
what we're going to do actually is once
we call this approv function the first
time we're going to set amount to stake
to be this amount and what we should do
instead of calling this a prove is we
should call this
prove and stake since it's this function
that's going to kick off yes it's going
to kick off our approve
erc20 but it's also going to change
the amount that we're going to stake and
later on once the transaction succeeds
it will also then kick off our stake
sent or our staking function so we're
going to change this to appr proven
stake that means below we have to
actually return appr proven stake and
not just approve and for stake send the
amount is going to be this amount to
stake which we got from our original
approve and stake and then we just have
to change this to approve and stake
we'll change this from approve to
approve and stake and realistically
that's all we really need to do here so
if we save we go back to our front end
let's go to one of these that I actually
have some of I'll type in one for in
here I'll hit the stake button and what
should happen is approval come up I'll
confirm and once this actually confirms
then I'll be able to another transaction
should pop up telling us to actually
stake and that's exactly what happens
here so we've approved now we can stake
we'll even watch menam Mas really really
quick here I'm doing this on Coen right
I just called this stake tokens function
for those of you doing this on ganach
would be a lot quicker but perfect that
was fantastic our balance even got
deducted by one now we have one of these
tokens actually staked and this is
fantastic however uh there's obviously a
couple issues here right what was
happening during that that whole section
right there was there was no indication
for us of what was really going on we
had no notifications we're totally left
in the dark here additionally uh this
page still looks disgusting so we want
to clean this up we want to make this
look a lot nicer so how can we actually
do this so for switching between these
we want to actually just change our use
effect here so we do want to check this
approved erc20 state but we also wanted
to see if we switch the token address we
want to just check to see if approve
vc20 is done if we switch our token
address and we also want to just check
to see this if amount to stake actually
changes so if we do amount to stake we
want to check kind of during all these
these three if any of these three
changes we'll just do a quick check hey
is approve erc20 done if yes great then
we'll we'll stake some tokens so this is
great but we're going to want to get
some notifications that these
transactions are going through these
transactions are pending uh and these
transactions finished so how do we
actually add those pieces to this well
used app has this thing called use
notifications this notifications bit
will help us actually get notified on
whether or not our transactions are
completing so to use these notifications
we're going to do a couple of different
things in here first all the way back in
our app. TSX we're actually going to
change our config here we're going to
add some
notifications in here to check
periodically if our things are done and
there's a couple of different parameters
there's a
xation period and then we'll set it to
be 1,000 this is in milliseconds so
we'll set it to be a th which is just 1
second and we'll do a check interval
also of 1,000 so basically we're saying
hey every second check the blockchain on
our transactions that we send please
thank you and now that we have this
notifications bit identified in our
staking form we can add this bit so from
edep De core we'll do comma use
notifications and now we can actually
start using some of these notifications
so right here at the top we'll do
const
notifications equals use
notifications we can actually start
working with some of these notifications
now we're going to want to see if
anything in any of these notifications
actually change and if these
notifications change we're going to want
to do something so since we're going to
want to check to see if this if
notification changes those of you who
have been following along with what I've
been explaining for use effect you know
that means we're going to want to use a
use effect we're going to say use effect
it's going to be this function and if we
don't have it imported let's go ahead
and import this from react this use
effect we're going to be looking to see
if these notifications change we're
going to be looking to see if our
transaction has completed so in our
little watching array here we're going
to say let's watch the notif ifications
here let's make sure if any of those
notifications changes if anything on our
metamask changes we're going to want to
do something right so we're going to say
if there are any notifications that are
approv erc20 or transaction succeeded we
want to show hey you know good job it's
been approved so to do this we're going
to say if
notifications.
filter this is going to be a function
based off the
notification on this notification we're
going to say
notification. type it's going to be
transaction. succeeded succeed and that
notification. transaction name then this
is why we needed to give them names
before in our use
State it's going to be approve erc20
transfer. length
is greater than zero then we're going to
do some stuff your transaction succeed
so we're saying if in these
notifications we're going to filter on a
notification if the type is transaction
succeeded and the name is approve erc20
transfer then we're going to do some
stuff and for now we're just going to do
console.log approved we can also then do
the same thing for if
notifications. filter
fter on the
notification
notification. type if that notification.
type is going to be again that
transaction
succeed
and
notification. transaction name equals
stake tokens capital
T stake tokens and there are more than
one. length is greater than zero
then we'll do
console.log tokens staked Okay so we've
got some notifications put in we're
going to do a little console logging
let's see if our use effect stuff is
actually going to work so let's go to
our front end we'll do a quick refresh
we go to where we have some tokens I'm
going to type one in here I'm going to
hit
stake going to hit
confirm and we're going to wait a little
bit and if this confirms correctly then
we're going to see a little console.log
print out that says approved and we do
indeed and that's perfect minim Mass
pops up again for our stake tokens we
hit approve there as well and we should
see a little console. log out here for
Stak token Stak and we do perfect so now
we have a way to actually track some of
these notifications and track what
actually happens on the blockchain
console. logging stuff is great but we
want to actually see it in our UI here
what we're going to want to do is show a
little waiting thing here while we're
waiting for it to be approved and then
she'll pop up when it actually does get
approved we can add a little constant
called is
mining which will be based off of
whether or not the transactions are
approved so we'll do const is
Mining and this will be equal to the
state of these transactions so this
should actually instead be approve erc20
it should be approve and stake erc20
State now say oops now we'll say is
mining will be equal to approve and
stake erc20 state. status equals equals
equals mining should probably have it
look like this then back in our use
stake instead of approve ec20 I'm going
to change this to approve and stake ec20
State and then we're also going to
return prove and stake erc20 stake let's
make this make a little bit more sense
here get that little red line to go away
and now what we can do with this is
mining thing is we can add this to our
button now we have this is mining thing
it's going to be based off of whether or
not approve and stake are done so we can
scroll down to our button and we can add
a little disabled flag so we'll say
disabled
equals and it'll be equal to dependent
on whether or not it it's done we'll
just add Is
Mining and if this is true then disabled
will be true and this isn't mining then
this will be false we can also add this
to be kind of like a little loading
thing so instead of just saying stake
all the time we'll do a tertiary
operator we'll say if it is mining then
we'll do like a little loading thing
material UI has this thing called
circular progress that we can use it's
like a little loading thing so we can do
if it is mining we'll do a circular
progress say the size is 26 or whatever
we want it to be
we'll close the tagout and if it's not
mining again we'll do this stake with a
bunch of exclamation marks here so now
if we save that go to our front end
looks like I need to fix something can't
find name approve erc20 State that's
because we changed it this is now appr
proven stake year 220 state so let's
change it to that now let's save go back
to the front end and okay cool let's go
to one of these that we have some stuff
with we have a little dial we'll do one
here we'll hit hit stake and if we did
this right this should show a little
loading thing while the transaction is
going through so we're going to hit
approve and perfect we do see a little
loading thing and it should stay like
this until the transaction finishes this
is a good way to indicate to the user
that we've actually approved now I'll
hit confirm for staking so we didn't
actually see the loading thing go back
up again so this probably means that we
didn't actually reload this is mining
correctly
ah and the reason we don't see the
little spinny thing is because this appr
proven stake erc20 state is really only
tracking the approve right we have our
cost appr proven stake which does all
this good stuff here but our staking
part this stake State we actually never
use right and we need to pass this back
to our our stake form so it can actually
know you know what's going on so what we
can do is we can add a new state hook
we'll do const we'll just call this one
state then we'll do set state it's going
to be equal to use
State and this will be that uh approve
in stake erc20 State we'll start it off
there and this will represent kind of
the overall state right for this will be
the true appr proven stake erc20 State
what we're going to do now is we're
going to have to track those both of
those States we're going to have to
track both the approving and the staking
so we're going to do use effect and
we're going to track both of those with
our little our little wonderful uh use
effect stuff so we're going to track
them with by doing of course proven
stake here C2 State and then stake state
so if either one of these change now
we're going to want to change this
overall State function and that is going
to get pushed back to our our stake form
here so what we're going to say is we're
going to say if proven stake erc20
state.
status equals equals
equals
success then we're going to set state to
be the uh stake State
otherwise we're going to set this
overall State we're going to do set
state to be this approve and stake bit
or just or really just kind of approve
here now we're going to pass this just
kind of overall State variable here to
our front end like this excuse me to our
stake form and in our stake form we're
just going to say we're just going to
map this state variable to The Proven
stake herec 20 State save here that
should work perfectly right now if we go
back to our front
we'll go to die or whatever we'll do one
we'll hit stake metam mous will pop up
we'll confirm we do indeed get this
little loading thing which is perfect
once it's done once it's approved we'll
confirm again and we get loading again
and this is perfect this is exactly what
we want because now the user has a good
idea ah okay I need to wait right the
transaction is going through the
transaction is being built and once it's
done it's all set so this is fantastic
we now have basically all the
functionality for staking right we have
a proove we have it doing some waiting
we have it actually staking let's clean
this up a little bit right let's make
this look a little bit nicer so first
we're going to go to index.css we're
going to we're going to add some bits in
here for a body we're just going to do
background color we're going to set this
to in set of background
color
to hsl we'll do 227 comma
61% comma 26% there's a whole bunch of
is the background color doesn't really
matter but we'll save we'll refresh our
front end and we'll get a nice little
background color here which is cool but
let's actually be even more creative
than just this let's do a nice little
linear gradient in here we'll just get
rid of this actually we'll do background
do
linear
gradient do
135 here do hsl
227 61%
comma
13% then we'll do hsl 227
61%
26% we'll do one more we'll do hsl again
this would be 227
61% 39% for some colors in here
semicolon there let's look at our front
and ah okay we're getting somewhere we
got some cool double gradients going on
in here we'll go to our main section
here and we'll do that Ed Styles bits
again so right in our looks like we
don't have any material UI in here so
we'll do a little import make
styles from at material- ui-
core right at the top we'll do const use
Styles equals make
Styles some theme which we're ignoring
nice little function thing here it's
then for our titles in here we'll do a
little make the color be theme. pallet.
common. white which again we're ignoring
theme but if we did have a theme we
would do like that we'll do text align
Center do some padding theme. spacing
for and in our main of course we'll just
add this in here const classes equals
use Styles and then we'll just put like
a
little little section in here do an
H2 or class name it's going to be equal
to classes. tile and we'll just call
this dap
token app we'll go back to the front end
we got like a nice little da token dap
token app nice white right at the top
that looks good we'll go to our your
wallet component We'll add some Styles
in here looks like we don't have any
Styles in here so we'll do the same
thing we'll
grab make Styles in here do a little H
use Styles equals make
Styles theme that we're going to
ignore some fun little function syntax
stuff here we say tab
content give this some styling we'll say
all the tab content stuff we'll have
display of
flex Flex
direct shun will be
column align items the
center and we'll do a gap for this which
will be theme. spacing of four give our
boxes some stuff so we'll say
box we
say background color is going to be
white say
border radius is going to be 25 PX to
give it some roundness here then we'll
also do a
header which we'll just do color of
white we're going to grab tab content
scroll down this is going to be inside
this little tab panel bit here this div
it's going to have class name
equals
classes. tab
content oops we got to add classes in
here before the
return do cons classes equals that use
Styles say this box well it's not we're
not going to do the overarching Box this
could actually just be this if we wanted
to we'll just say it's this first box so
this will be class
name equals classes.
boox and then our H1 is going to be
class name equals classes.
header let's save it and let's take a
look
who this is already starting to look a
lot better now as you guys can kind of
see the functionality is really the
important part behind the application
and doing a lot of this ED Style stuff
is what's really going to make it uh
look a lot prettier right so if you're
like Hey how do I do this pretty stuff
now I know I didn't really explain what
any of this pretty prettiness was doing
um there's a ton of tutorials on doing
CSS that's basically what this is that
you guys can learn a little bit more to
make your stuff look pretty now it looks
like for the most part we have
everything that we need to stake I know
we have the spinning wheel which is
great but let's also add a little bit of
an alert at the bottom to say hey your
transaction has gone through
successfully so what we're going to do
is we're going to pop it over to our
stake form we're going to wrap our input
and our button into their own little div
here right and that is going to put a
little bit of space actually between our
little component here and some other
stuff which is kind of nice but what
we're going to do is the reason that
we're doing this is so that we can add
some alerts this section down here is
where we're going to add uh some
alerting to do that we're going to use
what's called a snack bar and alerts
from Material UI you can look at both of
these in the documentation provides a
brief message about app processes and
something like this like we're just
going to say hey you did it transaction
has come through so what we're going to
do is we're going to import snack bar
from material ui/ so we're going to do
comma snack bar we're also going to
import alerting like a little alert box
import alert from at
Material ui- laab alert and what this is
going to do is it's also going to make
these alerts basically down below our
button and our input we're going to do a
little little snack bar in here snack
bar and we're going to say this is going
to open when we want to show that the
erc20 is done which we're not exactly
sure how to do that quite yet we'll have
it autohide
autohide duration is going to be equal
to about 5 seconds or 5,000 milliseconds
and then on close we're also going to do
some stuff inside this little snack bar
yes and I know we haven't filled this
out yet actually let's just do this for
now have blanks for now inside this
snack bar we're going to have some
alerts
or we say on close we're also going to
do some stuff severity is going to be
success and this alert is what's going
to have our text in here so we'll say
ERC 20 token transfer approved now
approve the second
transaction and we're going to have two
of these little snack bars one is going
to be for the
erc20 and one is going to be for staking
token so we're going to call this
one token
staked or excuse me tokens staked now we
need to Define when these open and also
when they close and and what to do when
they close so this erc20 thing should
pop up when erc20 has been approved so
we're going to want to create some
variable that's going to track whether
or not it's actually been approved so
we'll create another state hook here do
const show
erc20 approval success comma set show
erc20 approval success it's going to be
equal to UST State and we're going to
start with false right we don't want to
show this thing right away and then
we're going to want to do the same thing
for staking tokens so we'll do const
show
stake token success then set set stake
token success and this will be also use
State and we will start this out with
false and what we're going to do is
right now we're doing this console.log
in here right and this is cute but we
want to actually turn this into uh
changing show erc20 approval success
right so when this actually goes through
when notification says hey it's been
approved we want to say okay great show
that approval status so instead of doing
console. log here we're going to say set
show your
C20
approval success to true and then we're
also going to set show stake token
success token
success to
false hopefully I'm spelling this right
set
show stake token success and let's
that spelled right great and then we're
going to do the same thing but the
opposite for staking token so get rid of
constant. log we'll do set show erc20
approval success to false and set show
stake erc2 to true now we'll say the ERC
21 is going to open and now we can also
have these notifications thing
track these two these ever change will
also run through this so we'll grab both
of these in here so this use effect will
now track these as well and we'll say
show erc20 approval status we'll open up
the erc20
alert and then the show stake token
success will open up the stake tokens
alert and then for both of these We'll
add a new function called handle close
snack which we'll just close it
out and turn those variables that we
just made to false so we'll do
const handle close
snack this will be a function and we'll
just say set show erc20 approval status
to false and then set show stake token
just going to copy paste it uh this one
also two false awesome now if we go back
refresh our front ends here looks like I
forgot to do an on close ah okay yep
we'll do hand handle along close snack
here for the alerts as well and there
are no tags there there are no brackets
there so I got to change that but now we
go to our front end we'll do a quick
refresh we see everything in here
looking great let's add one in here
we'll hit stake this will pop up we'll
confirm we'll get the little progress
bar which is exactly what we want and
you see here now we get this little
popup it says erc20 token transfer
approved now approve the second trans
transaction this should uh go away after
a few seconds or
not let's just approve the second one oh
looks like it now went away so maybe it
was a little bit longer than 5 seconds
and now we see the token stake popped up
perfect so we have some popups we have a
little bit of ways to show the user how
to do everything now now you'll notice
this doesn't look exactly like what we
see in the GitHub repo right and this
GitHub repo looks a little bit different
it's got this little slidy bar it's got
this second token Farm contract for
staking however a lot of what we're
going to keep doing is just going to be
a lot of more front-end stuff and at
this point you pretty much should have
everything that you need to build the
rest of the contract so what we're going
to do is we're going to have the rest of
this be a challenge if you want it if
you would like to complete it you can
absolutely add this second token farb
contract with this unstake all we bit or
unstake all FAU dep Etc we're going to
have two versions of this front end in
here we're going to have this more
cleaned up version and then we're going
to have a little bit more raw version
this one's the the more raw version all
the code is going to be there so if you
want to say ah I don't really want to
code and follow this along you can just
copy paste the code or you can say you
know what I'm going to do this unstaking
part all myself and that would be
awesome also fantastic you should be
incredibly proud of yourself because at
the end of the day at this point you
have a way to stake tokens into a smart
contract and build a front end which is
absolutely massive absolutely fantastic
you should be patting yourself from the
back excellent job excellent job let's
go ahead and wrap this course up welcome
back friends how do you feel good
smarter empowered ready to Take On The
World excellent well you absolutely 100%
should be and you deserve a massive
Round of Applause because you have just
done something fantastic you have
started your journey and equipped
yourself with the tools to become an
incredibly powerful intelligent
smart contract engineer in this space
now I would be remiss if I didn't
comment on security and audits when it
comes to doing your smart contracts as
you know all these smart contracts are
available on chain for anybody to see
and anybody to work with this means that
having a security mindset is incredibly
incredibly important and I highly
recommend if you're going to go main it
if you're going to take your application
onto a real Network where it's going to
be securing a lot of people's money and
a lot of people's assets you absolutely
need to get an audit there is no excuse
for not getting an audit and having an
application that's securing a lot of
people's money getting an audit is
essentially just having somebody else
peer-review your code looking for any
vulnerabilities that could be exploited
in audit can be the difference between
your protocol skyrocketing into the
future and doing fantastically
successfully or dwindling getting hacked
and everyone losing faith in your
abilities audits are essential we've got
some help helpful links in the GitHub
repository associated with this course
to learn more about audits who to get
them from and some helpful tips on
setting your smart contracts up to make
Auditors lives easier while we're
talking about security it's also helpful
to know some of the most common attacks
in this space we've got another
wonderful Link in the GitHub repository
that will show you some of these attacks
and how to get around them and what they
actually look like two of them that are
big enough that I think I need to
mention here are going to be Oracle
attacks and re-entrancy attacks these
these are the two attacks that I see
happen most often unfortunately right
now in the state of defi protocols get
hacked for millions of dollars literally
almost every day and it is a travesty to
the space that this is happening most of
the time these attacks are preventable
so understanding some of these security
tips doing your due diligence and
getting an audit is going to make both
you as a smart contract developer and as
a Dap developer and as a protocol better
but also the entire space is going to be
more safe secure and easier for
newcomers to get into thankfully you can
sleep a lot easier on those Oracle
manipulation attacks because you've
learned some best practices for working
with oracles you've learned how to work
with a chain link decentralized Oracle
Network to get your data and do your
external computation using a chain link
decentralized Oracle Network or a dawn
will solve these Oracle manipulation
attacks so that you don't have to deal
with people manipulating a centralized
Oracle because you are going to be using
a decentralized one reinsurance attacks
are a little bit trickier to detect but
whenever you call an external smart
contract a smart contract outside your
project you especially should think H
does somebody in that smart contract
have access to changing some variables
that I don't want them to change again
we have some wonderful examples in that
GitHub repository associated with this
course to teach you more about that
additionally I highly recommend
everybody check out both ethernut and
Dam vulnerable defi these are two games
that show you some of the exploits and
some of the low-level solidity things
you can do that you might want to look
out for when you're writing your smart
contracts all right so now that we've
got the security piece out of the way
once again huge congratulations for
getting this far you now have the tools
to Build a Better World to build these
smart contract applications and to
empower yourself and your community with
these blockchain applications now the
first question you might be asking is
Patrick this is great but where do I go
now what do I do I have all these tools
I want to go use them after absolutely
my first bit of advice here is going to
say you can always learn more and
there's always going to be more places
to learn and grow and even though this
course gave you a full setup of
everything that you're going to need to
get going and Get Off to the Races and
start building it's good to know where
else you can learn more and where else
you can grow some amazing places are
going to be crypto zombies dap
University Ivan on Tech chain shot eat
the blocks Patrick Collins my YouTube
Channel Austin Griffith's YouTube
channel Nat's YouTube channel the
ethereum.org website chain link blogs
and really any other material you can
get your hands on while you're learning
you should 100% be growing with the
community this is something that I've
been pushing from the start blockchain
and smart contract world is different
from these corporate worlds we are a
decentralized open-source group open
source open sourced ecosystem where we
flourish if the people around us
flourish so growing and connecting with
the community is a absolute must and is
a and it's a way to really accelerate
all the momentum that you're getting
after taking this course Twitter the eev
rdit brownie Discord the ethereum
Discord the chain link Discord there are
all these discords and all these
communities that you can jump in you can
grow ask questions chat spread ideas
then once you're in these communities
then you can start really coding and
tinkering more hackathons are some of
the best places to put your stuff to the
test and also really learn and build and
grow in the blockchain space there are
hackathons happening all the time and
these are places where you can show up
you can learn from some of the sponsors
you can build really cool things and you
can win prizes as well we've seen some
projects win a hackathon go on to raise
millions in seed funding and become a
billion doll protocol some have gotten
advisors from top investors like Mark
cubin and these projects do wildly
successful but at the same time we also
see a huge uptick and a huge number of
the newcomers in this space people have
never written a smart contract never
written any of the code come in try
learn grow and come out an incredibly
powerful engineer with more networking
and with more more people around them
who they know they can lean on and talk
to in this community so whether or not
you want to win a hackathon doesn't
really matter hackathons are a great
place to sharpen your coding skills get
better meet some people maybe win some
prizes and a lot of these decentralized
projects do look at the hackathon
winners looking for some talent to pick
up for their teams a lot of the
engineers that I work with right now I
work with them because they got picked
up from a hackathon so hackathons are
great places to go eth Global eth India
eth Global eth India and the chain link
hackathon are some of the best
hackathons in the business so be sure to
check those out all these decentralized
protocols have a ton of work that people
can be doing to help grow their protocol
in some way and they all have Community
Grant projects where people can come in
propose some Grant propose something to
the community and that person builds it
out so if you have an idea on how to
improve one of these decentralized
applications you can go ahead propose
what you want to improve and if you get
approved you could be awarded a grant to
work on that as well you could become a
smart contract consultant here you can
start offering your services to people
who are looking for really strong
solidity and smart contract developers
you can start reaching out to some of
these projects now that you have these
skills you can start reaching out to
other people saying hey I've got a great
idea of something I want to build and
I'm looking to take it to the next level
and that's the most important piece of
advice I have for you here just build
just have a good time and build things
that you enjoy building you'll learn the
most the fastest by building tinkering
and trying new things things and this is
also one of the best ways to meet people
in the industry everybody that I work
with in my life in this space I work
with them because I was building
something and we became close because we
were working on the same things I feel
incredibly lucky to have met and
interact with so many Fantastic people
in this space and I hope that one day
I'll get to meet and interact with you
too so good luck to you all and let's
rebuild this world let's make a world
where there's more Economic Opportunity
there's more equality and let's rebuild
some of this institutional trust while
having an absolute blast in this wild
west that is cryptocurrency smart
contracts and blockchain like I said I
hope to meet you all one day and just do
me a favor and make today an amazing day
take care everybody
